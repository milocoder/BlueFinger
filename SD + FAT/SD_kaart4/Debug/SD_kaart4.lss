
SD_kaart4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a0  00800100  00001bb0  00001c44  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001bb0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000518  008001a0  008001a0  00001ce4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001ce4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001d14  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000190  00000000  00000000  00001d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002939  00000000  00000000  00001ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010f8  00000000  00000000  00004819  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001699  00000000  00000000  00005911  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000638  00000000  00000000  00006fac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009d6  00000000  00000000  000075e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000024e4  00000000  00000000  00007fba  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000150  00000000  00000000  0000a49e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 dd 03 	jmp	0x7ba	; 0x7ba <__vector_10>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 fc 00 	jmp	0x1f8	; 0x1f8 <__vector_18>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf ef       	ldi	r28, 0xFF	; 255
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e0       	ldi	r26, 0x00	; 0
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	e0 eb       	ldi	r30, 0xB0	; 176
      a8:	fb e1       	ldi	r31, 0x1B	; 27
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a0 3a       	cpi	r26, 0xA0	; 160
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	26 e0       	ldi	r18, 0x06	; 6
      b8:	a0 ea       	ldi	r26, 0xA0	; 160
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	a8 3b       	cpi	r26, 0xB8	; 184
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 12 05 	call	0xa24	; 0xa24 <main>
      ca:	0c 94 d6 0d 	jmp	0x1bac	; 0x1bac <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <initCAN>:

		messageAvailable = 1;
	}

	return messageAvailable;
}
      d2:	e8 ed       	ldi	r30, 0xD8	; 216
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	80 81       	ld	r24, Z
      d8:	81 60       	ori	r24, 0x01	; 1
      da:	80 83       	st	Z, r24
      dc:	86 e0       	ldi	r24, 0x06	; 6
      de:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7f80e2>
      e2:	84 e0       	ldi	r24, 0x04	; 4
      e4:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7f80e3>
      e8:	83 e1       	ldi	r24, 0x13	; 19
      ea:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7f80e4>
      ee:	80 e0       	ldi	r24, 0x00	; 0
      f0:	08 c0       	rjmp	.+16     	; 0x102 <initCAN+0x30>
      f2:	98 2f       	mov	r25, r24
      f4:	92 95       	swap	r25
      f6:	90 7f       	andi	r25, 0xF0	; 240
      f8:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
      fc:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     100:	8f 5f       	subi	r24, 0xFF	; 255
     102:	8f 30       	cpi	r24, 0x0F	; 15
     104:	b0 f3       	brcs	.-20     	; 0xf2 <initCAN+0x20>
     106:	78 94       	sei
     108:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     10c:	80 eb       	ldi	r24, 0xB0	; 176
     10e:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7f80db>
     112:	e8 ed       	ldi	r30, 0xD8	; 216
     114:	f0 e0       	ldi	r31, 0x00	; 0
     116:	80 81       	ld	r24, Z
     118:	82 60       	ori	r24, 0x02	; 2
     11a:	80 83       	st	Z, r24
     11c:	08 95       	ret

0000011e <getFreeMob>:
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	0a c0       	rjmp	.+20     	; 0x136 <getFreeMob+0x18>
     122:	98 2f       	mov	r25, r24
     124:	92 95       	swap	r25
     126:	90 7f       	andi	r25, 0xF0	; 240
     128:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     12c:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     130:	90 7c       	andi	r25, 0xC0	; 192
     132:	21 f0       	breq	.+8      	; 0x13c <getFreeMob+0x1e>
     134:	8f 5f       	subi	r24, 0xFF	; 255
     136:	8f 30       	cpi	r24, 0x0F	; 15
     138:	a0 f3       	brcs	.-24     	; 0x122 <getFreeMob+0x4>
     13a:	8f ef       	ldi	r24, 0xFF	; 255
     13c:	08 95       	ret

0000013e <listenForMessage>:
     13e:	1f 93       	push	r17
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	ec 01       	movw	r28, r24
     146:	16 2f       	mov	r17, r22
     148:	0e 94 8f 00 	call	0x11e	; 0x11e <getFreeMob>
     14c:	8f 3f       	cpi	r24, 0xFF	; 255
     14e:	09 f4       	brne	.+2      	; 0x152 <listenForMessage+0x14>
     150:	4e c0       	rjmp	.+156    	; 0x1ee <listenForMessage+0xb0>
     152:	ed ee       	ldi	r30, 0xED	; 237
     154:	f0 e0       	ldi	r31, 0x00	; 0
     156:	90 81       	ld	r25, Z
     158:	48 2f       	mov	r20, r24
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	9a 01       	movw	r18, r20
     15e:	22 95       	swap	r18
     160:	32 95       	swap	r19
     162:	30 7f       	andi	r19, 0xF0	; 240
     164:	32 27       	eor	r19, r18
     166:	20 7f       	andi	r18, 0xF0	; 240
     168:	32 27       	eor	r19, r18
     16a:	29 2b       	or	r18, r25
     16c:	20 83       	st	Z, r18
     16e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     172:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     176:	9c 2f       	mov	r25, r28
     178:	92 95       	swap	r25
     17a:	99 0f       	add	r25, r25
     17c:	90 7e       	andi	r25, 0xE0	; 224
     17e:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     182:	d6 95       	lsr	r29
     184:	c7 95       	ror	r28
     186:	d6 95       	lsr	r29
     188:	c7 95       	ror	r28
     18a:	d6 95       	lsr	r29
     18c:	c7 95       	ror	r28
     18e:	c0 93 f3 00 	sts	0x00F3, r28	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     192:	19 30       	cpi	r17, 0x09	; 9
     194:	08 f0       	brcs	.+2      	; 0x198 <listenForMessage+0x5a>
     196:	18 e0       	ldi	r17, 0x08	; 8
     198:	ef ee       	ldi	r30, 0xEF	; 239
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	60 81       	ld	r22, Z
     19e:	61 2b       	or	r22, r17
     1a0:	60 83       	st	Z, r22
     1a2:	88 30       	cpi	r24, 0x08	; 8
     1a4:	78 f4       	brcc	.+30     	; 0x1c4 <listenForMessage+0x86>
     1a6:	ee ed       	ldi	r30, 0xDE	; 222
     1a8:	f0 e0       	ldi	r31, 0x00	; 0
     1aa:	40 81       	ld	r20, Z
     1ac:	21 e0       	ldi	r18, 0x01	; 1
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	b9 01       	movw	r22, r18
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <listenForMessage+0x7a>
     1b4:	66 0f       	add	r22, r22
     1b6:	77 1f       	adc	r23, r23
     1b8:	8a 95       	dec	r24
     1ba:	e2 f7       	brpl	.-8      	; 0x1b4 <listenForMessage+0x76>
     1bc:	cb 01       	movw	r24, r22
     1be:	84 2b       	or	r24, r20
     1c0:	80 83       	st	Z, r24
     1c2:	0e c0       	rjmp	.+28     	; 0x1e0 <listenForMessage+0xa2>
     1c4:	ef ed       	ldi	r30, 0xDF	; 223
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	20 81       	ld	r18, Z
     1ca:	48 50       	subi	r20, 0x08	; 8
     1cc:	51 09       	sbc	r21, r1
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <listenForMessage+0x9a>
     1d4:	88 0f       	add	r24, r24
     1d6:	99 1f       	adc	r25, r25
     1d8:	4a 95       	dec	r20
     1da:	e2 f7       	brpl	.-8      	; 0x1d4 <listenForMessage+0x96>
     1dc:	82 2b       	or	r24, r18
     1de:	80 83       	st	Z, r24
     1e0:	ef ee       	ldi	r30, 0xEF	; 239
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	80 68       	ori	r24, 0x80	; 128
     1e8:	80 83       	st	Z, r24
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <listenForMessage+0xb2>
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	1f 91       	pop	r17
     1f6:	08 95       	ret

000001f8 <__vector_18>:
 * Note that the NO_BLOCK attribute is not applied here, so while this is running,
 * all interrupts are blocked.
 *
 */
ISR( CANIT_vect )
{
     1f8:	1f 92       	push	r1
     1fa:	0f 92       	push	r0
     1fc:	0f b6       	in	r0, 0x3f	; 63
     1fe:	0f 92       	push	r0
     200:	11 24       	eor	r1, r1
     202:	2f 93       	push	r18
     204:	3f 93       	push	r19
     206:	4f 93       	push	r20
     208:	5f 93       	push	r21
     20a:	6f 93       	push	r22
     20c:	7f 93       	push	r23
     20e:	8f 93       	push	r24
     210:	9f 93       	push	r25
     212:	af 93       	push	r26
     214:	bf 93       	push	r27
     216:	cf 93       	push	r28
     218:	ef 93       	push	r30
     21a:	ff 93       	push	r31
	// **Save off CANPAGE to prevent application code bugs**
	uint8_t canPage = CANPAGE;
     21c:	c0 91 ed 00 	lds	r28, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     220:	87 c0       	rjmp	.+270    	; 0x330 <__vector_18+0x138>
	{
		// Point to the Message Object that needs to be serviced
		CANPAGE = CANHPMOB & 0xF0;
     222:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     226:	80 7f       	andi	r24, 0xF0	; 240
     228:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

		// Service the correct kind of interrupt
		// Transmit Interrupts
		if( CANSTMOB & (1 << TXOK) )
     22c:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     230:	86 ff       	sbrs	r24, 6
     232:	0c c0       	rjmp	.+24     	; 0x24c <__vector_18+0x54>
		{
			// Acknowledge the interrupt
			CANSTMOB = 0;
     234:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			// Free up the MOb
			CANCDMOB = 0;
     238:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>

			// Determine the MOb index
			uint8_t mob = (CANPAGE & 0xF0) >> 8;
     23c:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

			// Disable interrupts for this MOb
			if( mob < 8 )
			{
				CANIE2 &= ~(1 << mob);
     240:	ee ed       	ldi	r30, 0xDE	; 222
     242:	f0 e0       	ldi	r31, 0x00	; 0
     244:	80 81       	ld	r24, Z
     246:	8e 7f       	andi	r24, 0xFE	; 254
     248:	80 83       	st	Z, r24
     24a:	72 c0       	rjmp	.+228    	; 0x330 <__vector_18+0x138>
			{
				CANIE1 &= ~(1 << (mob-8));
			}
		}
		// Receive Interrupts
		else if ( CANSTMOB & (1 << RXOK) )
     24c:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     250:	85 ff       	sbrs	r24, 5
     252:	62 c0       	rjmp	.+196    	; 0x318 <__vector_18+0x120>
		{
			// Default to impossible ID
			uint16_t id = 0xFFFF;

			// Load the message data into a free message buffer object
			if( CANCDMOB & (1 << IDE) )
     254:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     258:	84 ff       	sbrs	r24, 4
     25a:	0e c0       	rjmp	.+28     	; 0x278 <__vector_18+0x80>
			{
				// Message type is CAN 2.0B
				id = (CANIDT4 >> 3) | ((CANIDT3 & 0x7F) << 5); 
     25c:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     260:	86 95       	lsr	r24
     262:	86 95       	lsr	r24
     264:	86 95       	lsr	r24
     266:	40 91 f1 00 	lds	r20, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     26a:	4f 77       	andi	r20, 0x7F	; 127
     26c:	90 e2       	ldi	r25, 0x20	; 32
     26e:	49 9f       	mul	r20, r25
     270:	a0 01       	movw	r20, r0
     272:	11 24       	eor	r1, r1
     274:	48 2b       	or	r20, r24
     276:	0f c0       	rjmp	.+30     	; 0x296 <__vector_18+0x9e>
			}
			else
			{
				// Message type is CAN 2.0A
				id = (CANIDT2 >> 5) | (((uint16_t)CANIDT1 << 3));
     278:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     27c:	82 95       	swap	r24
     27e:	86 95       	lsr	r24
     280:	87 70       	andi	r24, 0x07	; 7
     282:	40 91 f3 00 	lds	r20, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     286:	50 e0       	ldi	r21, 0x00	; 0
     288:	44 0f       	add	r20, r20
     28a:	55 1f       	adc	r21, r21
     28c:	44 0f       	add	r20, r20
     28e:	55 1f       	adc	r21, r21
     290:	44 0f       	add	r20, r20
     292:	55 1f       	adc	r21, r21
     294:	48 2b       	or	r20, r24
			}

			messageBuffer[bufIndex].id = id;
     296:	20 91 a1 01 	lds	r18, 0x01A1	; 0x8001a1 <bufIndex>
     29a:	30 e0       	ldi	r19, 0x00	; 0
     29c:	8b e0       	ldi	r24, 0x0B	; 11
     29e:	82 9f       	mul	r24, r18
     2a0:	f0 01       	movw	r30, r0
     2a2:	83 9f       	mul	r24, r19
     2a4:	f0 0d       	add	r31, r0
     2a6:	11 24       	eor	r1, r1
     2a8:	ee 54       	subi	r30, 0x4E	; 78
     2aa:	fa 4f       	sbci	r31, 0xFA	; 250
     2ac:	40 83       	st	Z, r20
     2ae:	95 2f       	mov	r25, r21
     2b0:	97 70       	andi	r25, 0x07	; 7
     2b2:	81 81       	ldd	r24, Z+1	; 0x01
     2b4:	88 7f       	andi	r24, 0xF8	; 248
     2b6:	89 2b       	or	r24, r25
     2b8:	81 83       	std	Z+1, r24	; 0x01

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;
     2ba:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     2be:	8f 70       	andi	r24, 0x0F	; 15
     2c0:	82 87       	std	Z+10, r24	; 0x0a

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	0e c0       	rjmp	.+28     	; 0x2e2 <__vector_18+0xea>
			{
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
     2c6:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7f80fa>
     2ca:	4b e0       	ldi	r20, 0x0B	; 11
     2cc:	42 9f       	mul	r20, r18
     2ce:	f0 01       	movw	r30, r0
     2d0:	43 9f       	mul	r20, r19
     2d2:	f0 0d       	add	r31, r0
     2d4:	11 24       	eor	r1, r1
     2d6:	ee 54       	subi	r30, 0x4E	; 78
     2d8:	fa 4f       	sbci	r31, 0xFA	; 250
     2da:	e9 0f       	add	r30, r25
     2dc:	f1 1d       	adc	r31, r1
     2de:	82 83       	std	Z+2, r24	; 0x02
			messageBuffer[bufIndex].id = id;

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     2e0:	9f 5f       	subi	r25, 0xFF	; 255
     2e2:	8b e0       	ldi	r24, 0x0B	; 11
     2e4:	82 9f       	mul	r24, r18
     2e6:	f0 01       	movw	r30, r0
     2e8:	83 9f       	mul	r24, r19
     2ea:	f0 0d       	add	r31, r0
     2ec:	11 24       	eor	r1, r1
     2ee:	ee 54       	subi	r30, 0x4E	; 78
     2f0:	fa 4f       	sbci	r31, 0xFA	; 250
     2f2:	82 85       	ldd	r24, Z+10	; 0x0a
     2f4:	98 17       	cp	r25, r24
     2f6:	38 f3       	brcs	.-50     	; 0x2c6 <__vector_18+0xce>
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
			}

			bufIndex = (bufIndex + 1) % MESSAGE_BUFFER_LENGTH;
     2f8:	c9 01       	movw	r24, r18
     2fa:	01 96       	adiw	r24, 0x01	; 1
     2fc:	64 e1       	ldi	r22, 0x14	; 20
     2fe:	70 e0       	ldi	r23, 0x00	; 0
     300:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <__divmodhi4>
     304:	80 93 a1 01 	sts	0x01A1, r24	; 0x8001a1 <bufIndex>

			// Acknowledge the interrupt
			CANSTMOB = 0;
     308:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			CANCDMOB |= (2 << CONMOB0);
     30c:	ef ee       	ldi	r30, 0xEF	; 239
     30e:	f0 e0       	ldi	r31, 0x00	; 0
     310:	80 81       	ld	r24, Z
     312:	80 68       	ori	r24, 0x80	; 128
     314:	80 83       	st	Z, r24
     316:	0c c0       	rjmp	.+24     	; 0x330 <__vector_18+0x138>
			
		}
		else if ( CANGIT & ~(1 << CANIT) )
     318:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	8f 77       	andi	r24, 0x7F	; 127
     320:	89 2b       	or	r24, r25
     322:	31 f0       	breq	.+12     	; 0x330 <__vector_18+0x138>
		{
			// Preserve the last error received
			lastError = CANGIT;
     324:	ea ed       	ldi	r30, 0xDA	; 218
     326:	f0 e0       	ldi	r31, 0x00	; 0
     328:	80 81       	ld	r24, Z
     32a:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <__data_end>

			// Clear the error
			CANGIT = 0;
     32e:	10 82       	st	Z, r1
	uint8_t canPage = CANPAGE;

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     330:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     334:	82 95       	swap	r24
     336:	8f 70       	andi	r24, 0x0F	; 15
     338:	8f 30       	cpi	r24, 0x0F	; 15
     33a:	09 f0       	breq	.+2      	; 0x33e <__vector_18+0x146>
     33c:	72 cf       	rjmp	.-284    	; 0x222 <__vector_18+0x2a>
			CANGIT = 0;
		}
	}

	// Restore CANPAGE register to where application code had it before interrupt
	CANPAGE = canPage;
     33e:	c0 93 ed 00 	sts	0x00ED, r28	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     342:	ff 91       	pop	r31
     344:	ef 91       	pop	r30
     346:	cf 91       	pop	r28
     348:	bf 91       	pop	r27
     34a:	af 91       	pop	r26
     34c:	9f 91       	pop	r25
     34e:	8f 91       	pop	r24
     350:	7f 91       	pop	r23
     352:	6f 91       	pop	r22
     354:	5f 91       	pop	r21
     356:	4f 91       	pop	r20
     358:	3f 91       	pop	r19
     35a:	2f 91       	pop	r18
     35c:	0f 90       	pop	r0
     35e:	0f be       	out	0x3f, r0	; 63
     360:	0f 90       	pop	r0
     362:	1f 90       	pop	r1
     364:	18 95       	reti

00000366 <init_spi>:
//

static void init_spi(void)
{
	/* Set MOSI and SCK output, all others input */
	DDR_SPI |= ((1 << MOSI) | (1 << SCK) | (1 << CS));
     366:	84 b1       	in	r24, 0x04	; 4
     368:	87 60       	ori	r24, 0x07	; 7
     36a:	84 b9       	out	0x04, r24	; 4
	
	// enable pull up resistor in MISO
	PORTB |= (1 << MISO);
     36c:	85 b1       	in	r24, 0x05	; 5
     36e:	88 60       	ori	r24, 0x08	; 8
     370:	85 b9       	out	0x05, r24	; 5
	
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPR0));
     372:	8c b5       	in	r24, 0x2c	; 44
     374:	81 65       	ori	r24, 0x51	; 81
     376:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<CS); 				//hoog maken CS	
     378:	85 b1       	in	r24, 0x05	; 5
     37a:	81 60       	ori	r24, 0x01	; 1
     37c:	85 b9       	out	0x05, r24	; 5
     37e:	08 95       	ret

00000380 <xmit_spi>:
}

static BYTE xmit_spi(BYTE data)
{
	PORTB &= ~(1<<CS); //laag maken
     380:	95 b1       	in	r25, 0x05	; 5
     382:	9e 7f       	andi	r25, 0xFE	; 254
     384:	95 b9       	out	0x05, r25	; 5
	/* Start transmission */
	SPDR = data;
     386:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     388:	0d b4       	in	r0, 0x2d	; 45
     38a:	07 fe       	sbrs	r0, 7
     38c:	fd cf       	rjmp	.-6      	; 0x388 <xmit_spi+0x8>
	PORTB |= (1<<CS);		//hoog maken CS
     38e:	85 b1       	in	r24, 0x05	; 5
     390:	81 60       	ori	r24, 0x01	; 1
     392:	85 b9       	out	0x05, r24	; 5
	
	return SPDR; 
     394:	8e b5       	in	r24, 0x2e	; 46
}
     396:	08 95       	ret

00000398 <rcv_spi>:

static BYTE rcv_spi(void)
{
	return xmit_spi(0xFF);
     398:	8f ef       	ldi	r24, 0xFF	; 255
     39a:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
}
     39e:	08 95       	ret

000003a0 <send_cmd>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static BYTE send_cmd(BYTE  cmd, /* 1st byte (Start + Index) */
                     DWORD arg ) /* Argument (32 bits) */
{
     3a0:	ff 92       	push	r15
     3a2:	0f 93       	push	r16
     3a4:	1f 93       	push	r17
     3a6:	cf 93       	push	r28
     3a8:	df 93       	push	r29
     3aa:	c8 2f       	mov	r28, r24
     3ac:	d4 2f       	mov	r29, r20
     3ae:	15 2f       	mov	r17, r21
     3b0:	06 2f       	mov	r16, r22
     3b2:	f7 2e       	mov	r15, r23
	BYTE n, res;

	if (cmd & 0x80) { /* ACMD<n> is the command sequence of CMD55-CMD<n> */
     3b4:	88 23       	and	r24, r24
     3b6:	4c f4       	brge	.+18     	; 0x3ca <send_cmd+0x2a>
		cmd &= 0x7F;
     3b8:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
     3ba:	40 e0       	ldi	r20, 0x00	; 0
     3bc:	50 e0       	ldi	r21, 0x00	; 0
     3be:	ba 01       	movw	r22, r20
     3c0:	87 e7       	ldi	r24, 0x77	; 119
     3c2:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
		if (res > 1)
     3c6:	82 30       	cpi	r24, 0x02	; 2
     3c8:	50 f5       	brcc	.+84     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
			return res;
	}

	/* Select the card */
	DESELECT();
     3ca:	85 b1       	in	r24, 0x05	; 5
     3cc:	81 60       	ori	r24, 0x01	; 1
     3ce:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     3d0:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
	SELECT();
     3d4:	85 b1       	in	r24, 0x05	; 5
     3d6:	8e 7f       	andi	r24, 0xFE	; 254
     3d8:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     3da:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>

	/* Send a command packet */
	xmit_spi(cmd);               /* Start + Command index */
     3de:	8c 2f       	mov	r24, r28
     3e0:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
     3e4:	8f 2d       	mov	r24, r15
     3e6:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
     3ea:	80 2f       	mov	r24, r16
     3ec:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
     3f0:	81 2f       	mov	r24, r17
     3f2:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
     3f6:	8d 2f       	mov	r24, r29
     3f8:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	n = 0x01;                    /* Dummy CRC + Stop */
	if (cmd == CMD0)
     3fc:	c0 34       	cpi	r28, 0x40	; 64
     3fe:	11 f0       	breq	.+4      	; 0x404 <__EEPROM_REGION_LENGTH__+0x4>
	xmit_spi(cmd);               /* Start + Command index */
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
	n = 0x01;                    /* Dummy CRC + Stop */
     400:	81 e0       	ldi	r24, 0x01	; 1
     402:	01 c0       	rjmp	.+2      	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
	if (cmd == CMD0)
		n = 0x95; /* Valid CRC for CMD0(0) */
     404:	85 e9       	ldi	r24, 0x95	; 149
	if (cmd == CMD8)
     406:	c8 34       	cpi	r28, 0x48	; 72
     408:	09 f4       	brne	.+2      	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
     40a:	87 e8       	ldi	r24, 0x87	; 135
	xmit_spi(n);
     40c:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>

	/* Receive a command response */
	n = 10; /* Wait for a valid response in timeout of 10 attempts */
     410:	ca e0       	ldi	r28, 0x0A	; 10
	do {
		res = rcv_spi();
     412:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
	} while ((res & 0x80) && --n);
     416:	88 23       	and	r24, r24
     418:	14 f4       	brge	.+4      	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
     41a:	c1 50       	subi	r28, 0x01	; 1
     41c:	d1 f7       	brne	.-12     	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>

	return res; /* Return with the response value */
}
     41e:	df 91       	pop	r29
     420:	cf 91       	pop	r28
     422:	1f 91       	pop	r17
     424:	0f 91       	pop	r16
     426:	ff 90       	pop	r15
     428:	08 95       	ret

0000042a <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(void)
{
     42a:	ef 92       	push	r14
     42c:	ff 92       	push	r15
     42e:	0f 93       	push	r16
     430:	1f 93       	push	r17
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	00 d0       	rcall	.+0      	; 0x438 <disk_initialize+0xe>
     438:	00 d0       	rcall	.+0      	; 0x43a <disk_initialize+0x10>
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING)
     43e:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     442:	81 11       	cpse	r24, r1
     444:	84 b1       	in	r24, 0x04	; 4
		disk_writep(0, 0); /* Finalize write process if it is in progress */
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
     446:	0e 94 b3 01 	call	0x366	; 0x366 <init_spi>
	DESELECT();
     44a:	85 b1       	in	r24, 0x05	; 5
     44c:	81 60       	ori	r24, 0x01	; 1
     44e:	85 b9       	out	0x05, r24	; 5
	for (n = 10; n; n--)
     450:	1a e0       	ldi	r17, 0x0A	; 10
     452:	03 c0       	rjmp	.+6      	; 0x45a <disk_initialize+0x30>
		rcv_spi(); /* 80 dummy clocks with CS=H */
     454:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
     458:	11 50       	subi	r17, 0x01	; 1
     45a:	11 11       	cpse	r17, r1
     45c:	fb cf       	rjmp	.-10     	; 0x454 <disk_initialize+0x2a>
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
     45e:	40 e0       	ldi	r20, 0x00	; 0
     460:	50 e0       	ldi	r21, 0x00	; 0
     462:	ba 01       	movw	r22, r20
     464:	80 e4       	ldi	r24, 0x40	; 64
     466:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     46a:	81 30       	cpi	r24, 0x01	; 1
     46c:	09 f0       	breq	.+2      	; 0x470 <disk_initialize+0x46>
     46e:	9b c0       	rjmp	.+310    	; 0x5a6 <disk_initialize+0x17c>
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
     470:	4a ea       	ldi	r20, 0xAA	; 170
     472:	51 e0       	ldi	r21, 0x01	; 1
     474:	60 e0       	ldi	r22, 0x00	; 0
     476:	70 e0       	ldi	r23, 0x00	; 0
     478:	88 e4       	ldi	r24, 0x48	; 72
     47a:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     47e:	81 30       	cpi	r24, 0x01	; 1
     480:	09 f0       	breq	.+2      	; 0x484 <disk_initialize+0x5a>
     482:	59 c0       	rjmp	.+178    	; 0x536 <disk_initialize+0x10c>
     484:	0d c0       	rjmp	.+26     	; 0x4a0 <disk_initialize+0x76>
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
     486:	e0 2e       	mov	r14, r16
     488:	f1 2c       	mov	r15, r1
     48a:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     48e:	e1 e0       	ldi	r30, 0x01	; 1
     490:	f0 e0       	ldi	r31, 0x00	; 0
     492:	ec 0f       	add	r30, r28
     494:	fd 1f       	adc	r31, r29
     496:	ee 0d       	add	r30, r14
     498:	ff 1d       	adc	r31, r15
     49a:	80 83       	st	Z, r24
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
     49c:	0f 5f       	subi	r16, 0xFF	; 255
     49e:	01 c0       	rjmp	.+2      	; 0x4a2 <disk_initialize+0x78>
     4a0:	01 2f       	mov	r16, r17
     4a2:	04 30       	cpi	r16, 0x04	; 4
     4a4:	80 f3       	brcs	.-32     	; 0x486 <disk_initialize+0x5c>
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
     4a6:	8b 81       	ldd	r24, Y+3	; 0x03
     4a8:	81 30       	cpi	r24, 0x01	; 1
     4aa:	09 f0       	breq	.+2      	; 0x4ae <disk_initialize+0x84>
     4ac:	7e c0       	rjmp	.+252    	; 0x5aa <disk_initialize+0x180>
     4ae:	8c 81       	ldd	r24, Y+4	; 0x04
     4b0:	8a 3a       	cpi	r24, 0xAA	; 170
     4b2:	61 f0       	breq	.+24     	; 0x4cc <disk_initialize+0xa2>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     4b4:	f1 2c       	mov	r15, r1
     4b6:	84 c0       	rjmp	.+264    	; 0x5c0 <disk_initialize+0x196>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     4b8:	8f e8       	ldi	r24, 0x8F	; 143
     4ba:	91 e0       	ldi	r25, 0x01	; 1
     4bc:	01 97       	sbiw	r24, 0x01	; 1
     4be:	f1 f7       	brne	.-4      	; 0x4bc <disk_initialize+0x92>
     4c0:	00 c0       	rjmp	.+0      	; 0x4c2 <disk_initialize+0x98>
     4c2:	00 00       	nop
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
     4c4:	91 e0       	ldi	r25, 0x01	; 1
     4c6:	e9 1a       	sub	r14, r25
     4c8:	f1 08       	sbc	r15, r1
     4ca:	06 c0       	rjmp	.+12     	; 0x4d8 <disk_initialize+0xae>
     4cc:	0f 2e       	mov	r0, r31
     4ce:	f0 e1       	ldi	r31, 0x10	; 16
     4d0:	ef 2e       	mov	r14, r31
     4d2:	f7 e2       	ldi	r31, 0x27	; 39
     4d4:	ff 2e       	mov	r15, r31
     4d6:	f0 2d       	mov	r31, r0
     4d8:	e1 14       	cp	r14, r1
     4da:	f1 04       	cpc	r15, r1
     4dc:	49 f0       	breq	.+18     	; 0x4f0 <disk_initialize+0xc6>
     4de:	40 e0       	ldi	r20, 0x00	; 0
     4e0:	50 e0       	ldi	r21, 0x00	; 0
     4e2:	60 e0       	ldi	r22, 0x00	; 0
     4e4:	70 e4       	ldi	r23, 0x40	; 64
     4e6:	89 ee       	ldi	r24, 0xE9	; 233
     4e8:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     4ec:	81 11       	cpse	r24, r1
     4ee:	e4 cf       	rjmp	.-56     	; 0x4b8 <disk_initialize+0x8e>
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
     4f0:	ef 28       	or	r14, r15
     4f2:	09 f4       	brne	.+2      	; 0x4f6 <disk_initialize+0xcc>
     4f4:	5c c0       	rjmp	.+184    	; 0x5ae <disk_initialize+0x184>
     4f6:	40 e0       	ldi	r20, 0x00	; 0
     4f8:	50 e0       	ldi	r21, 0x00	; 0
     4fa:	ba 01       	movw	r22, r20
     4fc:	8a e7       	ldi	r24, 0x7A	; 122
     4fe:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     502:	88 23       	and	r24, r24
     504:	71 f0       	breq	.+28     	; 0x522 <disk_initialize+0xf8>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     506:	f1 2c       	mov	r15, r1
     508:	5b c0       	rjmp	.+182    	; 0x5c0 <disk_initialize+0x196>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
     50a:	e1 2e       	mov	r14, r17
     50c:	f1 2c       	mov	r15, r1
     50e:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     512:	e1 e0       	ldi	r30, 0x01	; 1
     514:	f0 e0       	ldi	r31, 0x00	; 0
     516:	ec 0f       	add	r30, r28
     518:	fd 1f       	adc	r31, r29
     51a:	ee 0d       	add	r30, r14
     51c:	ff 1d       	adc	r31, r15
     51e:	80 83       	st	Z, r24
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
     520:	1f 5f       	subi	r17, 0xFF	; 255
     522:	14 30       	cpi	r17, 0x04	; 4
     524:	90 f3       	brcs	.-28     	; 0x50a <disk_initialize+0xe0>
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     526:	89 81       	ldd	r24, Y+1	; 0x01
     528:	86 ff       	sbrs	r24, 6
     52a:	43 c0       	rjmp	.+134    	; 0x5b2 <disk_initialize+0x188>
     52c:	0f 2e       	mov	r0, r31
     52e:	fc e0       	ldi	r31, 0x0C	; 12
     530:	ff 2e       	mov	r15, r31
     532:	f0 2d       	mov	r31, r0
     534:	45 c0       	rjmp	.+138    	; 0x5c0 <disk_initialize+0x196>
				}
			}
		} else { /* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) {
     536:	40 e0       	ldi	r20, 0x00	; 0
     538:	50 e0       	ldi	r21, 0x00	; 0
     53a:	ba 01       	movw	r22, r20
     53c:	89 ee       	ldi	r24, 0xE9	; 233
     53e:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     542:	82 30       	cpi	r24, 0x02	; 2
     544:	40 f4       	brcc	.+16     	; 0x556 <disk_initialize+0x12c>
				ty  = CT_SD1;
     546:	68 94       	set
     548:	ff 24       	eor	r15, r15
     54a:	f1 f8       	bld	r15, 1
				cmd = ACMD41; /* SDv1 */
     54c:	0f 2e       	mov	r0, r31
     54e:	f9 ee       	ldi	r31, 0xE9	; 233
     550:	ef 2e       	mov	r14, r31
     552:	f0 2d       	mov	r31, r0
     554:	06 c0       	rjmp	.+12     	; 0x562 <disk_initialize+0x138>
			} else {
				ty  = CT_MMC;
     556:	ff 24       	eor	r15, r15
     558:	f3 94       	inc	r15
				cmd = CMD1; /* MMCv3 */
     55a:	0f 2e       	mov	r0, r31
     55c:	f1 e4       	ldi	r31, 0x41	; 65
     55e:	ef 2e       	mov	r14, r31
     560:	f0 2d       	mov	r31, r0
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
     562:	00 e1       	ldi	r16, 0x10	; 16
     564:	17 e2       	ldi	r17, 0x27	; 39
     566:	08 c0       	rjmp	.+16     	; 0x578 <disk_initialize+0x14e>
     568:	8f e8       	ldi	r24, 0x8F	; 143
     56a:	91 e0       	ldi	r25, 0x01	; 1
     56c:	01 97       	sbiw	r24, 0x01	; 1
     56e:	f1 f7       	brne	.-4      	; 0x56c <disk_initialize+0x142>
     570:	00 c0       	rjmp	.+0      	; 0x572 <disk_initialize+0x148>
     572:	00 00       	nop
     574:	01 50       	subi	r16, 0x01	; 1
     576:	11 09       	sbc	r17, r1
     578:	01 15       	cp	r16, r1
     57a:	11 05       	cpc	r17, r1
     57c:	41 f0       	breq	.+16     	; 0x58e <disk_initialize+0x164>
     57e:	40 e0       	ldi	r20, 0x00	; 0
     580:	50 e0       	ldi	r21, 0x00	; 0
     582:	ba 01       	movw	r22, r20
     584:	8e 2d       	mov	r24, r14
     586:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     58a:	81 11       	cpse	r24, r1
     58c:	ed cf       	rjmp	.-38     	; 0x568 <disk_initialize+0x13e>
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
     58e:	01 2b       	or	r16, r17
     590:	a1 f0       	breq	.+40     	; 0x5ba <disk_initialize+0x190>
     592:	40 e0       	ldi	r20, 0x00	; 0
     594:	52 e0       	ldi	r21, 0x02	; 2
     596:	60 e0       	ldi	r22, 0x00	; 0
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	80 e5       	ldi	r24, 0x50	; 80
     59c:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     5a0:	81 11       	cpse	r24, r1
     5a2:	0d c0       	rjmp	.+26     	; 0x5be <disk_initialize+0x194>
     5a4:	0d c0       	rjmp	.+26     	; 0x5c0 <disk_initialize+0x196>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     5a6:	f1 2c       	mov	r15, r1
     5a8:	0b c0       	rjmp	.+22     	; 0x5c0 <disk_initialize+0x196>
     5aa:	f1 2c       	mov	r15, r1
     5ac:	09 c0       	rjmp	.+18     	; 0x5c0 <disk_initialize+0x196>
     5ae:	f1 2c       	mov	r15, r1
     5b0:	07 c0       	rjmp	.+14     	; 0x5c0 <disk_initialize+0x196>
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     5b2:	68 94       	set
     5b4:	ff 24       	eor	r15, r15
     5b6:	f2 f8       	bld	r15, 2
     5b8:	03 c0       	rjmp	.+6      	; 0x5c0 <disk_initialize+0x196>
				cmd = CMD1; /* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
				ty = 0;
     5ba:	f1 2c       	mov	r15, r1
     5bc:	01 c0       	rjmp	.+2      	; 0x5c0 <disk_initialize+0x196>
     5be:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     5c0:	f0 92 a4 01 	sts	0x01A4, r15	; 0x8001a4 <CardType>
	DESELECT();
     5c4:	85 b1       	in	r24, 0x05	; 5
     5c6:	81 60       	ori	r24, 0x01	; 1
     5c8:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     5ca:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>

	return ty ? 0 : STA_NOINIT;
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	f1 10       	cpse	r15, r1
     5d2:	80 e0       	ldi	r24, 0x00	; 0
}
     5d4:	0f 90       	pop	r0
     5d6:	0f 90       	pop	r0
     5d8:	0f 90       	pop	r0
     5da:	0f 90       	pop	r0
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	1f 91       	pop	r17
     5e2:	0f 91       	pop	r16
     5e4:	ff 90       	pop	r15
     5e6:	ef 90       	pop	r14
     5e8:	08 95       	ret

000005ea <disk_readp>:
DRESULT disk_readp(BYTE *buff,   /* Pointer to the read buffer (NULL:Forward to the stream) */
                   DWORD sector, /* Sector number (LBA) */
                   UINT  offset, /* Byte offset to read from (0..511) */
                   UINT  count   /* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
     5ea:	af 92       	push	r10
     5ec:	bf 92       	push	r11
     5ee:	cf 92       	push	r12
     5f0:	df 92       	push	r13
     5f2:	ef 92       	push	r14
     5f4:	ff 92       	push	r15
     5f6:	0f 93       	push	r16
     5f8:	1f 93       	push	r17
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	6c 01       	movw	r12, r24
     600:	79 01       	movw	r14, r18
	DRESULT res;
	BYTE    rc;
	UINT    bc;

	if (!(CardType & CT_BLOCK))
     602:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     606:	83 fd       	sbrc	r24, 3
     608:	09 c0       	rjmp	.+18     	; 0x61c <disk_readp+0x32>
		sector *= 512; /* Convert to byte address if needed */
     60a:	03 2e       	mov	r0, r19
     60c:	39 e0       	ldi	r19, 0x09	; 9
     60e:	44 0f       	add	r20, r20
     610:	55 1f       	adc	r21, r21
     612:	66 1f       	adc	r22, r22
     614:	77 1f       	adc	r23, r23
     616:	3a 95       	dec	r19
     618:	d1 f7       	brne	.-12     	; 0x60e <disk_readp+0x24>
     61a:	30 2d       	mov	r19, r0

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
     61c:	81 e5       	ldi	r24, 0x51	; 81
     61e:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     622:	81 11       	cpse	r24, r1
     624:	31 c0       	rjmp	.+98     	; 0x688 <disk_readp+0x9e>

		// bc = 40000;	/* Time counter */
		do { /* Wait for response */
			rc = rcv_spi();
     626:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
		} while (rc == 0xFF);
     62a:	8f 3f       	cpi	r24, 0xFF	; 255
     62c:	e1 f3       	breq	.-8      	; 0x626 <disk_readp+0x3c>

		if (rc == 0xFE) { /* A data packet arrived */
     62e:	8e 3f       	cpi	r24, 0xFE	; 254
     630:	69 f5       	brne	.+90     	; 0x68c <disk_readp+0xa2>

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */
     632:	cc 27       	eor	r28, r28
     634:	dd 27       	eor	r29, r29
     636:	ce 19       	sub	r28, r14
     638:	df 09       	sbc	r29, r15
     63a:	c0 1b       	sub	r28, r16
     63c:	d1 0b       	sbc	r29, r17
     63e:	ce 5f       	subi	r28, 0xFE	; 254
     640:	dd 4f       	sbci	r29, 0xFD	; 253

			/* Skip leading bytes */
			while (offset--)
     642:	03 c0       	rjmp	.+6      	; 0x64a <disk_readp+0x60>
				rcv_spi();
     644:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
		if (rc == 0xFE) { /* A data packet arrived */

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */

			/* Skip leading bytes */
			while (offset--)
     648:	75 01       	movw	r14, r10
     64a:	57 01       	movw	r10, r14
     64c:	81 e0       	ldi	r24, 0x01	; 1
     64e:	a8 1a       	sub	r10, r24
     650:	b1 08       	sbc	r11, r1
     652:	ef 28       	or	r14, r15
     654:	b9 f7       	brne	.-18     	; 0x644 <disk_readp+0x5a>
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
     656:	c1 14       	cp	r12, r1
     658:	d1 04       	cpc	r13, r1
     65a:	69 f0       	breq	.+26     	; 0x676 <disk_readp+0x8c>
				do {
					*buff++ = rcv_spi();
     65c:	76 01       	movw	r14, r12
     65e:	ef ef       	ldi	r30, 0xFF	; 255
     660:	ee 1a       	sub	r14, r30
     662:	fe 0a       	sbc	r15, r30
     664:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     668:	f6 01       	movw	r30, r12
     66a:	80 83       	st	Z, r24
				} while (--count);
     66c:	01 50       	subi	r16, 0x01	; 1
     66e:	11 09       	sbc	r17, r1
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
				do {
					*buff++ = rcv_spi();
     670:	67 01       	movw	r12, r14
				} while (--count);
     672:	a1 f7       	brne	.-24     	; 0x65c <disk_readp+0x72>
     674:	03 c0       	rjmp	.+6      	; 0x67c <disk_readp+0x92>
			} else { /* Forward data to the outgoing stream */
				do {
					// FORWARD(rcv_spi());
				} while (--count);
     676:	01 50       	subi	r16, 0x01	; 1
     678:	11 09       	sbc	r17, r1
     67a:	e9 f7       	brne	.-6      	; 0x676 <disk_readp+0x8c>
			}

			/* Skip trailing bytes and CRC */
			do
				rcv_spi();
     67c:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
			while (--bc);
     680:	21 97       	sbiw	r28, 0x01	; 1
     682:	e1 f7       	brne	.-8      	; 0x67c <disk_readp+0x92>

			res = RES_OK;
     684:	c0 e0       	ldi	r28, 0x00	; 0
     686:	03 c0       	rjmp	.+6      	; 0x68e <disk_readp+0xa4>
	UINT    bc;

	if (!(CardType & CT_BLOCK))
		sector *= 512; /* Convert to byte address if needed */

	res = RES_ERROR;
     688:	c1 e0       	ldi	r28, 0x01	; 1
     68a:	01 c0       	rjmp	.+2      	; 0x68e <disk_readp+0xa4>
     68c:	c1 e0       	ldi	r28, 0x01	; 1

			res = RES_OK;
		}
	}

	DESELECT();
     68e:	85 b1       	in	r24, 0x05	; 5
     690:	81 60       	ori	r24, 0x01	; 1
     692:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     694:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>

	return res;
}
     698:	8c 2f       	mov	r24, r28
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	1f 91       	pop	r17
     6a0:	0f 91       	pop	r16
     6a2:	ff 90       	pop	r15
     6a4:	ef 90       	pop	r14
     6a6:	df 90       	pop	r13
     6a8:	cf 90       	pop	r12
     6aa:	bf 90       	pop	r11
     6ac:	af 90       	pop	r10
     6ae:	08 95       	ret

000006b0 <disk_writep>:

#if _USE_WRITE
DRESULT disk_writep(const BYTE *buff, /* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
                    DWORD       sc    /* Number of bytes to send, Sector number (LBA) or zero */
)
{
     6b0:	0f 93       	push	r16
     6b2:	1f 93       	push	r17
     6b4:	cf 93       	push	r28
     6b6:	df 93       	push	r29
     6b8:	fc 01       	movw	r30, r24
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
     6ba:	89 2b       	or	r24, r25
     6bc:	f1 f0       	breq	.+60     	; 0x6fa <disk_writep+0x4a>
		bc = sc;
     6be:	ea 01       	movw	r28, r20
		while (bc && wc) { /* Send data bytes to the card */
     6c0:	11 c0       	rjmp	.+34     	; 0x6e4 <disk_writep+0x34>
			xmit_spi(*buff++);
     6c2:	8f 01       	movw	r16, r30
     6c4:	0f 5f       	subi	r16, 0xFF	; 255
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	80 81       	ld	r24, Z
     6ca:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
			wc--;
     6ce:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <wc.1882>
     6d2:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <wc.1882+0x1>
     6d6:	01 97       	sbiw	r24, 0x01	; 1
     6d8:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <wc.1882+0x1>
     6dc:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <wc.1882>
			bc--;
     6e0:	21 97       	sbiw	r28, 0x01	; 1
	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
     6e2:	f8 01       	movw	r30, r16

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
     6e4:	20 97       	sbiw	r28, 0x00	; 0
     6e6:	09 f4       	brne	.+2      	; 0x6ea <disk_writep+0x3a>
     6e8:	5f c0       	rjmp	.+190    	; 0x7a8 <disk_writep+0xf8>
     6ea:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <wc.1882>
     6ee:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <wc.1882+0x1>
     6f2:	89 2b       	or	r24, r25
     6f4:	31 f7       	brne	.-52     	; 0x6c2 <disk_writep+0x12>
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     6f6:	c0 e0       	ldi	r28, 0x00	; 0
     6f8:	5a c0       	rjmp	.+180    	; 0x7ae <disk_writep+0xfe>
	} else {
		if (sc) { /* Initiate sector write process */
     6fa:	41 15       	cp	r20, r1
     6fc:	51 05       	cpc	r21, r1
     6fe:	61 05       	cpc	r22, r1
     700:	71 05       	cpc	r23, r1
     702:	01 f1       	breq	.+64     	; 0x744 <disk_writep+0x94>
			if (!(CardType & CT_BLOCK))
     704:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     708:	83 fd       	sbrc	r24, 3
     70a:	09 c0       	rjmp	.+18     	; 0x71e <disk_writep+0x6e>
				sc *= 512;                  /* Convert to byte address if needed */
     70c:	03 2e       	mov	r0, r19
     70e:	39 e0       	ldi	r19, 0x09	; 9
     710:	44 0f       	add	r20, r20
     712:	55 1f       	adc	r21, r21
     714:	66 1f       	adc	r22, r22
     716:	77 1f       	adc	r23, r23
     718:	3a 95       	dec	r19
     71a:	d1 f7       	brne	.-12     	; 0x710 <disk_writep+0x60>
     71c:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sc) == 0) { /* WRITE_SINGLE_BLOCK */
     71e:	88 e5       	ldi	r24, 0x58	; 88
     720:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     724:	81 11       	cpse	r24, r1
     726:	42 c0       	rjmp	.+132    	; 0x7ac <disk_writep+0xfc>
				xmit_spi(0xFF);
     728:	8f ef       	ldi	r24, 0xFF	; 255
     72a:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
				xmit_spi(0xFE); /* Data block header */
     72e:	8e ef       	ldi	r24, 0xFE	; 254
     730:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
				wc  = 512;      /* Set byte counter */
     734:	80 e0       	ldi	r24, 0x00	; 0
     736:	92 e0       	ldi	r25, 0x02	; 2
     738:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <wc.1882+0x1>
     73c:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <wc.1882>
				res = RES_OK;
     740:	c0 e0       	ldi	r28, 0x00	; 0
     742:	35 c0       	rjmp	.+106    	; 0x7ae <disk_writep+0xfe>
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
     744:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <wc.1882>
     748:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <wc.1882+0x1>
     74c:	02 96       	adiw	r24, 0x02	; 2
			while (bc--) {
     74e:	04 c0       	rjmp	.+8      	; 0x758 <disk_writep+0xa8>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
     750:	80 e0       	ldi	r24, 0x00	; 0
     752:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
				wc  = 512;      /* Set byte counter */
				res = RES_OK;
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
			while (bc--) {
     756:	ce 01       	movw	r24, r28
     758:	ec 01       	movw	r28, r24
     75a:	21 97       	sbiw	r28, 0x01	; 1
     75c:	89 2b       	or	r24, r25
     75e:	c1 f7       	brne	.-16     	; 0x750 <disk_writep+0xa0>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
			}
			do {
				res = rcv_spi();
     760:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     764:	c8 2f       	mov	r28, r24
			} while (res == 0xFF);
     766:	8f 3f       	cpi	r24, 0xFF	; 255
     768:	d9 f3       	breq	.-10     	; 0x760 <disk_writep+0xb0>
			if ((res & 0x1F) == 0x05) { /* Receive data resp and wait for end of write process in timeout of 500ms */
     76a:	8f 71       	andi	r24, 0x1F	; 31
     76c:	85 30       	cpi	r24, 0x05	; 5
     76e:	b1 f4       	brne	.+44     	; 0x79c <disk_writep+0xec>
     770:	09 c0       	rjmp	.+18     	; 0x784 <disk_writep+0xd4>
     772:	8f e8       	ldi	r24, 0x8F	; 143
     774:	91 e0       	ldi	r25, 0x01	; 1
     776:	01 97       	sbiw	r24, 0x01	; 1
     778:	f1 f7       	brne	.-4      	; 0x776 <disk_writep+0xc6>
     77a:	00 c0       	rjmp	.+0      	; 0x77c <disk_writep+0xcc>
     77c:	00 00       	nop
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--) /* Wait for ready */
     77e:	01 50       	subi	r16, 0x01	; 1
     780:	11 09       	sbc	r17, r1
     782:	02 c0       	rjmp	.+4      	; 0x788 <disk_writep+0xd8>
     784:	08 e8       	ldi	r16, 0x88	; 136
     786:	13 e1       	ldi	r17, 0x13	; 19
     788:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     78c:	8f 3f       	cpi	r24, 0xFF	; 255
     78e:	19 f0       	breq	.+6      	; 0x796 <disk_writep+0xe6>
     790:	01 15       	cp	r16, r1
     792:	11 05       	cpc	r17, r1
     794:	71 f7       	brne	.-36     	; 0x772 <disk_writep+0xc2>
					_delay_us(100);
				if (bc)
     796:	01 2b       	or	r16, r17
     798:	09 f0       	breq	.+2      	; 0x79c <disk_writep+0xec>
					res = RES_OK;
     79a:	c0 e0       	ldi	r28, 0x00	; 0
			}
			DESELECT();
     79c:	85 b1       	in	r24, 0x05	; 5
     79e:	81 60       	ori	r24, 0x01	; 1
     7a0:	85 b9       	out	0x05, r24	; 5
			rcv_spi();
     7a2:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     7a6:	03 c0       	rjmp	.+6      	; 0x7ae <disk_writep+0xfe>
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     7a8:	c0 e0       	ldi	r28, 0x00	; 0
     7aa:	01 c0       	rjmp	.+2      	; 0x7ae <disk_writep+0xfe>
{
	DRESULT     res;
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;
     7ac:	c1 e0       	ldi	r28, 0x01	; 1
			rcv_spi();
		}
	}

	return res;
}
     7ae:	8c 2f       	mov	r24, r28
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	0f 91       	pop	r16
     7b8:	08 95       	ret

000007ba <__vector_10>:
void start_log_message(void);
unsigned long find_offset(void);
void writeToCard(void);

ISR(TIMER2_OVF_vect)
{
     7ba:	1f 92       	push	r1
     7bc:	0f 92       	push	r0
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	0f 92       	push	r0
     7c2:	11 24       	eor	r1, r1
     7c4:	8f 93       	push	r24
     7c6:	9f 93       	push	r25
	overflowCounter++;
     7c8:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <overflowCounter>
     7cc:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <overflowCounter+0x1>
     7d0:	01 96       	adiw	r24, 0x01	; 1
     7d2:	90 93 ab 01 	sts	0x01AB, r25	; 0x8001ab <overflowCounter+0x1>
     7d6:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <overflowCounter>
	TCNT2 = 0x00;
     7da:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
}
     7de:	9f 91       	pop	r25
     7e0:	8f 91       	pop	r24
     7e2:	0f 90       	pop	r0
     7e4:	0f be       	out	0x3f, r0	; 63
     7e6:	0f 90       	pop	r0
     7e8:	1f 90       	pop	r1
     7ea:	18 95       	reti

000007ec <init_timer>:
	}
}

void init_timer(void)
{	
	TCNT2 = 0x00; // start counting at 0
     7ec:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
	TCCR2A = ((1 << CS22) | (1 << CS21) | (1 << CS20)); // prescaler op 1024
     7f0:	87 e0       	ldi	r24, 0x07	; 7
     7f2:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
	TIMSK2 = (1 << TOIE2);
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7f8070>
     7fc:	08 95       	ret

000007fe <fill_buffer>:
	
			
		// if statement hierboven kan herhaald worden voor andere ID's.
	}*/
	
	write_buffer[bufferAmt++] = '\n';
     7fe:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <bufferAmt>
     802:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <bufferAmt+0x1>
     806:	9c 01       	movw	r18, r24
     808:	2f 5f       	subi	r18, 0xFF	; 255
     80a:	3f 4f       	sbci	r19, 0xFF	; 255
     80c:	30 93 ad 01 	sts	0x01AD, r19	; 0x8001ad <bufferAmt+0x1>
     810:	20 93 ac 01 	sts	0x01AC, r18	; 0x8001ac <bufferAmt>
     814:	fc 01       	movw	r30, r24
     816:	e0 55       	subi	r30, 0x50	; 80
     818:	fc 4f       	sbci	r31, 0xFC	; 252
     81a:	2a e0       	ldi	r18, 0x0A	; 10
     81c:	20 83       	st	Z, r18
	const char* string = "testen: ";
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     81e:	20 e0       	ldi	r18, 0x00	; 0
     820:	30 e0       	ldi	r19, 0x00	; 0
     822:	15 c0       	rjmp	.+42     	; 0x84e <__DATA_REGION_LENGTH__+0x4e>
	{
		write_buffer[bufferAmt++] = string[i];
     824:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <bufferAmt>
     828:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <bufferAmt+0x1>
     82c:	ac 01       	movw	r20, r24
     82e:	4f 5f       	subi	r20, 0xFF	; 255
     830:	5f 4f       	sbci	r21, 0xFF	; 255
     832:	50 93 ad 01 	sts	0x01AD, r21	; 0x8001ad <bufferAmt+0x1>
     836:	40 93 ac 01 	sts	0x01AC, r20	; 0x8001ac <bufferAmt>
     83a:	f9 01       	movw	r30, r18
     83c:	e0 50       	subi	r30, 0x00	; 0
     83e:	ff 4f       	sbci	r31, 0xFF	; 255
     840:	40 81       	ld	r20, Z
     842:	fc 01       	movw	r30, r24
     844:	e0 55       	subi	r30, 0x50	; 80
     846:	fc 4f       	sbci	r31, 0xFC	; 252
     848:	40 83       	st	Z, r20
	}*/
	
	write_buffer[bufferAmt++] = '\n';
	const char* string = "testen: ";
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     84a:	2f 5f       	subi	r18, 0xFF	; 255
     84c:	3f 4f       	sbci	r19, 0xFF	; 255
     84e:	28 30       	cpi	r18, 0x08	; 8
     850:	31 05       	cpc	r19, r1
     852:	44 f3       	brlt	.-48     	; 0x824 <__DATA_REGION_LENGTH__+0x24>
     854:	20 e0       	ldi	r18, 0x00	; 0
     856:	30 e0       	ldi	r19, 0x00	; 0
     858:	40 e3       	ldi	r20, 0x30	; 48
     85a:	12 c0       	rjmp	.+36     	; 0x880 <__DATA_REGION_LENGTH__+0x80>
		write_buffer[bufferAmt++] = string[i];
	}
	char c = 48;
	for (int i = 0; i < 10; i++)
	{
		write_buffer[bufferAmt++] = c++;
     85c:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <bufferAmt>
     860:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <bufferAmt+0x1>
     864:	bc 01       	movw	r22, r24
     866:	6f 5f       	subi	r22, 0xFF	; 255
     868:	7f 4f       	sbci	r23, 0xFF	; 255
     86a:	70 93 ad 01 	sts	0x01AD, r23	; 0x8001ad <bufferAmt+0x1>
     86e:	60 93 ac 01 	sts	0x01AC, r22	; 0x8001ac <bufferAmt>
     872:	fc 01       	movw	r30, r24
     874:	e0 55       	subi	r30, 0x50	; 80
     876:	fc 4f       	sbci	r31, 0xFC	; 252
     878:	40 83       	st	Z, r20
	for (int i = 0; i < length; i++)
	{
		write_buffer[bufferAmt++] = string[i];
	}
	char c = 48;
	for (int i = 0; i < 10; i++)
     87a:	2f 5f       	subi	r18, 0xFF	; 255
     87c:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		write_buffer[bufferAmt++] = c++;
     87e:	4f 5f       	subi	r20, 0xFF	; 255
	for (int i = 0; i < length; i++)
	{
		write_buffer[bufferAmt++] = string[i];
	}
	char c = 48;
	for (int i = 0; i < 10; i++)
     880:	2a 30       	cpi	r18, 0x0A	; 10
     882:	31 05       	cpc	r19, r1
     884:	5c f3       	brlt	.-42     	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
	{
		write_buffer[bufferAmt++] = c++;
	}
	
	if(bufferAmt>=(512-30)) // sectorgrootte van 512 bytes - ongeveer 30 bytes (iets meer dan 2 lines)
     886:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <bufferAmt>
     88a:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <bufferAmt+0x1>
     88e:	82 3e       	cpi	r24, 0xE2	; 226
     890:	91 40       	sbci	r25, 0x01	; 1
     892:	3c f0       	brlt	.+14     	; 0x8a2 <__DATA_REGION_LENGTH__+0xa2>
	{
			
		bufferAmt = 0;
     894:	10 92 ad 01 	sts	0x01AD, r1	; 0x8001ad <bufferAmt+0x1>
     898:	10 92 ac 01 	sts	0x01AC, r1	; 0x8001ac <bufferAmt>
		startWriting = true; // als dit op true staat gaat de microcontroller in de main>while(logging) in de if-statement en vult vanaf daar de sd-kaart 
     89c:	81 e0       	ldi	r24, 0x01	; 1
     89e:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <startWriting>
     8a2:	08 95       	ret

000008a4 <writeToCard>:


void writeToCard(void)
{
	// Set file pointer to beginning of sector 
	pf_lseek(curOffset); // offset van 0 is te vinden in sector 8448 van de sd-kaart
     8a4:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <curOffset>
     8a8:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <curOffset+0x1>
     8ac:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <curOffset+0x2>
     8b0:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <curOffset+0x3>
     8b4:	0e 94 47 0c 	call	0x188e	; 0x188e <pf_lseek>
	// Write buffer 
	pf_write(write_buffer, BUFFER_SIZE, &byte_counter);
     8b8:	4e ea       	ldi	r20, 0xAE	; 174
     8ba:	51 e0       	ldi	r21, 0x01	; 1
     8bc:	60 e0       	ldi	r22, 0x00	; 0
     8be:	72 e0       	ldi	r23, 0x02	; 2
     8c0:	80 eb       	ldi	r24, 0xB0	; 176
     8c2:	93 e0       	ldi	r25, 0x03	; 3
     8c4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <pf_write>
	if (byte_counter < BUFFER_SIZE) {
		// End of file 
	}
	// Finalize write 
	pf_write(0, 0, &byte_counter);
     8c8:	4e ea       	ldi	r20, 0xAE	; 174
     8ca:	51 e0       	ldi	r21, 0x01	; 1
     8cc:	60 e0       	ldi	r22, 0x00	; 0
     8ce:	70 e0       	ldi	r23, 0x00	; 0
     8d0:	80 e0       	ldi	r24, 0x00	; 0
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	0e 94 3b 0b 	call	0x1676	; 0x1676 <pf_write>
	// Reset file pointer to beginning of sector 1 
	pf_lseek(curOffset);
     8d8:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <curOffset>
     8dc:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <curOffset+0x1>
     8e0:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <curOffset+0x2>
     8e4:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <curOffset+0x3>
     8e8:	0e 94 47 0c 	call	0x188e	; 0x188e <pf_lseek>
	// Read back the same bytes 
	pf_read(read_buffer, BUFFER_SIZE, &byte_counter);
     8ec:	4e ea       	ldi	r20, 0xAE	; 174
     8ee:	51 e0       	ldi	r21, 0x01	; 1
     8f0:	60 e0       	ldi	r22, 0x00	; 0
     8f2:	72 e0       	ldi	r23, 0x02	; 2
     8f4:	80 eb       	ldi	r24, 0xB0	; 176
     8f6:	91 e0       	ldi	r25, 0x01	; 1
     8f8:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <pf_read>
     8fc:	08 95       	ret

000008fe <find_offset>:
	}
	*/
}

unsigned long find_offset(void)
{
     8fe:	cf 92       	push	r12
     900:	df 92       	push	r13
     902:	ef 92       	push	r14
     904:	ff 92       	push	r15
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	00 d0       	rcall	.+0      	; 0x90c <__stack+0xd>
     90c:	1f 92       	push	r1
     90e:	cd b7       	in	r28, 0x3d	; 61
     910:	de b7       	in	r29, 0x3e	; 62
	// begin bij sector 0. kijk naar waarde 1e char. als die erop wijst dat de sector al geschreven is, ga naar sector 1. ga zo door. return offset als sector leeg lijkt te zijn
	uint8_t read_first[1]  = {};
     912:	19 82       	std	Y+1, r1	; 0x01
	UINT bytecounter = 1;
     914:	81 e0       	ldi	r24, 0x01	; 1
     916:	90 e0       	ldi	r25, 0x00	; 0
     918:	9b 83       	std	Y+3, r25	; 0x03
     91a:	8a 83       	std	Y+2, r24	; 0x02
	unsigned long tempOffset = 0;
     91c:	c1 2c       	mov	r12, r1
     91e:	d1 2c       	mov	r13, r1
     920:	76 01       	movw	r14, r12
	unsigned long maxOffset = 51200; // als hij geen lege sector kan vinden na de 1e 100 sectoren
	while(1)
	{
		pf_lseek(tempOffset);
     922:	c7 01       	movw	r24, r14
     924:	b6 01       	movw	r22, r12
     926:	0e 94 47 0c 	call	0x188e	; 0x188e <pf_lseek>
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
     92a:	ae 01       	movw	r20, r28
     92c:	4e 5f       	subi	r20, 0xFE	; 254
     92e:	5f 4f       	sbci	r21, 0xFF	; 255
     930:	61 e0       	ldi	r22, 0x01	; 1
     932:	70 e0       	ldi	r23, 0x00	; 0
     934:	ce 01       	movw	r24, r28
     936:	01 96       	adiw	r24, 0x01	; 1
     938:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <pf_read>
		if(read_first[0] == 32)
     93c:	89 81       	ldd	r24, Y+1	; 0x01
     93e:	80 32       	cpi	r24, 0x20	; 32
     940:	79 f0       	breq	.+30     	; 0x960 <__stack+0x61>
		{
			return tempOffset;
		} else {
			tempOffset += 512;
     942:	82 e0       	ldi	r24, 0x02	; 2
     944:	d8 0e       	add	r13, r24
     946:	e1 1c       	adc	r14, r1
     948:	f1 1c       	adc	r15, r1
			if(tempOffset >= maxOffset)
     94a:	c1 14       	cp	r12, r1
     94c:	88 ec       	ldi	r24, 0xC8	; 200
     94e:	d8 06       	cpc	r13, r24
     950:	e1 04       	cpc	r14, r1
     952:	f1 04       	cpc	r15, r1
     954:	30 f3       	brcs	.-52     	; 0x922 <__stack+0x23>
			break;
		}
	}
	return 0;
     956:	60 e0       	ldi	r22, 0x00	; 0
     958:	70 e0       	ldi	r23, 0x00	; 0
     95a:	80 e0       	ldi	r24, 0x00	; 0
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	04 c0       	rjmp	.+8      	; 0x968 <__stack+0x69>
	{
		pf_lseek(tempOffset);
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
		if(read_first[0] == 32)
		{
			return tempOffset;
     960:	6c 2d       	mov	r22, r12
     962:	7d 2d       	mov	r23, r13
     964:	8e 2d       	mov	r24, r14
     966:	9f 2d       	mov	r25, r15
			if(tempOffset >= maxOffset)
			break;
		}
	}
	return 0;
}
     968:	0f 90       	pop	r0
     96a:	0f 90       	pop	r0
     96c:	0f 90       	pop	r0
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	ff 90       	pop	r15
     974:	ef 90       	pop	r14
     976:	df 90       	pop	r13
     978:	cf 90       	pop	r12
     97a:	08 95       	ret

0000097c <start_log_message>:

void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
     97c:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <bufferAmt>
     980:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <bufferAmt+0x1>
     984:	9c 01       	movw	r18, r24
     986:	2f 5f       	subi	r18, 0xFF	; 255
     988:	3f 4f       	sbci	r19, 0xFF	; 255
     98a:	30 93 ad 01 	sts	0x01AD, r19	; 0x8001ad <bufferAmt+0x1>
     98e:	20 93 ac 01 	sts	0x01AC, r18	; 0x8001ac <bufferAmt>
     992:	fc 01       	movw	r30, r24
     994:	e0 55       	subi	r30, 0x50	; 80
     996:	fc 4f       	sbci	r31, 0xFC	; 252
     998:	2a e0       	ldi	r18, 0x0A	; 10
     99a:	20 83       	st	Z, r18
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     99c:	20 e0       	ldi	r18, 0x00	; 0
     99e:	30 e0       	ldi	r19, 0x00	; 0
     9a0:	15 c0       	rjmp	.+42     	; 0x9cc <start_log_message+0x50>
	{
		write_buffer[bufferAmt++] = string[i];
     9a2:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <bufferAmt>
     9a6:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <bufferAmt+0x1>
     9aa:	ac 01       	movw	r20, r24
     9ac:	4f 5f       	subi	r20, 0xFF	; 255
     9ae:	5f 4f       	sbci	r21, 0xFF	; 255
     9b0:	50 93 ad 01 	sts	0x01AD, r21	; 0x8001ad <bufferAmt+0x1>
     9b4:	40 93 ac 01 	sts	0x01AC, r20	; 0x8001ac <bufferAmt>
     9b8:	f9 01       	movw	r30, r18
     9ba:	e7 5f       	subi	r30, 0xF7	; 247
     9bc:	fe 4f       	sbci	r31, 0xFE	; 254
     9be:	40 81       	ld	r20, Z
     9c0:	fc 01       	movw	r30, r24
     9c2:	e0 55       	subi	r30, 0x50	; 80
     9c4:	fc 4f       	sbci	r31, 0xFC	; 252
     9c6:	40 83       	st	Z, r20
void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     9c8:	2f 5f       	subi	r18, 0xFF	; 255
     9ca:	3f 4f       	sbci	r19, 0xFF	; 255
     9cc:	2e 30       	cpi	r18, 0x0E	; 14
     9ce:	31 05       	cpc	r19, r1
     9d0:	44 f3       	brlt	.-48     	; 0x9a2 <start_log_message+0x26>
	{
		write_buffer[bufferAmt++] = string[i];
	}
	write_buffer[bufferAmt++] = '\n';
     9d2:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <bufferAmt>
     9d6:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <bufferAmt+0x1>
     9da:	9c 01       	movw	r18, r24
     9dc:	2f 5f       	subi	r18, 0xFF	; 255
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	30 93 ad 01 	sts	0x01AD, r19	; 0x8001ad <bufferAmt+0x1>
     9e4:	20 93 ac 01 	sts	0x01AC, r18	; 0x8001ac <bufferAmt>
     9e8:	fc 01       	movw	r30, r24
     9ea:	e0 55       	subi	r30, 0x50	; 80
     9ec:	fc 4f       	sbci	r31, 0xFC	; 252
     9ee:	2a e0       	ldi	r18, 0x0A	; 10
     9f0:	20 83       	st	Z, r18
     9f2:	08 95       	ret

000009f4 <init_sd_card>:
	DSTATUS status;
	FRESULT result;
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
     9f4:	0e 94 15 02 	call	0x42a	; 0x42a <disk_initialize>
		if (status != 0) {
     9f8:	81 11       	cpse	r24, r1
     9fa:	07 c0       	rjmp	.+14     	; 0xa0a <init_sd_card+0x16>
			ERROR = 1; 
		} else {
			ERROR = 0;			
			// Set SPI clock faster after initialization 
			SPCR = (1<<MSTR) | (0<<SPR1) | (0<<SPR0) | (1<<SPE);
     9fc:	80 e5       	ldi	r24, 0x50	; 80
     9fe:	8c bd       	out	0x2c, r24	; 44
			SPSR = (1<<SPI2X); 		
     a00:	81 e0       	ldi	r24, 0x01	; 1
     a02:	8d bd       	out	0x2d, r24	; 45
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
		} else {
			ERROR = 0;			
     a04:	80 e0       	ldi	r24, 0x00	; 0
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	02 c0       	rjmp	.+4      	; 0xa0e <init_sd_card+0x1a>
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	90 e0       	ldi	r25, 0x00	; 0
			//SPR1 en 0 op 0 SPI clock set to fck/4 (blaz. 174)
			//MSTR, in mastermode zetten
			//SPE, SPI enable maken.
			//SPI2X, het verdubbelen van de snelheid.			
		}
	} while (ERROR == 1);
     a0e:	01 97       	sbiw	r24, 0x01	; 1
     a10:	89 f3       	breq	.-30     	; 0x9f4 <init_sd_card>

	// Mount volume 
	result = pf_mount(&file_system);
     a12:	8e e8       	ldi	r24, 0x8E	; 142
     a14:	96 e0       	ldi	r25, 0x06	; 6
     a16:	0e 94 49 08 	call	0x1092	; 0x1092 <pf_mount>
	if (result != FR_OK) {} // error

	// Open file 
	result = pf_open("LOG.txt");
     a1a:	88 e1       	ldi	r24, 0x18	; 24
     a1c:	91 e0       	ldi	r25, 0x01	; 1
     a1e:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <pf_open>
     a22:	08 95       	ret

00000a24 <main>:
}
	
int main(void)
{	
	_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | ((0<<CLKPS3) | (0<<CLKPS2) | (1<<CLKPS1) | (0<<CLKPS0))));
	init_sd_card(); // initialize sd-card
     a24:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <init_sd_card>
	sei();
     a28:	78 94       	sei
	initCAN(); // init can-bus
     a2a:	0e 94 69 00 	call	0xd2	; 0xd2 <initCAN>
	listenForMessage(CAN_ID_SNELHEIDSMETER, 8);
     a2e:	68 e0       	ldi	r22, 0x08	; 8
     a30:	80 e1       	ldi	r24, 0x10	; 16
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	0e 94 9f 00 	call	0x13e	; 0x13e <listenForMessage>
	init_timer();
     a38:	0e 94 f6 03 	call	0x7ec	; 0x7ec <init_timer>
	curOffset = find_offset(); // returnt offset van eerstvolgende lege sector
     a3c:	0e 94 7f 04 	call	0x8fe	; 0x8fe <find_offset>
     a40:	60 93 a5 01 	sts	0x01A5, r22	; 0x8001a5 <curOffset>
     a44:	70 93 a6 01 	sts	0x01A6, r23	; 0x8001a6 <curOffset+0x1>
     a48:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <curOffset+0x2>
     a4c:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <curOffset+0x3>
	start_log_message(); // schrijf start log bericht naar de kaart zodat je kan zien wanneer de auto opnieuw aan is gezet
     a50:	0e 94 be 04 	call	0x97c	; 0x97c <start_log_message>
	while(1)
	{
		if(overflowCounter>=61) // 61 komt van 16.000.000 / 1024 (klokfrequentie / timer2prescaler) =  15625. 15625 / 256 (8 bit timer) = 61
     a54:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <overflowCounter>
     a58:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <overflowCounter+0x1>
     a5c:	cd 97       	sbiw	r24, 0x3d	; 61
     a5e:	34 f0       	brlt	.+12     	; 0xa6c <main+0x48>
		{
			fill_buffer();
     a60:	0e 94 ff 03 	call	0x7fe	; 0x7fe <fill_buffer>
			overflowCounter = 0;
     a64:	10 92 ab 01 	sts	0x01AB, r1	; 0x8001ab <overflowCounter+0x1>
     a68:	10 92 aa 01 	sts	0x01AA, r1	; 0x8001aa <overflowCounter>
		}
		
		if(startWriting)
     a6c:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <startWriting>
     a70:	88 23       	and	r24, r24
     a72:	81 f3       	breq	.-32     	; 0xa54 <main+0x30>
		{
			writeToCard(); // schrijf buffer op kaart
     a74:	0e 94 52 04 	call	0x8a4	; 0x8a4 <writeToCard>
			PORTC ^= (1 << PC0); // toggle ter indicatie op oscilloscoop dat 1 sector geschreven is
     a78:	98 b1       	in	r25, 0x08	; 8
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	89 27       	eor	r24, r25
     a7e:	88 b9       	out	0x08, r24	; 8
			curOffset += 512; // zet pointer naar volgende sector
     a80:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <curOffset>
     a84:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <curOffset+0x1>
     a88:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <curOffset+0x2>
     a8c:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <curOffset+0x3>
     a90:	9e 5f       	subi	r25, 0xFE	; 254
     a92:	af 4f       	sbci	r26, 0xFF	; 255
     a94:	bf 4f       	sbci	r27, 0xFF	; 255
     a96:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <curOffset>
     a9a:	90 93 a6 01 	sts	0x01A6, r25	; 0x8001a6 <curOffset+0x1>
     a9e:	a0 93 a7 01 	sts	0x01A7, r26	; 0x8001a7 <curOffset+0x2>
     aa2:	b0 93 a8 01 	sts	0x01A8, r27	; 0x8001a8 <curOffset+0x3>
			startWriting = false;
     aa6:	10 92 a9 01 	sts	0x01A9, r1	; 0x8001a9 <startWriting>
     aaa:	d4 cf       	rjmp	.-88     	; 0xa54 <main+0x30>

00000aac <mem_set>:

static FATFS *FatFs; /* Pointer to the file system object (logical drive) */

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
     aac:	fc 01       	movw	r30, r24
	char *d = (char *)dst;
	while (cnt--)
     aae:	03 c0       	rjmp	.+6      	; 0xab6 <mem_set+0xa>
		*d++ = (char)val;
     ab0:	60 83       	st	Z, r22

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     ab2:	ac 01       	movw	r20, r24
		*d++ = (char)val;
     ab4:	31 96       	adiw	r30, 0x01	; 1

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     ab6:	ca 01       	movw	r24, r20
     ab8:	01 97       	sbiw	r24, 0x01	; 1
     aba:	45 2b       	or	r20, r21
     abc:	c9 f7       	brne	.-14     	; 0xab0 <mem_set+0x4>
		*d++ = (char)val;
}
     abe:	08 95       	ret

00000ac0 <mem_cmp>:

/* Compare memory to memory */
static int mem_cmp(const void *dst, const void *src, int cnt)
{
     ac0:	cf 93       	push	r28
     ac2:	df 93       	push	r29
     ac4:	dc 01       	movw	r26, r24
     ac6:	fb 01       	movw	r30, r22
	const char *d = (const char *)dst, *s = (const char *)src;
	int         r = 0;
     ac8:	80 e0       	ldi	r24, 0x00	; 0
     aca:	90 e0       	ldi	r25, 0x00	; 0
	while (cnt-- && (r = *d++ - *s++) == 0)
     acc:	02 c0       	rjmp	.+4      	; 0xad2 <mem_cmp+0x12>
     ace:	fb 01       	movw	r30, r22
     ad0:	de 01       	movw	r26, r28
     ad2:	9a 01       	movw	r18, r20
     ad4:	21 50       	subi	r18, 0x01	; 1
     ad6:	31 09       	sbc	r19, r1
     ad8:	45 2b       	or	r20, r21
     ada:	61 f0       	breq	.+24     	; 0xaf4 <mem_cmp+0x34>
     adc:	ed 01       	movw	r28, r26
     ade:	21 96       	adiw	r28, 0x01	; 1
     ae0:	8c 91       	ld	r24, X
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	bf 01       	movw	r22, r30
     ae6:	6f 5f       	subi	r22, 0xFF	; 255
     ae8:	7f 4f       	sbci	r23, 0xFF	; 255
     aea:	40 81       	ld	r20, Z
     aec:	84 1b       	sub	r24, r20
     aee:	91 09       	sbc	r25, r1
     af0:	a9 01       	movw	r20, r18
     af2:	69 f3       	breq	.-38     	; 0xace <mem_cmp+0xe>
		;
	return r;
}
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	08 95       	ret

00000afa <clust2sect>:
/*-----------------------------------------------------------------------*/

static DWORD clust2sect(           /* !=0: Sector number, 0: Failed - invalid cluster# */
                        CLUST clst /* Cluster# to be converted */
)
{
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
	FATFS *fs = FatFs;
     afe:	e0 91 b0 05 	lds	r30, 0x05B0	; 0x8005b0 <FatFs>
     b02:	f0 91 b1 05 	lds	r31, 0x05B1	; 0x8005b1 <FatFs+0x1>

	clst -= 2;
     b06:	9b 01       	movw	r18, r22
     b08:	ac 01       	movw	r20, r24
     b0a:	22 50       	subi	r18, 0x02	; 2
     b0c:	31 09       	sbc	r19, r1
     b0e:	41 09       	sbc	r20, r1
     b10:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2))
     b12:	86 81       	ldd	r24, Z+6	; 0x06
     b14:	97 81       	ldd	r25, Z+7	; 0x07
     b16:	a0 85       	ldd	r26, Z+8	; 0x08
     b18:	b1 85       	ldd	r27, Z+9	; 0x09
     b1a:	02 97       	sbiw	r24, 0x02	; 2
     b1c:	a1 09       	sbc	r26, r1
     b1e:	b1 09       	sbc	r27, r1
     b20:	28 17       	cp	r18, r24
     b22:	39 07       	cpc	r19, r25
     b24:	4a 07       	cpc	r20, r26
     b26:	5b 07       	cpc	r21, r27
     b28:	68 f4       	brcc	.+26     	; 0xb44 <clust2sect+0x4a>
		return 0; /* Invalid cluster# */
	return (DWORD)clst * fs->csize + fs->database;
     b2a:	a2 81       	ldd	r26, Z+2	; 0x02
     b2c:	b0 e0       	ldi	r27, 0x00	; 0
     b2e:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <__muluhisi3>
     b32:	02 89       	ldd	r16, Z+18	; 0x12
     b34:	13 89       	ldd	r17, Z+19	; 0x13
     b36:	24 89       	ldd	r18, Z+20	; 0x14
     b38:	35 89       	ldd	r19, Z+21	; 0x15
     b3a:	60 0f       	add	r22, r16
     b3c:	71 1f       	adc	r23, r17
     b3e:	82 1f       	adc	r24, r18
     b40:	93 1f       	adc	r25, r19
     b42:	03 c0       	rjmp	.+6      	; 0xb4a <clust2sect+0x50>
{
	FATFS *fs = FatFs;

	clst -= 2;
	if (clst >= (fs->n_fatent - 2))
		return 0; /* Invalid cluster# */
     b44:	60 e0       	ldi	r22, 0x00	; 0
     b46:	70 e0       	ldi	r23, 0x00	; 0
     b48:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     b4a:	1f 91       	pop	r17
     b4c:	0f 91       	pop	r16
     b4e:	08 95       	ret

00000b50 <get_clust>:

static CLUST get_clust(BYTE *dir /* Pointer to directory entry */
)
{
     b50:	0f 93       	push	r16
     b52:	1f 93       	push	r17
     b54:	fc 01       	movw	r30, r24
	FATFS *fs   = FatFs;
	CLUST  clst = 0;

	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
		clst = LD_WORD(dir + DIR_FstClusHI);
     b56:	65 89       	ldd	r22, Z+21	; 0x15
     b58:	70 e0       	ldi	r23, 0x00	; 0
     b5a:	76 2f       	mov	r23, r22
     b5c:	66 27       	eor	r22, r22
     b5e:	84 89       	ldd	r24, Z+20	; 0x14
     b60:	68 2b       	or	r22, r24
     b62:	cb 01       	movw	r24, r22
     b64:	a0 e0       	ldi	r26, 0x00	; 0
     b66:	b0 e0       	ldi	r27, 0x00	; 0
		clst <<= 16;
     b68:	bc 01       	movw	r22, r24
     b6a:	55 27       	eor	r21, r21
     b6c:	44 27       	eor	r20, r20
	}
	clst |= LD_WORD(dir + DIR_FstClusLO);
     b6e:	83 8d       	ldd	r24, Z+27	; 0x1b
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	98 2f       	mov	r25, r24
     b74:	88 27       	eor	r24, r24
     b76:	22 8d       	ldd	r18, Z+26	; 0x1a
     b78:	82 2b       	or	r24, r18
     b7a:	a0 e0       	ldi	r26, 0x00	; 0
     b7c:	b0 e0       	ldi	r27, 0x00	; 0
     b7e:	8c 01       	movw	r16, r24
     b80:	9d 01       	movw	r18, r26
     b82:	04 2b       	or	r16, r20
     b84:	15 2b       	or	r17, r21
     b86:	26 2b       	or	r18, r22
     b88:	37 2b       	or	r19, r23
     b8a:	c9 01       	movw	r24, r18
     b8c:	b8 01       	movw	r22, r16

	return clst;
}
     b8e:	1f 91       	pop	r17
     b90:	0f 91       	pop	r16
     b92:	08 95       	ret

00000b94 <dir_rewind>:
/* Directory handling - Rewind directory index                           */
/*-----------------------------------------------------------------------*/

static FRESULT dir_rewind(DIR *dj /* Pointer to directory object */
)
{
     b94:	0f 93       	push	r16
     b96:	1f 93       	push	r17
     b98:	cf 93       	push	r28
     b9a:	df 93       	push	r29
     b9c:	fc 01       	movw	r30, r24
	CLUST  clst;
	FATFS *fs = FatFs;
     b9e:	a0 91 b0 05 	lds	r26, 0x05B0	; 0x8005b0 <FatFs>
     ba2:	b0 91 b1 05 	lds	r27, 0x05B1	; 0x8005b1 <FatFs+0x1>

	dj->index = 0;
     ba6:	11 82       	std	Z+1, r1	; 0x01
     ba8:	10 82       	st	Z, r1
	clst      = dj->sclust;
     baa:	64 81       	ldd	r22, Z+4	; 0x04
     bac:	75 81       	ldd	r23, Z+5	; 0x05
     bae:	86 81       	ldd	r24, Z+6	; 0x06
     bb0:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
     bb2:	61 30       	cpi	r22, 0x01	; 1
     bb4:	71 05       	cpc	r23, r1
     bb6:	81 05       	cpc	r24, r1
     bb8:	91 05       	cpc	r25, r1
     bba:	19 f1       	breq	.+70     	; 0xc02 <dir_rewind+0x6e>
     bbc:	16 96       	adiw	r26, 0x06	; 6
     bbe:	0d 91       	ld	r16, X+
     bc0:	1d 91       	ld	r17, X+
     bc2:	2d 91       	ld	r18, X+
     bc4:	3c 91       	ld	r19, X
     bc6:	19 97       	sbiw	r26, 0x09	; 9
     bc8:	60 17       	cp	r22, r16
     bca:	71 07       	cpc	r23, r17
     bcc:	82 07       	cpc	r24, r18
     bce:	93 07       	cpc	r25, r19
     bd0:	d0 f4       	brcc	.+52     	; 0xc06 <dir_rewind+0x72>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst
     bd2:	61 15       	cp	r22, r1
     bd4:	71 05       	cpc	r23, r1
     bd6:	81 05       	cpc	r24, r1
     bd8:	91 05       	cpc	r25, r1
     bda:	31 f4       	brne	.+12     	; 0xbe8 <dir_rewind+0x54>
	    && (_FS_32ONLY || fs->fs_type == FS_FAT32)) /* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
     bdc:	1e 96       	adiw	r26, 0x0e	; 14
     bde:	6d 91       	ld	r22, X+
     be0:	7d 91       	ld	r23, X+
     be2:	8d 91       	ld	r24, X+
     be4:	9c 91       	ld	r25, X
     be6:	51 97       	sbiw	r26, 0x11	; 17
     be8:	ef 01       	movw	r28, r30
	dj->clust = clst;                                                  /* Current cluster */
     bea:	60 87       	std	Z+8, r22	; 0x08
     bec:	71 87       	std	Z+9, r23	; 0x09
     bee:	82 87       	std	Z+10, r24	; 0x0a
     bf0:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */
     bf2:	0e 94 7d 05 	call	0xafa	; 0xafa <clust2sect>
     bf6:	6c 87       	std	Y+12, r22	; 0x0c
     bf8:	7d 87       	std	Y+13, r23	; 0x0d
     bfa:	8e 87       	std	Y+14, r24	; 0x0e
     bfc:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK; /* Seek succeeded */
     bfe:	80 e0       	ldi	r24, 0x00	; 0
     c00:	03 c0       	rjmp	.+6      	; 0xc08 <dir_rewind+0x74>
	FATFS *fs = FatFs;

	dj->index = 0;
	clst      = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
		return FR_DISK_ERR;
     c02:	81 e0       	ldi	r24, 0x01	; 1
     c04:	01 c0       	rjmp	.+2      	; 0xc08 <dir_rewind+0x74>
     c06:	81 e0       	ldi	r24, 0x01	; 1
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;                                                  /* Current cluster */
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */

	return FR_OK; /* Seek succeeded */
}
     c08:	df 91       	pop	r29
     c0a:	cf 91       	pop	r28
     c0c:	1f 91       	pop	r17
     c0e:	0f 91       	pop	r16
     c10:	08 95       	ret

00000c12 <create_name>:
/*-----------------------------------------------------------------------*/

static FRESULT create_name(DIR *        dj,  /* Pointer to the directory object */
                           const char **path /* Pointer to pointer to the segment in the path string */
)
{
     c12:	0f 93       	push	r16
     c14:	1f 93       	push	r17
     c16:	cf 93       	push	r28
     c18:	df 93       	push	r29
     c1a:	eb 01       	movw	r28, r22
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
     c1c:	fc 01       	movw	r30, r24
     c1e:	02 81       	ldd	r16, Z+2	; 0x02
     c20:	13 81       	ldd	r17, Z+3	; 0x03
	mem_set(sfn, ' ', 11);
     c22:	4b e0       	ldi	r20, 0x0B	; 11
     c24:	50 e0       	ldi	r21, 0x00	; 0
     c26:	60 e2       	ldi	r22, 0x20	; 32
     c28:	70 e0       	ldi	r23, 0x00	; 0
     c2a:	c8 01       	movw	r24, r16
     c2c:	0e 94 56 05 	call	0xaac	; 0xaac <mem_set>
	si = i = 0;
	ni     = 8;
	p      = *path;
     c30:	28 81       	ld	r18, Y
     c32:	39 81       	ldd	r19, Y+1	; 0x01
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0;
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	80 e0       	ldi	r24, 0x00	; 0
	ni     = 8;
     c38:	58 e0       	ldi	r21, 0x08	; 8
     c3a:	01 c0       	rjmp	.+2      	; 0xc3e <create_name+0x2c>
     c3c:	84 2f       	mov	r24, r20
	p      = *path;
	for (;;) {
		c = p[si++];
     c3e:	41 e0       	ldi	r20, 0x01	; 1
     c40:	48 0f       	add	r20, r24
     c42:	f9 01       	movw	r30, r18
     c44:	e8 0f       	add	r30, r24
     c46:	f1 1d       	adc	r31, r1
     c48:	e0 81       	ld	r30, Z
		if (c <= ' ' || c == '/')
     c4a:	e1 32       	cpi	r30, 0x21	; 33
     c4c:	f0 f0       	brcs	.+60     	; 0xc8a <create_name+0x78>
     c4e:	ef 32       	cpi	r30, 0x2F	; 47
     c50:	e1 f0       	breq	.+56     	; 0xc8a <create_name+0x78>
			break; /* Break on end of segment */
		if (c == '.' || i >= ni) {
     c52:	ee 32       	cpi	r30, 0x2E	; 46
     c54:	11 f0       	breq	.+4      	; 0xc5a <create_name+0x48>
     c56:	95 17       	cp	r25, r21
     c58:	38 f0       	brcs	.+14     	; 0xc68 <create_name+0x56>
			if (ni != 8 || c != '.')
     c5a:	58 30       	cpi	r21, 0x08	; 8
     c5c:	b1 f4       	brne	.+44     	; 0xc8a <create_name+0x78>
     c5e:	ee 32       	cpi	r30, 0x2E	; 46
     c60:	a1 f4       	brne	.+40     	; 0xc8a <create_name+0x78>
				break;
			i  = 8;
     c62:	98 e0       	ldi	r25, 0x08	; 8
			ni = 11;
     c64:	5b e0       	ldi	r21, 0x0B	; 11
     c66:	ea cf       	rjmp	.-44     	; 0xc3c <create_name+0x2a>
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80) /* To upper extended char (SBCS) */
     c68:	ee 23       	and	r30, r30
     c6a:	24 f4       	brge	.+8      	; 0xc74 <create_name+0x62>
			c = cvt[c - 0x80];
     c6c:	f0 e0       	ldi	r31, 0x00	; 0
     c6e:	e0 56       	subi	r30, 0x60	; 96
     c70:	ff 4f       	sbci	r31, 0xFF	; 255
     c72:	e0 81       	ld	r30, Z
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{ /* Single byte code */
			if (_USE_LCC && IsLower(c))
     c74:	8f e9       	ldi	r24, 0x9F	; 159
     c76:	8e 0f       	add	r24, r30
     c78:	8a 31       	cpi	r24, 0x1A	; 26
     c7a:	08 f4       	brcc	.+2      	; 0xc7e <create_name+0x6c>
				c -= 0x20; /* toupper */
     c7c:	e0 52       	subi	r30, 0x20	; 32
			sfn[i++] = c;
     c7e:	d8 01       	movw	r26, r16
     c80:	a9 0f       	add	r26, r25
     c82:	b1 1d       	adc	r27, r1
     c84:	ec 93       	st	X, r30
     c86:	9f 5f       	subi	r25, 0xFF	; 255
     c88:	d9 cf       	rjmp	.-78     	; 0xc3c <create_name+0x2a>
		}
	}
	*path = &p[si]; /* Rerurn pointer to the next segment */
     c8a:	24 0f       	add	r18, r20
     c8c:	31 1d       	adc	r19, r1
     c8e:	39 83       	std	Y+1, r19	; 0x01
     c90:	28 83       	st	Y, r18

	sfn[11] = (c <= ' ') ? 1 : 0; /* Set last segment flag if end of path */
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	e1 32       	cpi	r30, 0x21	; 33
     c96:	08 f0       	brcs	.+2      	; 0xc9a <create_name+0x88>
     c98:	80 e0       	ldi	r24, 0x00	; 0
     c9a:	f8 01       	movw	r30, r16
     c9c:	83 87       	std	Z+11, r24	; 0x0b

	return FR_OK;
}
     c9e:	80 e0       	ldi	r24, 0x00	; 0
     ca0:	df 91       	pop	r29
     ca2:	cf 91       	pop	r28
     ca4:	1f 91       	pop	r17
     ca6:	0f 91       	pop	r16
     ca8:	08 95       	ret

00000caa <check_fs>:

static BYTE check_fs(/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     caa:	cf 92       	push	r12
     cac:	df 92       	push	r13
     cae:	ef 92       	push	r14
     cb0:	ff 92       	push	r15
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	ec 01       	movw	r28, r24
     cbc:	6a 01       	movw	r12, r20
     cbe:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
     cc0:	02 e0       	ldi	r16, 0x02	; 2
     cc2:	10 e0       	ldi	r17, 0x00	; 0
     cc4:	2e ef       	ldi	r18, 0xFE	; 254
     cc6:	31 e0       	ldi	r19, 0x01	; 1
     cc8:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
     ccc:	81 11       	cpse	r24, r1
     cce:	1d c0       	rjmp	.+58     	; 0xd0a <check_fs+0x60>
		return 3;
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
     cd0:	89 81       	ldd	r24, Y+1	; 0x01
     cd2:	90 e0       	ldi	r25, 0x00	; 0
     cd4:	98 2f       	mov	r25, r24
     cd6:	88 27       	eor	r24, r24
     cd8:	28 81       	ld	r18, Y
     cda:	82 2b       	or	r24, r18
     cdc:	85 35       	cpi	r24, 0x55	; 85
     cde:	9a 4a       	sbci	r25, 0xAA	; 170
     ce0:	b1 f4       	brne	.+44     	; 0xd0e <check_fs+0x64>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
     ce2:	22 e5       	ldi	r18, 0x52	; 82
     ce4:	30 e0       	ldi	r19, 0x00	; 0
     ce6:	b7 01       	movw	r22, r14
     ce8:	a6 01       	movw	r20, r12
     cea:	ce 01       	movw	r24, r28
     cec:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
     cf0:	81 11       	cpse	r24, r1
     cf2:	0f c0       	rjmp	.+30     	; 0xd12 <check_fs+0x68>
     cf4:	89 81       	ldd	r24, Y+1	; 0x01
     cf6:	90 e0       	ldi	r25, 0x00	; 0
     cf8:	98 2f       	mov	r25, r24
     cfa:	88 27       	eor	r24, r24
     cfc:	28 81       	ld	r18, Y
     cfe:	82 2b       	or	r24, r18
     d00:	86 34       	cpi	r24, 0x46	; 70
     d02:	91 44       	sbci	r25, 0x41	; 65
     d04:	41 f0       	breq	.+16     	; 0xd16 <check_fs+0x6c>
		return 0;
	return 1;
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	07 c0       	rjmp	.+14     	; 0xd18 <check_fs+0x6e>
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
		return 3;
     d0a:	83 e0       	ldi	r24, 0x03	; 3
     d0c:	05 c0       	rjmp	.+10     	; 0xd18 <check_fs+0x6e>
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
		return 2;
     d0e:	82 e0       	ldi	r24, 0x02	; 2
     d10:	03 c0       	rjmp	.+6      	; 0xd18 <check_fs+0x6e>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
	return 1;
     d12:	81 e0       	ldi	r24, 0x01	; 1
     d14:	01 c0       	rjmp	.+2      	; 0xd18 <check_fs+0x6e>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
     d16:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
     d18:	df 91       	pop	r29
     d1a:	cf 91       	pop	r28
     d1c:	1f 91       	pop	r17
     d1e:	0f 91       	pop	r16
     d20:	ff 90       	pop	r15
     d22:	ef 90       	pop	r14
     d24:	df 90       	pop	r13
     d26:	cf 90       	pop	r12
     d28:	08 95       	ret

00000d2a <get_fat>:
/*-----------------------------------------------------------------------*/

static CLUST get_fat(           /* 1:IO error, Else:Cluster status */
                     CLUST clst /* Cluster# to get the link information */
)
{
     d2a:	cf 92       	push	r12
     d2c:	df 92       	push	r13
     d2e:	ef 92       	push	r14
     d30:	ff 92       	push	r15
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	00 d0       	rcall	.+0      	; 0xd3c <get_fat+0x12>
     d3c:	00 d0       	rcall	.+0      	; 0xd3e <get_fat+0x14>
     d3e:	cd b7       	in	r28, 0x3d	; 61
     d40:	de b7       	in	r29, 0x3e	; 62
	BYTE   buf[4];
	FATFS *fs = FatFs;
     d42:	e0 91 b0 05 	lds	r30, 0x05B0	; 0x8005b0 <FatFs>
     d46:	f0 91 b1 05 	lds	r31, 0x05B1	; 0x8005b1 <FatFs+0x1>

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
     d4a:	62 30       	cpi	r22, 0x02	; 2
     d4c:	71 05       	cpc	r23, r1
     d4e:	81 05       	cpc	r24, r1
     d50:	91 05       	cpc	r25, r1
     d52:	08 f4       	brcc	.+2      	; 0xd56 <get_fat+0x2c>
     d54:	56 c0       	rjmp	.+172    	; 0xe02 <get_fat+0xd8>
     d56:	06 81       	ldd	r16, Z+6	; 0x06
     d58:	17 81       	ldd	r17, Z+7	; 0x07
     d5a:	20 85       	ldd	r18, Z+8	; 0x08
     d5c:	31 85       	ldd	r19, Z+9	; 0x09
     d5e:	60 17       	cp	r22, r16
     d60:	71 07       	cpc	r23, r17
     d62:	82 07       	cpc	r24, r18
     d64:	93 07       	cpc	r25, r19
     d66:	08 f0       	brcs	.+2      	; 0xd6a <get_fat+0x40>
     d68:	51 c0       	rjmp	.+162    	; 0xe0c <get_fat+0xe2>
		return 1;

	switch (fs->fs_type) {
     d6a:	20 81       	ld	r18, Z
     d6c:	23 30       	cpi	r18, 0x03	; 3
     d6e:	09 f0       	breq	.+2      	; 0xd72 <get_fat+0x48>
     d70:	52 c0       	rjmp	.+164    	; 0xe16 <get_fat+0xec>
     d72:	dc 01       	movw	r26, r24
     d74:	cb 01       	movw	r24, r22
			break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32:
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4))
     d76:	9c 01       	movw	r18, r24
     d78:	2f 77       	andi	r18, 0x7F	; 127
     d7a:	33 27       	eor	r19, r19
     d7c:	c2 84       	ldd	r12, Z+10	; 0x0a
     d7e:	d3 84       	ldd	r13, Z+11	; 0x0b
     d80:	e4 84       	ldd	r14, Z+12	; 0x0c
     d82:	f5 84       	ldd	r15, Z+13	; 0x0d
     d84:	68 94       	set
     d86:	16 f8       	bld	r1, 6
     d88:	b6 95       	lsr	r27
     d8a:	a7 95       	ror	r26
     d8c:	97 95       	ror	r25
     d8e:	87 95       	ror	r24
     d90:	16 94       	lsr	r1
     d92:	d1 f7       	brne	.-12     	; 0xd88 <get_fat+0x5e>
     d94:	22 0f       	add	r18, r18
     d96:	33 1f       	adc	r19, r19
     d98:	22 0f       	add	r18, r18
     d9a:	33 1f       	adc	r19, r19
     d9c:	b7 01       	movw	r22, r14
     d9e:	a6 01       	movw	r20, r12
     da0:	48 0f       	add	r20, r24
     da2:	59 1f       	adc	r21, r25
     da4:	6a 1f       	adc	r22, r26
     da6:	7b 1f       	adc	r23, r27
     da8:	04 e0       	ldi	r16, 0x04	; 4
     daa:	10 e0       	ldi	r17, 0x00	; 0
     dac:	ce 01       	movw	r24, r28
     dae:	01 96       	adiw	r24, 0x01	; 1
     db0:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
     db4:	81 11       	cpse	r24, r1
     db6:	34 c0       	rjmp	.+104    	; 0xe20 <get_fat+0xf6>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
     db8:	8c 81       	ldd	r24, Y+4	; 0x04
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	a0 e0       	ldi	r26, 0x00	; 0
     dbe:	b0 e0       	ldi	r27, 0x00	; 0
     dc0:	78 2f       	mov	r23, r24
     dc2:	66 27       	eor	r22, r22
     dc4:	55 27       	eor	r21, r21
     dc6:	44 27       	eor	r20, r20
     dc8:	9b 81       	ldd	r25, Y+3	; 0x03
     dca:	89 2f       	mov	r24, r25
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	a0 e0       	ldi	r26, 0x00	; 0
     dd0:	b0 e0       	ldi	r27, 0x00	; 0
     dd2:	dc 01       	movw	r26, r24
     dd4:	99 27       	eor	r25, r25
     dd6:	88 27       	eor	r24, r24
     dd8:	84 2b       	or	r24, r20
     dda:	95 2b       	or	r25, r21
     ddc:	a6 2b       	or	r26, r22
     dde:	b7 2b       	or	r27, r23
     de0:	6a 81       	ldd	r22, Y+2	; 0x02
     de2:	70 e0       	ldi	r23, 0x00	; 0
     de4:	76 2f       	mov	r23, r22
     de6:	66 27       	eor	r22, r22
     de8:	ab 01       	movw	r20, r22
     dea:	60 e0       	ldi	r22, 0x00	; 0
     dec:	70 e0       	ldi	r23, 0x00	; 0
     dee:	84 2b       	or	r24, r20
     df0:	95 2b       	or	r25, r21
     df2:	a6 2b       	or	r26, r22
     df4:	b7 2b       	or	r27, r23
     df6:	29 81       	ldd	r18, Y+1	; 0x01
     df8:	82 2b       	or	r24, r18
     dfa:	bc 01       	movw	r22, r24
     dfc:	cd 01       	movw	r24, r26
     dfe:	9f 70       	andi	r25, 0x0F	; 15
     e00:	13 c0       	rjmp	.+38     	; 0xe28 <get_fat+0xfe>
{
	BYTE   buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
		return 1;
     e02:	61 e0       	ldi	r22, 0x01	; 1
     e04:	70 e0       	ldi	r23, 0x00	; 0
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	90 e0       	ldi	r25, 0x00	; 0
     e0a:	0e c0       	rjmp	.+28     	; 0xe28 <get_fat+0xfe>
     e0c:	61 e0       	ldi	r22, 0x01	; 1
     e0e:	70 e0       	ldi	r23, 0x00	; 0
     e10:	80 e0       	ldi	r24, 0x00	; 0
     e12:	90 e0       	ldi	r25, 0x00	; 0
     e14:	09 c0       	rjmp	.+18     	; 0xe28 <get_fat+0xfe>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1; /* An error occured at the disk I/O layer */
     e16:	61 e0       	ldi	r22, 0x01	; 1
     e18:	70 e0       	ldi	r23, 0x00	; 0
     e1a:	80 e0       	ldi	r24, 0x00	; 0
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	04 c0       	rjmp	.+8      	; 0xe28 <get_fat+0xfe>
     e20:	61 e0       	ldi	r22, 0x01	; 1
     e22:	70 e0       	ldi	r23, 0x00	; 0
     e24:	80 e0       	ldi	r24, 0x00	; 0
     e26:	90 e0       	ldi	r25, 0x00	; 0
}
     e28:	0f 90       	pop	r0
     e2a:	0f 90       	pop	r0
     e2c:	0f 90       	pop	r0
     e2e:	0f 90       	pop	r0
     e30:	df 91       	pop	r29
     e32:	cf 91       	pop	r28
     e34:	1f 91       	pop	r17
     e36:	0f 91       	pop	r16
     e38:	ff 90       	pop	r15
     e3a:	ef 90       	pop	r14
     e3c:	df 90       	pop	r13
     e3e:	cf 90       	pop	r12
     e40:	08 95       	ret

00000e42 <dir_next>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_next(        /* FR_OK:Succeeded, FR_NO_FILE:End of table */
                        DIR *dj /* Pointer to directory object */
)
{
     e42:	cf 92       	push	r12
     e44:	df 92       	push	r13
     e46:	ef 92       	push	r14
     e48:	ff 92       	push	r15
     e4a:	0f 93       	push	r16
     e4c:	1f 93       	push	r17
     e4e:	cf 93       	push	r28
     e50:	df 93       	push	r29
	CLUST  clst;
	WORD   i;
	FATFS *fs = FatFs;
     e52:	e0 90 b0 05 	lds	r14, 0x05B0	; 0x8005b0 <FatFs>
     e56:	f0 90 b1 05 	lds	r15, 0x05B1	; 0x8005b1 <FatFs+0x1>

	i = dj->index + 1;
     e5a:	fc 01       	movw	r30, r24
     e5c:	c0 81       	ld	r28, Z
     e5e:	d1 81       	ldd	r29, Z+1	; 0x01
     e60:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
     e62:	09 f4       	brne	.+2      	; 0xe66 <dir_next+0x24>
     e64:	5c c0       	rjmp	.+184    	; 0xf1e <dir_next+0xdc>
     e66:	44 85       	ldd	r20, Z+12	; 0x0c
     e68:	55 85       	ldd	r21, Z+13	; 0x0d
     e6a:	66 85       	ldd	r22, Z+14	; 0x0e
     e6c:	77 85       	ldd	r23, Z+15	; 0x0f
     e6e:	41 15       	cp	r20, r1
     e70:	51 05       	cpc	r21, r1
     e72:	61 05       	cpc	r22, r1
     e74:	71 05       	cpc	r23, r1
     e76:	09 f4       	brne	.+2      	; 0xe7a <dir_next+0x38>
     e78:	54 c0       	rjmp	.+168    	; 0xf22 <dir_next+0xe0>
     e7a:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i % 16)) { /* Sector changed? */
     e7c:	ce 01       	movw	r24, r28
     e7e:	8f 70       	andi	r24, 0x0F	; 15
     e80:	99 27       	eor	r25, r25
     e82:	89 2b       	or	r24, r25
     e84:	09 f0       	breq	.+2      	; 0xe88 <dir_next+0x46>
     e86:	46 c0       	rjmp	.+140    	; 0xf14 <dir_next+0xd2>
		dj->sect++;  /* Next sector */
     e88:	4f 5f       	subi	r20, 0xFF	; 255
     e8a:	5f 4f       	sbci	r21, 0xFF	; 255
     e8c:	6f 4f       	sbci	r22, 0xFF	; 255
     e8e:	7f 4f       	sbci	r23, 0xFF	; 255
     e90:	44 87       	std	Z+12, r20	; 0x0c
     e92:	55 87       	std	Z+13, r21	; 0x0d
     e94:	66 87       	std	Z+14, r22	; 0x0e
     e96:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {       /* Static table */
     e98:	40 85       	ldd	r20, Z+8	; 0x08
     e9a:	51 85       	ldd	r21, Z+9	; 0x09
     e9c:	62 85       	ldd	r22, Z+10	; 0x0a
     e9e:	73 85       	ldd	r23, Z+11	; 0x0b
     ea0:	41 15       	cp	r20, r1
     ea2:	51 05       	cpc	r21, r1
     ea4:	61 05       	cpc	r22, r1
     ea6:	71 05       	cpc	r23, r1
     ea8:	39 f4       	brne	.+14     	; 0xeb8 <dir_next+0x76>
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
     eaa:	f7 01       	movw	r30, r14
     eac:	84 81       	ldd	r24, Z+4	; 0x04
     eae:	95 81       	ldd	r25, Z+5	; 0x05
     eb0:	c8 17       	cp	r28, r24
     eb2:	d9 07       	cpc	r29, r25
     eb4:	c0 f5       	brcc	.+112    	; 0xf26 <dir_next+0xe4>
     eb6:	2e c0       	rjmp	.+92     	; 0xf14 <dir_next+0xd2>
				return FR_NO_FILE;
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
     eb8:	f7 01       	movw	r30, r14
     eba:	82 81       	ldd	r24, Z+2	; 0x02
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	01 97       	sbiw	r24, 0x01	; 1
     ec0:	9e 01       	movw	r18, r28
     ec2:	32 95       	swap	r19
     ec4:	22 95       	swap	r18
     ec6:	2f 70       	andi	r18, 0x0F	; 15
     ec8:	23 27       	eor	r18, r19
     eca:	3f 70       	andi	r19, 0x0F	; 15
     ecc:	23 27       	eor	r18, r19
     ece:	82 23       	and	r24, r18
     ed0:	93 23       	and	r25, r19
     ed2:	89 2b       	or	r24, r25
     ed4:	f9 f4       	brne	.+62     	; 0xf14 <dir_next+0xd2>
				clst = get_fat(dj->clust);           /* Get next cluster */
     ed6:	cb 01       	movw	r24, r22
     ed8:	ba 01       	movw	r22, r20
     eda:	0e 94 95 06 	call	0xd2a	; 0xd2a <get_fat>
				if (clst <= 1)
     ede:	62 30       	cpi	r22, 0x02	; 2
     ee0:	71 05       	cpc	r23, r1
     ee2:	81 05       	cpc	r24, r1
     ee4:	91 05       	cpc	r25, r1
     ee6:	08 f1       	brcs	.+66     	; 0xf2a <dir_next+0xe8>
					return FR_DISK_ERR;
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
     ee8:	f7 01       	movw	r30, r14
     eea:	c6 80       	ldd	r12, Z+6	; 0x06
     eec:	d7 80       	ldd	r13, Z+7	; 0x07
     eee:	e0 84       	ldd	r14, Z+8	; 0x08
     ef0:	f1 84       	ldd	r15, Z+9	; 0x09
     ef2:	6c 15       	cp	r22, r12
     ef4:	7d 05       	cpc	r23, r13
     ef6:	8e 05       	cpc	r24, r14
     ef8:	9f 05       	cpc	r25, r15
     efa:	c8 f4       	brcc	.+50     	; 0xf2e <dir_next+0xec>
					return FR_NO_FILE;    /* Report EOT */
				dj->clust = clst;         /* Initialize data for new cluster */
     efc:	f8 01       	movw	r30, r16
     efe:	60 87       	std	Z+8, r22	; 0x08
     f00:	71 87       	std	Z+9, r23	; 0x09
     f02:	82 87       	std	Z+10, r24	; 0x0a
     f04:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect  = clust2sect(clst);
     f06:	0e 94 7d 05 	call	0xafa	; 0xafa <clust2sect>
     f0a:	f8 01       	movw	r30, r16
     f0c:	64 87       	std	Z+12, r22	; 0x0c
     f0e:	75 87       	std	Z+13, r23	; 0x0d
     f10:	86 87       	std	Z+14, r24	; 0x0e
     f12:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
     f14:	f8 01       	movw	r30, r16
     f16:	d1 83       	std	Z+1, r29	; 0x01
     f18:	c0 83       	st	Z, r28

	return FR_OK;
     f1a:	80 e0       	ldi	r24, 0x00	; 0
     f1c:	09 c0       	rjmp	.+18     	; 0xf30 <dir_next+0xee>
	WORD   i;
	FATFS *fs = FatFs;

	i = dj->index + 1;
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
     f1e:	83 e0       	ldi	r24, 0x03	; 3
     f20:	07 c0       	rjmp	.+14     	; 0xf30 <dir_next+0xee>
     f22:	83 e0       	ldi	r24, 0x03	; 3
     f24:	05 c0       	rjmp	.+10     	; 0xf30 <dir_next+0xee>
	if (!(i % 16)) { /* Sector changed? */
		dj->sect++;  /* Next sector */

		if (dj->clust == 0) {       /* Static table */
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
				return FR_NO_FILE;
     f26:	83 e0       	ldi	r24, 0x03	; 3
     f28:	03 c0       	rjmp	.+6      	; 0xf30 <dir_next+0xee>
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
				clst = get_fat(dj->clust);           /* Get next cluster */
				if (clst <= 1)
					return FR_DISK_ERR;
     f2a:	81 e0       	ldi	r24, 0x01	; 1
     f2c:	01 c0       	rjmp	.+2      	; 0xf30 <dir_next+0xee>
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
					return FR_NO_FILE;    /* Report EOT */
     f2e:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
     f30:	df 91       	pop	r29
     f32:	cf 91       	pop	r28
     f34:	1f 91       	pop	r17
     f36:	0f 91       	pop	r16
     f38:	ff 90       	pop	r15
     f3a:	ef 90       	pop	r14
     f3c:	df 90       	pop	r13
     f3e:	cf 90       	pop	r12
     f40:	08 95       	ret

00000f42 <dir_find>:
/*-----------------------------------------------------------------------*/

	static FRESULT dir_find(DIR * dj, /* Pointer to the directory object linked to the file name */
							BYTE *dir /* 32-byte working buffer */
	)
	{
     f42:	cf 92       	push	r12
     f44:	df 92       	push	r13
     f46:	ff 92       	push	r15
     f48:	0f 93       	push	r16
     f4a:	1f 93       	push	r17
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	ec 01       	movw	r28, r24
     f52:	6b 01       	movw	r12, r22
		FRESULT res;
		BYTE    c;

		res = dir_rewind(dj); /* Rewind directory object */
     f54:	0e 94 ca 05 	call	0xb94	; 0xb94 <dir_rewind>
		if (res != FR_OK)
     f58:	81 11       	cpse	r24, r1
     f5a:	37 c0       	rjmp	.+110    	; 0xfca <dir_find+0x88>
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     f5c:	28 81       	ld	r18, Y
     f5e:	39 81       	ldd	r19, Y+1	; 0x01
     f60:	2f 70       	andi	r18, 0x0F	; 15
     f62:	33 27       	eor	r19, r19
     f64:	22 0f       	add	r18, r18
     f66:	33 1f       	adc	r19, r19
     f68:	22 95       	swap	r18
     f6a:	32 95       	swap	r19
     f6c:	30 7f       	andi	r19, 0xF0	; 240
     f6e:	32 27       	eor	r19, r18
     f70:	20 7f       	andi	r18, 0xF0	; 240
     f72:	32 27       	eor	r19, r18
     f74:	4c 85       	ldd	r20, Y+12	; 0x0c
     f76:	5d 85       	ldd	r21, Y+13	; 0x0d
     f78:	6e 85       	ldd	r22, Y+14	; 0x0e
     f7a:	7f 85       	ldd	r23, Y+15	; 0x0f
     f7c:	00 e2       	ldi	r16, 0x20	; 32
     f7e:	10 e0       	ldi	r17, 0x00	; 0
     f80:	c6 01       	movw	r24, r12
     f82:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
					  ? FR_DISK_ERR
					  : FR_OK;
     f86:	91 e0       	ldi	r25, 0x01	; 1
     f88:	81 11       	cpse	r24, r1
     f8a:	01 c0       	rjmp	.+2      	; 0xf8e <dir_find+0x4c>
     f8c:	90 e0       	ldi	r25, 0x00	; 0
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     f8e:	f9 2e       	mov	r15, r25
					  ? FR_DISK_ERR
					  : FR_OK;
			if (res != FR_OK)
     f90:	91 11       	cpse	r25, r1
     f92:	16 c0       	rjmp	.+44     	; 0xfc0 <dir_find+0x7e>
				break;
			c = dir[DIR_Name]; /* First character */
     f94:	f6 01       	movw	r30, r12
     f96:	80 81       	ld	r24, Z
			if (c == 0) { ///// hieerrr fout misschien
     f98:	88 23       	and	r24, r24
     f9a:	a1 f0       	breq	.+40     	; 0xfc4 <dir_find+0x82>
				res = FR_NO_FILE;
				break;
			}                                                           /* Reached to end of table */
			if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
     f9c:	83 85       	ldd	r24, Z+11	; 0x0b
     f9e:	83 fd       	sbrc	r24, 3
     fa0:	09 c0       	rjmp	.+18     	; 0xfb4 <dir_find+0x72>
     fa2:	6a 81       	ldd	r22, Y+2	; 0x02
     fa4:	7b 81       	ldd	r23, Y+3	; 0x03
     fa6:	4b e0       	ldi	r20, 0x0B	; 11
     fa8:	50 e0       	ldi	r21, 0x00	; 0
     faa:	c6 01       	movw	r24, r12
     fac:	0e 94 60 05 	call	0xac0	; 0xac0 <mem_cmp>
     fb0:	89 2b       	or	r24, r25
     fb2:	51 f0       	breq	.+20     	; 0xfc8 <dir_find+0x86>
				break;
			res = dir_next(dj); /* Next entry */
     fb4:	ce 01       	movw	r24, r28
     fb6:	0e 94 21 07 	call	0xe42	; 0xe42 <dir_next>
		} while (res == FR_OK);
     fba:	88 23       	and	r24, r24
     fbc:	79 f2       	breq	.-98     	; 0xf5c <dir_find+0x1a>
     fbe:	05 c0       	rjmp	.+10     	; 0xfca <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     fc0:	89 2f       	mov	r24, r25
     fc2:	03 c0       	rjmp	.+6      	; 0xfca <dir_find+0x88>
					  : FR_OK;
			if (res != FR_OK)
				break;
			c = dir[DIR_Name]; /* First character */
			if (c == 0) { ///// hieerrr fout misschien
				res = FR_NO_FILE;
     fc4:	83 e0       	ldi	r24, 0x03	; 3
     fc6:	01 c0       	rjmp	.+2      	; 0xfca <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     fc8:	8f 2d       	mov	r24, r15
				break;
			res = dir_next(dj); /* Next entry */
		} while (res == FR_OK);

		return res;
	}
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	1f 91       	pop	r17
     fd0:	0f 91       	pop	r16
     fd2:	ff 90       	pop	r15
     fd4:	df 90       	pop	r13
     fd6:	cf 90       	pop	r12
     fd8:	08 95       	ret

00000fda <follow_path>:
static FRESULT follow_path(                 /* FR_OK(0): successful, !=0: error code */
                           DIR *       dj,  /* Directory object to return last directory and found object */
                           BYTE *      dir, /* 32-byte working buffer */
                           const char *path /* Full-path string to find a file or directory */
)
{
     fda:	ef 92       	push	r14
     fdc:	ff 92       	push	r15
     fde:	0f 93       	push	r16
     fe0:	1f 93       	push	r17
     fe2:	cf 93       	push	r28
     fe4:	df 93       	push	r29
     fe6:	00 d0       	rcall	.+0      	; 0xfe8 <follow_path+0xe>
     fe8:	cd b7       	in	r28, 0x3d	; 61
     fea:	de b7       	in	r29, 0x3e	; 62
     fec:	8c 01       	movw	r16, r24
     fee:	7b 01       	movw	r14, r22
     ff0:	5a 83       	std	Y+2, r21	; 0x02
     ff2:	49 83       	std	Y+1, r20	; 0x01
	FRESULT res;

	while (*path == ' ')
     ff4:	03 c0       	rjmp	.+6      	; 0xffc <follow_path+0x22>
		path++; /* Strip leading spaces */
     ff6:	31 96       	adiw	r30, 0x01	; 1
     ff8:	fa 83       	std	Y+2, r31	; 0x02
     ffa:	e9 83       	std	Y+1, r30	; 0x01
                           const char *path /* Full-path string to find a file or directory */
)
{
	FRESULT res;

	while (*path == ' ')
     ffc:	e9 81       	ldd	r30, Y+1	; 0x01
     ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    1000:	80 81       	ld	r24, Z
    1002:	80 32       	cpi	r24, 0x20	; 32
    1004:	c1 f3       	breq	.-16     	; 0xff6 <follow_path+0x1c>
		path++; /* Strip leading spaces */
	if (*path == '/')
    1006:	8f 32       	cpi	r24, 0x2F	; 47
    1008:	19 f4       	brne	.+6      	; 0x1010 <follow_path+0x36>
		path++;     /* Strip heading separator if exist */
    100a:	31 96       	adiw	r30, 0x01	; 1
    100c:	fa 83       	std	Y+2, r31	; 0x02
    100e:	e9 83       	std	Y+1, r30	; 0x01
	dj->sclust = 0; /* Set start directory (always root dir) */
    1010:	d8 01       	movw	r26, r16
    1012:	14 96       	adiw	r26, 0x04	; 4
    1014:	1d 92       	st	X+, r1
    1016:	1d 92       	st	X+, r1
    1018:	1d 92       	st	X+, r1
    101a:	1c 92       	st	X, r1
    101c:	17 97       	sbiw	r26, 0x07	; 7

	if ((BYTE)*path < ' ') { /* Null path means the root directory */
    101e:	e9 81       	ldd	r30, Y+1	; 0x01
    1020:	fa 81       	ldd	r31, Y+2	; 0x02
    1022:	80 81       	ld	r24, Z
    1024:	80 32       	cpi	r24, 0x20	; 32
    1026:	30 f4       	brcc	.+12     	; 0x1034 <follow_path+0x5a>
		res    = dir_rewind(dj);
    1028:	c8 01       	movw	r24, r16
    102a:	0e 94 ca 05 	call	0xb94	; 0xb94 <dir_rewind>
		dir[0] = 0;
    102e:	f7 01       	movw	r30, r14
    1030:	10 82       	st	Z, r1
    1032:	26 c0       	rjmp	.+76     	; 0x1080 <follow_path+0xa6>

	} else { /* Follow path */
		for (;;) {
			res = create_name(dj, &path); /* Get a segment */
    1034:	be 01       	movw	r22, r28
    1036:	6f 5f       	subi	r22, 0xFF	; 255
    1038:	7f 4f       	sbci	r23, 0xFF	; 255
    103a:	c8 01       	movw	r24, r16
    103c:	0e 94 09 06 	call	0xc12	; 0xc12 <create_name>
			if (res != FR_OK)
    1040:	81 11       	cpse	r24, r1
    1042:	1e c0       	rjmp	.+60     	; 0x1080 <follow_path+0xa6>
				break;
			res = dir_find(dj, dir); /* Find it */ // het gaat denk ik hier fout
    1044:	b7 01       	movw	r22, r14
    1046:	c8 01       	movw	r24, r16
    1048:	0e 94 a1 07 	call	0xf42	; 0xf42 <dir_find>
			if (res != FR_OK)
    104c:	81 11       	cpse	r24, r1
    104e:	18 c0       	rjmp	.+48     	; 0x1080 <follow_path+0xa6>
				break; /* Could not find the object */
			if (dj->fn[11])
    1050:	d8 01       	movw	r26, r16
    1052:	12 96       	adiw	r26, 0x02	; 2
    1054:	ed 91       	ld	r30, X+
    1056:	fc 91       	ld	r31, X
    1058:	13 97       	sbiw	r26, 0x03	; 3
    105a:	93 85       	ldd	r25, Z+11	; 0x0b
    105c:	91 11       	cpse	r25, r1
    105e:	10 c0       	rjmp	.+32     	; 0x1080 <follow_path+0xa6>
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
    1060:	f7 01       	movw	r30, r14
    1062:	83 85       	ldd	r24, Z+11	; 0x0b
    1064:	84 ff       	sbrs	r24, 4
    1066:	0b c0       	rjmp	.+22     	; 0x107e <follow_path+0xa4>
				res = FR_NO_FILE;
				break;
			}
			dj->sclust = get_clust(dir); /* Follow next */
    1068:	c7 01       	movw	r24, r14
    106a:	0e 94 a8 05 	call	0xb50	; 0xb50 <get_clust>
    106e:	d8 01       	movw	r26, r16
    1070:	14 96       	adiw	r26, 0x04	; 4
    1072:	6d 93       	st	X+, r22
    1074:	7d 93       	st	X+, r23
    1076:	8d 93       	st	X+, r24
    1078:	9c 93       	st	X, r25
    107a:	17 97       	sbiw	r26, 0x07	; 7
		}
    107c:	db cf       	rjmp	.-74     	; 0x1034 <follow_path+0x5a>
			if (res != FR_OK)
				break; /* Could not find the object */
			if (dj->fn[11])
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE;
    107e:	83 e0       	ldi	r24, 0x03	; 3
			dj->sclust = get_clust(dir); /* Follow next */
		}
	}

	return res;
}
    1080:	0f 90       	pop	r0
    1082:	0f 90       	pop	r0
    1084:	df 91       	pop	r29
    1086:	cf 91       	pop	r28
    1088:	1f 91       	pop	r17
    108a:	0f 91       	pop	r16
    108c:	ff 90       	pop	r15
    108e:	ef 90       	pop	r14
    1090:	08 95       	ret

00001092 <pf_mount>:
/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount(FATFS *fs /* Pointer to new file system object */)
{
    1092:	4f 92       	push	r4
    1094:	5f 92       	push	r5
    1096:	6f 92       	push	r6
    1098:	7f 92       	push	r7
    109a:	8f 92       	push	r8
    109c:	9f 92       	push	r9
    109e:	af 92       	push	r10
    10a0:	bf 92       	push	r11
    10a2:	df 92       	push	r13
    10a4:	ef 92       	push	r14
    10a6:	ff 92       	push	r15
    10a8:	0f 93       	push	r16
    10aa:	1f 93       	push	r17
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	cd b7       	in	r28, 0x3d	; 61
    10b2:	de b7       	in	r29, 0x3e	; 62
    10b4:	a8 97       	sbiw	r28, 0x28	; 40
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	f8 94       	cli
    10ba:	de bf       	out	0x3e, r29	; 62
    10bc:	0f be       	out	0x3f, r0	; 63
    10be:	cd bf       	out	0x3d, r28	; 61
    10c0:	7c 01       	movw	r14, r24
	BYTE  fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;

	FatFs = 0;
    10c2:	10 92 b1 05 	sts	0x05B1, r1	; 0x8005b1 <FatFs+0x1>
    10c6:	10 92 b0 05 	sts	0x05B0, r1	; 0x8005b0 <FatFs>

	if (disk_initialize() & STA_NOINIT)
    10ca:	0e 94 15 02 	call	0x42a	; 0x42a <disk_initialize>
    10ce:	80 fd       	sbrc	r24, 0
    10d0:	62 c1       	rjmp	.+708    	; 0x1396 <pf_mount+0x304>
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
    10d2:	40 e0       	ldi	r20, 0x00	; 0
    10d4:	50 e0       	ldi	r21, 0x00	; 0
    10d6:	ba 01       	movw	r22, r20
    10d8:	ce 01       	movw	r24, r28
    10da:	01 96       	adiw	r24, 0x01	; 1
    10dc:	0e 94 55 06 	call	0xcaa	; 0xcaa <check_fs>
    10e0:	d8 2e       	mov	r13, r24
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
    10e2:	21 e0       	ldi	r18, 0x01	; 1
    10e4:	82 13       	cpse	r24, r18
    10e6:	38 c0       	rjmp	.+112    	; 0x1158 <pf_mount+0xc6>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
    10e8:	00 e1       	ldi	r16, 0x10	; 16
    10ea:	10 e0       	ldi	r17, 0x00	; 0
    10ec:	2e eb       	ldi	r18, 0xBE	; 190
    10ee:	31 e0       	ldi	r19, 0x01	; 1
    10f0:	40 e0       	ldi	r20, 0x00	; 0
    10f2:	50 e0       	ldi	r21, 0x00	; 0
    10f4:	ba 01       	movw	r22, r20
    10f6:	ce 01       	movw	r24, r28
    10f8:	01 96       	adiw	r24, 0x01	; 1
    10fa:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
    10fe:	81 11       	cpse	r24, r1
    1100:	2f c0       	rjmp	.+94     	; 0x1160 <pf_mount+0xce>
			fmt = 3;
		} else {
			if (buf[4]) {                     /* Is the partition existing? */
    1102:	8d 81       	ldd	r24, Y+5	; 0x05
    1104:	88 23       	and	r24, r24
    1106:	a1 f1       	breq	.+104    	; 0x1170 <pf_mount+0xde>
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
    1108:	8c 84       	ldd	r8, Y+12	; 0x0c
    110a:	91 2c       	mov	r9, r1
    110c:	a1 2c       	mov	r10, r1
    110e:	b1 2c       	mov	r11, r1
    1110:	b8 2c       	mov	r11, r8
    1112:	aa 24       	eor	r10, r10
    1114:	99 24       	eor	r9, r9
    1116:	88 24       	eor	r8, r8
    1118:	9b 85       	ldd	r25, Y+11	; 0x0b
    111a:	89 2f       	mov	r24, r25
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	a0 e0       	ldi	r26, 0x00	; 0
    1120:	b0 e0       	ldi	r27, 0x00	; 0
    1122:	dc 01       	movw	r26, r24
    1124:	99 27       	eor	r25, r25
    1126:	88 27       	eor	r24, r24
    1128:	88 29       	or	r24, r8
    112a:	99 29       	or	r25, r9
    112c:	aa 29       	or	r26, r10
    112e:	bb 29       	or	r27, r11
    1130:	8a 84       	ldd	r8, Y+10	; 0x0a
    1132:	91 2c       	mov	r9, r1
    1134:	98 2c       	mov	r9, r8
    1136:	88 24       	eor	r8, r8
    1138:	a1 2c       	mov	r10, r1
    113a:	b1 2c       	mov	r11, r1
    113c:	88 2a       	or	r8, r24
    113e:	99 2a       	or	r9, r25
    1140:	aa 2a       	or	r10, r26
    1142:	bb 2a       	or	r11, r27
    1144:	89 85       	ldd	r24, Y+9	; 0x09
    1146:	88 2a       	or	r8, r24
				fmt   = check_fs(buf, bsect); /* Check the partition */
    1148:	b5 01       	movw	r22, r10
    114a:	a4 01       	movw	r20, r8
    114c:	ce 01       	movw	r24, r28
    114e:	01 96       	adiw	r24, 0x01	; 1
    1150:	0e 94 55 06 	call	0xcaa	; 0xcaa <check_fs>
    1154:	d8 2e       	mov	r13, r24
    1156:	0f c0       	rjmp	.+30     	; 0x1176 <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1158:	81 2c       	mov	r8, r1
    115a:	91 2c       	mov	r9, r1
    115c:	54 01       	movw	r10, r8
    115e:	0b c0       	rjmp	.+22     	; 0x1176 <pf_mount+0xe4>
    1160:	81 2c       	mov	r8, r1
    1162:	91 2c       	mov	r9, r1
    1164:	54 01       	movw	r10, r8
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
			fmt = 3;
    1166:	0f 2e       	mov	r0, r31
    1168:	f3 e0       	ldi	r31, 0x03	; 3
    116a:	df 2e       	mov	r13, r31
    116c:	f0 2d       	mov	r31, r0
    116e:	03 c0       	rjmp	.+6      	; 0x1176 <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1170:	81 2c       	mov	r8, r1
    1172:	91 2c       	mov	r9, r1
    1174:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
    1176:	43 e0       	ldi	r20, 0x03	; 3
    1178:	d4 16       	cp	r13, r20
    117a:	09 f4       	brne	.+2      	; 0x117e <pf_mount+0xec>
    117c:	0e c1       	rjmp	.+540    	; 0x139a <pf_mount+0x308>
		return FR_DISK_ERR;
	if (fmt)
    117e:	d1 10       	cpse	r13, r1
    1180:	0e c1       	rjmp	.+540    	; 0x139e <pf_mount+0x30c>
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
    1182:	04 e2       	ldi	r16, 0x24	; 36
    1184:	10 e0       	ldi	r17, 0x00	; 0
    1186:	2d e0       	ldi	r18, 0x0D	; 13
    1188:	30 e0       	ldi	r19, 0x00	; 0
    118a:	b5 01       	movw	r22, r10
    118c:	a4 01       	movw	r20, r8
    118e:	ce 01       	movw	r24, r28
    1190:	01 96       	adiw	r24, 0x01	; 1
    1192:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
    1196:	81 11       	cpse	r24, r1
    1198:	04 c1       	rjmp	.+520    	; 0x13a2 <pf_mount+0x310>
		return FR_DISK_ERR;

	fsize = LD_WORD(buf + BPB_FATSz16 - 13); /* Number of sectors per FAT */
    119a:	2b 85       	ldd	r18, Y+11	; 0x0b
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	32 2f       	mov	r19, r18
    11a0:	22 27       	eor	r18, r18
    11a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    11a4:	28 2b       	or	r18, r24
    11a6:	40 e0       	ldi	r20, 0x00	; 0
    11a8:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize)
    11aa:	21 15       	cp	r18, r1
    11ac:	31 05       	cpc	r19, r1
    11ae:	41 05       	cpc	r20, r1
    11b0:	51 05       	cpc	r21, r1
    11b2:	21 f5       	brne	.+72     	; 0x11fc <pf_mount+0x16a>
		fsize = LD_DWORD(buf + BPB_FATSz32 - 13);
    11b4:	2b 8d       	ldd	r18, Y+27	; 0x1b
    11b6:	82 2f       	mov	r24, r18
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	a0 e0       	ldi	r26, 0x00	; 0
    11bc:	b0 e0       	ldi	r27, 0x00	; 0
    11be:	78 2f       	mov	r23, r24
    11c0:	66 27       	eor	r22, r22
    11c2:	55 27       	eor	r21, r21
    11c4:	44 27       	eor	r20, r20
    11c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    11c8:	89 2f       	mov	r24, r25
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	a0 e0       	ldi	r26, 0x00	; 0
    11ce:	b0 e0       	ldi	r27, 0x00	; 0
    11d0:	dc 01       	movw	r26, r24
    11d2:	99 27       	eor	r25, r25
    11d4:	88 27       	eor	r24, r24
    11d6:	84 2b       	or	r24, r20
    11d8:	95 2b       	or	r25, r21
    11da:	a6 2b       	or	r26, r22
    11dc:	b7 2b       	or	r27, r23
    11de:	29 8d       	ldd	r18, Y+25	; 0x19
    11e0:	30 e0       	ldi	r19, 0x00	; 0
    11e2:	32 2f       	mov	r19, r18
    11e4:	22 27       	eor	r18, r18
    11e6:	a9 01       	movw	r20, r18
    11e8:	60 e0       	ldi	r22, 0x00	; 0
    11ea:	70 e0       	ldi	r23, 0x00	; 0
    11ec:	48 2b       	or	r20, r24
    11ee:	59 2b       	or	r21, r25
    11f0:	6a 2b       	or	r22, r26
    11f2:	7b 2b       	or	r23, r27
    11f4:	88 8d       	ldd	r24, Y+24	; 0x18
    11f6:	9a 01       	movw	r18, r20
    11f8:	ab 01       	movw	r20, r22
    11fa:	28 2b       	or	r18, r24

	fsize *= buf[BPB_NumFATs - 13];                             /* Number of sectors in FAT area */
    11fc:	ac 81       	ldd	r26, Y+4	; 0x04
    11fe:	b0 e0       	ldi	r27, 0x00	; 0
    1200:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <__muluhisi3>
    1204:	6d a3       	std	Y+37, r22	; 0x25
    1206:	7e a3       	std	Y+38, r23	; 0x26
    1208:	8f a3       	std	Y+39, r24	; 0x27
    120a:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase   = bsect + LD_WORD(buf + BPB_RsvdSecCnt - 13); /* FAT start sector (lba) */
    120c:	8b 81       	ldd	r24, Y+3	; 0x03
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	98 2f       	mov	r25, r24
    1212:	88 27       	eor	r24, r24
    1214:	4a 81       	ldd	r20, Y+2	; 0x02
    1216:	50 e0       	ldi	r21, 0x00	; 0
    1218:	84 2b       	or	r24, r20
    121a:	95 2b       	or	r25, r21
    121c:	88 0e       	add	r8, r24
    121e:	99 1e       	adc	r9, r25
    1220:	a1 1c       	adc	r10, r1
    1222:	b1 1c       	adc	r11, r1
    1224:	d7 01       	movw	r26, r14
    1226:	1a 96       	adiw	r26, 0x0a	; 10
    1228:	8d 92       	st	X+, r8
    122a:	9d 92       	st	X+, r9
    122c:	ad 92       	st	X+, r10
    122e:	bc 92       	st	X, r11
    1230:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
    1232:	a9 81       	ldd	r26, Y+1	; 0x01
    1234:	f7 01       	movw	r30, r14
    1236:	a2 83       	std	Z+2, r26	; 0x02
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
    1238:	8e 81       	ldd	r24, Y+6	; 0x06
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	98 2f       	mov	r25, r24
    123e:	88 27       	eor	r24, r24
    1240:	2d 81       	ldd	r18, Y+5	; 0x05
    1242:	82 2b       	or	r24, r18
    1244:	95 83       	std	Z+5, r25	; 0x05
    1246:	84 83       	std	Z+4, r24	; 0x04
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
    1248:	08 85       	ldd	r16, Y+8	; 0x08
    124a:	10 e0       	ldi	r17, 0x00	; 0
    124c:	10 2f       	mov	r17, r16
    124e:	00 27       	eor	r16, r16
    1250:	2f 81       	ldd	r18, Y+7	; 0x07
    1252:	02 2b       	or	r16, r18
    1254:	20 e0       	ldi	r18, 0x00	; 0
    1256:	30 e0       	ldi	r19, 0x00	; 0
	if (!tsect)
    1258:	01 15       	cp	r16, r1
    125a:	11 05       	cpc	r17, r1
    125c:	21 05       	cpc	r18, r1
    125e:	31 05       	cpc	r19, r1
    1260:	01 f5       	brne	.+64     	; 0x12a2 <pf_mount+0x210>
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
    1262:	0f 89       	ldd	r16, Y+23	; 0x17
    1264:	10 e0       	ldi	r17, 0x00	; 0
    1266:	20 e0       	ldi	r18, 0x00	; 0
    1268:	30 e0       	ldi	r19, 0x00	; 0
    126a:	70 2e       	mov	r7, r16
    126c:	66 24       	eor	r6, r6
    126e:	55 24       	eor	r5, r5
    1270:	44 24       	eor	r4, r4
    1272:	0e 89       	ldd	r16, Y+22	; 0x16
    1274:	10 e0       	ldi	r17, 0x00	; 0
    1276:	20 e0       	ldi	r18, 0x00	; 0
    1278:	30 e0       	ldi	r19, 0x00	; 0
    127a:	98 01       	movw	r18, r16
    127c:	11 27       	eor	r17, r17
    127e:	00 27       	eor	r16, r16
    1280:	40 2a       	or	r4, r16
    1282:	51 2a       	or	r5, r17
    1284:	62 2a       	or	r6, r18
    1286:	73 2a       	or	r7, r19
    1288:	2d 89       	ldd	r18, Y+21	; 0x15
    128a:	30 e0       	ldi	r19, 0x00	; 0
    128c:	32 2f       	mov	r19, r18
    128e:	22 27       	eor	r18, r18
    1290:	89 01       	movw	r16, r18
    1292:	20 e0       	ldi	r18, 0x00	; 0
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	04 29       	or	r16, r4
    1298:	15 29       	or	r17, r5
    129a:	26 29       	or	r18, r6
    129c:	37 29       	or	r19, r7
    129e:	6c 89       	ldd	r22, Y+20	; 0x14
    12a0:	06 2b       	or	r16, r22
	mclst = (tsect /* Last cluster# + 1 */
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
    12a2:	eb 81       	ldd	r30, Y+3	; 0x03
    12a4:	f0 e0       	ldi	r31, 0x00	; 0
    12a6:	fe 2f       	mov	r31, r30
    12a8:	ee 27       	eor	r30, r30
    12aa:	4e 2b       	or	r20, r30
    12ac:	5f 2b       	or	r21, r31
    12ae:	04 1b       	sub	r16, r20
    12b0:	15 0b       	sbc	r17, r21
    12b2:	21 09       	sbc	r18, r1
    12b4:	31 09       	sbc	r19, r1
    12b6:	4d a1       	ldd	r20, Y+37	; 0x25
    12b8:	5e a1       	ldd	r21, Y+38	; 0x26
    12ba:	6f a1       	ldd	r22, Y+39	; 0x27
    12bc:	78 a5       	ldd	r23, Y+40	; 0x28
    12be:	04 1b       	sub	r16, r20
    12c0:	15 0b       	sbc	r17, r21
    12c2:	26 0b       	sbc	r18, r22
    12c4:	37 0b       	sbc	r19, r23
    12c6:	92 95       	swap	r25
    12c8:	82 95       	swap	r24
    12ca:	8f 70       	andi	r24, 0x0F	; 15
    12cc:	89 27       	eor	r24, r25
    12ce:	9f 70       	andi	r25, 0x0F	; 15
    12d0:	89 27       	eor	r24, r25
    12d2:	2c 01       	movw	r4, r24
    12d4:	61 2c       	mov	r6, r1
    12d6:	71 2c       	mov	r7, r1
    12d8:	c9 01       	movw	r24, r18
    12da:	b8 01       	movw	r22, r16
    12dc:	64 19       	sub	r22, r4
    12de:	75 09       	sbc	r23, r5
    12e0:	86 09       	sbc	r24, r6
    12e2:	97 09       	sbc	r25, r7
	            / fs->csize
    12e4:	2a 2f       	mov	r18, r26
    12e6:	30 e0       	ldi	r19, 0x00	; 0
    12e8:	40 e0       	ldi	r20, 0x00	; 0
    12ea:	50 e0       	ldi	r21, 0x00	; 0
    12ec:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <__udivmodsi4>
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
	if (!tsect)
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
	mclst = (tsect /* Last cluster# + 1 */
    12f0:	da 01       	movw	r26, r20
    12f2:	c9 01       	movw	r24, r18
    12f4:	02 96       	adiw	r24, 0x02	; 2
    12f6:	a1 1d       	adc	r26, r1
    12f8:	b1 1d       	adc	r27, r1
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
	            / fs->csize
	        + 2;
	fs->n_fatent = (CLUST)mclst;
    12fa:	f7 01       	movw	r30, r14
    12fc:	86 83       	std	Z+6, r24	; 0x06
    12fe:	97 83       	std	Z+7, r25	; 0x07
    1300:	a0 87       	std	Z+8, r26	; 0x08
    1302:	b1 87       	std	Z+9, r27	; 0x09
	fmt = 0; /* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    1304:	87 3f       	cpi	r24, 0xF7	; 247
    1306:	9f 4f       	sbci	r25, 0xFF	; 255
    1308:	a1 05       	cpc	r26, r1
    130a:	b1 05       	cpc	r27, r1
    130c:	20 f0       	brcs	.+8      	; 0x1316 <pf_mount+0x284>
		fmt = FS_FAT32;
    130e:	0f 2e       	mov	r0, r31
    1310:	f3 e0       	ldi	r31, 0x03	; 3
    1312:	df 2e       	mov	r13, r31
    1314:	f0 2d       	mov	r31, r0
	if (!fmt)
    1316:	dd 20       	and	r13, r13
    1318:	09 f4       	brne	.+2      	; 0x131c <pf_mount+0x28a>
    131a:	45 c0       	rjmp	.+138    	; 0x13a6 <pf_mount+0x314>
		return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    131c:	d7 01       	movw	r26, r14
    131e:	dc 92       	st	X, r13

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf + (BPB_RootClus - 13)); /* Root directory start cluster */
    1320:	8b a1       	ldd	r24, Y+35	; 0x23
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	a0 e0       	ldi	r26, 0x00	; 0
    1326:	b0 e0       	ldi	r27, 0x00	; 0
    1328:	78 2f       	mov	r23, r24
    132a:	66 27       	eor	r22, r22
    132c:	55 27       	eor	r21, r21
    132e:	44 27       	eor	r20, r20
    1330:	8a a1       	ldd	r24, Y+34	; 0x22
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	a0 e0       	ldi	r26, 0x00	; 0
    1336:	b0 e0       	ldi	r27, 0x00	; 0
    1338:	dc 01       	movw	r26, r24
    133a:	99 27       	eor	r25, r25
    133c:	88 27       	eor	r24, r24
    133e:	84 2b       	or	r24, r20
    1340:	95 2b       	or	r25, r21
    1342:	a6 2b       	or	r26, r22
    1344:	b7 2b       	or	r27, r23
    1346:	49 a1       	ldd	r20, Y+33	; 0x21
    1348:	50 e0       	ldi	r21, 0x00	; 0
    134a:	54 2f       	mov	r21, r20
    134c:	44 27       	eor	r20, r20
    134e:	60 e0       	ldi	r22, 0x00	; 0
    1350:	70 e0       	ldi	r23, 0x00	; 0
    1352:	84 2b       	or	r24, r20
    1354:	95 2b       	or	r25, r21
    1356:	a6 2b       	or	r26, r22
    1358:	b7 2b       	or	r27, r23
    135a:	28 a1       	ldd	r18, Y+32	; 0x20
    135c:	82 2b       	or	r24, r18
    135e:	f7 01       	movw	r30, r14
    1360:	86 87       	std	Z+14, r24	; 0x0e
    1362:	97 87       	std	Z+15, r25	; 0x0f
    1364:	a0 8b       	std	Z+16, r26	; 0x10
    1366:	b1 8b       	std	Z+17, r27	; 0x11
	else
		fs->dirbase = fs->fatbase + fsize;                   /* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16; /* Data start sector (lba) */
    1368:	4d a1       	ldd	r20, Y+37	; 0x25
    136a:	5e a1       	ldd	r21, Y+38	; 0x26
    136c:	6f a1       	ldd	r22, Y+39	; 0x27
    136e:	78 a5       	ldd	r23, Y+40	; 0x28
    1370:	84 0e       	add	r8, r20
    1372:	95 1e       	adc	r9, r21
    1374:	a6 1e       	adc	r10, r22
    1376:	b7 1e       	adc	r11, r23
    1378:	84 0c       	add	r8, r4
    137a:	95 1c       	adc	r9, r5
    137c:	a6 1c       	adc	r10, r6
    137e:	b7 1c       	adc	r11, r7
    1380:	82 8a       	std	Z+18, r8	; 0x12
    1382:	93 8a       	std	Z+19, r9	; 0x13
    1384:	a4 8a       	std	Z+20, r10	; 0x14
    1386:	b5 8a       	std	Z+21, r11	; 0x15

	fs->flag = 0;
    1388:	11 82       	std	Z+1, r1	; 0x01
	FatFs    = fs;
    138a:	f0 92 b1 05 	sts	0x05B1, r15	; 0x8005b1 <FatFs+0x1>
    138e:	e0 92 b0 05 	sts	0x05B0, r14	; 0x8005b0 <FatFs>

	return FR_OK;
    1392:	80 e0       	ldi	r24, 0x00	; 0
    1394:	09 c0       	rjmp	.+18     	; 0x13a8 <pf_mount+0x316>
	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)
	{
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
    1396:	82 e0       	ldi	r24, 0x02	; 2
    1398:	07 c0       	rjmp	.+14     	; 0x13a8 <pf_mount+0x316>
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
		return FR_DISK_ERR;
    139a:	81 e0       	ldi	r24, 0x01	; 1
    139c:	05 c0       	rjmp	.+10     	; 0x13a8 <pf_mount+0x316>
	if (fmt)
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */
    139e:	86 e0       	ldi	r24, 0x06	; 6
    13a0:	03 c0       	rjmp	.+6      	; 0x13a8 <pf_mount+0x316>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
		return FR_DISK_ERR;
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	01 c0       	rjmp	.+2      	; 0x13a8 <pf_mount+0x316>
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
		fmt = FS_FAT32;
	if (!fmt)
		return FR_NO_FILESYSTEM;
    13a6:	86 e0       	ldi	r24, 0x06	; 6

	fs->flag = 0;
	FatFs    = fs;

	return FR_OK;
}
    13a8:	a8 96       	adiw	r28, 0x28	; 40
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	f8 94       	cli
    13ae:	de bf       	out	0x3e, r29	; 62
    13b0:	0f be       	out	0x3f, r0	; 63
    13b2:	cd bf       	out	0x3d, r28	; 61
    13b4:	df 91       	pop	r29
    13b6:	cf 91       	pop	r28
    13b8:	1f 91       	pop	r17
    13ba:	0f 91       	pop	r16
    13bc:	ff 90       	pop	r15
    13be:	ef 90       	pop	r14
    13c0:	df 90       	pop	r13
    13c2:	bf 90       	pop	r11
    13c4:	af 90       	pop	r10
    13c6:	9f 90       	pop	r9
    13c8:	8f 90       	pop	r8
    13ca:	7f 90       	pop	r7
    13cc:	6f 90       	pop	r6
    13ce:	5f 90       	pop	r5
    13d0:	4f 90       	pop	r4
    13d2:	08 95       	ret

000013d4 <pf_open>:
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT pf_open(const char *path /* Pointer to the file name */
)
 {
    13d4:	0f 93       	push	r16
    13d6:	1f 93       	push	r17
    13d8:	cf 93       	push	r28
    13da:	df 93       	push	r29
    13dc:	cd b7       	in	r28, 0x3d	; 61
    13de:	de b7       	in	r29, 0x3e	; 62
    13e0:	ec 97       	sbiw	r28, 0x3c	; 60
    13e2:	0f b6       	in	r0, 0x3f	; 63
    13e4:	f8 94       	cli
    13e6:	de bf       	out	0x3e, r29	; 62
    13e8:	0f be       	out	0x3f, r0	; 63
    13ea:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;
    13ec:	00 91 b0 05 	lds	r16, 0x05B0	; 0x8005b0 <FatFs>
    13f0:	10 91 b1 05 	lds	r17, 0x05B1	; 0x8005b1 <FatFs+0x1>

	if (!fs)
    13f4:	01 15       	cp	r16, r1
    13f6:	11 05       	cpc	r17, r1
    13f8:	09 f4       	brne	.+2      	; 0x13fc <pf_open+0x28>
    13fa:	4a c0       	rjmp	.+148    	; 0x1490 <pf_open+0xbc>
    13fc:	ac 01       	movw	r20, r24
		return FR_NOT_ENABLED; /* Check file system */

	fs->flag = 0;
    13fe:	f8 01       	movw	r30, r16
    1400:	11 82       	std	Z+1, r1	; 0x01
	dj.fn    = sp;
    1402:	ce 01       	movw	r24, r28
    1404:	41 96       	adiw	r24, 0x11	; 17
    1406:	9c 83       	std	Y+4, r25	; 0x04
    1408:	8b 83       	std	Y+3, r24	; 0x03
	res      = follow_path(&dj, dir, path); /* Follow the file path */
    140a:	be 01       	movw	r22, r28
    140c:	63 5e       	subi	r22, 0xE3	; 227
    140e:	7f 4f       	sbci	r23, 0xFF	; 255
    1410:	40 97       	sbiw	r24, 0x10	; 16
    1412:	0e 94 ed 07 	call	0xfda	; 0xfda <follow_path>
	if (res != FR_OK)
    1416:	81 11       	cpse	r24, r1
    1418:	40 c0       	rjmp	.+128    	; 0x149a <pf_open+0xc6>
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
    141a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    141c:	88 23       	and	r24, r24
    141e:	d1 f1       	breq	.+116    	; 0x1494 <pf_open+0xc0>
    1420:	88 a5       	ldd	r24, Y+40	; 0x28
    1422:	84 fd       	sbrc	r24, 4
    1424:	39 c0       	rjmp	.+114    	; 0x1498 <pf_open+0xc4>
		return FR_NO_FILE;
	

	fs->org_clust = get_clust(dir);               /* File start cluster */
    1426:	ce 01       	movw	r24, r28
    1428:	4d 96       	adiw	r24, 0x1d	; 29
    142a:	0e 94 a8 05 	call	0xb50	; 0xb50 <get_clust>
    142e:	f8 01       	movw	r30, r16
    1430:	66 8f       	std	Z+30, r22	; 0x1e
    1432:	77 8f       	std	Z+31, r23	; 0x1f
    1434:	80 a3       	std	Z+32, r24	; 0x20
    1436:	91 a3       	std	Z+33, r25	; 0x21
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
    1438:	8c ad       	ldd	r24, Y+60	; 0x3c
    143a:	90 e0       	ldi	r25, 0x00	; 0
    143c:	a0 e0       	ldi	r26, 0x00	; 0
    143e:	b0 e0       	ldi	r27, 0x00	; 0
    1440:	78 2f       	mov	r23, r24
    1442:	66 27       	eor	r22, r22
    1444:	55 27       	eor	r21, r21
    1446:	44 27       	eor	r20, r20
    1448:	9b ad       	ldd	r25, Y+59	; 0x3b
    144a:	89 2f       	mov	r24, r25
    144c:	90 e0       	ldi	r25, 0x00	; 0
    144e:	a0 e0       	ldi	r26, 0x00	; 0
    1450:	b0 e0       	ldi	r27, 0x00	; 0
    1452:	dc 01       	movw	r26, r24
    1454:	99 27       	eor	r25, r25
    1456:	88 27       	eor	r24, r24
    1458:	84 2b       	or	r24, r20
    145a:	95 2b       	or	r25, r21
    145c:	a6 2b       	or	r26, r22
    145e:	b7 2b       	or	r27, r23
    1460:	4a ad       	ldd	r20, Y+58	; 0x3a
    1462:	50 e0       	ldi	r21, 0x00	; 0
    1464:	54 2f       	mov	r21, r20
    1466:	44 27       	eor	r20, r20
    1468:	60 e0       	ldi	r22, 0x00	; 0
    146a:	70 e0       	ldi	r23, 0x00	; 0
    146c:	84 2b       	or	r24, r20
    146e:	95 2b       	or	r25, r21
    1470:	a6 2b       	or	r26, r22
    1472:	b7 2b       	or	r27, r23
    1474:	29 ad       	ldd	r18, Y+57	; 0x39
    1476:	82 2b       	or	r24, r18
    1478:	82 8f       	std	Z+26, r24	; 0x1a
    147a:	93 8f       	std	Z+27, r25	; 0x1b
    147c:	a4 8f       	std	Z+28, r26	; 0x1c
    147e:	b5 8f       	std	Z+29, r27	; 0x1d
	fs->fptr      = 0;                            /* File pointer */
    1480:	16 8a       	std	Z+22, r1	; 0x16
    1482:	17 8a       	std	Z+23, r1	; 0x17
    1484:	10 8e       	std	Z+24, r1	; 0x18
    1486:	11 8e       	std	Z+25, r1	; 0x19
	fs->flag      = FA_OPENED;
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	81 83       	std	Z+1, r24	; 0x01

	return FR_OK;
    148c:	80 e0       	ldi	r24, 0x00	; 0
    148e:	05 c0       	rjmp	.+10     	; 0x149a <pf_open+0xc6>
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED; /* Check file system */
    1490:	85 e0       	ldi	r24, 0x05	; 5
    1492:	03 c0       	rjmp	.+6      	; 0x149a <pf_open+0xc6>
	dj.fn    = sp;
	res      = follow_path(&dj, dir, path); /* Follow the file path */
	if (res != FR_OK)
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
		return FR_NO_FILE;
    1494:	83 e0       	ldi	r24, 0x03	; 3
    1496:	01 c0       	rjmp	.+2      	; 0x149a <pf_open+0xc6>
    1498:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
	fs->fptr      = 0;                            /* File pointer */
	fs->flag      = FA_OPENED;

	return FR_OK;
}
    149a:	ec 96       	adiw	r28, 0x3c	; 60
    149c:	0f b6       	in	r0, 0x3f	; 63
    149e:	f8 94       	cli
    14a0:	de bf       	out	0x3e, r29	; 62
    14a2:	0f be       	out	0x3f, r0	; 63
    14a4:	cd bf       	out	0x3d, r28	; 61
    14a6:	df 91       	pop	r29
    14a8:	cf 91       	pop	r28
    14aa:	1f 91       	pop	r17
    14ac:	0f 91       	pop	r16
    14ae:	08 95       	ret

000014b0 <pf_read>:

FRESULT pf_read(void *buff, /* Pointer to the read buffer (NULL:Forward data to the stream)*/
                UINT  btr,  /* Number of bytes to read */
                UINT *br    /* Pointer to number of bytes read */
)
{
    14b0:	6f 92       	push	r6
    14b2:	7f 92       	push	r7
    14b4:	8f 92       	push	r8
    14b6:	9f 92       	push	r9
    14b8:	af 92       	push	r10
    14ba:	bf 92       	push	r11
    14bc:	cf 92       	push	r12
    14be:	df 92       	push	r13
    14c0:	ef 92       	push	r14
    14c2:	ff 92       	push	r15
    14c4:	0f 93       	push	r16
    14c6:	1f 93       	push	r17
    14c8:	cf 93       	push	r28
    14ca:	df 93       	push	r29
    14cc:	3c 01       	movw	r6, r24
    14ce:	6b 01       	movw	r12, r22
    14d0:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST   clst;
	DWORD   sect, remain;
	UINT    rcnt;
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;
    14d2:	e0 90 b0 05 	lds	r14, 0x05B0	; 0x8005b0 <FatFs>
    14d6:	f0 90 b1 05 	lds	r15, 0x05B1	; 0x8005b1 <FatFs+0x1>

	*br = 0;
    14da:	fa 01       	movw	r30, r20
    14dc:	11 82       	std	Z+1, r1	; 0x01
    14de:	10 82       	st	Z, r1
	if (!fs)
    14e0:	e1 14       	cp	r14, r1
    14e2:	f1 04       	cpc	r15, r1
    14e4:	09 f4       	brne	.+2      	; 0x14e8 <pf_read+0x38>
    14e6:	b5 c0       	rjmp	.+362    	; 0x1652 <pf_read+0x1a2>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    14e8:	f7 01       	movw	r30, r14
    14ea:	81 81       	ldd	r24, Z+1	; 0x01
    14ec:	80 ff       	sbrs	r24, 0
    14ee:	b3 c0       	rjmp	.+358    	; 0x1656 <pf_read+0x1a6>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    14f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    14f2:	93 8d       	ldd	r25, Z+27	; 0x1b
    14f4:	a4 8d       	ldd	r26, Z+28	; 0x1c
    14f6:	b5 8d       	ldd	r27, Z+29	; 0x1d
    14f8:	46 89       	ldd	r20, Z+22	; 0x16
    14fa:	57 89       	ldd	r21, Z+23	; 0x17
    14fc:	60 8d       	ldd	r22, Z+24	; 0x18
    14fe:	71 8d       	ldd	r23, Z+25	; 0x19
    1500:	84 1b       	sub	r24, r20
    1502:	95 0b       	sbc	r25, r21
    1504:	a6 0b       	sbc	r26, r22
    1506:	b7 0b       	sbc	r27, r23
	if (btr > remain)
    1508:	a6 01       	movw	r20, r12
    150a:	60 e0       	ldi	r22, 0x00	; 0
    150c:	70 e0       	ldi	r23, 0x00	; 0
    150e:	84 17       	cp	r24, r20
    1510:	95 07       	cpc	r25, r21
    1512:	a6 07       	cpc	r26, r22
    1514:	b7 07       	cpc	r27, r23
    1516:	08 f4       	brcc	.+2      	; 0x151a <pf_read+0x6a>
		btr = (UINT)remain; /* Truncate btr by remaining bytes */
    1518:	6c 01       	movw	r12, r24
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
		if (rcnt > btr)
			rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    151a:	53 01       	movw	r10, r6
    151c:	94 c0       	rjmp	.+296    	; 0x1646 <pf_read+0x196>
	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {                       /* On the sector boundary? */
    151e:	f7 01       	movw	r30, r14
    1520:	86 89       	ldd	r24, Z+22	; 0x16
    1522:	97 89       	ldd	r25, Z+23	; 0x17
    1524:	a0 8d       	ldd	r26, Z+24	; 0x18
    1526:	b1 8d       	ldd	r27, Z+25	; 0x19
    1528:	ac 01       	movw	r20, r24
    152a:	bd 01       	movw	r22, r26
    152c:	51 70       	andi	r21, 0x01	; 1
    152e:	66 27       	eor	r22, r22
    1530:	77 27       	eor	r23, r23
    1532:	45 2b       	or	r20, r21
    1534:	46 2b       	or	r20, r22
    1536:	47 2b       	or	r20, r23
    1538:	09 f0       	breq	.+2      	; 0x153c <pf_read+0x8c>
    153a:	48 c0       	rjmp	.+144    	; 0x15cc <pf_read+0x11c>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    153c:	c2 81       	ldd	r28, Z+2	; 0x02
    153e:	c1 50       	subi	r28, 0x01	; 1
    1540:	ac 01       	movw	r20, r24
    1542:	bd 01       	movw	r22, r26
    1544:	03 2e       	mov	r0, r19
    1546:	39 e0       	ldi	r19, 0x09	; 9
    1548:	76 95       	lsr	r23
    154a:	67 95       	ror	r22
    154c:	57 95       	ror	r21
    154e:	47 95       	ror	r20
    1550:	3a 95       	dec	r19
    1552:	d1 f7       	brne	.-12     	; 0x1548 <pf_read+0x98>
    1554:	30 2d       	mov	r19, r0
    1556:	c4 23       	and	r28, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1558:	f1 f4       	brne	.+60     	; 0x1596 <pf_read+0xe6>
				if (fs->fptr == 0)                         /* On the top of the file? */
    155a:	89 2b       	or	r24, r25
    155c:	8a 2b       	or	r24, r26
    155e:	8b 2b       	or	r24, r27
    1560:	29 f4       	brne	.+10     	; 0x156c <pf_read+0xbc>
					clst = fs->org_clust;
    1562:	66 8d       	ldd	r22, Z+30	; 0x1e
    1564:	77 8d       	ldd	r23, Z+31	; 0x1f
    1566:	80 a1       	ldd	r24, Z+32	; 0x20
    1568:	91 a1       	ldd	r25, Z+33	; 0x21
    156a:	07 c0       	rjmp	.+14     	; 0x157a <pf_read+0xca>
				else
					clst = get_fat(fs->curr_clust);
    156c:	f7 01       	movw	r30, r14
    156e:	62 a1       	ldd	r22, Z+34	; 0x22
    1570:	73 a1       	ldd	r23, Z+35	; 0x23
    1572:	84 a1       	ldd	r24, Z+36	; 0x24
    1574:	95 a1       	ldd	r25, Z+37	; 0x25
    1576:	0e 94 95 06 	call	0xd2a	; 0xd2a <get_fat>
				if (clst <= 1)
    157a:	62 30       	cpi	r22, 0x02	; 2
    157c:	71 05       	cpc	r23, r1
    157e:	81 05       	cpc	r24, r1
    1580:	91 05       	cpc	r25, r1
    1582:	20 f4       	brcc	.+8      	; 0x158c <pf_read+0xdc>
					ABORT(FR_DISK_ERR);
    1584:	f7 01       	movw	r30, r14
    1586:	11 82       	std	Z+1, r1	; 0x01
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	66 c0       	rjmp	.+204    	; 0x1658 <pf_read+0x1a8>
				fs->curr_clust = clst; /* Update current cluster */
    158c:	f7 01       	movw	r30, r14
    158e:	62 a3       	std	Z+34, r22	; 0x22
    1590:	73 a3       	std	Z+35, r23	; 0x23
    1592:	84 a3       	std	Z+36, r24	; 0x24
    1594:	95 a3       	std	Z+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    1596:	f7 01       	movw	r30, r14
    1598:	62 a1       	ldd	r22, Z+34	; 0x22
    159a:	73 a1       	ldd	r23, Z+35	; 0x23
    159c:	84 a1       	ldd	r24, Z+36	; 0x24
    159e:	95 a1       	ldd	r25, Z+37	; 0x25
    15a0:	0e 94 7d 05 	call	0xafa	; 0xafa <clust2sect>
			if (!sect)
    15a4:	61 15       	cp	r22, r1
    15a6:	71 05       	cpc	r23, r1
    15a8:	81 05       	cpc	r24, r1
    15aa:	91 05       	cpc	r25, r1
    15ac:	21 f4       	brne	.+8      	; 0x15b6 <pf_read+0x106>
				ABORT(FR_DISK_ERR);
    15ae:	f7 01       	movw	r30, r14
    15b0:	11 82       	std	Z+1, r1	; 0x01
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	51 c0       	rjmp	.+162    	; 0x1658 <pf_read+0x1a8>
			fs->dsect = sect + cs;
    15b6:	dc 01       	movw	r26, r24
    15b8:	cb 01       	movw	r24, r22
    15ba:	8c 0f       	add	r24, r28
    15bc:	91 1d       	adc	r25, r1
    15be:	a1 1d       	adc	r26, r1
    15c0:	b1 1d       	adc	r27, r1
    15c2:	f7 01       	movw	r30, r14
    15c4:	86 a3       	std	Z+38, r24	; 0x26
    15c6:	97 a3       	std	Z+39, r25	; 0x27
    15c8:	a0 a7       	std	Z+40, r26	; 0x28
    15ca:	b1 a7       	std	Z+41, r27	; 0x29
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
    15cc:	f7 01       	movw	r30, r14
    15ce:	86 89       	ldd	r24, Z+22	; 0x16
    15d0:	97 89       	ldd	r25, Z+23	; 0x17
    15d2:	a0 8d       	ldd	r26, Z+24	; 0x18
    15d4:	b1 8d       	ldd	r27, Z+25	; 0x19
    15d6:	9c 01       	movw	r18, r24
    15d8:	31 70       	andi	r19, 0x01	; 1
    15da:	c0 e0       	ldi	r28, 0x00	; 0
    15dc:	d2 e0       	ldi	r29, 0x02	; 2
    15de:	c2 1b       	sub	r28, r18
    15e0:	d3 0b       	sbc	r29, r19
		if (rcnt > btr)
    15e2:	cc 16       	cp	r12, r28
    15e4:	dd 06       	cpc	r13, r29
    15e6:	08 f4       	brcc	.+2      	; 0x15ea <pf_read+0x13a>
			rcnt = btr;
    15e8:	e6 01       	movw	r28, r12
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    15ea:	f7 01       	movw	r30, r14
    15ec:	46 a1       	ldd	r20, Z+38	; 0x26
    15ee:	57 a1       	ldd	r21, Z+39	; 0x27
    15f0:	60 a5       	ldd	r22, Z+40	; 0x28
    15f2:	71 a5       	ldd	r23, Z+41	; 0x29
    15f4:	61 14       	cp	r6, r1
    15f6:	71 04       	cpc	r7, r1
    15f8:	19 f4       	brne	.+6      	; 0x1600 <pf_read+0x150>
    15fa:	80 e0       	ldi	r24, 0x00	; 0
    15fc:	90 e0       	ldi	r25, 0x00	; 0
    15fe:	02 c0       	rjmp	.+4      	; 0x1604 <pf_read+0x154>
    1600:	8a 2d       	mov	r24, r10
    1602:	9b 2d       	mov	r25, r11
    1604:	8e 01       	movw	r16, r28
    1606:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
		if (dr)
    160a:	88 23       	and	r24, r24
    160c:	21 f0       	breq	.+8      	; 0x1616 <pf_read+0x166>
			ABORT(FR_DISK_ERR);
    160e:	f7 01       	movw	r30, r14
    1610:	11 82       	std	Z+1, r1	; 0x01
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	21 c0       	rjmp	.+66     	; 0x1658 <pf_read+0x1a8>
		fs->fptr += rcnt;
    1616:	f7 01       	movw	r30, r14
    1618:	86 89       	ldd	r24, Z+22	; 0x16
    161a:	97 89       	ldd	r25, Z+23	; 0x17
    161c:	a0 8d       	ldd	r26, Z+24	; 0x18
    161e:	b1 8d       	ldd	r27, Z+25	; 0x19
    1620:	8c 0f       	add	r24, r28
    1622:	9d 1f       	adc	r25, r29
    1624:	a1 1d       	adc	r26, r1
    1626:	b1 1d       	adc	r27, r1
    1628:	86 8b       	std	Z+22, r24	; 0x16
    162a:	97 8b       	std	Z+23, r25	; 0x17
    162c:	a0 8f       	std	Z+24, r26	; 0x18
    162e:	b1 8f       	std	Z+25, r27	; 0x19
		rbuff += rcnt; /* Update pointers and counters */
    1630:	ac 0e       	add	r10, r28
    1632:	bd 1e       	adc	r11, r29
		btr -= rcnt;
    1634:	cc 1a       	sub	r12, r28
    1636:	dd 0a       	sbc	r13, r29
		*br += rcnt;
    1638:	f4 01       	movw	r30, r8
    163a:	80 81       	ld	r24, Z
    163c:	91 81       	ldd	r25, Z+1	; 0x01
    163e:	c8 0f       	add	r28, r24
    1640:	d9 1f       	adc	r29, r25
    1642:	d1 83       	std	Z+1, r29	; 0x01
    1644:	c0 83       	st	Z, r28

	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
    1646:	c1 14       	cp	r12, r1
    1648:	d1 04       	cpc	r13, r1
    164a:	09 f0       	breq	.+2      	; 0x164e <pf_read+0x19e>
    164c:	68 cf       	rjmp	.-304    	; 0x151e <pf_read+0x6e>
		rbuff += rcnt; /* Update pointers and counters */
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
    164e:	80 e0       	ldi	r24, 0x00	; 0
    1650:	03 c0       	rjmp	.+6      	; 0x1658 <pf_read+0x1a8>
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;

	*br = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1652:	85 e0       	ldi	r24, 0x05	; 5
    1654:	01 c0       	rjmp	.+2      	; 0x1658 <pf_read+0x1a8>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1656:	84 e0       	ldi	r24, 0x04	; 4
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
}
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	1f 91       	pop	r17
    165e:	0f 91       	pop	r16
    1660:	ff 90       	pop	r15
    1662:	ef 90       	pop	r14
    1664:	df 90       	pop	r13
    1666:	cf 90       	pop	r12
    1668:	bf 90       	pop	r11
    166a:	af 90       	pop	r10
    166c:	9f 90       	pop	r9
    166e:	8f 90       	pop	r8
    1670:	7f 90       	pop	r7
    1672:	6f 90       	pop	r6
    1674:	08 95       	ret

00001676 <pf_write>:

FRESULT pf_write(const void *buff, /* Pointer to the data to be written */
                 UINT        btw,  /* Number of bytes to write (0:Finalize the current write operation) */
                 UINT *      bw    /* Pointer to number of bytes written */
)
{
    1676:	4f 92       	push	r4
    1678:	5f 92       	push	r5
    167a:	6f 92       	push	r6
    167c:	7f 92       	push	r7
    167e:	af 92       	push	r10
    1680:	bf 92       	push	r11
    1682:	cf 92       	push	r12
    1684:	df 92       	push	r13
    1686:	ef 92       	push	r14
    1688:	ff 92       	push	r15
    168a:	0f 93       	push	r16
    168c:	1f 93       	push	r17
    168e:	cf 93       	push	r28
    1690:	df 93       	push	r29
    1692:	7c 01       	movw	r14, r24
    1694:	5b 01       	movw	r10, r22
    1696:	6a 01       	movw	r12, r20
	CLUST       clst;
	DWORD       sect, remain;
	const BYTE *p = buff;
	BYTE        cs;
	UINT        wcnt;
	FATFS *     fs = FatFs;
    1698:	c0 91 b0 05 	lds	r28, 0x05B0	; 0x8005b0 <FatFs>
    169c:	d0 91 b1 05 	lds	r29, 0x05B1	; 0x8005b1 <FatFs+0x1>

	*bw = 0;
    16a0:	fa 01       	movw	r30, r20
    16a2:	11 82       	std	Z+1, r1	; 0x01
    16a4:	10 82       	st	Z, r1
	if (!fs)
    16a6:	20 97       	sbiw	r28, 0x00	; 0
    16a8:	09 f4       	brne	.+2      	; 0x16ac <pf_write+0x36>
    16aa:	df c0       	rjmp	.+446    	; 0x186a <pf_write+0x1f4>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
    16ae:	80 ff       	sbrs	r24, 0
    16b0:	de c0       	rjmp	.+444    	; 0x186e <pf_write+0x1f8>
		return FR_NOT_OPENED;

	if (!btw) { /* Finalize request */
    16b2:	67 2b       	or	r22, r23
    16b4:	99 f4       	brne	.+38     	; 0x16dc <pf_write+0x66>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0))
    16b6:	86 ff       	sbrs	r24, 6
    16b8:	0c c0       	rjmp	.+24     	; 0x16d2 <pf_write+0x5c>
    16ba:	40 e0       	ldi	r20, 0x00	; 0
    16bc:	50 e0       	ldi	r21, 0x00	; 0
    16be:	ba 01       	movw	r22, r20
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    16c8:	88 23       	and	r24, r24
    16ca:	19 f0       	breq	.+6      	; 0x16d2 <pf_write+0x5c>
			ABORT(FR_DISK_ERR);
    16cc:	19 82       	std	Y+1, r1	; 0x01
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	cf c0       	rjmp	.+414    	; 0x1870 <pf_write+0x1fa>
		fs->flag &= ~FA__WIP;
    16d2:	89 81       	ldd	r24, Y+1	; 0x01
    16d4:	8f 7b       	andi	r24, 0xBF	; 191
    16d6:	89 83       	std	Y+1, r24	; 0x01
		return FR_OK;
    16d8:	80 e0       	ldi	r24, 0x00	; 0
    16da:	ca c0       	rjmp	.+404    	; 0x1870 <pf_write+0x1fa>
	} else {                       /* Write data request */
		if (!(fs->flag & FA__WIP)) /* Round-down fptr to the sector boundary */
    16dc:	86 fd       	sbrc	r24, 6
    16de:	0a c0       	rjmp	.+20     	; 0x16f4 <pf_write+0x7e>
			fs->fptr &= 0xFFFFFE00;
    16e0:	8e 89       	ldd	r24, Y+22	; 0x16
    16e2:	9f 89       	ldd	r25, Y+23	; 0x17
    16e4:	a8 8d       	ldd	r26, Y+24	; 0x18
    16e6:	b9 8d       	ldd	r27, Y+25	; 0x19
    16e8:	88 27       	eor	r24, r24
    16ea:	9e 7f       	andi	r25, 0xFE	; 254
    16ec:	8e 8b       	std	Y+22, r24	; 0x16
    16ee:	9f 8b       	std	Y+23, r25	; 0x17
    16f0:	a8 8f       	std	Y+24, r26	; 0x18
    16f2:	b9 8f       	std	Y+25, r27	; 0x19
	}
	remain = fs->fsize - fs->fptr;
    16f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16f6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    16f8:	ac 8d       	ldd	r26, Y+28	; 0x1c
    16fa:	bd 8d       	ldd	r27, Y+29	; 0x1d
    16fc:	4e 89       	ldd	r20, Y+22	; 0x16
    16fe:	5f 89       	ldd	r21, Y+23	; 0x17
    1700:	68 8d       	ldd	r22, Y+24	; 0x18
    1702:	79 8d       	ldd	r23, Y+25	; 0x19
    1704:	84 1b       	sub	r24, r20
    1706:	95 0b       	sbc	r25, r21
    1708:	a6 0b       	sbc	r26, r22
    170a:	b7 0b       	sbc	r27, r23
	if (btw > remain)
    170c:	a5 01       	movw	r20, r10
    170e:	60 e0       	ldi	r22, 0x00	; 0
    1710:	70 e0       	ldi	r23, 0x00	; 0
    1712:	84 17       	cp	r24, r20
    1714:	95 07       	cpc	r25, r21
    1716:	a6 07       	cpc	r26, r22
    1718:	b7 07       	cpc	r27, r23
    171a:	08 f0       	brcs	.+2      	; 0x171e <pf_write+0xa8>
    171c:	a0 c0       	rjmp	.+320    	; 0x185e <pf_write+0x1e8>
		btw = (UINT)remain; /* Truncate btw by remaining bytes */
    171e:	5c 01       	movw	r10, r24
    1720:	9e c0       	rjmp	.+316    	; 0x185e <pf_write+0x1e8>

	while (btw) {                                          /* Repeat until all data transferred */
		if ((UINT)fs->fptr % 512 == 0) {                   /* On the sector boundary? */
    1722:	8e 89       	ldd	r24, Y+22	; 0x16
    1724:	9f 89       	ldd	r25, Y+23	; 0x17
    1726:	a8 8d       	ldd	r26, Y+24	; 0x18
    1728:	b9 8d       	ldd	r27, Y+25	; 0x19
    172a:	9c 01       	movw	r18, r24
    172c:	31 70       	andi	r19, 0x01	; 1
    172e:	23 2b       	or	r18, r19
    1730:	09 f0       	breq	.+2      	; 0x1734 <pf_write+0xbe>
    1732:	4e c0       	rjmp	.+156    	; 0x17d0 <pf_write+0x15a>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1734:	1a 81       	ldd	r17, Y+2	; 0x02
    1736:	11 50       	subi	r17, 0x01	; 1
    1738:	ac 01       	movw	r20, r24
    173a:	bd 01       	movw	r22, r26
    173c:	03 2e       	mov	r0, r19
    173e:	39 e0       	ldi	r19, 0x09	; 9
    1740:	76 95       	lsr	r23
    1742:	67 95       	ror	r22
    1744:	57 95       	ror	r21
    1746:	47 95       	ror	r20
    1748:	3a 95       	dec	r19
    174a:	d1 f7       	brne	.-12     	; 0x1740 <pf_write+0xca>
    174c:	30 2d       	mov	r19, r0
    174e:	14 23       	and	r17, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1750:	d9 f4       	brne	.+54     	; 0x1788 <pf_write+0x112>
				if (fs->fptr == 0)                         /* On the top of the file? */
    1752:	89 2b       	or	r24, r25
    1754:	8a 2b       	or	r24, r26
    1756:	8b 2b       	or	r24, r27
    1758:	29 f4       	brne	.+10     	; 0x1764 <pf_write+0xee>
					clst = fs->org_clust;
    175a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    175c:	7f 8d       	ldd	r23, Y+31	; 0x1f
    175e:	88 a1       	ldd	r24, Y+32	; 0x20
    1760:	99 a1       	ldd	r25, Y+33	; 0x21
    1762:	06 c0       	rjmp	.+12     	; 0x1770 <pf_write+0xfa>
				else
					clst = get_fat(fs->curr_clust);
    1764:	6a a1       	ldd	r22, Y+34	; 0x22
    1766:	7b a1       	ldd	r23, Y+35	; 0x23
    1768:	8c a1       	ldd	r24, Y+36	; 0x24
    176a:	9d a1       	ldd	r25, Y+37	; 0x25
    176c:	0e 94 95 06 	call	0xd2a	; 0xd2a <get_fat>
				if (clst <= 1)
    1770:	62 30       	cpi	r22, 0x02	; 2
    1772:	71 05       	cpc	r23, r1
    1774:	81 05       	cpc	r24, r1
    1776:	91 05       	cpc	r25, r1
    1778:	18 f4       	brcc	.+6      	; 0x1780 <pf_write+0x10a>
					ABORT(FR_DISK_ERR);
    177a:	19 82       	std	Y+1, r1	; 0x01
    177c:	81 e0       	ldi	r24, 0x01	; 1
    177e:	78 c0       	rjmp	.+240    	; 0x1870 <pf_write+0x1fa>
				fs->curr_clust = clst; /* Update current cluster */
    1780:	6a a3       	std	Y+34, r22	; 0x22
    1782:	7b a3       	std	Y+35, r23	; 0x23
    1784:	8c a3       	std	Y+36, r24	; 0x24
    1786:	9d a3       	std	Y+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    1788:	6a a1       	ldd	r22, Y+34	; 0x22
    178a:	7b a1       	ldd	r23, Y+35	; 0x23
    178c:	8c a1       	ldd	r24, Y+36	; 0x24
    178e:	9d a1       	ldd	r25, Y+37	; 0x25
    1790:	0e 94 7d 05 	call	0xafa	; 0xafa <clust2sect>
			if (!sect)
    1794:	61 15       	cp	r22, r1
    1796:	71 05       	cpc	r23, r1
    1798:	81 05       	cpc	r24, r1
    179a:	91 05       	cpc	r25, r1
    179c:	19 f4       	brne	.+6      	; 0x17a4 <pf_write+0x12e>
				ABORT(FR_DISK_ERR);
    179e:	19 82       	std	Y+1, r1	; 0x01
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	66 c0       	rjmp	.+204    	; 0x1870 <pf_write+0x1fa>
			fs->dsect = sect + cs;
    17a4:	ab 01       	movw	r20, r22
    17a6:	bc 01       	movw	r22, r24
    17a8:	41 0f       	add	r20, r17
    17aa:	51 1d       	adc	r21, r1
    17ac:	61 1d       	adc	r22, r1
    17ae:	71 1d       	adc	r23, r1
    17b0:	4e a3       	std	Y+38, r20	; 0x26
    17b2:	5f a3       	std	Y+39, r21	; 0x27
    17b4:	68 a7       	std	Y+40, r22	; 0x28
    17b6:	79 a7       	std	Y+41, r23	; 0x29
			if (disk_writep(0, fs->dsect))
    17b8:	80 e0       	ldi	r24, 0x00	; 0
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    17c0:	88 23       	and	r24, r24
    17c2:	19 f0       	breq	.+6      	; 0x17ca <pf_write+0x154>
				ABORT(FR_DISK_ERR); /* Initiate a sector write operation */
    17c4:	19 82       	std	Y+1, r1	; 0x01
    17c6:	81 e0       	ldi	r24, 0x01	; 1
    17c8:	53 c0       	rjmp	.+166    	; 0x1870 <pf_write+0x1fa>
			fs->flag |= FA__WIP;
    17ca:	89 81       	ldd	r24, Y+1	; 0x01
    17cc:	80 64       	ori	r24, 0x40	; 64
    17ce:	89 83       	std	Y+1, r24	; 0x01
		}
		wcnt = 512 - (UINT)fs->fptr % 512; /* Number of bytes to write to the sector */
    17d0:	8e 89       	ldd	r24, Y+22	; 0x16
    17d2:	9f 89       	ldd	r25, Y+23	; 0x17
    17d4:	a8 8d       	ldd	r26, Y+24	; 0x18
    17d6:	b9 8d       	ldd	r27, Y+25	; 0x19
    17d8:	91 70       	andi	r25, 0x01	; 1
    17da:	00 e0       	ldi	r16, 0x00	; 0
    17dc:	12 e0       	ldi	r17, 0x02	; 2
    17de:	08 1b       	sub	r16, r24
    17e0:	19 0b       	sbc	r17, r25
		if (wcnt > btw)
    17e2:	a0 16       	cp	r10, r16
    17e4:	b1 06       	cpc	r11, r17
    17e6:	08 f4       	brcc	.+2      	; 0x17ea <pf_write+0x174>
			wcnt = btw;
    17e8:	85 01       	movw	r16, r10
		if (disk_writep(p, wcnt))
    17ea:	28 01       	movw	r4, r16
    17ec:	61 2c       	mov	r6, r1
    17ee:	71 2c       	mov	r7, r1
    17f0:	b3 01       	movw	r22, r6
    17f2:	a2 01       	movw	r20, r4
    17f4:	c7 01       	movw	r24, r14
    17f6:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    17fa:	88 23       	and	r24, r24
    17fc:	19 f0       	breq	.+6      	; 0x1804 <pf_write+0x18e>
			ABORT(FR_DISK_ERR); /* Send data to the sector */
    17fe:	19 82       	std	Y+1, r1	; 0x01
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	36 c0       	rjmp	.+108    	; 0x1870 <pf_write+0x1fa>
		fs->fptr += wcnt;
    1804:	8e 89       	ldd	r24, Y+22	; 0x16
    1806:	9f 89       	ldd	r25, Y+23	; 0x17
    1808:	a8 8d       	ldd	r26, Y+24	; 0x18
    180a:	b9 8d       	ldd	r27, Y+25	; 0x19
    180c:	48 0e       	add	r4, r24
    180e:	59 1e       	adc	r5, r25
    1810:	6a 1e       	adc	r6, r26
    1812:	7b 1e       	adc	r7, r27
    1814:	4e 8a       	std	Y+22, r4	; 0x16
    1816:	5f 8a       	std	Y+23, r5	; 0x17
    1818:	68 8e       	std	Y+24, r6	; 0x18
    181a:	79 8e       	std	Y+25, r7	; 0x19
		p += wcnt; /* Update pointers and counters */
    181c:	e0 0e       	add	r14, r16
    181e:	f1 1e       	adc	r15, r17
		btw -= wcnt;
    1820:	a0 1a       	sub	r10, r16
    1822:	b1 0a       	sbc	r11, r17
		*bw += wcnt;
    1824:	f6 01       	movw	r30, r12
    1826:	80 81       	ld	r24, Z
    1828:	91 81       	ldd	r25, Z+1	; 0x01
    182a:	08 0f       	add	r16, r24
    182c:	19 1f       	adc	r17, r25
    182e:	11 83       	std	Z+1, r17	; 0x01
    1830:	00 83       	st	Z, r16
		if ((UINT)fs->fptr % 512 == 0) {
    1832:	8e 89       	ldd	r24, Y+22	; 0x16
    1834:	9f 89       	ldd	r25, Y+23	; 0x17
    1836:	a8 8d       	ldd	r26, Y+24	; 0x18
    1838:	b9 8d       	ldd	r27, Y+25	; 0x19
    183a:	91 70       	andi	r25, 0x01	; 1
    183c:	89 2b       	or	r24, r25
    183e:	79 f4       	brne	.+30     	; 0x185e <pf_write+0x1e8>
			if (disk_writep(0, 0))
    1840:	40 e0       	ldi	r20, 0x00	; 0
    1842:	50 e0       	ldi	r21, 0x00	; 0
    1844:	ba 01       	movw	r22, r20
    1846:	80 e0       	ldi	r24, 0x00	; 0
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    184e:	88 23       	and	r24, r24
    1850:	19 f0       	breq	.+6      	; 0x1858 <pf_write+0x1e2>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
    1852:	19 82       	std	Y+1, r1	; 0x01
    1854:	81 e0       	ldi	r24, 0x01	; 1
    1856:	0c c0       	rjmp	.+24     	; 0x1870 <pf_write+0x1fa>
			fs->flag &= ~FA__WIP;
    1858:	89 81       	ldd	r24, Y+1	; 0x01
    185a:	8f 7b       	andi	r24, 0xBF	; 191
    185c:	89 83       	std	Y+1, r24	; 0x01
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain)
		btw = (UINT)remain; /* Truncate btw by remaining bytes */

	while (btw) {                                          /* Repeat until all data transferred */
    185e:	a1 14       	cp	r10, r1
    1860:	b1 04       	cpc	r11, r1
    1862:	09 f0       	breq	.+2      	; 0x1866 <pf_write+0x1f0>
    1864:	5e cf       	rjmp	.-324    	; 0x1722 <pf_write+0xac>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    1866:	80 e0       	ldi	r24, 0x00	; 0
    1868:	03 c0       	rjmp	.+6      	; 0x1870 <pf_write+0x1fa>
	UINT        wcnt;
	FATFS *     fs = FatFs;

	*bw = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    186a:	85 e0       	ldi	r24, 0x05	; 5
    186c:	01 c0       	rjmp	.+2      	; 0x1870 <pf_write+0x1fa>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    186e:	84 e0       	ldi	r24, 0x04	; 4
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
}
    1870:	df 91       	pop	r29
    1872:	cf 91       	pop	r28
    1874:	1f 91       	pop	r17
    1876:	0f 91       	pop	r16
    1878:	ff 90       	pop	r15
    187a:	ef 90       	pop	r14
    187c:	df 90       	pop	r13
    187e:	cf 90       	pop	r12
    1880:	bf 90       	pop	r11
    1882:	af 90       	pop	r10
    1884:	7f 90       	pop	r7
    1886:	6f 90       	pop	r6
    1888:	5f 90       	pop	r5
    188a:	4f 90       	pop	r4
    188c:	08 95       	ret

0000188e <pf_lseek>:
/*-----------------------------------------------------------------------*/
#if _USE_LSEEK

FRESULT pf_lseek(DWORD ofs /* File pointer from top of file */
)
{
    188e:	4f 92       	push	r4
    1890:	5f 92       	push	r5
    1892:	6f 92       	push	r6
    1894:	7f 92       	push	r7
    1896:	8f 92       	push	r8
    1898:	9f 92       	push	r9
    189a:	af 92       	push	r10
    189c:	bf 92       	push	r11
    189e:	cf 92       	push	r12
    18a0:	df 92       	push	r13
    18a2:	ef 92       	push	r14
    18a4:	ff 92       	push	r15
    18a6:	cf 93       	push	r28
    18a8:	df 93       	push	r29
    18aa:	00 d0       	rcall	.+0      	; 0x18ac <pf_lseek+0x1e>
    18ac:	00 d0       	rcall	.+0      	; 0x18ae <pf_lseek+0x20>
    18ae:	00 d0       	rcall	.+0      	; 0x18b0 <pf_lseek+0x22>
    18b0:	cd b7       	in	r28, 0x3d	; 61
    18b2:	de b7       	in	r29, 0x3e	; 62
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;
    18b4:	20 91 b0 05 	lds	r18, 0x05B0	; 0x8005b0 <FatFs>
    18b8:	30 91 b1 05 	lds	r19, 0x05B1	; 0x8005b1 <FatFs+0x1>
    18bc:	3e 83       	std	Y+6, r19	; 0x06
    18be:	2d 83       	std	Y+5, r18	; 0x05

	if (!fs)
    18c0:	21 15       	cp	r18, r1
    18c2:	31 05       	cpc	r19, r1
    18c4:	09 f4       	brne	.+2      	; 0x18c8 <pf_lseek+0x3a>
    18c6:	f4 c0       	rjmp	.+488    	; 0x1ab0 <pf_lseek+0x222>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    18c8:	d9 01       	movw	r26, r18
    18ca:	11 96       	adiw	r26, 0x01	; 1
    18cc:	2c 91       	ld	r18, X
    18ce:	11 97       	sbiw	r26, 0x01	; 1
    18d0:	20 ff       	sbrs	r18, 0
    18d2:	f0 c0       	rjmp	.+480    	; 0x1ab4 <pf_lseek+0x226>
		return FR_NOT_OPENED;

	if (ofs > fs->fsize)
    18d4:	5a 96       	adiw	r26, 0x1a	; 26
    18d6:	cd 90       	ld	r12, X+
    18d8:	dd 90       	ld	r13, X+
    18da:	ed 90       	ld	r14, X+
    18dc:	fc 90       	ld	r15, X
    18de:	5d 97       	sbiw	r26, 0x1d	; 29
    18e0:	c6 16       	cp	r12, r22
    18e2:	d7 06       	cpc	r13, r23
    18e4:	e8 06       	cpc	r14, r24
    18e6:	f9 06       	cpc	r15, r25
    18e8:	10 f0       	brcs	.+4      	; 0x18ee <pf_lseek+0x60>
    18ea:	6b 01       	movw	r12, r22
    18ec:	7c 01       	movw	r14, r24
		ofs = fs->fsize; /* Clip offset with the file size */
	ifptr    = fs->fptr;
    18ee:	ed 81       	ldd	r30, Y+5	; 0x05
    18f0:	fe 81       	ldd	r31, Y+6	; 0x06
    18f2:	46 88       	ldd	r4, Z+22	; 0x16
    18f4:	57 88       	ldd	r5, Z+23	; 0x17
    18f6:	60 8c       	ldd	r6, Z+24	; 0x18
    18f8:	71 8c       	ldd	r7, Z+25	; 0x19
	fs->fptr = 0;
    18fa:	16 8a       	std	Z+22, r1	; 0x16
    18fc:	17 8a       	std	Z+23, r1	; 0x17
    18fe:	10 8e       	std	Z+24, r1	; 0x18
    1900:	11 8e       	std	Z+25, r1	; 0x19
	if (ofs > 0) {
    1902:	c1 14       	cp	r12, r1
    1904:	d1 04       	cpc	r13, r1
    1906:	e1 04       	cpc	r14, r1
    1908:	f1 04       	cpc	r15, r1
    190a:	09 f4       	brne	.+2      	; 0x190e <pf_lseek+0x80>
    190c:	d5 c0       	rjmp	.+426    	; 0x1ab8 <pf_lseek+0x22a>
		bcs = (DWORD)fs->csize * 512;                            /* Cluster size (byte) */
    190e:	82 80       	ldd	r8, Z+2	; 0x02
    1910:	91 2c       	mov	r9, r1
    1912:	a1 2c       	mov	r10, r1
    1914:	b1 2c       	mov	r11, r1
    1916:	07 2e       	mov	r0, r23
    1918:	79 e0       	ldi	r23, 0x09	; 9
    191a:	88 0c       	add	r8, r8
    191c:	99 1c       	adc	r9, r9
    191e:	aa 1c       	adc	r10, r10
    1920:	bb 1c       	adc	r11, r11
    1922:	7a 95       	dec	r23
    1924:	d1 f7       	brne	.-12     	; 0x191a <pf_lseek+0x8c>
    1926:	70 2d       	mov	r23, r0
		if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
    1928:	41 14       	cp	r4, r1
    192a:	51 04       	cpc	r5, r1
    192c:	61 04       	cpc	r6, r1
    192e:	71 04       	cpc	r7, r1
    1930:	09 f4       	brne	.+2      	; 0x1934 <pf_lseek+0xa6>
    1932:	40 c0       	rjmp	.+128    	; 0x19b4 <pf_lseek+0x126>
    1934:	c7 01       	movw	r24, r14
    1936:	b6 01       	movw	r22, r12
    1938:	61 50       	subi	r22, 0x01	; 1
    193a:	71 09       	sbc	r23, r1
    193c:	81 09       	sbc	r24, r1
    193e:	91 09       	sbc	r25, r1
    1940:	a5 01       	movw	r20, r10
    1942:	94 01       	movw	r18, r8
    1944:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <__udivmodsi4>
    1948:	29 83       	std	Y+1, r18	; 0x01
    194a:	3a 83       	std	Y+2, r19	; 0x02
    194c:	4b 83       	std	Y+3, r20	; 0x03
    194e:	5c 83       	std	Y+4, r21	; 0x04
    1950:	b1 e0       	ldi	r27, 0x01	; 1
    1952:	4b 1a       	sub	r4, r27
    1954:	51 08       	sbc	r5, r1
    1956:	61 08       	sbc	r6, r1
    1958:	71 08       	sbc	r7, r1
    195a:	c3 01       	movw	r24, r6
    195c:	b2 01       	movw	r22, r4
    195e:	a5 01       	movw	r20, r10
    1960:	94 01       	movw	r18, r8
    1962:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <__udivmodsi4>
    1966:	89 81       	ldd	r24, Y+1	; 0x01
    1968:	9a 81       	ldd	r25, Y+2	; 0x02
    196a:	ab 81       	ldd	r26, Y+3	; 0x03
    196c:	bc 81       	ldd	r27, Y+4	; 0x04
    196e:	82 17       	cp	r24, r18
    1970:	93 07       	cpc	r25, r19
    1972:	a4 07       	cpc	r26, r20
    1974:	b5 07       	cpc	r27, r21
    1976:	f0 f0       	brcs	.+60     	; 0x19b4 <pf_lseek+0x126>
			fs->fptr = (ifptr - 1) & ~(bcs - 1);                 /* start from the current cluster */
    1978:	88 27       	eor	r24, r24
    197a:	99 27       	eor	r25, r25
    197c:	dc 01       	movw	r26, r24
    197e:	88 19       	sub	r24, r8
    1980:	99 09       	sbc	r25, r9
    1982:	aa 09       	sbc	r26, r10
    1984:	bb 09       	sbc	r27, r11
    1986:	48 22       	and	r4, r24
    1988:	59 22       	and	r5, r25
    198a:	6a 22       	and	r6, r26
    198c:	7b 22       	and	r7, r27
    198e:	ad 81       	ldd	r26, Y+5	; 0x05
    1990:	be 81       	ldd	r27, Y+6	; 0x06
    1992:	56 96       	adiw	r26, 0x16	; 22
    1994:	4d 92       	st	X+, r4
    1996:	5d 92       	st	X+, r5
    1998:	6d 92       	st	X+, r6
    199a:	7c 92       	st	X, r7
    199c:	59 97       	sbiw	r26, 0x19	; 25
			ofs -= fs->fptr;
    199e:	c4 18       	sub	r12, r4
    19a0:	d5 08       	sbc	r13, r5
    19a2:	e6 08       	sbc	r14, r6
    19a4:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    19a6:	92 96       	adiw	r26, 0x22	; 34
    19a8:	6d 91       	ld	r22, X+
    19aa:	7d 91       	ld	r23, X+
    19ac:	8d 91       	ld	r24, X+
    19ae:	9c 91       	ld	r25, X
    19b0:	95 97       	sbiw	r26, 0x25	; 37
    19b2:	39 c0       	rjmp	.+114    	; 0x1a26 <pf_lseek+0x198>
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
    19b4:	ed 81       	ldd	r30, Y+5	; 0x05
    19b6:	fe 81       	ldd	r31, Y+6	; 0x06
    19b8:	66 8d       	ldd	r22, Z+30	; 0x1e
    19ba:	77 8d       	ldd	r23, Z+31	; 0x1f
    19bc:	80 a1       	ldd	r24, Z+32	; 0x20
    19be:	91 a1       	ldd	r25, Z+33	; 0x21
			fs->curr_clust = clst;
    19c0:	62 a3       	std	Z+34, r22	; 0x22
    19c2:	73 a3       	std	Z+35, r23	; 0x23
    19c4:	84 a3       	std	Z+36, r24	; 0x24
    19c6:	95 a3       	std	Z+37, r25	; 0x25
    19c8:	2e c0       	rjmp	.+92     	; 0x1a26 <pf_lseek+0x198>
		}
		while (ofs > bcs) {       /* Cluster following loop */
			clst = get_fat(clst); /* Follow cluster chain */
    19ca:	0e 94 95 06 	call	0xd2a	; 0xd2a <get_fat>
			if (clst <= 1 || clst >= fs->n_fatent)
    19ce:	62 30       	cpi	r22, 0x02	; 2
    19d0:	71 05       	cpc	r23, r1
    19d2:	81 05       	cpc	r24, r1
    19d4:	91 05       	cpc	r25, r1
    19d6:	58 f0       	brcs	.+22     	; 0x19ee <pf_lseek+0x160>
    19d8:	ed 81       	ldd	r30, Y+5	; 0x05
    19da:	fe 81       	ldd	r31, Y+6	; 0x06
    19dc:	46 80       	ldd	r4, Z+6	; 0x06
    19de:	57 80       	ldd	r5, Z+7	; 0x07
    19e0:	60 84       	ldd	r6, Z+8	; 0x08
    19e2:	71 84       	ldd	r7, Z+9	; 0x09
    19e4:	64 15       	cp	r22, r4
    19e6:	75 05       	cpc	r23, r5
    19e8:	86 05       	cpc	r24, r6
    19ea:	97 05       	cpc	r25, r7
    19ec:	30 f0       	brcs	.+12     	; 0x19fa <pf_lseek+0x16c>
				ABORT(FR_DISK_ERR);
    19ee:	ad 81       	ldd	r26, Y+5	; 0x05
    19f0:	be 81       	ldd	r27, Y+6	; 0x06
    19f2:	11 96       	adiw	r26, 0x01	; 1
    19f4:	1c 92       	st	X, r1
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	60 c0       	rjmp	.+192    	; 0x1aba <pf_lseek+0x22c>
			fs->curr_clust = clst;
    19fa:	ed 81       	ldd	r30, Y+5	; 0x05
    19fc:	fe 81       	ldd	r31, Y+6	; 0x06
    19fe:	62 a3       	std	Z+34, r22	; 0x22
    1a00:	73 a3       	std	Z+35, r23	; 0x23
    1a02:	84 a3       	std	Z+36, r24	; 0x24
    1a04:	95 a3       	std	Z+37, r25	; 0x25
			fs->fptr += bcs;
    1a06:	46 88       	ldd	r4, Z+22	; 0x16
    1a08:	57 88       	ldd	r5, Z+23	; 0x17
    1a0a:	60 8c       	ldd	r6, Z+24	; 0x18
    1a0c:	71 8c       	ldd	r7, Z+25	; 0x19
    1a0e:	48 0c       	add	r4, r8
    1a10:	59 1c       	adc	r5, r9
    1a12:	6a 1c       	adc	r6, r10
    1a14:	7b 1c       	adc	r7, r11
    1a16:	46 8a       	std	Z+22, r4	; 0x16
    1a18:	57 8a       	std	Z+23, r5	; 0x17
    1a1a:	60 8e       	std	Z+24, r6	; 0x18
    1a1c:	71 8e       	std	Z+25, r7	; 0x19
			ofs -= bcs;
    1a1e:	c8 18       	sub	r12, r8
    1a20:	d9 08       	sbc	r13, r9
    1a22:	ea 08       	sbc	r14, r10
    1a24:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {       /* Cluster following loop */
    1a26:	8c 14       	cp	r8, r12
    1a28:	9d 04       	cpc	r9, r13
    1a2a:	ae 04       	cpc	r10, r14
    1a2c:	bf 04       	cpc	r11, r15
    1a2e:	68 f2       	brcs	.-102    	; 0x19ca <pf_lseek+0x13c>
				ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    1a30:	ed 81       	ldd	r30, Y+5	; 0x05
    1a32:	fe 81       	ldd	r31, Y+6	; 0x06
    1a34:	86 88       	ldd	r8, Z+22	; 0x16
    1a36:	97 88       	ldd	r9, Z+23	; 0x17
    1a38:	a0 8c       	ldd	r10, Z+24	; 0x18
    1a3a:	b1 8c       	ldd	r11, Z+25	; 0x19
    1a3c:	c8 0c       	add	r12, r8
    1a3e:	d9 1c       	adc	r13, r9
    1a40:	ea 1c       	adc	r14, r10
    1a42:	fb 1c       	adc	r15, r11
    1a44:	c6 8a       	std	Z+22, r12	; 0x16
    1a46:	d7 8a       	std	Z+23, r13	; 0x17
    1a48:	e0 8e       	std	Z+24, r14	; 0x18
    1a4a:	f1 8e       	std	Z+25, r15	; 0x19
		sect = clust2sect(clst); /* Current sector */
    1a4c:	0e 94 7d 05 	call	0xafa	; 0xafa <clust2sect>
		if (!sect)
    1a50:	61 15       	cp	r22, r1
    1a52:	71 05       	cpc	r23, r1
    1a54:	81 05       	cpc	r24, r1
    1a56:	91 05       	cpc	r25, r1
    1a58:	29 f4       	brne	.+10     	; 0x1a64 <pf_lseek+0x1d6>
			ABORT(FR_DISK_ERR);
    1a5a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a5c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a5e:	11 82       	std	Z+1, r1	; 0x01
    1a60:	81 e0       	ldi	r24, 0x01	; 1
    1a62:	2b c0       	rjmp	.+86     	; 0x1aba <pf_lseek+0x22c>
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    1a64:	0b 2e       	mov	r0, r27
    1a66:	b9 e0       	ldi	r27, 0x09	; 9
    1a68:	f6 94       	lsr	r15
    1a6a:	e7 94       	ror	r14
    1a6c:	d7 94       	ror	r13
    1a6e:	c7 94       	ror	r12
    1a70:	ba 95       	dec	r27
    1a72:	d1 f7       	brne	.-12     	; 0x1a68 <pf_lseek+0x1da>
    1a74:	b0 2d       	mov	r27, r0
    1a76:	ad 81       	ldd	r26, Y+5	; 0x05
    1a78:	be 81       	ldd	r27, Y+6	; 0x06
    1a7a:	12 96       	adiw	r26, 0x02	; 2
    1a7c:	2c 91       	ld	r18, X
    1a7e:	30 e0       	ldi	r19, 0x00	; 0
    1a80:	21 50       	subi	r18, 0x01	; 1
    1a82:	31 09       	sbc	r19, r1
    1a84:	49 01       	movw	r8, r18
    1a86:	33 0f       	add	r19, r19
    1a88:	aa 08       	sbc	r10, r10
    1a8a:	bb 08       	sbc	r11, r11
    1a8c:	c8 20       	and	r12, r8
    1a8e:	d9 20       	and	r13, r9
    1a90:	ea 20       	and	r14, r10
    1a92:	fb 20       	and	r15, r11
    1a94:	dc 01       	movw	r26, r24
    1a96:	cb 01       	movw	r24, r22
    1a98:	8c 0d       	add	r24, r12
    1a9a:	9d 1d       	adc	r25, r13
    1a9c:	ae 1d       	adc	r26, r14
    1a9e:	bf 1d       	adc	r27, r15
    1aa0:	ed 81       	ldd	r30, Y+5	; 0x05
    1aa2:	fe 81       	ldd	r31, Y+6	; 0x06
    1aa4:	86 a3       	std	Z+38, r24	; 0x26
    1aa6:	97 a3       	std	Z+39, r25	; 0x27
    1aa8:	a0 a7       	std	Z+40, r26	; 0x28
    1aaa:	b1 a7       	std	Z+41, r27	; 0x29
	}

	return FR_OK;
    1aac:	80 e0       	ldi	r24, 0x00	; 0
    1aae:	05 c0       	rjmp	.+10     	; 0x1aba <pf_lseek+0x22c>
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1ab0:	85 e0       	ldi	r24, 0x05	; 5
    1ab2:	03 c0       	rjmp	.+6      	; 0x1aba <pf_lseek+0x22c>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1ab4:	84 e0       	ldi	r24, 0x04	; 4
    1ab6:	01 c0       	rjmp	.+2      	; 0x1aba <pf_lseek+0x22c>
		if (!sect)
			ABORT(FR_DISK_ERR);
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
    1ab8:	80 e0       	ldi	r24, 0x00	; 0
}
    1aba:	26 96       	adiw	r28, 0x06	; 6
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	de bf       	out	0x3e, r29	; 62
    1ac2:	0f be       	out	0x3f, r0	; 63
    1ac4:	cd bf       	out	0x3d, r28	; 61
    1ac6:	df 91       	pop	r29
    1ac8:	cf 91       	pop	r28
    1aca:	ff 90       	pop	r15
    1acc:	ef 90       	pop	r14
    1ace:	df 90       	pop	r13
    1ad0:	cf 90       	pop	r12
    1ad2:	bf 90       	pop	r11
    1ad4:	af 90       	pop	r10
    1ad6:	9f 90       	pop	r9
    1ad8:	8f 90       	pop	r8
    1ada:	7f 90       	pop	r7
    1adc:	6f 90       	pop	r6
    1ade:	5f 90       	pop	r5
    1ae0:	4f 90       	pop	r4
    1ae2:	08 95       	ret

00001ae4 <__divmodhi4>:
    1ae4:	97 fb       	bst	r25, 7
    1ae6:	07 2e       	mov	r0, r23
    1ae8:	16 f4       	brtc	.+4      	; 0x1aee <__divmodhi4+0xa>
    1aea:	00 94       	com	r0
    1aec:	07 d0       	rcall	.+14     	; 0x1afc <__divmodhi4_neg1>
    1aee:	77 fd       	sbrc	r23, 7
    1af0:	09 d0       	rcall	.+18     	; 0x1b04 <__divmodhi4_neg2>
    1af2:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <__udivmodhi4>
    1af6:	07 fc       	sbrc	r0, 7
    1af8:	05 d0       	rcall	.+10     	; 0x1b04 <__divmodhi4_neg2>
    1afa:	3e f4       	brtc	.+14     	; 0x1b0a <__divmodhi4_exit>

00001afc <__divmodhi4_neg1>:
    1afc:	90 95       	com	r25
    1afe:	81 95       	neg	r24
    1b00:	9f 4f       	sbci	r25, 0xFF	; 255
    1b02:	08 95       	ret

00001b04 <__divmodhi4_neg2>:
    1b04:	70 95       	com	r23
    1b06:	61 95       	neg	r22
    1b08:	7f 4f       	sbci	r23, 0xFF	; 255

00001b0a <__divmodhi4_exit>:
    1b0a:	08 95       	ret

00001b0c <__udivmodsi4>:
    1b0c:	a1 e2       	ldi	r26, 0x21	; 33
    1b0e:	1a 2e       	mov	r1, r26
    1b10:	aa 1b       	sub	r26, r26
    1b12:	bb 1b       	sub	r27, r27
    1b14:	fd 01       	movw	r30, r26
    1b16:	0d c0       	rjmp	.+26     	; 0x1b32 <__udivmodsi4_ep>

00001b18 <__udivmodsi4_loop>:
    1b18:	aa 1f       	adc	r26, r26
    1b1a:	bb 1f       	adc	r27, r27
    1b1c:	ee 1f       	adc	r30, r30
    1b1e:	ff 1f       	adc	r31, r31
    1b20:	a2 17       	cp	r26, r18
    1b22:	b3 07       	cpc	r27, r19
    1b24:	e4 07       	cpc	r30, r20
    1b26:	f5 07       	cpc	r31, r21
    1b28:	20 f0       	brcs	.+8      	; 0x1b32 <__udivmodsi4_ep>
    1b2a:	a2 1b       	sub	r26, r18
    1b2c:	b3 0b       	sbc	r27, r19
    1b2e:	e4 0b       	sbc	r30, r20
    1b30:	f5 0b       	sbc	r31, r21

00001b32 <__udivmodsi4_ep>:
    1b32:	66 1f       	adc	r22, r22
    1b34:	77 1f       	adc	r23, r23
    1b36:	88 1f       	adc	r24, r24
    1b38:	99 1f       	adc	r25, r25
    1b3a:	1a 94       	dec	r1
    1b3c:	69 f7       	brne	.-38     	; 0x1b18 <__udivmodsi4_loop>
    1b3e:	60 95       	com	r22
    1b40:	70 95       	com	r23
    1b42:	80 95       	com	r24
    1b44:	90 95       	com	r25
    1b46:	9b 01       	movw	r18, r22
    1b48:	ac 01       	movw	r20, r24
    1b4a:	bd 01       	movw	r22, r26
    1b4c:	cf 01       	movw	r24, r30
    1b4e:	08 95       	ret

00001b50 <__muluhisi3>:
    1b50:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <__umulhisi3>
    1b54:	a5 9f       	mul	r26, r21
    1b56:	90 0d       	add	r25, r0
    1b58:	b4 9f       	mul	r27, r20
    1b5a:	90 0d       	add	r25, r0
    1b5c:	a4 9f       	mul	r26, r20
    1b5e:	80 0d       	add	r24, r0
    1b60:	91 1d       	adc	r25, r1
    1b62:	11 24       	eor	r1, r1
    1b64:	08 95       	ret

00001b66 <__udivmodhi4>:
    1b66:	aa 1b       	sub	r26, r26
    1b68:	bb 1b       	sub	r27, r27
    1b6a:	51 e1       	ldi	r21, 0x11	; 17
    1b6c:	07 c0       	rjmp	.+14     	; 0x1b7c <__udivmodhi4_ep>

00001b6e <__udivmodhi4_loop>:
    1b6e:	aa 1f       	adc	r26, r26
    1b70:	bb 1f       	adc	r27, r27
    1b72:	a6 17       	cp	r26, r22
    1b74:	b7 07       	cpc	r27, r23
    1b76:	10 f0       	brcs	.+4      	; 0x1b7c <__udivmodhi4_ep>
    1b78:	a6 1b       	sub	r26, r22
    1b7a:	b7 0b       	sbc	r27, r23

00001b7c <__udivmodhi4_ep>:
    1b7c:	88 1f       	adc	r24, r24
    1b7e:	99 1f       	adc	r25, r25
    1b80:	5a 95       	dec	r21
    1b82:	a9 f7       	brne	.-22     	; 0x1b6e <__udivmodhi4_loop>
    1b84:	80 95       	com	r24
    1b86:	90 95       	com	r25
    1b88:	bc 01       	movw	r22, r24
    1b8a:	cd 01       	movw	r24, r26
    1b8c:	08 95       	ret

00001b8e <__umulhisi3>:
    1b8e:	a2 9f       	mul	r26, r18
    1b90:	b0 01       	movw	r22, r0
    1b92:	b3 9f       	mul	r27, r19
    1b94:	c0 01       	movw	r24, r0
    1b96:	a3 9f       	mul	r26, r19
    1b98:	70 0d       	add	r23, r0
    1b9a:	81 1d       	adc	r24, r1
    1b9c:	11 24       	eor	r1, r1
    1b9e:	91 1d       	adc	r25, r1
    1ba0:	b2 9f       	mul	r27, r18
    1ba2:	70 0d       	add	r23, r0
    1ba4:	81 1d       	adc	r24, r1
    1ba6:	11 24       	eor	r1, r1
    1ba8:	91 1d       	adc	r25, r1
    1baa:	08 95       	ret

00001bac <_exit>:
    1bac:	f8 94       	cli

00001bae <__stop_program>:
    1bae:	ff cf       	rjmp	.-2      	; 0x1bae <__stop_program>
