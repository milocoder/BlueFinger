
SD_kaart4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000bc  00800100  000022a8  0000233c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000022a8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000519  008001bc  008001bc  000023f8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000023f8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002454  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000190  00000000  00000000  00002490  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a34  00000000  00000000  00002620  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001158  00000000  00000000  00005054  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000016cc  00000000  00000000  000061ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000654  00000000  00000000  00007878  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009fa  00000000  00000000  00007ecc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000025bc  00000000  00000000  000088c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000168  00000000  00000000  0000ae82  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 28 04 	jmp	0x850	; 0x850 <__vector_10>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_18>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf ef       	ldi	r28, 0xFF	; 255
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e0       	ldi	r26, 0x00	; 0
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	e8 ea       	ldi	r30, 0xA8	; 168
      a8:	f2 e2       	ldi	r31, 0x22	; 34
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	ac 3b       	cpi	r26, 0xBC	; 188
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	26 e0       	ldi	r18, 0x06	; 6
      b8:	ac eb       	ldi	r26, 0xBC	; 188
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	a5 3d       	cpi	r26, 0xD5	; 213
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 a4 05 	call	0xb48	; 0xb48 <main>
      ca:	0c 94 52 11 	jmp	0x22a4	; 0x22a4 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <initCAN>:

	// Set the MOB's mode to transmission, also activating it.
	CANCDMOB |= (0x01 << CONMOB0);

	return 1;
}
      d2:	e8 ed       	ldi	r30, 0xD8	; 216
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	80 81       	ld	r24, Z
      d8:	81 60       	ori	r24, 0x01	; 1
      da:	80 83       	st	Z, r24
      dc:	86 e0       	ldi	r24, 0x06	; 6
      de:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7f80e2>
      e2:	84 e0       	ldi	r24, 0x04	; 4
      e4:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7f80e3>
      e8:	83 e1       	ldi	r24, 0x13	; 19
      ea:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7f80e4>
      ee:	80 e0       	ldi	r24, 0x00	; 0
      f0:	08 c0       	rjmp	.+16     	; 0x102 <initCAN+0x30>
      f2:	98 2f       	mov	r25, r24
      f4:	92 95       	swap	r25
      f6:	90 7f       	andi	r25, 0xF0	; 240
      f8:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
      fc:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     100:	8f 5f       	subi	r24, 0xFF	; 255
     102:	8f 30       	cpi	r24, 0x0F	; 15
     104:	b0 f3       	brcs	.-20     	; 0xf2 <initCAN+0x20>
     106:	78 94       	sei
     108:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     10c:	80 eb       	ldi	r24, 0xB0	; 176
     10e:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7f80db>
     112:	e8 ed       	ldi	r30, 0xD8	; 216
     114:	f0 e0       	ldi	r31, 0x00	; 0
     116:	80 81       	ld	r24, Z
     118:	82 60       	ori	r24, 0x02	; 2
     11a:	80 83       	st	Z, r24
     11c:	08 95       	ret

0000011e <getFreeMob>:
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	0a c0       	rjmp	.+20     	; 0x136 <getFreeMob+0x18>
     122:	98 2f       	mov	r25, r24
     124:	92 95       	swap	r25
     126:	90 7f       	andi	r25, 0xF0	; 240
     128:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     12c:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     130:	90 7c       	andi	r25, 0xC0	; 192
     132:	21 f0       	breq	.+8      	; 0x13c <getFreeMob+0x1e>
     134:	8f 5f       	subi	r24, 0xFF	; 255
     136:	8f 30       	cpi	r24, 0x0F	; 15
     138:	a0 f3       	brcs	.-24     	; 0x122 <getFreeMob+0x4>
     13a:	8f ef       	ldi	r24, 0xFF	; 255
     13c:	08 95       	ret

0000013e <listenForMessage>:
 * @param[in] id - the provided id
 * @return 0 if no free message objects left, 1 otherwise
 *
 */
uint8_t listenForMessage( uint16_t id, uint8_t expectedLength )
{
     13e:	1f 93       	push	r17
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	ec 01       	movw	r28, r24
     146:	16 2f       	mov	r17, r22
	// Try to get a free MOb
	uint8_t mobIndex = getFreeMob();
     148:	0e 94 8f 00 	call	0x11e	; 0x11e <getFreeMob>

	if( mobIndex == 0xFF )
     14c:	8f 3f       	cpi	r24, 0xFF	; 255
     14e:	09 f4       	brne	.+2      	; 0x152 <listenForMessage+0x14>
     150:	4e c0       	rjmp	.+156    	; 0x1ee <listenForMessage+0xb0>
		// No free Message Objects
		return 0;
	}

	// Point to the free message object
	CANPAGE |= (mobIndex << 4);
     152:	ed ee       	ldi	r30, 0xED	; 237
     154:	f0 e0       	ldi	r31, 0x00	; 0
     156:	90 81       	ld	r25, Z
     158:	48 2f       	mov	r20, r24
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	9a 01       	movw	r18, r20
     15e:	22 95       	swap	r18
     160:	32 95       	swap	r19
     162:	30 7f       	andi	r19, 0xF0	; 240
     164:	32 27       	eor	r19, r18
     166:	20 7f       	andi	r18, 0xF0	; 240
     168:	32 27       	eor	r19, r18
     16a:	29 2b       	or	r18, r25
     16c:	20 83       	st	Z, r18

	// Set the MOb's CAN id to the id to be listened for
	CANIDT4 = 0;
     16e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
	CANIDT3 = 0;
     172:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
	CANIDT2 = id << 5;
     176:	9c 2f       	mov	r25, r28
     178:	92 95       	swap	r25
     17a:	99 0f       	add	r25, r25
     17c:	90 7e       	andi	r25, 0xE0	; 224
     17e:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
	CANIDT1 = id >> 3;
     182:	d6 95       	lsr	r29
     184:	c7 95       	ror	r28
     186:	d6 95       	lsr	r29
     188:	c7 95       	ror	r28
     18a:	d6 95       	lsr	r29
     18c:	c7 95       	ror	r28
     18e:	c0 93 f3 00 	sts	0x00F3, r28	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>

	if( expectedLength > 8 )
     192:	19 30       	cpi	r17, 0x09	; 9
     194:	08 f0       	brcs	.+2      	; 0x198 <listenForMessage+0x5a>
	{
		expectedLength = 8;
     196:	18 e0       	ldi	r17, 0x08	; 8
	}

	// Set the MOb's expected length
	CANCDMOB |= expectedLength;
     198:	ef ee       	ldi	r30, 0xEF	; 239
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	60 81       	ld	r22, Z
     19e:	61 2b       	or	r22, r17
     1a0:	60 83       	st	Z, r22

	// Enable interrupts for this MOb
	if( mobIndex < 8 )
     1a2:	88 30       	cpi	r24, 0x08	; 8
     1a4:	78 f4       	brcc	.+30     	; 0x1c4 <listenForMessage+0x86>
	{
		CANIE2 |= (1 << mobIndex);
     1a6:	ee ed       	ldi	r30, 0xDE	; 222
     1a8:	f0 e0       	ldi	r31, 0x00	; 0
     1aa:	40 81       	ld	r20, Z
     1ac:	21 e0       	ldi	r18, 0x01	; 1
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	b9 01       	movw	r22, r18
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <listenForMessage+0x7a>
     1b4:	66 0f       	add	r22, r22
     1b6:	77 1f       	adc	r23, r23
     1b8:	8a 95       	dec	r24
     1ba:	e2 f7       	brpl	.-8      	; 0x1b4 <listenForMessage+0x76>
     1bc:	cb 01       	movw	r24, r22
     1be:	84 2b       	or	r24, r20
     1c0:	80 83       	st	Z, r24
     1c2:	0e c0       	rjmp	.+28     	; 0x1e0 <listenForMessage+0xa2>
	}
	else
	{
		CANIE1 |= (1 << (mobIndex-8));
     1c4:	ef ed       	ldi	r30, 0xDF	; 223
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	20 81       	ld	r18, Z
     1ca:	48 50       	subi	r20, 0x08	; 8
     1cc:	51 09       	sbc	r21, r1
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <listenForMessage+0x9a>
     1d4:	88 0f       	add	r24, r24
     1d6:	99 1f       	adc	r25, r25
     1d8:	4a 95       	dec	r20
     1da:	e2 f7       	brpl	.-8      	; 0x1d4 <listenForMessage+0x96>
     1dc:	82 2b       	or	r24, r18
     1de:	80 83       	st	Z, r24
	}

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);
     1e0:	ef ee       	ldi	r30, 0xEF	; 239
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	80 68       	ori	r24, 0x80	; 128
     1e8:	80 83       	st	Z, r24

	return 1;
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <listenForMessage+0xb2>
	uint8_t mobIndex = getFreeMob();

	if( mobIndex == 0xFF )
	{
		// No free Message Objects
		return 0;
     1ee:	80 e0       	ldi	r24, 0x00	; 0

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);

	return 1;
}
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	1f 91       	pop	r17
     1f6:	08 95       	ret

000001f8 <getMessage>:
 * @param[out] message - message data to fill
 * @return 1 if message was filled, 0 otherwise
 *
 */
uint8_t getMessage( CANMessage * message )
{
     1f8:	dc 01       	movw	r26, r24
	// Default to no message available
	uint8_t messageAvailable = 0;

	if( serviceIndex != bufIndex )
     1fa:	e0 91 be 01 	lds	r30, 0x01BE	; 0x8001be <serviceIndex>
     1fe:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <bufIndex>
     202:	e8 17       	cp	r30, r24
     204:	09 f4       	brne	.+2      	; 0x208 <getMessage+0x10>
     206:	41 c0       	rjmp	.+130    	; 0x28a <getMessage+0x92>
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
     208:	2b e0       	ldi	r18, 0x0B	; 11
     20a:	2e 9f       	mul	r18, r30
     20c:	f0 01       	movw	r30, r0
     20e:	11 24       	eor	r1, r1
     210:	e1 53       	subi	r30, 0x31	; 49
     212:	fa 4f       	sbci	r31, 0xFA	; 250
     214:	30 81       	ld	r19, Z
     216:	81 81       	ldd	r24, Z+1	; 0x01
     218:	98 2f       	mov	r25, r24
     21a:	97 70       	andi	r25, 0x07	; 7
     21c:	3c 93       	st	X, r19
     21e:	11 96       	adiw	r26, 0x01	; 1
     220:	8c 91       	ld	r24, X
     222:	11 97       	sbiw	r26, 0x01	; 1
     224:	88 7f       	andi	r24, 0xF8	; 248
     226:	89 2b       	or	r24, r25
     228:	11 96       	adiw	r26, 0x01	; 1
     22a:	8c 93       	st	X, r24
     22c:	11 97       	sbiw	r26, 0x01	; 1
		message->length = messageBuffer[ serviceIndex ].length;
     22e:	60 91 be 01 	lds	r22, 0x01BE	; 0x8001be <serviceIndex>
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	26 9f       	mul	r18, r22
     236:	f0 01       	movw	r30, r0
     238:	27 9f       	mul	r18, r23
     23a:	f0 0d       	add	r31, r0
     23c:	11 24       	eor	r1, r1
     23e:	e1 53       	subi	r30, 0x31	; 49
     240:	fa 4f       	sbci	r31, 0xFA	; 250
     242:	82 85       	ldd	r24, Z+10	; 0x0a
     244:	1a 96       	adiw	r26, 0x0a	; 10
     246:	8c 93       	st	X, r24
     248:	1a 97       	sbiw	r26, 0x0a	; 10

		for( uint8_t i = 0; i < message->length; ++i )
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	12 c0       	rjmp	.+36     	; 0x272 <getMessage+0x7a>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
     24e:	29 2f       	mov	r18, r25
     250:	30 e0       	ldi	r19, 0x00	; 0
     252:	4b e0       	ldi	r20, 0x0B	; 11
     254:	46 9f       	mul	r20, r22
     256:	f0 01       	movw	r30, r0
     258:	47 9f       	mul	r20, r23
     25a:	f0 0d       	add	r31, r0
     25c:	11 24       	eor	r1, r1
     25e:	e1 53       	subi	r30, 0x31	; 49
     260:	fa 4f       	sbci	r31, 0xFA	; 250
     262:	e2 0f       	add	r30, r18
     264:	f3 1f       	adc	r31, r19
     266:	42 81       	ldd	r20, Z+2	; 0x02
     268:	fd 01       	movw	r30, r26
     26a:	e2 0f       	add	r30, r18
     26c:	f3 1f       	adc	r31, r19
     26e:	42 83       	std	Z+2, r20	; 0x02
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
		message->length = messageBuffer[ serviceIndex ].length;

		for( uint8_t i = 0; i < message->length; ++i )
     270:	9f 5f       	subi	r25, 0xFF	; 255
     272:	98 17       	cp	r25, r24
     274:	60 f3       	brcs	.-40     	; 0x24e <getMessage+0x56>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
		}

		// Increment the index pointing to the next message to be serviced
		serviceIndex = (serviceIndex + 1) % MESSAGE_BUFFER_LENGTH;
     276:	cb 01       	movw	r24, r22
     278:	01 96       	adiw	r24, 0x01	; 1
     27a:	64 e1       	ldi	r22, 0x14	; 20
     27c:	70 e0       	ldi	r23, 0x00	; 0
     27e:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <__divmodhi4>
     282:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <serviceIndex>

		messageAvailable = 1;
     286:	81 e0       	ldi	r24, 0x01	; 1
     288:	08 95       	ret
 *
 */
uint8_t getMessage( CANMessage * message )
{
	// Default to no message available
	uint8_t messageAvailable = 0;
     28a:	80 e0       	ldi	r24, 0x00	; 0

		messageAvailable = 1;
	}

	return messageAvailable;
}
     28c:	08 95       	ret

0000028e <__vector_18>:
 * Note that the NO_BLOCK attribute is not applied here, so while this is running,
 * all interrupts are blocked.
 *
 */
ISR( CANIT_vect )
{
     28e:	1f 92       	push	r1
     290:	0f 92       	push	r0
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	0f 92       	push	r0
     296:	11 24       	eor	r1, r1
     298:	2f 93       	push	r18
     29a:	3f 93       	push	r19
     29c:	4f 93       	push	r20
     29e:	5f 93       	push	r21
     2a0:	6f 93       	push	r22
     2a2:	7f 93       	push	r23
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	cf 93       	push	r28
     2ae:	ef 93       	push	r30
     2b0:	ff 93       	push	r31
	// **Save off CANPAGE to prevent application code bugs**
	uint8_t canPage = CANPAGE;
     2b2:	c0 91 ed 00 	lds	r28, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     2b6:	87 c0       	rjmp	.+270    	; 0x3c6 <__vector_18+0x138>
	{
		// Point to the Message Object that needs to be serviced
		CANPAGE = CANHPMOB & 0xF0;
     2b8:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     2bc:	80 7f       	andi	r24, 0xF0	; 240
     2be:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

		// Service the correct kind of interrupt
		// Transmit Interrupts
		if( CANSTMOB & (1 << TXOK) )
     2c2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2c6:	86 ff       	sbrs	r24, 6
     2c8:	0c c0       	rjmp	.+24     	; 0x2e2 <__vector_18+0x54>
		{
			// Acknowledge the interrupt
			CANSTMOB = 0;
     2ca:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			// Free up the MOb
			CANCDMOB = 0;
     2ce:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>

			// Determine the MOb index
			uint8_t mob = (CANPAGE & 0xF0) >> 8;
     2d2:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

			// Disable interrupts for this MOb
			if( mob < 8 )
			{
				CANIE2 &= ~(1 << mob);
     2d6:	ee ed       	ldi	r30, 0xDE	; 222
     2d8:	f0 e0       	ldi	r31, 0x00	; 0
     2da:	80 81       	ld	r24, Z
     2dc:	8e 7f       	andi	r24, 0xFE	; 254
     2de:	80 83       	st	Z, r24
     2e0:	72 c0       	rjmp	.+228    	; 0x3c6 <__vector_18+0x138>
			{
				CANIE1 &= ~(1 << (mob-8));
			}
		}
		// Receive Interrupts
		else if ( CANSTMOB & (1 << RXOK) )
     2e2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2e6:	85 ff       	sbrs	r24, 5
     2e8:	62 c0       	rjmp	.+196    	; 0x3ae <__vector_18+0x120>
		{
			// Default to impossible ID
			uint16_t id = 0xFFFF;

			// Load the message data into a free message buffer object
			if( CANCDMOB & (1 << IDE) )
     2ea:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     2ee:	84 ff       	sbrs	r24, 4
     2f0:	0e c0       	rjmp	.+28     	; 0x30e <__vector_18+0x80>
			{
				// Message type is CAN 2.0B
				id = (CANIDT4 >> 3) | ((CANIDT3 & 0x7F) << 5); 
     2f2:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     2f6:	86 95       	lsr	r24
     2f8:	86 95       	lsr	r24
     2fa:	86 95       	lsr	r24
     2fc:	40 91 f1 00 	lds	r20, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     300:	4f 77       	andi	r20, 0x7F	; 127
     302:	90 e2       	ldi	r25, 0x20	; 32
     304:	49 9f       	mul	r20, r25
     306:	a0 01       	movw	r20, r0
     308:	11 24       	eor	r1, r1
     30a:	48 2b       	or	r20, r24
     30c:	0f c0       	rjmp	.+30     	; 0x32c <__vector_18+0x9e>
			}
			else
			{
				// Message type is CAN 2.0A
				id = (CANIDT2 >> 5) | (((uint16_t)CANIDT1 << 3));
     30e:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     312:	82 95       	swap	r24
     314:	86 95       	lsr	r24
     316:	87 70       	andi	r24, 0x07	; 7
     318:	40 91 f3 00 	lds	r20, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     31c:	50 e0       	ldi	r21, 0x00	; 0
     31e:	44 0f       	add	r20, r20
     320:	55 1f       	adc	r21, r21
     322:	44 0f       	add	r20, r20
     324:	55 1f       	adc	r21, r21
     326:	44 0f       	add	r20, r20
     328:	55 1f       	adc	r21, r21
     32a:	48 2b       	or	r20, r24
			}

			messageBuffer[bufIndex].id = id;
     32c:	20 91 bd 01 	lds	r18, 0x01BD	; 0x8001bd <bufIndex>
     330:	30 e0       	ldi	r19, 0x00	; 0
     332:	8b e0       	ldi	r24, 0x0B	; 11
     334:	82 9f       	mul	r24, r18
     336:	f0 01       	movw	r30, r0
     338:	83 9f       	mul	r24, r19
     33a:	f0 0d       	add	r31, r0
     33c:	11 24       	eor	r1, r1
     33e:	e1 53       	subi	r30, 0x31	; 49
     340:	fa 4f       	sbci	r31, 0xFA	; 250
     342:	40 83       	st	Z, r20
     344:	95 2f       	mov	r25, r21
     346:	97 70       	andi	r25, 0x07	; 7
     348:	81 81       	ldd	r24, Z+1	; 0x01
     34a:	88 7f       	andi	r24, 0xF8	; 248
     34c:	89 2b       	or	r24, r25
     34e:	81 83       	std	Z+1, r24	; 0x01

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;
     350:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     354:	8f 70       	andi	r24, 0x0F	; 15
     356:	82 87       	std	Z+10, r24	; 0x0a

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	0e c0       	rjmp	.+28     	; 0x378 <__vector_18+0xea>
			{
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
     35c:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7f80fa>
     360:	4b e0       	ldi	r20, 0x0B	; 11
     362:	42 9f       	mul	r20, r18
     364:	f0 01       	movw	r30, r0
     366:	43 9f       	mul	r20, r19
     368:	f0 0d       	add	r31, r0
     36a:	11 24       	eor	r1, r1
     36c:	e1 53       	subi	r30, 0x31	; 49
     36e:	fa 4f       	sbci	r31, 0xFA	; 250
     370:	e9 0f       	add	r30, r25
     372:	f1 1d       	adc	r31, r1
     374:	82 83       	std	Z+2, r24	; 0x02
			messageBuffer[bufIndex].id = id;

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     376:	9f 5f       	subi	r25, 0xFF	; 255
     378:	8b e0       	ldi	r24, 0x0B	; 11
     37a:	82 9f       	mul	r24, r18
     37c:	f0 01       	movw	r30, r0
     37e:	83 9f       	mul	r24, r19
     380:	f0 0d       	add	r31, r0
     382:	11 24       	eor	r1, r1
     384:	e1 53       	subi	r30, 0x31	; 49
     386:	fa 4f       	sbci	r31, 0xFA	; 250
     388:	82 85       	ldd	r24, Z+10	; 0x0a
     38a:	98 17       	cp	r25, r24
     38c:	38 f3       	brcs	.-50     	; 0x35c <__vector_18+0xce>
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
			}

			bufIndex = (bufIndex + 1) % MESSAGE_BUFFER_LENGTH;
     38e:	c9 01       	movw	r24, r18
     390:	01 96       	adiw	r24, 0x01	; 1
     392:	64 e1       	ldi	r22, 0x14	; 20
     394:	70 e0       	ldi	r23, 0x00	; 0
     396:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <__divmodhi4>
     39a:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <bufIndex>

			// Acknowledge the interrupt
			CANSTMOB = 0;
     39e:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			CANCDMOB |= (2 << CONMOB0);
     3a2:	ef ee       	ldi	r30, 0xEF	; 239
     3a4:	f0 e0       	ldi	r31, 0x00	; 0
     3a6:	80 81       	ld	r24, Z
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 83       	st	Z, r24
     3ac:	0c c0       	rjmp	.+24     	; 0x3c6 <__vector_18+0x138>
			
		}
		else if ( CANGIT & ~(1 << CANIT) )
     3ae:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	89 2b       	or	r24, r25
     3b8:	31 f0       	breq	.+12     	; 0x3c6 <__vector_18+0x138>
		{
			// Preserve the last error received
			lastError = CANGIT;
     3ba:	ea ed       	ldi	r30, 0xDA	; 218
     3bc:	f0 e0       	ldi	r31, 0x00	; 0
     3be:	80 81       	ld	r24, Z
     3c0:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <__data_end>

			// Clear the error
			CANGIT = 0;
     3c4:	10 82       	st	Z, r1
	uint8_t canPage = CANPAGE;

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     3c6:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     3ca:	82 95       	swap	r24
     3cc:	8f 70       	andi	r24, 0x0F	; 15
     3ce:	8f 30       	cpi	r24, 0x0F	; 15
     3d0:	09 f0       	breq	.+2      	; 0x3d4 <__vector_18+0x146>
     3d2:	72 cf       	rjmp	.-284    	; 0x2b8 <__vector_18+0x2a>
			CANGIT = 0;
		}
	}

	// Restore CANPAGE register to where application code had it before interrupt
	CANPAGE = canPage;
     3d4:	c0 93 ed 00 	sts	0x00ED, r28	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     3d8:	ff 91       	pop	r31
     3da:	ef 91       	pop	r30
     3dc:	cf 91       	pop	r28
     3de:	bf 91       	pop	r27
     3e0:	af 91       	pop	r26
     3e2:	9f 91       	pop	r25
     3e4:	8f 91       	pop	r24
     3e6:	7f 91       	pop	r23
     3e8:	6f 91       	pop	r22
     3ea:	5f 91       	pop	r21
     3ec:	4f 91       	pop	r20
     3ee:	3f 91       	pop	r19
     3f0:	2f 91       	pop	r18
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0
     3f8:	1f 90       	pop	r1
     3fa:	18 95       	reti

000003fc <init_spi>:
//

static void init_spi(void)
{
	/* Set MOSI and SCK output, all others input */
	DDR_SPI |= ((1 << MOSI) | (1 << SCK) | (1 << CS));
     3fc:	84 b1       	in	r24, 0x04	; 4
     3fe:	87 60       	ori	r24, 0x07	; 7
     400:	84 b9       	out	0x04, r24	; 4
	
	// enable pull up resistor in MISO
	PORTB |= (1 << MISO);
     402:	85 b1       	in	r24, 0x05	; 5
     404:	88 60       	ori	r24, 0x08	; 8
     406:	85 b9       	out	0x05, r24	; 5
	
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPR0));
     408:	8c b5       	in	r24, 0x2c	; 44
     40a:	81 65       	ori	r24, 0x51	; 81
     40c:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<CS); 				//hoog maken CS	
     40e:	85 b1       	in	r24, 0x05	; 5
     410:	81 60       	ori	r24, 0x01	; 1
     412:	85 b9       	out	0x05, r24	; 5
     414:	08 95       	ret

00000416 <xmit_spi>:
}

static BYTE xmit_spi(BYTE data)
{
	PORTB &= ~(1<<CS); //laag maken
     416:	95 b1       	in	r25, 0x05	; 5
     418:	9e 7f       	andi	r25, 0xFE	; 254
     41a:	95 b9       	out	0x05, r25	; 5
	/* Start transmission */
	SPDR = data;
     41c:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     41e:	0d b4       	in	r0, 0x2d	; 45
     420:	07 fe       	sbrs	r0, 7
     422:	fd cf       	rjmp	.-6      	; 0x41e <xmit_spi+0x8>
	PORTB |= (1<<CS);		//hoog maken CS
     424:	85 b1       	in	r24, 0x05	; 5
     426:	81 60       	ori	r24, 0x01	; 1
     428:	85 b9       	out	0x05, r24	; 5
	
	return SPDR; 
     42a:	8e b5       	in	r24, 0x2e	; 46
}
     42c:	08 95       	ret

0000042e <rcv_spi>:

static BYTE rcv_spi(void)
{
	return xmit_spi(0xFF);
     42e:	8f ef       	ldi	r24, 0xFF	; 255
     430:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
}
     434:	08 95       	ret

00000436 <send_cmd>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static BYTE send_cmd(BYTE  cmd, /* 1st byte (Start + Index) */
                     DWORD arg ) /* Argument (32 bits) */
{
     436:	ff 92       	push	r15
     438:	0f 93       	push	r16
     43a:	1f 93       	push	r17
     43c:	cf 93       	push	r28
     43e:	df 93       	push	r29
     440:	c8 2f       	mov	r28, r24
     442:	d4 2f       	mov	r29, r20
     444:	15 2f       	mov	r17, r21
     446:	06 2f       	mov	r16, r22
     448:	f7 2e       	mov	r15, r23
	BYTE n, res;

	if (cmd & 0x80) { /* ACMD<n> is the command sequence of CMD55-CMD<n> */
     44a:	88 23       	and	r24, r24
     44c:	4c f4       	brge	.+18     	; 0x460 <send_cmd+0x2a>
		cmd &= 0x7F;
     44e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	50 e0       	ldi	r21, 0x00	; 0
     454:	ba 01       	movw	r22, r20
     456:	87 e7       	ldi	r24, 0x77	; 119
     458:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
		if (res > 1)
     45c:	82 30       	cpi	r24, 0x02	; 2
     45e:	50 f5       	brcc	.+84     	; 0x4b4 <send_cmd+0x7e>
			return res;
	}

	/* Select the card */
	DESELECT();
     460:	85 b1       	in	r24, 0x05	; 5
     462:	81 60       	ori	r24, 0x01	; 1
     464:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     466:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	SELECT();
     46a:	85 b1       	in	r24, 0x05	; 5
     46c:	8e 7f       	andi	r24, 0xFE	; 254
     46e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     470:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	/* Send a command packet */
	xmit_spi(cmd);               /* Start + Command index */
     474:	8c 2f       	mov	r24, r28
     476:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
     47a:	8f 2d       	mov	r24, r15
     47c:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
     480:	80 2f       	mov	r24, r16
     482:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
     486:	81 2f       	mov	r24, r17
     488:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
     48c:	8d 2f       	mov	r24, r29
     48e:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	n = 0x01;                    /* Dummy CRC + Stop */
	if (cmd == CMD0)
     492:	c0 34       	cpi	r28, 0x40	; 64
     494:	11 f0       	breq	.+4      	; 0x49a <send_cmd+0x64>
	xmit_spi(cmd);               /* Start + Command index */
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
	n = 0x01;                    /* Dummy CRC + Stop */
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	01 c0       	rjmp	.+2      	; 0x49c <send_cmd+0x66>
	if (cmd == CMD0)
		n = 0x95; /* Valid CRC for CMD0(0) */
     49a:	85 e9       	ldi	r24, 0x95	; 149
	if (cmd == CMD8)
     49c:	c8 34       	cpi	r28, 0x48	; 72
     49e:	09 f4       	brne	.+2      	; 0x4a2 <send_cmd+0x6c>
		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
     4a0:	87 e8       	ldi	r24, 0x87	; 135
	xmit_spi(n);
     4a2:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>

	/* Receive a command response */
	n = 10; /* Wait for a valid response in timeout of 10 attempts */
     4a6:	ca e0       	ldi	r28, 0x0A	; 10
	do {
		res = rcv_spi();
     4a8:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	} while ((res & 0x80) && --n);
     4ac:	88 23       	and	r24, r24
     4ae:	14 f4       	brge	.+4      	; 0x4b4 <send_cmd+0x7e>
     4b0:	c1 50       	subi	r28, 0x01	; 1
     4b2:	d1 f7       	brne	.-12     	; 0x4a8 <send_cmd+0x72>

	return res; /* Return with the response value */
}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	1f 91       	pop	r17
     4ba:	0f 91       	pop	r16
     4bc:	ff 90       	pop	r15
     4be:	08 95       	ret

000004c0 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(void)
{
     4c0:	ef 92       	push	r14
     4c2:	ff 92       	push	r15
     4c4:	0f 93       	push	r16
     4c6:	1f 93       	push	r17
     4c8:	cf 93       	push	r28
     4ca:	df 93       	push	r29
     4cc:	00 d0       	rcall	.+0      	; 0x4ce <disk_initialize+0xe>
     4ce:	00 d0       	rcall	.+0      	; 0x4d0 <disk_initialize+0x10>
     4d0:	cd b7       	in	r28, 0x3d	; 61
     4d2:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING)
     4d4:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     4d8:	81 11       	cpse	r24, r1
     4da:	84 b1       	in	r24, 0x04	; 4
		disk_writep(0, 0); /* Finalize write process if it is in progress */
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
     4dc:	0e 94 fe 01 	call	0x3fc	; 0x3fc <init_spi>
	DESELECT();
     4e0:	85 b1       	in	r24, 0x05	; 5
     4e2:	81 60       	ori	r24, 0x01	; 1
     4e4:	85 b9       	out	0x05, r24	; 5
	for (n = 10; n; n--)
     4e6:	1a e0       	ldi	r17, 0x0A	; 10
     4e8:	03 c0       	rjmp	.+6      	; 0x4f0 <disk_initialize+0x30>
		rcv_spi(); /* 80 dummy clocks with CS=H */
     4ea:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
     4ee:	11 50       	subi	r17, 0x01	; 1
     4f0:	11 11       	cpse	r17, r1
     4f2:	fb cf       	rjmp	.-10     	; 0x4ea <disk_initialize+0x2a>
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
     4f4:	40 e0       	ldi	r20, 0x00	; 0
     4f6:	50 e0       	ldi	r21, 0x00	; 0
     4f8:	ba 01       	movw	r22, r20
     4fa:	80 e4       	ldi	r24, 0x40	; 64
     4fc:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     500:	81 30       	cpi	r24, 0x01	; 1
     502:	09 f0       	breq	.+2      	; 0x506 <disk_initialize+0x46>
     504:	9b c0       	rjmp	.+310    	; 0x63c <disk_initialize+0x17c>
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
     506:	4a ea       	ldi	r20, 0xAA	; 170
     508:	51 e0       	ldi	r21, 0x01	; 1
     50a:	60 e0       	ldi	r22, 0x00	; 0
     50c:	70 e0       	ldi	r23, 0x00	; 0
     50e:	88 e4       	ldi	r24, 0x48	; 72
     510:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     514:	81 30       	cpi	r24, 0x01	; 1
     516:	09 f0       	breq	.+2      	; 0x51a <disk_initialize+0x5a>
     518:	59 c0       	rjmp	.+178    	; 0x5cc <disk_initialize+0x10c>
     51a:	0d c0       	rjmp	.+26     	; 0x536 <disk_initialize+0x76>
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
     51c:	e0 2e       	mov	r14, r16
     51e:	f1 2c       	mov	r15, r1
     520:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     524:	e1 e0       	ldi	r30, 0x01	; 1
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	ec 0f       	add	r30, r28
     52a:	fd 1f       	adc	r31, r29
     52c:	ee 0d       	add	r30, r14
     52e:	ff 1d       	adc	r31, r15
     530:	80 83       	st	Z, r24
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
     532:	0f 5f       	subi	r16, 0xFF	; 255
     534:	01 c0       	rjmp	.+2      	; 0x538 <disk_initialize+0x78>
     536:	01 2f       	mov	r16, r17
     538:	04 30       	cpi	r16, 0x04	; 4
     53a:	80 f3       	brcs	.-32     	; 0x51c <disk_initialize+0x5c>
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
     53c:	8b 81       	ldd	r24, Y+3	; 0x03
     53e:	81 30       	cpi	r24, 0x01	; 1
     540:	09 f0       	breq	.+2      	; 0x544 <disk_initialize+0x84>
     542:	7e c0       	rjmp	.+252    	; 0x640 <disk_initialize+0x180>
     544:	8c 81       	ldd	r24, Y+4	; 0x04
     546:	8a 3a       	cpi	r24, 0xAA	; 170
     548:	61 f0       	breq	.+24     	; 0x562 <disk_initialize+0xa2>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     54a:	f1 2c       	mov	r15, r1
     54c:	84 c0       	rjmp	.+264    	; 0x656 <disk_initialize+0x196>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     54e:	8f e8       	ldi	r24, 0x8F	; 143
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	01 97       	sbiw	r24, 0x01	; 1
     554:	f1 f7       	brne	.-4      	; 0x552 <disk_initialize+0x92>
     556:	00 c0       	rjmp	.+0      	; 0x558 <disk_initialize+0x98>
     558:	00 00       	nop
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
     55a:	91 e0       	ldi	r25, 0x01	; 1
     55c:	e9 1a       	sub	r14, r25
     55e:	f1 08       	sbc	r15, r1
     560:	06 c0       	rjmp	.+12     	; 0x56e <disk_initialize+0xae>
     562:	0f 2e       	mov	r0, r31
     564:	f0 e1       	ldi	r31, 0x10	; 16
     566:	ef 2e       	mov	r14, r31
     568:	f7 e2       	ldi	r31, 0x27	; 39
     56a:	ff 2e       	mov	r15, r31
     56c:	f0 2d       	mov	r31, r0
     56e:	e1 14       	cp	r14, r1
     570:	f1 04       	cpc	r15, r1
     572:	49 f0       	breq	.+18     	; 0x586 <disk_initialize+0xc6>
     574:	40 e0       	ldi	r20, 0x00	; 0
     576:	50 e0       	ldi	r21, 0x00	; 0
     578:	60 e0       	ldi	r22, 0x00	; 0
     57a:	70 e4       	ldi	r23, 0x40	; 64
     57c:	89 ee       	ldi	r24, 0xE9	; 233
     57e:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     582:	81 11       	cpse	r24, r1
     584:	e4 cf       	rjmp	.-56     	; 0x54e <disk_initialize+0x8e>
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
     586:	ef 28       	or	r14, r15
     588:	09 f4       	brne	.+2      	; 0x58c <disk_initialize+0xcc>
     58a:	5c c0       	rjmp	.+184    	; 0x644 <disk_initialize+0x184>
     58c:	40 e0       	ldi	r20, 0x00	; 0
     58e:	50 e0       	ldi	r21, 0x00	; 0
     590:	ba 01       	movw	r22, r20
     592:	8a e7       	ldi	r24, 0x7A	; 122
     594:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	71 f0       	breq	.+28     	; 0x5b8 <disk_initialize+0xf8>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     59c:	f1 2c       	mov	r15, r1
     59e:	5b c0       	rjmp	.+182    	; 0x656 <disk_initialize+0x196>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
     5a0:	e1 2e       	mov	r14, r17
     5a2:	f1 2c       	mov	r15, r1
     5a4:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     5a8:	e1 e0       	ldi	r30, 0x01	; 1
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	ec 0f       	add	r30, r28
     5ae:	fd 1f       	adc	r31, r29
     5b0:	ee 0d       	add	r30, r14
     5b2:	ff 1d       	adc	r31, r15
     5b4:	80 83       	st	Z, r24
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
     5b6:	1f 5f       	subi	r17, 0xFF	; 255
     5b8:	14 30       	cpi	r17, 0x04	; 4
     5ba:	90 f3       	brcs	.-28     	; 0x5a0 <disk_initialize+0xe0>
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     5bc:	89 81       	ldd	r24, Y+1	; 0x01
     5be:	86 ff       	sbrs	r24, 6
     5c0:	43 c0       	rjmp	.+134    	; 0x648 <disk_initialize+0x188>
     5c2:	0f 2e       	mov	r0, r31
     5c4:	fc e0       	ldi	r31, 0x0C	; 12
     5c6:	ff 2e       	mov	r15, r31
     5c8:	f0 2d       	mov	r31, r0
     5ca:	45 c0       	rjmp	.+138    	; 0x656 <disk_initialize+0x196>
				}
			}
		} else { /* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) {
     5cc:	40 e0       	ldi	r20, 0x00	; 0
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	ba 01       	movw	r22, r20
     5d2:	89 ee       	ldi	r24, 0xE9	; 233
     5d4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     5d8:	82 30       	cpi	r24, 0x02	; 2
     5da:	40 f4       	brcc	.+16     	; 0x5ec <disk_initialize+0x12c>
				ty  = CT_SD1;
     5dc:	68 94       	set
     5de:	ff 24       	eor	r15, r15
     5e0:	f1 f8       	bld	r15, 1
				cmd = ACMD41; /* SDv1 */
     5e2:	0f 2e       	mov	r0, r31
     5e4:	f9 ee       	ldi	r31, 0xE9	; 233
     5e6:	ef 2e       	mov	r14, r31
     5e8:	f0 2d       	mov	r31, r0
     5ea:	06 c0       	rjmp	.+12     	; 0x5f8 <disk_initialize+0x138>
			} else {
				ty  = CT_MMC;
     5ec:	ff 24       	eor	r15, r15
     5ee:	f3 94       	inc	r15
				cmd = CMD1; /* MMCv3 */
     5f0:	0f 2e       	mov	r0, r31
     5f2:	f1 e4       	ldi	r31, 0x41	; 65
     5f4:	ef 2e       	mov	r14, r31
     5f6:	f0 2d       	mov	r31, r0
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
     5f8:	00 e1       	ldi	r16, 0x10	; 16
     5fa:	17 e2       	ldi	r17, 0x27	; 39
     5fc:	08 c0       	rjmp	.+16     	; 0x60e <disk_initialize+0x14e>
     5fe:	8f e8       	ldi	r24, 0x8F	; 143
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	01 97       	sbiw	r24, 0x01	; 1
     604:	f1 f7       	brne	.-4      	; 0x602 <disk_initialize+0x142>
     606:	00 c0       	rjmp	.+0      	; 0x608 <disk_initialize+0x148>
     608:	00 00       	nop
     60a:	01 50       	subi	r16, 0x01	; 1
     60c:	11 09       	sbc	r17, r1
     60e:	01 15       	cp	r16, r1
     610:	11 05       	cpc	r17, r1
     612:	41 f0       	breq	.+16     	; 0x624 <disk_initialize+0x164>
     614:	40 e0       	ldi	r20, 0x00	; 0
     616:	50 e0       	ldi	r21, 0x00	; 0
     618:	ba 01       	movw	r22, r20
     61a:	8e 2d       	mov	r24, r14
     61c:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     620:	81 11       	cpse	r24, r1
     622:	ed cf       	rjmp	.-38     	; 0x5fe <disk_initialize+0x13e>
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
     624:	01 2b       	or	r16, r17
     626:	a1 f0       	breq	.+40     	; 0x650 <disk_initialize+0x190>
     628:	40 e0       	ldi	r20, 0x00	; 0
     62a:	52 e0       	ldi	r21, 0x02	; 2
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 e5       	ldi	r24, 0x50	; 80
     632:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     636:	81 11       	cpse	r24, r1
     638:	0d c0       	rjmp	.+26     	; 0x654 <disk_initialize+0x194>
     63a:	0d c0       	rjmp	.+26     	; 0x656 <disk_initialize+0x196>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     63c:	f1 2c       	mov	r15, r1
     63e:	0b c0       	rjmp	.+22     	; 0x656 <disk_initialize+0x196>
     640:	f1 2c       	mov	r15, r1
     642:	09 c0       	rjmp	.+18     	; 0x656 <disk_initialize+0x196>
     644:	f1 2c       	mov	r15, r1
     646:	07 c0       	rjmp	.+14     	; 0x656 <disk_initialize+0x196>
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     648:	68 94       	set
     64a:	ff 24       	eor	r15, r15
     64c:	f2 f8       	bld	r15, 2
     64e:	03 c0       	rjmp	.+6      	; 0x656 <disk_initialize+0x196>
				cmd = CMD1; /* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
				ty = 0;
     650:	f1 2c       	mov	r15, r1
     652:	01 c0       	rjmp	.+2      	; 0x656 <disk_initialize+0x196>
     654:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     656:	f0 92 c1 01 	sts	0x01C1, r15	; 0x8001c1 <CardType>
	DESELECT();
     65a:	85 b1       	in	r24, 0x05	; 5
     65c:	81 60       	ori	r24, 0x01	; 1
     65e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     660:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return ty ? 0 : STA_NOINIT;
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	f1 10       	cpse	r15, r1
     668:	80 e0       	ldi	r24, 0x00	; 0
}
     66a:	0f 90       	pop	r0
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	0f 90       	pop	r0
     672:	df 91       	pop	r29
     674:	cf 91       	pop	r28
     676:	1f 91       	pop	r17
     678:	0f 91       	pop	r16
     67a:	ff 90       	pop	r15
     67c:	ef 90       	pop	r14
     67e:	08 95       	ret

00000680 <disk_readp>:
DRESULT disk_readp(BYTE *buff,   /* Pointer to the read buffer (NULL:Forward to the stream) */
                   DWORD sector, /* Sector number (LBA) */
                   UINT  offset, /* Byte offset to read from (0..511) */
                   UINT  count   /* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
     680:	af 92       	push	r10
     682:	bf 92       	push	r11
     684:	cf 92       	push	r12
     686:	df 92       	push	r13
     688:	ef 92       	push	r14
     68a:	ff 92       	push	r15
     68c:	0f 93       	push	r16
     68e:	1f 93       	push	r17
     690:	cf 93       	push	r28
     692:	df 93       	push	r29
     694:	6c 01       	movw	r12, r24
     696:	79 01       	movw	r14, r18
	DRESULT res;
	BYTE    rc;
	UINT    bc;

	if (!(CardType & CT_BLOCK))
     698:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     69c:	83 fd       	sbrc	r24, 3
     69e:	09 c0       	rjmp	.+18     	; 0x6b2 <disk_readp+0x32>
		sector *= 512; /* Convert to byte address if needed */
     6a0:	03 2e       	mov	r0, r19
     6a2:	39 e0       	ldi	r19, 0x09	; 9
     6a4:	44 0f       	add	r20, r20
     6a6:	55 1f       	adc	r21, r21
     6a8:	66 1f       	adc	r22, r22
     6aa:	77 1f       	adc	r23, r23
     6ac:	3a 95       	dec	r19
     6ae:	d1 f7       	brne	.-12     	; 0x6a4 <disk_readp+0x24>
     6b0:	30 2d       	mov	r19, r0

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
     6b2:	81 e5       	ldi	r24, 0x51	; 81
     6b4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     6b8:	81 11       	cpse	r24, r1
     6ba:	31 c0       	rjmp	.+98     	; 0x71e <disk_readp+0x9e>

		// bc = 40000;	/* Time counter */
		do { /* Wait for response */
			rc = rcv_spi();
     6bc:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		} while (rc == 0xFF);
     6c0:	8f 3f       	cpi	r24, 0xFF	; 255
     6c2:	e1 f3       	breq	.-8      	; 0x6bc <disk_readp+0x3c>

		if (rc == 0xFE) { /* A data packet arrived */
     6c4:	8e 3f       	cpi	r24, 0xFE	; 254
     6c6:	69 f5       	brne	.+90     	; 0x722 <disk_readp+0xa2>

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */
     6c8:	cc 27       	eor	r28, r28
     6ca:	dd 27       	eor	r29, r29
     6cc:	ce 19       	sub	r28, r14
     6ce:	df 09       	sbc	r29, r15
     6d0:	c0 1b       	sub	r28, r16
     6d2:	d1 0b       	sbc	r29, r17
     6d4:	ce 5f       	subi	r28, 0xFE	; 254
     6d6:	dd 4f       	sbci	r29, 0xFD	; 253

			/* Skip leading bytes */
			while (offset--)
     6d8:	03 c0       	rjmp	.+6      	; 0x6e0 <disk_readp+0x60>
				rcv_spi();
     6da:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		if (rc == 0xFE) { /* A data packet arrived */

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */

			/* Skip leading bytes */
			while (offset--)
     6de:	75 01       	movw	r14, r10
     6e0:	57 01       	movw	r10, r14
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	a8 1a       	sub	r10, r24
     6e6:	b1 08       	sbc	r11, r1
     6e8:	ef 28       	or	r14, r15
     6ea:	b9 f7       	brne	.-18     	; 0x6da <disk_readp+0x5a>
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
     6ec:	c1 14       	cp	r12, r1
     6ee:	d1 04       	cpc	r13, r1
     6f0:	69 f0       	breq	.+26     	; 0x70c <disk_readp+0x8c>
				do {
					*buff++ = rcv_spi();
     6f2:	76 01       	movw	r14, r12
     6f4:	ef ef       	ldi	r30, 0xFF	; 255
     6f6:	ee 1a       	sub	r14, r30
     6f8:	fe 0a       	sbc	r15, r30
     6fa:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     6fe:	f6 01       	movw	r30, r12
     700:	80 83       	st	Z, r24
				} while (--count);
     702:	01 50       	subi	r16, 0x01	; 1
     704:	11 09       	sbc	r17, r1
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
				do {
					*buff++ = rcv_spi();
     706:	67 01       	movw	r12, r14
				} while (--count);
     708:	a1 f7       	brne	.-24     	; 0x6f2 <disk_readp+0x72>
     70a:	03 c0       	rjmp	.+6      	; 0x712 <disk_readp+0x92>
			} else { /* Forward data to the outgoing stream */
				do {
					// FORWARD(rcv_spi());
				} while (--count);
     70c:	01 50       	subi	r16, 0x01	; 1
     70e:	11 09       	sbc	r17, r1
     710:	e9 f7       	brne	.-6      	; 0x70c <disk_readp+0x8c>
			}

			/* Skip trailing bytes and CRC */
			do
				rcv_spi();
     712:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
			while (--bc);
     716:	21 97       	sbiw	r28, 0x01	; 1
     718:	e1 f7       	brne	.-8      	; 0x712 <disk_readp+0x92>

			res = RES_OK;
     71a:	c0 e0       	ldi	r28, 0x00	; 0
     71c:	03 c0       	rjmp	.+6      	; 0x724 <disk_readp+0xa4>
	UINT    bc;

	if (!(CardType & CT_BLOCK))
		sector *= 512; /* Convert to byte address if needed */

	res = RES_ERROR;
     71e:	c1 e0       	ldi	r28, 0x01	; 1
     720:	01 c0       	rjmp	.+2      	; 0x724 <disk_readp+0xa4>
     722:	c1 e0       	ldi	r28, 0x01	; 1

			res = RES_OK;
		}
	}

	DESELECT();
     724:	85 b1       	in	r24, 0x05	; 5
     726:	81 60       	ori	r24, 0x01	; 1
     728:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     72a:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return res;
}
     72e:	8c 2f       	mov	r24, r28
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	df 90       	pop	r13
     73e:	cf 90       	pop	r12
     740:	bf 90       	pop	r11
     742:	af 90       	pop	r10
     744:	08 95       	ret

00000746 <disk_writep>:

#if _USE_WRITE
DRESULT disk_writep(const BYTE *buff, /* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
                    DWORD       sc    /* Number of bytes to send, Sector number (LBA) or zero */
)
{
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	fc 01       	movw	r30, r24
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
     750:	89 2b       	or	r24, r25
     752:	f1 f0       	breq	.+60     	; 0x790 <disk_writep+0x4a>
		bc = sc;
     754:	ea 01       	movw	r28, r20
		while (bc && wc) { /* Send data bytes to the card */
     756:	11 c0       	rjmp	.+34     	; 0x77a <disk_writep+0x34>
			xmit_spi(*buff++);
     758:	8f 01       	movw	r16, r30
     75a:	0f 5f       	subi	r16, 0xFF	; 255
     75c:	1f 4f       	sbci	r17, 0xFF	; 255
     75e:	80 81       	ld	r24, Z
     760:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
			wc--;
     764:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     768:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     76c:	01 97       	sbiw	r24, 0x01	; 1
     76e:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <wc.1882+0x1>
     772:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <wc.1882>
			bc--;
     776:	21 97       	sbiw	r28, 0x01	; 1
	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
     778:	f8 01       	movw	r30, r16

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
     77a:	20 97       	sbiw	r28, 0x00	; 0
     77c:	09 f4       	brne	.+2      	; 0x780 <disk_writep+0x3a>
     77e:	5f c0       	rjmp	.+190    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
     780:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     784:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     788:	89 2b       	or	r24, r25
     78a:	31 f7       	brne	.-52     	; 0x758 <disk_writep+0x12>
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     78c:	c0 e0       	ldi	r28, 0x00	; 0
     78e:	5a c0       	rjmp	.+180    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
	} else {
		if (sc) { /* Initiate sector write process */
     790:	41 15       	cp	r20, r1
     792:	51 05       	cpc	r21, r1
     794:	61 05       	cpc	r22, r1
     796:	71 05       	cpc	r23, r1
     798:	01 f1       	breq	.+64     	; 0x7da <disk_writep+0x94>
			if (!(CardType & CT_BLOCK))
     79a:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     79e:	83 fd       	sbrc	r24, 3
     7a0:	09 c0       	rjmp	.+18     	; 0x7b4 <disk_writep+0x6e>
				sc *= 512;                  /* Convert to byte address if needed */
     7a2:	03 2e       	mov	r0, r19
     7a4:	39 e0       	ldi	r19, 0x09	; 9
     7a6:	44 0f       	add	r20, r20
     7a8:	55 1f       	adc	r21, r21
     7aa:	66 1f       	adc	r22, r22
     7ac:	77 1f       	adc	r23, r23
     7ae:	3a 95       	dec	r19
     7b0:	d1 f7       	brne	.-12     	; 0x7a6 <disk_writep+0x60>
     7b2:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sc) == 0) { /* WRITE_SINGLE_BLOCK */
     7b4:	88 e5       	ldi	r24, 0x58	; 88
     7b6:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     7ba:	81 11       	cpse	r24, r1
     7bc:	42 c0       	rjmp	.+132    	; 0x842 <__DATA_REGION_LENGTH__+0x42>
				xmit_spi(0xFF);
     7be:	8f ef       	ldi	r24, 0xFF	; 255
     7c0:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				xmit_spi(0xFE); /* Data block header */
     7c4:	8e ef       	ldi	r24, 0xFE	; 254
     7c6:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	92 e0       	ldi	r25, 0x02	; 2
     7ce:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <wc.1882+0x1>
     7d2:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <wc.1882>
				res = RES_OK;
     7d6:	c0 e0       	ldi	r28, 0x00	; 0
     7d8:	35 c0       	rjmp	.+106    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
     7da:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     7de:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     7e2:	02 96       	adiw	r24, 0x02	; 2
			while (bc--) {
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <disk_writep+0xa8>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
     7e6:	80 e0       	ldi	r24, 0x00	; 0
     7e8:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
				res = RES_OK;
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
			while (bc--) {
     7ec:	ce 01       	movw	r24, r28
     7ee:	ec 01       	movw	r28, r24
     7f0:	21 97       	sbiw	r28, 0x01	; 1
     7f2:	89 2b       	or	r24, r25
     7f4:	c1 f7       	brne	.-16     	; 0x7e6 <disk_writep+0xa0>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
			}
			do {
				res = rcv_spi();
     7f6:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     7fa:	c8 2f       	mov	r28, r24
			} while (res == 0xFF);
     7fc:	8f 3f       	cpi	r24, 0xFF	; 255
     7fe:	d9 f3       	breq	.-10     	; 0x7f6 <disk_writep+0xb0>
			if ((res & 0x1F) == 0x05) { /* Receive data resp and wait for end of write process in timeout of 500ms */
     800:	8f 71       	andi	r24, 0x1F	; 31
     802:	85 30       	cpi	r24, 0x05	; 5
     804:	b1 f4       	brne	.+44     	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     806:	09 c0       	rjmp	.+18     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     808:	8f e8       	ldi	r24, 0x8F	; 143
     80a:	91 e0       	ldi	r25, 0x01	; 1
     80c:	01 97       	sbiw	r24, 0x01	; 1
     80e:	f1 f7       	brne	.-4      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     810:	00 c0       	rjmp	.+0      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
     812:	00 00       	nop
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--) /* Wait for ready */
     814:	01 50       	subi	r16, 0x01	; 1
     816:	11 09       	sbc	r17, r1
     818:	02 c0       	rjmp	.+4      	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     81a:	08 e8       	ldi	r16, 0x88	; 136
     81c:	13 e1       	ldi	r17, 0x13	; 19
     81e:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     822:	8f 3f       	cpi	r24, 0xFF	; 255
     824:	19 f0       	breq	.+6      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     826:	01 15       	cp	r16, r1
     828:	11 05       	cpc	r17, r1
     82a:	71 f7       	brne	.-36     	; 0x808 <__DATA_REGION_LENGTH__+0x8>
					_delay_us(100);
				if (bc)
     82c:	01 2b       	or	r16, r17
     82e:	09 f0       	breq	.+2      	; 0x832 <__DATA_REGION_LENGTH__+0x32>
					res = RES_OK;
     830:	c0 e0       	ldi	r28, 0x00	; 0
			}
			DESELECT();
     832:	85 b1       	in	r24, 0x05	; 5
     834:	81 60       	ori	r24, 0x01	; 1
     836:	85 b9       	out	0x05, r24	; 5
			rcv_spi();
     838:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     83c:	03 c0       	rjmp	.+6      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     83e:	c0 e0       	ldi	r28, 0x00	; 0
     840:	01 c0       	rjmp	.+2      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
{
	DRESULT     res;
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;
     842:	c1 e0       	ldi	r28, 0x01	; 1
			rcv_spi();
		}
	}

	return res;
}
     844:	8c 2f       	mov	r24, r28
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	1f 91       	pop	r17
     84c:	0f 91       	pop	r16
     84e:	08 95       	ret

00000850 <__vector_10>:
void start_log_message(void);
unsigned long find_offset(void);
void writeToCard(void);

ISR(TIMER2_OVF_vect)
{
     850:	1f 92       	push	r1
     852:	0f 92       	push	r0
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	0f 92       	push	r0
     858:	11 24       	eor	r1, r1
     85a:	8f 93       	push	r24
     85c:	9f 93       	push	r25
	overflowCounter++;
     85e:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <overflowCounter>
     862:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <overflowCounter+0x1>
     866:	01 96       	adiw	r24, 0x01	; 1
     868:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <overflowCounter+0x1>
     86c:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <overflowCounter>
	TCNT2 = 0x00;
     870:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
}
     874:	9f 91       	pop	r25
     876:	8f 91       	pop	r24
     878:	0f 90       	pop	r0
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	0f 90       	pop	r0
     87e:	1f 90       	pop	r1
     880:	18 95       	reti

00000882 <init_timer>:
	}
}

void init_timer(void)
{	
	TCNT2 = 0x00; // start counting at 0
     882:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
	TCCR2A = ((1 << CS22) | (1 << CS21) | (1 << CS20)); // prescaler op 1024
     886:	87 e0       	ldi	r24, 0x07	; 7
     888:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
	TIMSK2 = (1 << TOIE2);
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7f8070>
     892:	08 95       	ret

00000894 <fill_buffer>:
}


void fill_buffer(void)
{
     894:	0f 93       	push	r16
     896:	1f 93       	push	r17
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
     89c:	cd b7       	in	r28, 0x3d	; 61
     89e:	de b7       	in	r29, 0x3e	; 62
     8a0:	6a 97       	sbiw	r28, 0x1a	; 26
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	de bf       	out	0x3e, r29	; 62
     8a8:	0f be       	out	0x3f, r0	; 63
     8aa:	cd bf       	out	0x3d, r28	; 61
	write_buffer[bufferAmt++] = '\n';
     8ac:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     8b0:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     8b4:	9c 01       	movw	r18, r24
     8b6:	2f 5f       	subi	r18, 0xFF	; 255
     8b8:	3f 4f       	sbci	r19, 0xFF	; 255
     8ba:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     8be:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     8c2:	fc 01       	movw	r30, r24
     8c4:	e3 53       	subi	r30, 0x33	; 51
     8c6:	fc 4f       	sbci	r31, 0xFC	; 252
     8c8:	2a e0       	ldi	r18, 0x0A	; 10
     8ca:	20 83       	st	Z, r18
	
	CANMessage bericht;
	int resultaat = getMessage(&bericht); // returnt 0 als het niet lukt om bericht uit te lezen, anders returnt 1
     8cc:	ce 01       	movw	r24, r28
     8ce:	01 96       	adiw	r24, 0x01	; 1
     8d0:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <getMessage>
	if(resultaat == 0)
     8d4:	88 23       	and	r24, r24
     8d6:	b9 f0       	breq	.+46     	; 0x906 <__stack+0x7>
     8d8:	1c c0       	rjmp	.+56     	; 0x912 <__stack+0x13>
		// geen bericht ontvangen > can-bus werkt niet
		const char* string = "GEEN DATA ONTVANGEN";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
		{
			write_buffer[bufferAmt++] = string[i];
     8da:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     8de:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     8e2:	ac 01       	movw	r20, r24
     8e4:	4f 5f       	subi	r20, 0xFF	; 255
     8e6:	5f 4f       	sbci	r21, 0xFF	; 255
     8e8:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <bufferAmt+0x1>
     8ec:	40 93 c9 01 	sts	0x01C9, r20	; 0x8001c9 <bufferAmt>
     8f0:	f9 01       	movw	r30, r18
     8f2:	e0 50       	subi	r30, 0x00	; 0
     8f4:	ff 4f       	sbci	r31, 0xFF	; 255
     8f6:	40 81       	ld	r20, Z
     8f8:	fc 01       	movw	r30, r24
     8fa:	e3 53       	subi	r30, 0x33	; 51
     8fc:	fc 4f       	sbci	r31, 0xFC	; 252
     8fe:	40 83       	st	Z, r20
	if(resultaat == 0)
	{
		// geen bericht ontvangen > can-bus werkt niet
		const char* string = "GEEN DATA ONTVANGEN";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
     900:	2f 5f       	subi	r18, 0xFF	; 255
     902:	3f 4f       	sbci	r19, 0xFF	; 255
     904:	02 c0       	rjmp	.+4      	; 0x90a <__stack+0xb>
     906:	20 e0       	ldi	r18, 0x00	; 0
     908:	30 e0       	ldi	r19, 0x00	; 0
     90a:	23 31       	cpi	r18, 0x13	; 19
     90c:	31 05       	cpc	r19, r1
     90e:	2c f3       	brlt	.-54     	; 0x8da <fill_buffer+0x46>
     910:	42 c0       	rjmp	.+132    	; 0x996 <__stack+0x97>
			write_buffer[bufferAmt++] = string[i];
		}
	} else 
	{
		// bericht ontvangen > schrijf data naar buffer
		if(bericht.id == CAN_ID_SNELHEIDSMETER)
     912:	89 81       	ldd	r24, Y+1	; 0x01
     914:	2a 81       	ldd	r18, Y+2	; 0x02
     916:	92 2f       	mov	r25, r18
     918:	97 70       	andi	r25, 0x07	; 7
     91a:	40 97       	sbiw	r24, 0x10	; 16
     91c:	e1 f5       	brne	.+120    	; 0x996 <__stack+0x97>
		{
			int val1 = bericht.data[0];
     91e:	8b 81       	ldd	r24, Y+3	; 0x03
			int val2 = bericht.data[1];
     920:	9c 81       	ldd	r25, Y+4	; 0x04
			char zin[15];
			sprintf(zin, "snelheid: %d.%d", val1, val2); 			
     922:	1f 92       	push	r1
     924:	9f 93       	push	r25
     926:	1f 92       	push	r1
     928:	8f 93       	push	r24
     92a:	84 e1       	ldi	r24, 0x14	; 20
     92c:	91 e0       	ldi	r25, 0x01	; 1
     92e:	9f 93       	push	r25
     930:	8f 93       	push	r24
     932:	8e 01       	movw	r16, r28
     934:	04 5f       	subi	r16, 0xF4	; 244
     936:	1f 4f       	sbci	r17, 0xFF	; 255
     938:	1f 93       	push	r17
     93a:	0f 93       	push	r16
     93c:	0e 94 68 0e 	call	0x1cd0	; 0x1cd0 <sprintf>
			int length = strlen(zin);
     940:	f8 01       	movw	r30, r16
     942:	01 90       	ld	r0, Z+
     944:	00 20       	and	r0, r0
     946:	e9 f7       	brne	.-6      	; 0x942 <__stack+0x43>
     948:	31 97       	sbiw	r30, 0x01	; 1
     94a:	bf 01       	movw	r22, r30
     94c:	60 1b       	sub	r22, r16
     94e:	71 0b       	sbc	r23, r17
			for (int i = 0; i < length; i++)
     950:	0f b6       	in	r0, 0x3f	; 63
     952:	f8 94       	cli
     954:	de bf       	out	0x3e, r29	; 62
     956:	0f be       	out	0x3f, r0	; 63
     958:	cd bf       	out	0x3d, r28	; 61
     95a:	20 e0       	ldi	r18, 0x00	; 0
     95c:	30 e0       	ldi	r19, 0x00	; 0
     95e:	18 c0       	rjmp	.+48     	; 0x990 <__stack+0x91>
			{
				write_buffer[bufferAmt++] = zin[i];
     960:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     964:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     968:	ac 01       	movw	r20, r24
     96a:	4f 5f       	subi	r20, 0xFF	; 255
     96c:	5f 4f       	sbci	r21, 0xFF	; 255
     96e:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <bufferAmt+0x1>
     972:	40 93 c9 01 	sts	0x01C9, r20	; 0x8001c9 <bufferAmt>
     976:	ec e0       	ldi	r30, 0x0C	; 12
     978:	f0 e0       	ldi	r31, 0x00	; 0
     97a:	ec 0f       	add	r30, r28
     97c:	fd 1f       	adc	r31, r29
     97e:	e2 0f       	add	r30, r18
     980:	f3 1f       	adc	r31, r19
     982:	40 81       	ld	r20, Z
     984:	fc 01       	movw	r30, r24
     986:	e3 53       	subi	r30, 0x33	; 51
     988:	fc 4f       	sbci	r31, 0xFC	; 252
     98a:	40 83       	st	Z, r20
			int val1 = bericht.data[0];
			int val2 = bericht.data[1];
			char zin[15];
			sprintf(zin, "snelheid: %d.%d", val1, val2); 			
			int length = strlen(zin);
			for (int i = 0; i < length; i++)
     98c:	2f 5f       	subi	r18, 0xFF	; 255
     98e:	3f 4f       	sbci	r19, 0xFF	; 255
     990:	26 17       	cp	r18, r22
     992:	37 07       	cpc	r19, r23
     994:	2c f3       	brlt	.-54     	; 0x960 <__stack+0x61>
	
			
		// if statement hierboven kan herhaald worden voor andere ID's.
	}
	
	if(bufferAmt>=(512-30)) // sectorgrootte van 512 bytes - ongeveer 30 bytes (iets meer dan 2 lines)
     996:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     99a:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     99e:	82 3e       	cpi	r24, 0xE2	; 226
     9a0:	91 40       	sbci	r25, 0x01	; 1
     9a2:	3c f0       	brlt	.+14     	; 0x9b2 <__stack+0xb3>
	{
			
		bufferAmt = 0;
     9a4:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <bufferAmt+0x1>
     9a8:	10 92 c9 01 	sts	0x01C9, r1	; 0x8001c9 <bufferAmt>
		startWriting = true; // als dit op true staat gaat de microcontroller in de main>while(logging) in de if-statement en vult vanaf daar de sd-kaart 
     9ac:	81 e0       	ldi	r24, 0x01	; 1
     9ae:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <startWriting>
	}
}
     9b2:	6a 96       	adiw	r28, 0x1a	; 26
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	de bf       	out	0x3e, r29	; 62
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	cd bf       	out	0x3d, r28	; 61
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	08 95       	ret

000009c8 <writeToCard>:


void writeToCard(void)
{
	// Set file pointer to beginning of sector 
	pf_lseek(curOffset); // offset van 0 is te vinden in sector 8448 van de sd-kaart
     9c8:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <curOffset>
     9cc:	70 91 c3 01 	lds	r23, 0x01C3	; 0x8001c3 <curOffset+0x1>
     9d0:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <curOffset+0x2>
     9d4:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <curOffset+0x3>
     9d8:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <pf_lseek>
	// Write buffer 
	pf_write(write_buffer, BUFFER_SIZE, &byte_counter);
     9dc:	4b ec       	ldi	r20, 0xCB	; 203
     9de:	51 e0       	ldi	r21, 0x01	; 1
     9e0:	60 e0       	ldi	r22, 0x00	; 0
     9e2:	72 e0       	ldi	r23, 0x02	; 2
     9e4:	8d ec       	ldi	r24, 0xCD	; 205
     9e6:	93 e0       	ldi	r25, 0x03	; 3
     9e8:	0e 94 cd 0b 	call	0x179a	; 0x179a <pf_write>
	if (byte_counter < BUFFER_SIZE) {
		// End of file 
	}
	// Finalize write 
	pf_write(0, 0, &byte_counter);
     9ec:	4b ec       	ldi	r20, 0xCB	; 203
     9ee:	51 e0       	ldi	r21, 0x01	; 1
     9f0:	60 e0       	ldi	r22, 0x00	; 0
     9f2:	70 e0       	ldi	r23, 0x00	; 0
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	0e 94 cd 0b 	call	0x179a	; 0x179a <pf_write>
	// Reset file pointer to beginning of sector 1 
	pf_lseek(curOffset);
     9fc:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <curOffset>
     a00:	70 91 c3 01 	lds	r23, 0x01C3	; 0x8001c3 <curOffset+0x1>
     a04:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <curOffset+0x2>
     a08:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <curOffset+0x3>
     a0c:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <pf_lseek>
	// Read back the same bytes 
	pf_read(read_buffer, BUFFER_SIZE, &byte_counter);
     a10:	4b ec       	ldi	r20, 0xCB	; 203
     a12:	51 e0       	ldi	r21, 0x01	; 1
     a14:	60 e0       	ldi	r22, 0x00	; 0
     a16:	72 e0       	ldi	r23, 0x02	; 2
     a18:	8d ec       	ldi	r24, 0xCD	; 205
     a1a:	91 e0       	ldi	r25, 0x01	; 1
     a1c:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <pf_read>
     a20:	08 95       	ret

00000a22 <find_offset>:
	}
	*/
}

unsigned long find_offset(void)
{
     a22:	cf 92       	push	r12
     a24:	df 92       	push	r13
     a26:	ef 92       	push	r14
     a28:	ff 92       	push	r15
     a2a:	cf 93       	push	r28
     a2c:	df 93       	push	r29
     a2e:	00 d0       	rcall	.+0      	; 0xa30 <find_offset+0xe>
     a30:	1f 92       	push	r1
     a32:	cd b7       	in	r28, 0x3d	; 61
     a34:	de b7       	in	r29, 0x3e	; 62
	// begin bij sector 0. kijk naar waarde 1e char. als die erop wijst dat de sector al geschreven is, ga naar sector 1. ga zo door. return offset als sector leeg lijkt te zijn
	uint8_t read_first[1]  = {};
     a36:	19 82       	std	Y+1, r1	; 0x01
	UINT bytecounter = 1;
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	9b 83       	std	Y+3, r25	; 0x03
     a3e:	8a 83       	std	Y+2, r24	; 0x02
	unsigned long tempOffset = 0;
     a40:	c1 2c       	mov	r12, r1
     a42:	d1 2c       	mov	r13, r1
     a44:	76 01       	movw	r14, r12
	unsigned long maxOffset = 51200; // als hij geen lege sector kan vinden na de 1e 100 sectoren
	while(1)
	{
		pf_lseek(tempOffset);
     a46:	c7 01       	movw	r24, r14
     a48:	b6 01       	movw	r22, r12
     a4a:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <pf_lseek>
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
     a4e:	ae 01       	movw	r20, r28
     a50:	4e 5f       	subi	r20, 0xFE	; 254
     a52:	5f 4f       	sbci	r21, 0xFF	; 255
     a54:	61 e0       	ldi	r22, 0x01	; 1
     a56:	70 e0       	ldi	r23, 0x00	; 0
     a58:	ce 01       	movw	r24, r28
     a5a:	01 96       	adiw	r24, 0x01	; 1
     a5c:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <pf_read>
		if(read_first[0] == 32)
     a60:	89 81       	ldd	r24, Y+1	; 0x01
     a62:	80 32       	cpi	r24, 0x20	; 32
     a64:	79 f0       	breq	.+30     	; 0xa84 <find_offset+0x62>
		{
			return tempOffset;
		} else {
			tempOffset += 512;
     a66:	82 e0       	ldi	r24, 0x02	; 2
     a68:	d8 0e       	add	r13, r24
     a6a:	e1 1c       	adc	r14, r1
     a6c:	f1 1c       	adc	r15, r1
			if(tempOffset >= maxOffset)
     a6e:	c1 14       	cp	r12, r1
     a70:	88 ec       	ldi	r24, 0xC8	; 200
     a72:	d8 06       	cpc	r13, r24
     a74:	e1 04       	cpc	r14, r1
     a76:	f1 04       	cpc	r15, r1
     a78:	30 f3       	brcs	.-52     	; 0xa46 <find_offset+0x24>
			break;
		}
	}
	return 0;
     a7a:	60 e0       	ldi	r22, 0x00	; 0
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	90 e0       	ldi	r25, 0x00	; 0
     a82:	04 c0       	rjmp	.+8      	; 0xa8c <find_offset+0x6a>
	{
		pf_lseek(tempOffset);
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
		if(read_first[0] == 32)
		{
			return tempOffset;
     a84:	6c 2d       	mov	r22, r12
     a86:	7d 2d       	mov	r23, r13
     a88:	8e 2d       	mov	r24, r14
     a8a:	9f 2d       	mov	r25, r15
			if(tempOffset >= maxOffset)
			break;
		}
	}
	return 0;
}
     a8c:	0f 90       	pop	r0
     a8e:	0f 90       	pop	r0
     a90:	0f 90       	pop	r0
     a92:	df 91       	pop	r29
     a94:	cf 91       	pop	r28
     a96:	ff 90       	pop	r15
     a98:	ef 90       	pop	r14
     a9a:	df 90       	pop	r13
     a9c:	cf 90       	pop	r12
     a9e:	08 95       	ret

00000aa0 <start_log_message>:

void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
     aa0:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     aa4:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     aa8:	9c 01       	movw	r18, r24
     aaa:	2f 5f       	subi	r18, 0xFF	; 255
     aac:	3f 4f       	sbci	r19, 0xFF	; 255
     aae:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     ab2:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     ab6:	fc 01       	movw	r30, r24
     ab8:	e3 53       	subi	r30, 0x33	; 51
     aba:	fc 4f       	sbci	r31, 0xFC	; 252
     abc:	2a e0       	ldi	r18, 0x0A	; 10
     abe:	20 83       	st	Z, r18
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     ac0:	20 e0       	ldi	r18, 0x00	; 0
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	15 c0       	rjmp	.+42     	; 0xaf0 <start_log_message+0x50>
	{
		write_buffer[bufferAmt++] = string[i];
     ac6:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     aca:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     ace:	ac 01       	movw	r20, r24
     ad0:	4f 5f       	subi	r20, 0xFF	; 255
     ad2:	5f 4f       	sbci	r21, 0xFF	; 255
     ad4:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <bufferAmt+0x1>
     ad8:	40 93 c9 01 	sts	0x01C9, r20	; 0x8001c9 <bufferAmt>
     adc:	f9 01       	movw	r30, r18
     ade:	ec 5d       	subi	r30, 0xDC	; 220
     ae0:	fe 4f       	sbci	r31, 0xFE	; 254
     ae2:	40 81       	ld	r20, Z
     ae4:	fc 01       	movw	r30, r24
     ae6:	e3 53       	subi	r30, 0x33	; 51
     ae8:	fc 4f       	sbci	r31, 0xFC	; 252
     aea:	40 83       	st	Z, r20
void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     aec:	2f 5f       	subi	r18, 0xFF	; 255
     aee:	3f 4f       	sbci	r19, 0xFF	; 255
     af0:	2e 30       	cpi	r18, 0x0E	; 14
     af2:	31 05       	cpc	r19, r1
     af4:	44 f3       	brlt	.-48     	; 0xac6 <start_log_message+0x26>
	{
		write_buffer[bufferAmt++] = string[i];
	}
	write_buffer[bufferAmt++] = '\n';
     af6:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     afa:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     afe:	9c 01       	movw	r18, r24
     b00:	2f 5f       	subi	r18, 0xFF	; 255
     b02:	3f 4f       	sbci	r19, 0xFF	; 255
     b04:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     b08:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     b0c:	fc 01       	movw	r30, r24
     b0e:	e3 53       	subi	r30, 0x33	; 51
     b10:	fc 4f       	sbci	r31, 0xFC	; 252
     b12:	2a e0       	ldi	r18, 0x0A	; 10
     b14:	20 83       	st	Z, r18
     b16:	08 95       	ret

00000b18 <init_sd_card>:
	DSTATUS status;
	FRESULT result;
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
     b18:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
		if (status != 0) {
     b1c:	81 11       	cpse	r24, r1
     b1e:	07 c0       	rjmp	.+14     	; 0xb2e <init_sd_card+0x16>
			ERROR = 1; 
		} else {
			ERROR = 0;			
			// Set SPI clock faster after initialization 
			SPCR = (1<<MSTR) | (0<<SPR1) | (0<<SPR0) | (1<<SPE);
     b20:	80 e5       	ldi	r24, 0x50	; 80
     b22:	8c bd       	out	0x2c, r24	; 44
			SPSR = (1<<SPI2X); 		
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	8d bd       	out	0x2d, r24	; 45
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
		} else {
			ERROR = 0;			
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	02 c0       	rjmp	.+4      	; 0xb32 <init_sd_card+0x1a>
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
     b2e:	81 e0       	ldi	r24, 0x01	; 1
     b30:	90 e0       	ldi	r25, 0x00	; 0
			//SPR1 en 0 op 0 SPI clock set to fck/4 (blaz. 174)
			//MSTR, in mastermode zetten
			//SPE, SPI enable maken.
			//SPI2X, het verdubbelen van de snelheid.			
		}
	} while (ERROR == 1);
     b32:	01 97       	sbiw	r24, 0x01	; 1
     b34:	89 f3       	breq	.-30     	; 0xb18 <init_sd_card>

	// Mount volume 
	result = pf_mount(&file_system);
     b36:	8b ea       	ldi	r24, 0xAB	; 171
     b38:	96 e0       	ldi	r25, 0x06	; 6
     b3a:	0e 94 db 08 	call	0x11b6	; 0x11b6 <pf_mount>
	if (result != FR_OK) {} // error

	// Open file 
	result = pf_open("LOG.txt");
     b3e:	83 e3       	ldi	r24, 0x33	; 51
     b40:	91 e0       	ldi	r25, 0x01	; 1
     b42:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <pf_open>
     b46:	08 95       	ret

00000b48 <main>:
}
	
int main(void)
{	
	_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | ((0<<CLKPS3) | (0<<CLKPS2) | (1<<CLKPS1) | (0<<CLKPS0))));
	init_sd_card(); // initialize sd-card
     b48:	0e 94 8c 05 	call	0xb18	; 0xb18 <init_sd_card>
	sei();
     b4c:	78 94       	sei
	initCAN(); // init can-bus
     b4e:	0e 94 69 00 	call	0xd2	; 0xd2 <initCAN>
	listenForMessage(CAN_ID_SNELHEIDSMETER, 8);
     b52:	68 e0       	ldi	r22, 0x08	; 8
     b54:	80 e1       	ldi	r24, 0x10	; 16
     b56:	90 e0       	ldi	r25, 0x00	; 0
     b58:	0e 94 9f 00 	call	0x13e	; 0x13e <listenForMessage>
	init_timer();
     b5c:	0e 94 41 04 	call	0x882	; 0x882 <init_timer>
	curOffset = find_offset(); // returnt offset van eerstvolgende lege sector
     b60:	0e 94 11 05 	call	0xa22	; 0xa22 <find_offset>
     b64:	60 93 c2 01 	sts	0x01C2, r22	; 0x8001c2 <curOffset>
     b68:	70 93 c3 01 	sts	0x01C3, r23	; 0x8001c3 <curOffset+0x1>
     b6c:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <curOffset+0x2>
     b70:	90 93 c5 01 	sts	0x01C5, r25	; 0x8001c5 <curOffset+0x3>
	start_log_message(); // schrijf start log bericht naar de kaart zodat je kan zien wanneer de auto opnieuw aan is gezet
     b74:	0e 94 50 05 	call	0xaa0	; 0xaa0 <start_log_message>
	while(1)
	{
		if(overflowCounter>=61) // 61 komt van 16.000.000 / 1024 (klokfrequentie / timer2prescaler) =  15625. 15625 / 256 (8 bit timer) = 61
     b78:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <overflowCounter>
     b7c:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <overflowCounter+0x1>
     b80:	cd 97       	sbiw	r24, 0x3d	; 61
     b82:	34 f0       	brlt	.+12     	; 0xb90 <main+0x48>
		{
			fill_buffer();
     b84:	0e 94 4a 04 	call	0x894	; 0x894 <fill_buffer>
			overflowCounter = 0;
     b88:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <overflowCounter+0x1>
     b8c:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <overflowCounter>
		}
		
		if(startWriting)
     b90:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <startWriting>
     b94:	88 23       	and	r24, r24
     b96:	81 f3       	breq	.-32     	; 0xb78 <main+0x30>
		{
			PORTC ^= (1 << PC0); // toggle ter indicatie op oscilloscoop
     b98:	98 b1       	in	r25, 0x08	; 8
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	89 27       	eor	r24, r25
     b9e:	88 b9       	out	0x08, r24	; 8
			writeToCard(); // schrijf buffer op kaart
     ba0:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <writeToCard>
			curOffset += 512; // zet pointer naar volgende sector
     ba4:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <curOffset>
     ba8:	90 91 c3 01 	lds	r25, 0x01C3	; 0x8001c3 <curOffset+0x1>
     bac:	a0 91 c4 01 	lds	r26, 0x01C4	; 0x8001c4 <curOffset+0x2>
     bb0:	b0 91 c5 01 	lds	r27, 0x01C5	; 0x8001c5 <curOffset+0x3>
     bb4:	9e 5f       	subi	r25, 0xFE	; 254
     bb6:	af 4f       	sbci	r26, 0xFF	; 255
     bb8:	bf 4f       	sbci	r27, 0xFF	; 255
     bba:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <curOffset>
     bbe:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <curOffset+0x1>
     bc2:	a0 93 c4 01 	sts	0x01C4, r26	; 0x8001c4 <curOffset+0x2>
     bc6:	b0 93 c5 01 	sts	0x01C5, r27	; 0x8001c5 <curOffset+0x3>
			startWriting = false;
     bca:	10 92 c6 01 	sts	0x01C6, r1	; 0x8001c6 <startWriting>
     bce:	d4 cf       	rjmp	.-88     	; 0xb78 <main+0x30>

00000bd0 <mem_set>:

static FATFS *FatFs; /* Pointer to the file system object (logical drive) */

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
     bd0:	fc 01       	movw	r30, r24
	char *d = (char *)dst;
	while (cnt--)
     bd2:	03 c0       	rjmp	.+6      	; 0xbda <mem_set+0xa>
		*d++ = (char)val;
     bd4:	60 83       	st	Z, r22

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     bd6:	ac 01       	movw	r20, r24
		*d++ = (char)val;
     bd8:	31 96       	adiw	r30, 0x01	; 1

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     bda:	ca 01       	movw	r24, r20
     bdc:	01 97       	sbiw	r24, 0x01	; 1
     bde:	45 2b       	or	r20, r21
     be0:	c9 f7       	brne	.-14     	; 0xbd4 <mem_set+0x4>
		*d++ = (char)val;
}
     be2:	08 95       	ret

00000be4 <mem_cmp>:

/* Compare memory to memory */
static int mem_cmp(const void *dst, const void *src, int cnt)
{
     be4:	cf 93       	push	r28
     be6:	df 93       	push	r29
     be8:	dc 01       	movw	r26, r24
     bea:	fb 01       	movw	r30, r22
	const char *d = (const char *)dst, *s = (const char *)src;
	int         r = 0;
     bec:	80 e0       	ldi	r24, 0x00	; 0
     bee:	90 e0       	ldi	r25, 0x00	; 0
	while (cnt-- && (r = *d++ - *s++) == 0)
     bf0:	02 c0       	rjmp	.+4      	; 0xbf6 <mem_cmp+0x12>
     bf2:	fb 01       	movw	r30, r22
     bf4:	de 01       	movw	r26, r28
     bf6:	9a 01       	movw	r18, r20
     bf8:	21 50       	subi	r18, 0x01	; 1
     bfa:	31 09       	sbc	r19, r1
     bfc:	45 2b       	or	r20, r21
     bfe:	61 f0       	breq	.+24     	; 0xc18 <mem_cmp+0x34>
     c00:	ed 01       	movw	r28, r26
     c02:	21 96       	adiw	r28, 0x01	; 1
     c04:	8c 91       	ld	r24, X
     c06:	90 e0       	ldi	r25, 0x00	; 0
     c08:	bf 01       	movw	r22, r30
     c0a:	6f 5f       	subi	r22, 0xFF	; 255
     c0c:	7f 4f       	sbci	r23, 0xFF	; 255
     c0e:	40 81       	ld	r20, Z
     c10:	84 1b       	sub	r24, r20
     c12:	91 09       	sbc	r25, r1
     c14:	a9 01       	movw	r20, r18
     c16:	69 f3       	breq	.-38     	; 0xbf2 <mem_cmp+0xe>
		;
	return r;
}
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	08 95       	ret

00000c1e <clust2sect>:
/*-----------------------------------------------------------------------*/

static DWORD clust2sect(           /* !=0: Sector number, 0: Failed - invalid cluster# */
                        CLUST clst /* Cluster# to be converted */
)
{
     c1e:	0f 93       	push	r16
     c20:	1f 93       	push	r17
	FATFS *fs = FatFs;
     c22:	e0 91 cd 05 	lds	r30, 0x05CD	; 0x8005cd <FatFs>
     c26:	f0 91 ce 05 	lds	r31, 0x05CE	; 0x8005ce <FatFs+0x1>

	clst -= 2;
     c2a:	9b 01       	movw	r18, r22
     c2c:	ac 01       	movw	r20, r24
     c2e:	22 50       	subi	r18, 0x02	; 2
     c30:	31 09       	sbc	r19, r1
     c32:	41 09       	sbc	r20, r1
     c34:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2))
     c36:	86 81       	ldd	r24, Z+6	; 0x06
     c38:	97 81       	ldd	r25, Z+7	; 0x07
     c3a:	a0 85       	ldd	r26, Z+8	; 0x08
     c3c:	b1 85       	ldd	r27, Z+9	; 0x09
     c3e:	02 97       	sbiw	r24, 0x02	; 2
     c40:	a1 09       	sbc	r26, r1
     c42:	b1 09       	sbc	r27, r1
     c44:	28 17       	cp	r18, r24
     c46:	39 07       	cpc	r19, r25
     c48:	4a 07       	cpc	r20, r26
     c4a:	5b 07       	cpc	r21, r27
     c4c:	68 f4       	brcc	.+26     	; 0xc68 <clust2sect+0x4a>
		return 0; /* Invalid cluster# */
	return (DWORD)clst * fs->csize + fs->database;
     c4e:	a2 81       	ldd	r26, Z+2	; 0x02
     c50:	b0 e0       	ldi	r27, 0x00	; 0
     c52:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <__muluhisi3>
     c56:	02 89       	ldd	r16, Z+18	; 0x12
     c58:	13 89       	ldd	r17, Z+19	; 0x13
     c5a:	24 89       	ldd	r18, Z+20	; 0x14
     c5c:	35 89       	ldd	r19, Z+21	; 0x15
     c5e:	60 0f       	add	r22, r16
     c60:	71 1f       	adc	r23, r17
     c62:	82 1f       	adc	r24, r18
     c64:	93 1f       	adc	r25, r19
     c66:	03 c0       	rjmp	.+6      	; 0xc6e <clust2sect+0x50>
{
	FATFS *fs = FatFs;

	clst -= 2;
	if (clst >= (fs->n_fatent - 2))
		return 0; /* Invalid cluster# */
     c68:	60 e0       	ldi	r22, 0x00	; 0
     c6a:	70 e0       	ldi	r23, 0x00	; 0
     c6c:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	08 95       	ret

00000c74 <get_clust>:

static CLUST get_clust(BYTE *dir /* Pointer to directory entry */
)
{
     c74:	0f 93       	push	r16
     c76:	1f 93       	push	r17
     c78:	fc 01       	movw	r30, r24
	FATFS *fs   = FatFs;
	CLUST  clst = 0;

	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
		clst = LD_WORD(dir + DIR_FstClusHI);
     c7a:	65 89       	ldd	r22, Z+21	; 0x15
     c7c:	70 e0       	ldi	r23, 0x00	; 0
     c7e:	76 2f       	mov	r23, r22
     c80:	66 27       	eor	r22, r22
     c82:	84 89       	ldd	r24, Z+20	; 0x14
     c84:	68 2b       	or	r22, r24
     c86:	cb 01       	movw	r24, r22
     c88:	a0 e0       	ldi	r26, 0x00	; 0
     c8a:	b0 e0       	ldi	r27, 0x00	; 0
		clst <<= 16;
     c8c:	bc 01       	movw	r22, r24
     c8e:	55 27       	eor	r21, r21
     c90:	44 27       	eor	r20, r20
	}
	clst |= LD_WORD(dir + DIR_FstClusLO);
     c92:	83 8d       	ldd	r24, Z+27	; 0x1b
     c94:	90 e0       	ldi	r25, 0x00	; 0
     c96:	98 2f       	mov	r25, r24
     c98:	88 27       	eor	r24, r24
     c9a:	22 8d       	ldd	r18, Z+26	; 0x1a
     c9c:	82 2b       	or	r24, r18
     c9e:	a0 e0       	ldi	r26, 0x00	; 0
     ca0:	b0 e0       	ldi	r27, 0x00	; 0
     ca2:	8c 01       	movw	r16, r24
     ca4:	9d 01       	movw	r18, r26
     ca6:	04 2b       	or	r16, r20
     ca8:	15 2b       	or	r17, r21
     caa:	26 2b       	or	r18, r22
     cac:	37 2b       	or	r19, r23
     cae:	c9 01       	movw	r24, r18
     cb0:	b8 01       	movw	r22, r16

	return clst;
}
     cb2:	1f 91       	pop	r17
     cb4:	0f 91       	pop	r16
     cb6:	08 95       	ret

00000cb8 <dir_rewind>:
/* Directory handling - Rewind directory index                           */
/*-----------------------------------------------------------------------*/

static FRESULT dir_rewind(DIR *dj /* Pointer to directory object */
)
{
     cb8:	0f 93       	push	r16
     cba:	1f 93       	push	r17
     cbc:	cf 93       	push	r28
     cbe:	df 93       	push	r29
     cc0:	fc 01       	movw	r30, r24
	CLUST  clst;
	FATFS *fs = FatFs;
     cc2:	a0 91 cd 05 	lds	r26, 0x05CD	; 0x8005cd <FatFs>
     cc6:	b0 91 ce 05 	lds	r27, 0x05CE	; 0x8005ce <FatFs+0x1>

	dj->index = 0;
     cca:	11 82       	std	Z+1, r1	; 0x01
     ccc:	10 82       	st	Z, r1
	clst      = dj->sclust;
     cce:	64 81       	ldd	r22, Z+4	; 0x04
     cd0:	75 81       	ldd	r23, Z+5	; 0x05
     cd2:	86 81       	ldd	r24, Z+6	; 0x06
     cd4:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
     cd6:	61 30       	cpi	r22, 0x01	; 1
     cd8:	71 05       	cpc	r23, r1
     cda:	81 05       	cpc	r24, r1
     cdc:	91 05       	cpc	r25, r1
     cde:	19 f1       	breq	.+70     	; 0xd26 <dir_rewind+0x6e>
     ce0:	16 96       	adiw	r26, 0x06	; 6
     ce2:	0d 91       	ld	r16, X+
     ce4:	1d 91       	ld	r17, X+
     ce6:	2d 91       	ld	r18, X+
     ce8:	3c 91       	ld	r19, X
     cea:	19 97       	sbiw	r26, 0x09	; 9
     cec:	60 17       	cp	r22, r16
     cee:	71 07       	cpc	r23, r17
     cf0:	82 07       	cpc	r24, r18
     cf2:	93 07       	cpc	r25, r19
     cf4:	d0 f4       	brcc	.+52     	; 0xd2a <dir_rewind+0x72>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst
     cf6:	61 15       	cp	r22, r1
     cf8:	71 05       	cpc	r23, r1
     cfa:	81 05       	cpc	r24, r1
     cfc:	91 05       	cpc	r25, r1
     cfe:	31 f4       	brne	.+12     	; 0xd0c <dir_rewind+0x54>
	    && (_FS_32ONLY || fs->fs_type == FS_FAT32)) /* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
     d00:	1e 96       	adiw	r26, 0x0e	; 14
     d02:	6d 91       	ld	r22, X+
     d04:	7d 91       	ld	r23, X+
     d06:	8d 91       	ld	r24, X+
     d08:	9c 91       	ld	r25, X
     d0a:	51 97       	sbiw	r26, 0x11	; 17
     d0c:	ef 01       	movw	r28, r30
	dj->clust = clst;                                                  /* Current cluster */
     d0e:	60 87       	std	Z+8, r22	; 0x08
     d10:	71 87       	std	Z+9, r23	; 0x09
     d12:	82 87       	std	Z+10, r24	; 0x0a
     d14:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */
     d16:	0e 94 0f 06 	call	0xc1e	; 0xc1e <clust2sect>
     d1a:	6c 87       	std	Y+12, r22	; 0x0c
     d1c:	7d 87       	std	Y+13, r23	; 0x0d
     d1e:	8e 87       	std	Y+14, r24	; 0x0e
     d20:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK; /* Seek succeeded */
     d22:	80 e0       	ldi	r24, 0x00	; 0
     d24:	03 c0       	rjmp	.+6      	; 0xd2c <dir_rewind+0x74>
	FATFS *fs = FatFs;

	dj->index = 0;
	clst      = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
		return FR_DISK_ERR;
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	01 c0       	rjmp	.+2      	; 0xd2c <dir_rewind+0x74>
     d2a:	81 e0       	ldi	r24, 0x01	; 1
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;                                                  /* Current cluster */
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */

	return FR_OK; /* Seek succeeded */
}
     d2c:	df 91       	pop	r29
     d2e:	cf 91       	pop	r28
     d30:	1f 91       	pop	r17
     d32:	0f 91       	pop	r16
     d34:	08 95       	ret

00000d36 <create_name>:
/*-----------------------------------------------------------------------*/

static FRESULT create_name(DIR *        dj,  /* Pointer to the directory object */
                           const char **path /* Pointer to pointer to the segment in the path string */
)
{
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	eb 01       	movw	r28, r22
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
     d40:	fc 01       	movw	r30, r24
     d42:	02 81       	ldd	r16, Z+2	; 0x02
     d44:	13 81       	ldd	r17, Z+3	; 0x03
	mem_set(sfn, ' ', 11);
     d46:	4b e0       	ldi	r20, 0x0B	; 11
     d48:	50 e0       	ldi	r21, 0x00	; 0
     d4a:	60 e2       	ldi	r22, 0x20	; 32
     d4c:	70 e0       	ldi	r23, 0x00	; 0
     d4e:	c8 01       	movw	r24, r16
     d50:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <mem_set>
	si = i = 0;
	ni     = 8;
	p      = *path;
     d54:	28 81       	ld	r18, Y
     d56:	39 81       	ldd	r19, Y+1	; 0x01
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0;
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	80 e0       	ldi	r24, 0x00	; 0
	ni     = 8;
     d5c:	58 e0       	ldi	r21, 0x08	; 8
     d5e:	01 c0       	rjmp	.+2      	; 0xd62 <create_name+0x2c>
     d60:	84 2f       	mov	r24, r20
	p      = *path;
	for (;;) {
		c = p[si++];
     d62:	41 e0       	ldi	r20, 0x01	; 1
     d64:	48 0f       	add	r20, r24
     d66:	f9 01       	movw	r30, r18
     d68:	e8 0f       	add	r30, r24
     d6a:	f1 1d       	adc	r31, r1
     d6c:	e0 81       	ld	r30, Z
		if (c <= ' ' || c == '/')
     d6e:	e1 32       	cpi	r30, 0x21	; 33
     d70:	f0 f0       	brcs	.+60     	; 0xdae <create_name+0x78>
     d72:	ef 32       	cpi	r30, 0x2F	; 47
     d74:	e1 f0       	breq	.+56     	; 0xdae <create_name+0x78>
			break; /* Break on end of segment */
		if (c == '.' || i >= ni) {
     d76:	ee 32       	cpi	r30, 0x2E	; 46
     d78:	11 f0       	breq	.+4      	; 0xd7e <create_name+0x48>
     d7a:	95 17       	cp	r25, r21
     d7c:	38 f0       	brcs	.+14     	; 0xd8c <create_name+0x56>
			if (ni != 8 || c != '.')
     d7e:	58 30       	cpi	r21, 0x08	; 8
     d80:	b1 f4       	brne	.+44     	; 0xdae <create_name+0x78>
     d82:	ee 32       	cpi	r30, 0x2E	; 46
     d84:	a1 f4       	brne	.+40     	; 0xdae <create_name+0x78>
				break;
			i  = 8;
     d86:	98 e0       	ldi	r25, 0x08	; 8
			ni = 11;
     d88:	5b e0       	ldi	r21, 0x0B	; 11
     d8a:	ea cf       	rjmp	.-44     	; 0xd60 <create_name+0x2a>
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80) /* To upper extended char (SBCS) */
     d8c:	ee 23       	and	r30, r30
     d8e:	24 f4       	brge	.+8      	; 0xd98 <create_name+0x62>
			c = cvt[c - 0x80];
     d90:	f0 e0       	ldi	r31, 0x00	; 0
     d92:	e5 54       	subi	r30, 0x45	; 69
     d94:	ff 4f       	sbci	r31, 0xFF	; 255
     d96:	e0 81       	ld	r30, Z
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{ /* Single byte code */
			if (_USE_LCC && IsLower(c))
     d98:	8f e9       	ldi	r24, 0x9F	; 159
     d9a:	8e 0f       	add	r24, r30
     d9c:	8a 31       	cpi	r24, 0x1A	; 26
     d9e:	08 f4       	brcc	.+2      	; 0xda2 <create_name+0x6c>
				c -= 0x20; /* toupper */
     da0:	e0 52       	subi	r30, 0x20	; 32
			sfn[i++] = c;
     da2:	d8 01       	movw	r26, r16
     da4:	a9 0f       	add	r26, r25
     da6:	b1 1d       	adc	r27, r1
     da8:	ec 93       	st	X, r30
     daa:	9f 5f       	subi	r25, 0xFF	; 255
     dac:	d9 cf       	rjmp	.-78     	; 0xd60 <create_name+0x2a>
		}
	}
	*path = &p[si]; /* Rerurn pointer to the next segment */
     dae:	24 0f       	add	r18, r20
     db0:	31 1d       	adc	r19, r1
     db2:	39 83       	std	Y+1, r19	; 0x01
     db4:	28 83       	st	Y, r18

	sfn[11] = (c <= ' ') ? 1 : 0; /* Set last segment flag if end of path */
     db6:	81 e0       	ldi	r24, 0x01	; 1
     db8:	e1 32       	cpi	r30, 0x21	; 33
     dba:	08 f0       	brcs	.+2      	; 0xdbe <create_name+0x88>
     dbc:	80 e0       	ldi	r24, 0x00	; 0
     dbe:	f8 01       	movw	r30, r16
     dc0:	83 87       	std	Z+11, r24	; 0x0b

	return FR_OK;
}
     dc2:	80 e0       	ldi	r24, 0x00	; 0
     dc4:	df 91       	pop	r29
     dc6:	cf 91       	pop	r28
     dc8:	1f 91       	pop	r17
     dca:	0f 91       	pop	r16
     dcc:	08 95       	ret

00000dce <check_fs>:

static BYTE check_fs(/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     dce:	cf 92       	push	r12
     dd0:	df 92       	push	r13
     dd2:	ef 92       	push	r14
     dd4:	ff 92       	push	r15
     dd6:	0f 93       	push	r16
     dd8:	1f 93       	push	r17
     dda:	cf 93       	push	r28
     ddc:	df 93       	push	r29
     dde:	ec 01       	movw	r28, r24
     de0:	6a 01       	movw	r12, r20
     de2:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
     de4:	02 e0       	ldi	r16, 0x02	; 2
     de6:	10 e0       	ldi	r17, 0x00	; 0
     de8:	2e ef       	ldi	r18, 0xFE	; 254
     dea:	31 e0       	ldi	r19, 0x01	; 1
     dec:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     df0:	81 11       	cpse	r24, r1
     df2:	1d c0       	rjmp	.+58     	; 0xe2e <check_fs+0x60>
		return 3;
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
     df4:	89 81       	ldd	r24, Y+1	; 0x01
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	98 2f       	mov	r25, r24
     dfa:	88 27       	eor	r24, r24
     dfc:	28 81       	ld	r18, Y
     dfe:	82 2b       	or	r24, r18
     e00:	85 35       	cpi	r24, 0x55	; 85
     e02:	9a 4a       	sbci	r25, 0xAA	; 170
     e04:	b1 f4       	brne	.+44     	; 0xe32 <check_fs+0x64>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
     e06:	22 e5       	ldi	r18, 0x52	; 82
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	b7 01       	movw	r22, r14
     e0c:	a6 01       	movw	r20, r12
     e0e:	ce 01       	movw	r24, r28
     e10:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     e14:	81 11       	cpse	r24, r1
     e16:	0f c0       	rjmp	.+30     	; 0xe36 <check_fs+0x68>
     e18:	89 81       	ldd	r24, Y+1	; 0x01
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	98 2f       	mov	r25, r24
     e1e:	88 27       	eor	r24, r24
     e20:	28 81       	ld	r18, Y
     e22:	82 2b       	or	r24, r18
     e24:	86 34       	cpi	r24, 0x46	; 70
     e26:	91 44       	sbci	r25, 0x41	; 65
     e28:	41 f0       	breq	.+16     	; 0xe3a <check_fs+0x6c>
		return 0;
	return 1;
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	07 c0       	rjmp	.+14     	; 0xe3c <check_fs+0x6e>
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
		return 3;
     e2e:	83 e0       	ldi	r24, 0x03	; 3
     e30:	05 c0       	rjmp	.+10     	; 0xe3c <check_fs+0x6e>
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
		return 2;
     e32:	82 e0       	ldi	r24, 0x02	; 2
     e34:	03 c0       	rjmp	.+6      	; 0xe3c <check_fs+0x6e>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
	return 1;
     e36:	81 e0       	ldi	r24, 0x01	; 1
     e38:	01 c0       	rjmp	.+2      	; 0xe3c <check_fs+0x6e>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
     e3a:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
     e3c:	df 91       	pop	r29
     e3e:	cf 91       	pop	r28
     e40:	1f 91       	pop	r17
     e42:	0f 91       	pop	r16
     e44:	ff 90       	pop	r15
     e46:	ef 90       	pop	r14
     e48:	df 90       	pop	r13
     e4a:	cf 90       	pop	r12
     e4c:	08 95       	ret

00000e4e <get_fat>:
/*-----------------------------------------------------------------------*/

static CLUST get_fat(           /* 1:IO error, Else:Cluster status */
                     CLUST clst /* Cluster# to get the link information */
)
{
     e4e:	cf 92       	push	r12
     e50:	df 92       	push	r13
     e52:	ef 92       	push	r14
     e54:	ff 92       	push	r15
     e56:	0f 93       	push	r16
     e58:	1f 93       	push	r17
     e5a:	cf 93       	push	r28
     e5c:	df 93       	push	r29
     e5e:	00 d0       	rcall	.+0      	; 0xe60 <get_fat+0x12>
     e60:	00 d0       	rcall	.+0      	; 0xe62 <get_fat+0x14>
     e62:	cd b7       	in	r28, 0x3d	; 61
     e64:	de b7       	in	r29, 0x3e	; 62
	BYTE   buf[4];
	FATFS *fs = FatFs;
     e66:	e0 91 cd 05 	lds	r30, 0x05CD	; 0x8005cd <FatFs>
     e6a:	f0 91 ce 05 	lds	r31, 0x05CE	; 0x8005ce <FatFs+0x1>

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
     e6e:	62 30       	cpi	r22, 0x02	; 2
     e70:	71 05       	cpc	r23, r1
     e72:	81 05       	cpc	r24, r1
     e74:	91 05       	cpc	r25, r1
     e76:	08 f4       	brcc	.+2      	; 0xe7a <get_fat+0x2c>
     e78:	56 c0       	rjmp	.+172    	; 0xf26 <get_fat+0xd8>
     e7a:	06 81       	ldd	r16, Z+6	; 0x06
     e7c:	17 81       	ldd	r17, Z+7	; 0x07
     e7e:	20 85       	ldd	r18, Z+8	; 0x08
     e80:	31 85       	ldd	r19, Z+9	; 0x09
     e82:	60 17       	cp	r22, r16
     e84:	71 07       	cpc	r23, r17
     e86:	82 07       	cpc	r24, r18
     e88:	93 07       	cpc	r25, r19
     e8a:	08 f0       	brcs	.+2      	; 0xe8e <get_fat+0x40>
     e8c:	51 c0       	rjmp	.+162    	; 0xf30 <get_fat+0xe2>
		return 1;

	switch (fs->fs_type) {
     e8e:	20 81       	ld	r18, Z
     e90:	23 30       	cpi	r18, 0x03	; 3
     e92:	09 f0       	breq	.+2      	; 0xe96 <get_fat+0x48>
     e94:	52 c0       	rjmp	.+164    	; 0xf3a <get_fat+0xec>
     e96:	dc 01       	movw	r26, r24
     e98:	cb 01       	movw	r24, r22
			break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32:
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4))
     e9a:	9c 01       	movw	r18, r24
     e9c:	2f 77       	andi	r18, 0x7F	; 127
     e9e:	33 27       	eor	r19, r19
     ea0:	c2 84       	ldd	r12, Z+10	; 0x0a
     ea2:	d3 84       	ldd	r13, Z+11	; 0x0b
     ea4:	e4 84       	ldd	r14, Z+12	; 0x0c
     ea6:	f5 84       	ldd	r15, Z+13	; 0x0d
     ea8:	68 94       	set
     eaa:	16 f8       	bld	r1, 6
     eac:	b6 95       	lsr	r27
     eae:	a7 95       	ror	r26
     eb0:	97 95       	ror	r25
     eb2:	87 95       	ror	r24
     eb4:	16 94       	lsr	r1
     eb6:	d1 f7       	brne	.-12     	; 0xeac <get_fat+0x5e>
     eb8:	22 0f       	add	r18, r18
     eba:	33 1f       	adc	r19, r19
     ebc:	22 0f       	add	r18, r18
     ebe:	33 1f       	adc	r19, r19
     ec0:	b7 01       	movw	r22, r14
     ec2:	a6 01       	movw	r20, r12
     ec4:	48 0f       	add	r20, r24
     ec6:	59 1f       	adc	r21, r25
     ec8:	6a 1f       	adc	r22, r26
     eca:	7b 1f       	adc	r23, r27
     ecc:	04 e0       	ldi	r16, 0x04	; 4
     ece:	10 e0       	ldi	r17, 0x00	; 0
     ed0:	ce 01       	movw	r24, r28
     ed2:	01 96       	adiw	r24, 0x01	; 1
     ed4:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     ed8:	81 11       	cpse	r24, r1
     eda:	34 c0       	rjmp	.+104    	; 0xf44 <get_fat+0xf6>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
     edc:	8c 81       	ldd	r24, Y+4	; 0x04
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	a0 e0       	ldi	r26, 0x00	; 0
     ee2:	b0 e0       	ldi	r27, 0x00	; 0
     ee4:	78 2f       	mov	r23, r24
     ee6:	66 27       	eor	r22, r22
     ee8:	55 27       	eor	r21, r21
     eea:	44 27       	eor	r20, r20
     eec:	9b 81       	ldd	r25, Y+3	; 0x03
     eee:	89 2f       	mov	r24, r25
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	a0 e0       	ldi	r26, 0x00	; 0
     ef4:	b0 e0       	ldi	r27, 0x00	; 0
     ef6:	dc 01       	movw	r26, r24
     ef8:	99 27       	eor	r25, r25
     efa:	88 27       	eor	r24, r24
     efc:	84 2b       	or	r24, r20
     efe:	95 2b       	or	r25, r21
     f00:	a6 2b       	or	r26, r22
     f02:	b7 2b       	or	r27, r23
     f04:	6a 81       	ldd	r22, Y+2	; 0x02
     f06:	70 e0       	ldi	r23, 0x00	; 0
     f08:	76 2f       	mov	r23, r22
     f0a:	66 27       	eor	r22, r22
     f0c:	ab 01       	movw	r20, r22
     f0e:	60 e0       	ldi	r22, 0x00	; 0
     f10:	70 e0       	ldi	r23, 0x00	; 0
     f12:	84 2b       	or	r24, r20
     f14:	95 2b       	or	r25, r21
     f16:	a6 2b       	or	r26, r22
     f18:	b7 2b       	or	r27, r23
     f1a:	29 81       	ldd	r18, Y+1	; 0x01
     f1c:	82 2b       	or	r24, r18
     f1e:	bc 01       	movw	r22, r24
     f20:	cd 01       	movw	r24, r26
     f22:	9f 70       	andi	r25, 0x0F	; 15
     f24:	13 c0       	rjmp	.+38     	; 0xf4c <get_fat+0xfe>
{
	BYTE   buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
		return 1;
     f26:	61 e0       	ldi	r22, 0x01	; 1
     f28:	70 e0       	ldi	r23, 0x00	; 0
     f2a:	80 e0       	ldi	r24, 0x00	; 0
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	0e c0       	rjmp	.+28     	; 0xf4c <get_fat+0xfe>
     f30:	61 e0       	ldi	r22, 0x01	; 1
     f32:	70 e0       	ldi	r23, 0x00	; 0
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	09 c0       	rjmp	.+18     	; 0xf4c <get_fat+0xfe>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1; /* An error occured at the disk I/O layer */
     f3a:	61 e0       	ldi	r22, 0x01	; 1
     f3c:	70 e0       	ldi	r23, 0x00	; 0
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	04 c0       	rjmp	.+8      	; 0xf4c <get_fat+0xfe>
     f44:	61 e0       	ldi	r22, 0x01	; 1
     f46:	70 e0       	ldi	r23, 0x00	; 0
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
}
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	0f 90       	pop	r0
     f52:	0f 90       	pop	r0
     f54:	df 91       	pop	r29
     f56:	cf 91       	pop	r28
     f58:	1f 91       	pop	r17
     f5a:	0f 91       	pop	r16
     f5c:	ff 90       	pop	r15
     f5e:	ef 90       	pop	r14
     f60:	df 90       	pop	r13
     f62:	cf 90       	pop	r12
     f64:	08 95       	ret

00000f66 <dir_next>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_next(        /* FR_OK:Succeeded, FR_NO_FILE:End of table */
                        DIR *dj /* Pointer to directory object */
)
{
     f66:	cf 92       	push	r12
     f68:	df 92       	push	r13
     f6a:	ef 92       	push	r14
     f6c:	ff 92       	push	r15
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
	CLUST  clst;
	WORD   i;
	FATFS *fs = FatFs;
     f76:	e0 90 cd 05 	lds	r14, 0x05CD	; 0x8005cd <FatFs>
     f7a:	f0 90 ce 05 	lds	r15, 0x05CE	; 0x8005ce <FatFs+0x1>

	i = dj->index + 1;
     f7e:	fc 01       	movw	r30, r24
     f80:	c0 81       	ld	r28, Z
     f82:	d1 81       	ldd	r29, Z+1	; 0x01
     f84:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
     f86:	09 f4       	brne	.+2      	; 0xf8a <dir_next+0x24>
     f88:	5c c0       	rjmp	.+184    	; 0x1042 <dir_next+0xdc>
     f8a:	44 85       	ldd	r20, Z+12	; 0x0c
     f8c:	55 85       	ldd	r21, Z+13	; 0x0d
     f8e:	66 85       	ldd	r22, Z+14	; 0x0e
     f90:	77 85       	ldd	r23, Z+15	; 0x0f
     f92:	41 15       	cp	r20, r1
     f94:	51 05       	cpc	r21, r1
     f96:	61 05       	cpc	r22, r1
     f98:	71 05       	cpc	r23, r1
     f9a:	09 f4       	brne	.+2      	; 0xf9e <dir_next+0x38>
     f9c:	54 c0       	rjmp	.+168    	; 0x1046 <dir_next+0xe0>
     f9e:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i % 16)) { /* Sector changed? */
     fa0:	ce 01       	movw	r24, r28
     fa2:	8f 70       	andi	r24, 0x0F	; 15
     fa4:	99 27       	eor	r25, r25
     fa6:	89 2b       	or	r24, r25
     fa8:	09 f0       	breq	.+2      	; 0xfac <dir_next+0x46>
     faa:	46 c0       	rjmp	.+140    	; 0x1038 <dir_next+0xd2>
		dj->sect++;  /* Next sector */
     fac:	4f 5f       	subi	r20, 0xFF	; 255
     fae:	5f 4f       	sbci	r21, 0xFF	; 255
     fb0:	6f 4f       	sbci	r22, 0xFF	; 255
     fb2:	7f 4f       	sbci	r23, 0xFF	; 255
     fb4:	44 87       	std	Z+12, r20	; 0x0c
     fb6:	55 87       	std	Z+13, r21	; 0x0d
     fb8:	66 87       	std	Z+14, r22	; 0x0e
     fba:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {       /* Static table */
     fbc:	40 85       	ldd	r20, Z+8	; 0x08
     fbe:	51 85       	ldd	r21, Z+9	; 0x09
     fc0:	62 85       	ldd	r22, Z+10	; 0x0a
     fc2:	73 85       	ldd	r23, Z+11	; 0x0b
     fc4:	41 15       	cp	r20, r1
     fc6:	51 05       	cpc	r21, r1
     fc8:	61 05       	cpc	r22, r1
     fca:	71 05       	cpc	r23, r1
     fcc:	39 f4       	brne	.+14     	; 0xfdc <dir_next+0x76>
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
     fce:	f7 01       	movw	r30, r14
     fd0:	84 81       	ldd	r24, Z+4	; 0x04
     fd2:	95 81       	ldd	r25, Z+5	; 0x05
     fd4:	c8 17       	cp	r28, r24
     fd6:	d9 07       	cpc	r29, r25
     fd8:	c0 f5       	brcc	.+112    	; 0x104a <dir_next+0xe4>
     fda:	2e c0       	rjmp	.+92     	; 0x1038 <dir_next+0xd2>
				return FR_NO_FILE;
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
     fdc:	f7 01       	movw	r30, r14
     fde:	82 81       	ldd	r24, Z+2	; 0x02
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	01 97       	sbiw	r24, 0x01	; 1
     fe4:	9e 01       	movw	r18, r28
     fe6:	32 95       	swap	r19
     fe8:	22 95       	swap	r18
     fea:	2f 70       	andi	r18, 0x0F	; 15
     fec:	23 27       	eor	r18, r19
     fee:	3f 70       	andi	r19, 0x0F	; 15
     ff0:	23 27       	eor	r18, r19
     ff2:	82 23       	and	r24, r18
     ff4:	93 23       	and	r25, r19
     ff6:	89 2b       	or	r24, r25
     ff8:	f9 f4       	brne	.+62     	; 0x1038 <dir_next+0xd2>
				clst = get_fat(dj->clust);           /* Get next cluster */
     ffa:	cb 01       	movw	r24, r22
     ffc:	ba 01       	movw	r22, r20
     ffe:	0e 94 27 07 	call	0xe4e	; 0xe4e <get_fat>
				if (clst <= 1)
    1002:	62 30       	cpi	r22, 0x02	; 2
    1004:	71 05       	cpc	r23, r1
    1006:	81 05       	cpc	r24, r1
    1008:	91 05       	cpc	r25, r1
    100a:	08 f1       	brcs	.+66     	; 0x104e <dir_next+0xe8>
					return FR_DISK_ERR;
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
    100c:	f7 01       	movw	r30, r14
    100e:	c6 80       	ldd	r12, Z+6	; 0x06
    1010:	d7 80       	ldd	r13, Z+7	; 0x07
    1012:	e0 84       	ldd	r14, Z+8	; 0x08
    1014:	f1 84       	ldd	r15, Z+9	; 0x09
    1016:	6c 15       	cp	r22, r12
    1018:	7d 05       	cpc	r23, r13
    101a:	8e 05       	cpc	r24, r14
    101c:	9f 05       	cpc	r25, r15
    101e:	c8 f4       	brcc	.+50     	; 0x1052 <dir_next+0xec>
					return FR_NO_FILE;    /* Report EOT */
				dj->clust = clst;         /* Initialize data for new cluster */
    1020:	f8 01       	movw	r30, r16
    1022:	60 87       	std	Z+8, r22	; 0x08
    1024:	71 87       	std	Z+9, r23	; 0x09
    1026:	82 87       	std	Z+10, r24	; 0x0a
    1028:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect  = clust2sect(clst);
    102a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <clust2sect>
    102e:	f8 01       	movw	r30, r16
    1030:	64 87       	std	Z+12, r22	; 0x0c
    1032:	75 87       	std	Z+13, r23	; 0x0d
    1034:	86 87       	std	Z+14, r24	; 0x0e
    1036:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
    1038:	f8 01       	movw	r30, r16
    103a:	d1 83       	std	Z+1, r29	; 0x01
    103c:	c0 83       	st	Z, r28

	return FR_OK;
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	09 c0       	rjmp	.+18     	; 0x1054 <dir_next+0xee>
	WORD   i;
	FATFS *fs = FatFs;

	i = dj->index + 1;
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    1042:	83 e0       	ldi	r24, 0x03	; 3
    1044:	07 c0       	rjmp	.+14     	; 0x1054 <dir_next+0xee>
    1046:	83 e0       	ldi	r24, 0x03	; 3
    1048:	05 c0       	rjmp	.+10     	; 0x1054 <dir_next+0xee>
	if (!(i % 16)) { /* Sector changed? */
		dj->sect++;  /* Next sector */

		if (dj->clust == 0) {       /* Static table */
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
				return FR_NO_FILE;
    104a:	83 e0       	ldi	r24, 0x03	; 3
    104c:	03 c0       	rjmp	.+6      	; 0x1054 <dir_next+0xee>
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
				clst = get_fat(dj->clust);           /* Get next cluster */
				if (clst <= 1)
					return FR_DISK_ERR;
    104e:	81 e0       	ldi	r24, 0x01	; 1
    1050:	01 c0       	rjmp	.+2      	; 0x1054 <dir_next+0xee>
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
					return FR_NO_FILE;    /* Report EOT */
    1052:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	1f 91       	pop	r17
    105a:	0f 91       	pop	r16
    105c:	ff 90       	pop	r15
    105e:	ef 90       	pop	r14
    1060:	df 90       	pop	r13
    1062:	cf 90       	pop	r12
    1064:	08 95       	ret

00001066 <dir_find>:
/*-----------------------------------------------------------------------*/

	static FRESULT dir_find(DIR * dj, /* Pointer to the directory object linked to the file name */
							BYTE *dir /* 32-byte working buffer */
	)
	{
    1066:	cf 92       	push	r12
    1068:	df 92       	push	r13
    106a:	ff 92       	push	r15
    106c:	0f 93       	push	r16
    106e:	1f 93       	push	r17
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	ec 01       	movw	r28, r24
    1076:	6b 01       	movw	r12, r22
		FRESULT res;
		BYTE    c;

		res = dir_rewind(dj); /* Rewind directory object */
    1078:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <dir_rewind>
		if (res != FR_OK)
    107c:	81 11       	cpse	r24, r1
    107e:	37 c0       	rjmp	.+110    	; 0x10ee <dir_find+0x88>
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    1080:	28 81       	ld	r18, Y
    1082:	39 81       	ldd	r19, Y+1	; 0x01
    1084:	2f 70       	andi	r18, 0x0F	; 15
    1086:	33 27       	eor	r19, r19
    1088:	22 0f       	add	r18, r18
    108a:	33 1f       	adc	r19, r19
    108c:	22 95       	swap	r18
    108e:	32 95       	swap	r19
    1090:	30 7f       	andi	r19, 0xF0	; 240
    1092:	32 27       	eor	r19, r18
    1094:	20 7f       	andi	r18, 0xF0	; 240
    1096:	32 27       	eor	r19, r18
    1098:	4c 85       	ldd	r20, Y+12	; 0x0c
    109a:	5d 85       	ldd	r21, Y+13	; 0x0d
    109c:	6e 85       	ldd	r22, Y+14	; 0x0e
    109e:	7f 85       	ldd	r23, Y+15	; 0x0f
    10a0:	00 e2       	ldi	r16, 0x20	; 32
    10a2:	10 e0       	ldi	r17, 0x00	; 0
    10a4:	c6 01       	movw	r24, r12
    10a6:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
					  ? FR_DISK_ERR
					  : FR_OK;
    10aa:	91 e0       	ldi	r25, 0x01	; 1
    10ac:	81 11       	cpse	r24, r1
    10ae:	01 c0       	rjmp	.+2      	; 0x10b2 <dir_find+0x4c>
    10b0:	90 e0       	ldi	r25, 0x00	; 0
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10b2:	f9 2e       	mov	r15, r25
					  ? FR_DISK_ERR
					  : FR_OK;
			if (res != FR_OK)
    10b4:	91 11       	cpse	r25, r1
    10b6:	16 c0       	rjmp	.+44     	; 0x10e4 <dir_find+0x7e>
				break;
			c = dir[DIR_Name]; /* First character */
    10b8:	f6 01       	movw	r30, r12
    10ba:	80 81       	ld	r24, Z
			if (c == 0) { ///// hieerrr fout misschien
    10bc:	88 23       	and	r24, r24
    10be:	a1 f0       	breq	.+40     	; 0x10e8 <dir_find+0x82>
				res = FR_NO_FILE;
				break;
			}                                                           /* Reached to end of table */
			if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    10c0:	83 85       	ldd	r24, Z+11	; 0x0b
    10c2:	83 fd       	sbrc	r24, 3
    10c4:	09 c0       	rjmp	.+18     	; 0x10d8 <dir_find+0x72>
    10c6:	6a 81       	ldd	r22, Y+2	; 0x02
    10c8:	7b 81       	ldd	r23, Y+3	; 0x03
    10ca:	4b e0       	ldi	r20, 0x0B	; 11
    10cc:	50 e0       	ldi	r21, 0x00	; 0
    10ce:	c6 01       	movw	r24, r12
    10d0:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <mem_cmp>
    10d4:	89 2b       	or	r24, r25
    10d6:	51 f0       	breq	.+20     	; 0x10ec <dir_find+0x86>
				break;
			res = dir_next(dj); /* Next entry */
    10d8:	ce 01       	movw	r24, r28
    10da:	0e 94 b3 07 	call	0xf66	; 0xf66 <dir_next>
		} while (res == FR_OK);
    10de:	88 23       	and	r24, r24
    10e0:	79 f2       	breq	.-98     	; 0x1080 <dir_find+0x1a>
    10e2:	05 c0       	rjmp	.+10     	; 0x10ee <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10e4:	89 2f       	mov	r24, r25
    10e6:	03 c0       	rjmp	.+6      	; 0x10ee <dir_find+0x88>
					  : FR_OK;
			if (res != FR_OK)
				break;
			c = dir[DIR_Name]; /* First character */
			if (c == 0) { ///// hieerrr fout misschien
				res = FR_NO_FILE;
    10e8:	83 e0       	ldi	r24, 0x03	; 3
    10ea:	01 c0       	rjmp	.+2      	; 0x10ee <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10ec:	8f 2d       	mov	r24, r15
				break;
			res = dir_next(dj); /* Next entry */
		} while (res == FR_OK);

		return res;
	}
    10ee:	df 91       	pop	r29
    10f0:	cf 91       	pop	r28
    10f2:	1f 91       	pop	r17
    10f4:	0f 91       	pop	r16
    10f6:	ff 90       	pop	r15
    10f8:	df 90       	pop	r13
    10fa:	cf 90       	pop	r12
    10fc:	08 95       	ret

000010fe <follow_path>:
static FRESULT follow_path(                 /* FR_OK(0): successful, !=0: error code */
                           DIR *       dj,  /* Directory object to return last directory and found object */
                           BYTE *      dir, /* 32-byte working buffer */
                           const char *path /* Full-path string to find a file or directory */
)
{
    10fe:	ef 92       	push	r14
    1100:	ff 92       	push	r15
    1102:	0f 93       	push	r16
    1104:	1f 93       	push	r17
    1106:	cf 93       	push	r28
    1108:	df 93       	push	r29
    110a:	00 d0       	rcall	.+0      	; 0x110c <follow_path+0xe>
    110c:	cd b7       	in	r28, 0x3d	; 61
    110e:	de b7       	in	r29, 0x3e	; 62
    1110:	8c 01       	movw	r16, r24
    1112:	7b 01       	movw	r14, r22
    1114:	5a 83       	std	Y+2, r21	; 0x02
    1116:	49 83       	std	Y+1, r20	; 0x01
	FRESULT res;

	while (*path == ' ')
    1118:	03 c0       	rjmp	.+6      	; 0x1120 <follow_path+0x22>
		path++; /* Strip leading spaces */
    111a:	31 96       	adiw	r30, 0x01	; 1
    111c:	fa 83       	std	Y+2, r31	; 0x02
    111e:	e9 83       	std	Y+1, r30	; 0x01
                           const char *path /* Full-path string to find a file or directory */
)
{
	FRESULT res;

	while (*path == ' ')
    1120:	e9 81       	ldd	r30, Y+1	; 0x01
    1122:	fa 81       	ldd	r31, Y+2	; 0x02
    1124:	80 81       	ld	r24, Z
    1126:	80 32       	cpi	r24, 0x20	; 32
    1128:	c1 f3       	breq	.-16     	; 0x111a <follow_path+0x1c>
		path++; /* Strip leading spaces */
	if (*path == '/')
    112a:	8f 32       	cpi	r24, 0x2F	; 47
    112c:	19 f4       	brne	.+6      	; 0x1134 <follow_path+0x36>
		path++;     /* Strip heading separator if exist */
    112e:	31 96       	adiw	r30, 0x01	; 1
    1130:	fa 83       	std	Y+2, r31	; 0x02
    1132:	e9 83       	std	Y+1, r30	; 0x01
	dj->sclust = 0; /* Set start directory (always root dir) */
    1134:	d8 01       	movw	r26, r16
    1136:	14 96       	adiw	r26, 0x04	; 4
    1138:	1d 92       	st	X+, r1
    113a:	1d 92       	st	X+, r1
    113c:	1d 92       	st	X+, r1
    113e:	1c 92       	st	X, r1
    1140:	17 97       	sbiw	r26, 0x07	; 7

	if ((BYTE)*path < ' ') { /* Null path means the root directory */
    1142:	e9 81       	ldd	r30, Y+1	; 0x01
    1144:	fa 81       	ldd	r31, Y+2	; 0x02
    1146:	80 81       	ld	r24, Z
    1148:	80 32       	cpi	r24, 0x20	; 32
    114a:	30 f4       	brcc	.+12     	; 0x1158 <follow_path+0x5a>
		res    = dir_rewind(dj);
    114c:	c8 01       	movw	r24, r16
    114e:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <dir_rewind>
		dir[0] = 0;
    1152:	f7 01       	movw	r30, r14
    1154:	10 82       	st	Z, r1
    1156:	26 c0       	rjmp	.+76     	; 0x11a4 <follow_path+0xa6>

	} else { /* Follow path */
		for (;;) {
			res = create_name(dj, &path); /* Get a segment */
    1158:	be 01       	movw	r22, r28
    115a:	6f 5f       	subi	r22, 0xFF	; 255
    115c:	7f 4f       	sbci	r23, 0xFF	; 255
    115e:	c8 01       	movw	r24, r16
    1160:	0e 94 9b 06 	call	0xd36	; 0xd36 <create_name>
			if (res != FR_OK)
    1164:	81 11       	cpse	r24, r1
    1166:	1e c0       	rjmp	.+60     	; 0x11a4 <follow_path+0xa6>
				break;
			res = dir_find(dj, dir); /* Find it */ // het gaat denk ik hier fout
    1168:	b7 01       	movw	r22, r14
    116a:	c8 01       	movw	r24, r16
    116c:	0e 94 33 08 	call	0x1066	; 0x1066 <dir_find>
			if (res != FR_OK)
    1170:	81 11       	cpse	r24, r1
    1172:	18 c0       	rjmp	.+48     	; 0x11a4 <follow_path+0xa6>
				break; /* Could not find the object */
			if (dj->fn[11])
    1174:	d8 01       	movw	r26, r16
    1176:	12 96       	adiw	r26, 0x02	; 2
    1178:	ed 91       	ld	r30, X+
    117a:	fc 91       	ld	r31, X
    117c:	13 97       	sbiw	r26, 0x03	; 3
    117e:	93 85       	ldd	r25, Z+11	; 0x0b
    1180:	91 11       	cpse	r25, r1
    1182:	10 c0       	rjmp	.+32     	; 0x11a4 <follow_path+0xa6>
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
    1184:	f7 01       	movw	r30, r14
    1186:	83 85       	ldd	r24, Z+11	; 0x0b
    1188:	84 ff       	sbrs	r24, 4
    118a:	0b c0       	rjmp	.+22     	; 0x11a2 <follow_path+0xa4>
				res = FR_NO_FILE;
				break;
			}
			dj->sclust = get_clust(dir); /* Follow next */
    118c:	c7 01       	movw	r24, r14
    118e:	0e 94 3a 06 	call	0xc74	; 0xc74 <get_clust>
    1192:	d8 01       	movw	r26, r16
    1194:	14 96       	adiw	r26, 0x04	; 4
    1196:	6d 93       	st	X+, r22
    1198:	7d 93       	st	X+, r23
    119a:	8d 93       	st	X+, r24
    119c:	9c 93       	st	X, r25
    119e:	17 97       	sbiw	r26, 0x07	; 7
		}
    11a0:	db cf       	rjmp	.-74     	; 0x1158 <follow_path+0x5a>
			if (res != FR_OK)
				break; /* Could not find the object */
			if (dj->fn[11])
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE;
    11a2:	83 e0       	ldi	r24, 0x03	; 3
			dj->sclust = get_clust(dir); /* Follow next */
		}
	}

	return res;
}
    11a4:	0f 90       	pop	r0
    11a6:	0f 90       	pop	r0
    11a8:	df 91       	pop	r29
    11aa:	cf 91       	pop	r28
    11ac:	1f 91       	pop	r17
    11ae:	0f 91       	pop	r16
    11b0:	ff 90       	pop	r15
    11b2:	ef 90       	pop	r14
    11b4:	08 95       	ret

000011b6 <pf_mount>:
/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount(FATFS *fs /* Pointer to new file system object */)
{
    11b6:	4f 92       	push	r4
    11b8:	5f 92       	push	r5
    11ba:	6f 92       	push	r6
    11bc:	7f 92       	push	r7
    11be:	8f 92       	push	r8
    11c0:	9f 92       	push	r9
    11c2:	af 92       	push	r10
    11c4:	bf 92       	push	r11
    11c6:	df 92       	push	r13
    11c8:	ef 92       	push	r14
    11ca:	ff 92       	push	r15
    11cc:	0f 93       	push	r16
    11ce:	1f 93       	push	r17
    11d0:	cf 93       	push	r28
    11d2:	df 93       	push	r29
    11d4:	cd b7       	in	r28, 0x3d	; 61
    11d6:	de b7       	in	r29, 0x3e	; 62
    11d8:	a8 97       	sbiw	r28, 0x28	; 40
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	f8 94       	cli
    11de:	de bf       	out	0x3e, r29	; 62
    11e0:	0f be       	out	0x3f, r0	; 63
    11e2:	cd bf       	out	0x3d, r28	; 61
    11e4:	7c 01       	movw	r14, r24
	BYTE  fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;

	FatFs = 0;
    11e6:	10 92 ce 05 	sts	0x05CE, r1	; 0x8005ce <FatFs+0x1>
    11ea:	10 92 cd 05 	sts	0x05CD, r1	; 0x8005cd <FatFs>

	if (disk_initialize() & STA_NOINIT)
    11ee:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
    11f2:	80 fd       	sbrc	r24, 0
    11f4:	62 c1       	rjmp	.+708    	; 0x14ba <pf_mount+0x304>
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
    11f6:	40 e0       	ldi	r20, 0x00	; 0
    11f8:	50 e0       	ldi	r21, 0x00	; 0
    11fa:	ba 01       	movw	r22, r20
    11fc:	ce 01       	movw	r24, r28
    11fe:	01 96       	adiw	r24, 0x01	; 1
    1200:	0e 94 e7 06 	call	0xdce	; 0xdce <check_fs>
    1204:	d8 2e       	mov	r13, r24
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
    1206:	21 e0       	ldi	r18, 0x01	; 1
    1208:	82 13       	cpse	r24, r18
    120a:	38 c0       	rjmp	.+112    	; 0x127c <pf_mount+0xc6>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
    120c:	00 e1       	ldi	r16, 0x10	; 16
    120e:	10 e0       	ldi	r17, 0x00	; 0
    1210:	2e eb       	ldi	r18, 0xBE	; 190
    1212:	31 e0       	ldi	r19, 0x01	; 1
    1214:	40 e0       	ldi	r20, 0x00	; 0
    1216:	50 e0       	ldi	r21, 0x00	; 0
    1218:	ba 01       	movw	r22, r20
    121a:	ce 01       	movw	r24, r28
    121c:	01 96       	adiw	r24, 0x01	; 1
    121e:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    1222:	81 11       	cpse	r24, r1
    1224:	2f c0       	rjmp	.+94     	; 0x1284 <pf_mount+0xce>
			fmt = 3;
		} else {
			if (buf[4]) {                     /* Is the partition existing? */
    1226:	8d 81       	ldd	r24, Y+5	; 0x05
    1228:	88 23       	and	r24, r24
    122a:	a1 f1       	breq	.+104    	; 0x1294 <pf_mount+0xde>
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
    122c:	8c 84       	ldd	r8, Y+12	; 0x0c
    122e:	91 2c       	mov	r9, r1
    1230:	a1 2c       	mov	r10, r1
    1232:	b1 2c       	mov	r11, r1
    1234:	b8 2c       	mov	r11, r8
    1236:	aa 24       	eor	r10, r10
    1238:	99 24       	eor	r9, r9
    123a:	88 24       	eor	r8, r8
    123c:	9b 85       	ldd	r25, Y+11	; 0x0b
    123e:	89 2f       	mov	r24, r25
    1240:	90 e0       	ldi	r25, 0x00	; 0
    1242:	a0 e0       	ldi	r26, 0x00	; 0
    1244:	b0 e0       	ldi	r27, 0x00	; 0
    1246:	dc 01       	movw	r26, r24
    1248:	99 27       	eor	r25, r25
    124a:	88 27       	eor	r24, r24
    124c:	88 29       	or	r24, r8
    124e:	99 29       	or	r25, r9
    1250:	aa 29       	or	r26, r10
    1252:	bb 29       	or	r27, r11
    1254:	8a 84       	ldd	r8, Y+10	; 0x0a
    1256:	91 2c       	mov	r9, r1
    1258:	98 2c       	mov	r9, r8
    125a:	88 24       	eor	r8, r8
    125c:	a1 2c       	mov	r10, r1
    125e:	b1 2c       	mov	r11, r1
    1260:	88 2a       	or	r8, r24
    1262:	99 2a       	or	r9, r25
    1264:	aa 2a       	or	r10, r26
    1266:	bb 2a       	or	r11, r27
    1268:	89 85       	ldd	r24, Y+9	; 0x09
    126a:	88 2a       	or	r8, r24
				fmt   = check_fs(buf, bsect); /* Check the partition */
    126c:	b5 01       	movw	r22, r10
    126e:	a4 01       	movw	r20, r8
    1270:	ce 01       	movw	r24, r28
    1272:	01 96       	adiw	r24, 0x01	; 1
    1274:	0e 94 e7 06 	call	0xdce	; 0xdce <check_fs>
    1278:	d8 2e       	mov	r13, r24
    127a:	0f c0       	rjmp	.+30     	; 0x129a <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    127c:	81 2c       	mov	r8, r1
    127e:	91 2c       	mov	r9, r1
    1280:	54 01       	movw	r10, r8
    1282:	0b c0       	rjmp	.+22     	; 0x129a <pf_mount+0xe4>
    1284:	81 2c       	mov	r8, r1
    1286:	91 2c       	mov	r9, r1
    1288:	54 01       	movw	r10, r8
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
			fmt = 3;
    128a:	0f 2e       	mov	r0, r31
    128c:	f3 e0       	ldi	r31, 0x03	; 3
    128e:	df 2e       	mov	r13, r31
    1290:	f0 2d       	mov	r31, r0
    1292:	03 c0       	rjmp	.+6      	; 0x129a <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1294:	81 2c       	mov	r8, r1
    1296:	91 2c       	mov	r9, r1
    1298:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
    129a:	43 e0       	ldi	r20, 0x03	; 3
    129c:	d4 16       	cp	r13, r20
    129e:	09 f4       	brne	.+2      	; 0x12a2 <pf_mount+0xec>
    12a0:	0e c1       	rjmp	.+540    	; 0x14be <pf_mount+0x308>
		return FR_DISK_ERR;
	if (fmt)
    12a2:	d1 10       	cpse	r13, r1
    12a4:	0e c1       	rjmp	.+540    	; 0x14c2 <pf_mount+0x30c>
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
    12a6:	04 e2       	ldi	r16, 0x24	; 36
    12a8:	10 e0       	ldi	r17, 0x00	; 0
    12aa:	2d e0       	ldi	r18, 0x0D	; 13
    12ac:	30 e0       	ldi	r19, 0x00	; 0
    12ae:	b5 01       	movw	r22, r10
    12b0:	a4 01       	movw	r20, r8
    12b2:	ce 01       	movw	r24, r28
    12b4:	01 96       	adiw	r24, 0x01	; 1
    12b6:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    12ba:	81 11       	cpse	r24, r1
    12bc:	04 c1       	rjmp	.+520    	; 0x14c6 <pf_mount+0x310>
		return FR_DISK_ERR;

	fsize = LD_WORD(buf + BPB_FATSz16 - 13); /* Number of sectors per FAT */
    12be:	2b 85       	ldd	r18, Y+11	; 0x0b
    12c0:	30 e0       	ldi	r19, 0x00	; 0
    12c2:	32 2f       	mov	r19, r18
    12c4:	22 27       	eor	r18, r18
    12c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    12c8:	28 2b       	or	r18, r24
    12ca:	40 e0       	ldi	r20, 0x00	; 0
    12cc:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize)
    12ce:	21 15       	cp	r18, r1
    12d0:	31 05       	cpc	r19, r1
    12d2:	41 05       	cpc	r20, r1
    12d4:	51 05       	cpc	r21, r1
    12d6:	21 f5       	brne	.+72     	; 0x1320 <pf_mount+0x16a>
		fsize = LD_DWORD(buf + BPB_FATSz32 - 13);
    12d8:	2b 8d       	ldd	r18, Y+27	; 0x1b
    12da:	82 2f       	mov	r24, r18
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	a0 e0       	ldi	r26, 0x00	; 0
    12e0:	b0 e0       	ldi	r27, 0x00	; 0
    12e2:	78 2f       	mov	r23, r24
    12e4:	66 27       	eor	r22, r22
    12e6:	55 27       	eor	r21, r21
    12e8:	44 27       	eor	r20, r20
    12ea:	9a 8d       	ldd	r25, Y+26	; 0x1a
    12ec:	89 2f       	mov	r24, r25
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	a0 e0       	ldi	r26, 0x00	; 0
    12f2:	b0 e0       	ldi	r27, 0x00	; 0
    12f4:	dc 01       	movw	r26, r24
    12f6:	99 27       	eor	r25, r25
    12f8:	88 27       	eor	r24, r24
    12fa:	84 2b       	or	r24, r20
    12fc:	95 2b       	or	r25, r21
    12fe:	a6 2b       	or	r26, r22
    1300:	b7 2b       	or	r27, r23
    1302:	29 8d       	ldd	r18, Y+25	; 0x19
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	32 2f       	mov	r19, r18
    1308:	22 27       	eor	r18, r18
    130a:	a9 01       	movw	r20, r18
    130c:	60 e0       	ldi	r22, 0x00	; 0
    130e:	70 e0       	ldi	r23, 0x00	; 0
    1310:	48 2b       	or	r20, r24
    1312:	59 2b       	or	r21, r25
    1314:	6a 2b       	or	r22, r26
    1316:	7b 2b       	or	r23, r27
    1318:	88 8d       	ldd	r24, Y+24	; 0x18
    131a:	9a 01       	movw	r18, r20
    131c:	ab 01       	movw	r20, r22
    131e:	28 2b       	or	r18, r24

	fsize *= buf[BPB_NumFATs - 13];                             /* Number of sectors in FAT area */
    1320:	ac 81       	ldd	r26, Y+4	; 0x04
    1322:	b0 e0       	ldi	r27, 0x00	; 0
    1324:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <__muluhisi3>
    1328:	6d a3       	std	Y+37, r22	; 0x25
    132a:	7e a3       	std	Y+38, r23	; 0x26
    132c:	8f a3       	std	Y+39, r24	; 0x27
    132e:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase   = bsect + LD_WORD(buf + BPB_RsvdSecCnt - 13); /* FAT start sector (lba) */
    1330:	8b 81       	ldd	r24, Y+3	; 0x03
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	98 2f       	mov	r25, r24
    1336:	88 27       	eor	r24, r24
    1338:	4a 81       	ldd	r20, Y+2	; 0x02
    133a:	50 e0       	ldi	r21, 0x00	; 0
    133c:	84 2b       	or	r24, r20
    133e:	95 2b       	or	r25, r21
    1340:	88 0e       	add	r8, r24
    1342:	99 1e       	adc	r9, r25
    1344:	a1 1c       	adc	r10, r1
    1346:	b1 1c       	adc	r11, r1
    1348:	d7 01       	movw	r26, r14
    134a:	1a 96       	adiw	r26, 0x0a	; 10
    134c:	8d 92       	st	X+, r8
    134e:	9d 92       	st	X+, r9
    1350:	ad 92       	st	X+, r10
    1352:	bc 92       	st	X, r11
    1354:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
    1356:	a9 81       	ldd	r26, Y+1	; 0x01
    1358:	f7 01       	movw	r30, r14
    135a:	a2 83       	std	Z+2, r26	; 0x02
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
    135c:	8e 81       	ldd	r24, Y+6	; 0x06
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	98 2f       	mov	r25, r24
    1362:	88 27       	eor	r24, r24
    1364:	2d 81       	ldd	r18, Y+5	; 0x05
    1366:	82 2b       	or	r24, r18
    1368:	95 83       	std	Z+5, r25	; 0x05
    136a:	84 83       	std	Z+4, r24	; 0x04
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
    136c:	08 85       	ldd	r16, Y+8	; 0x08
    136e:	10 e0       	ldi	r17, 0x00	; 0
    1370:	10 2f       	mov	r17, r16
    1372:	00 27       	eor	r16, r16
    1374:	2f 81       	ldd	r18, Y+7	; 0x07
    1376:	02 2b       	or	r16, r18
    1378:	20 e0       	ldi	r18, 0x00	; 0
    137a:	30 e0       	ldi	r19, 0x00	; 0
	if (!tsect)
    137c:	01 15       	cp	r16, r1
    137e:	11 05       	cpc	r17, r1
    1380:	21 05       	cpc	r18, r1
    1382:	31 05       	cpc	r19, r1
    1384:	01 f5       	brne	.+64     	; 0x13c6 <pf_mount+0x210>
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
    1386:	0f 89       	ldd	r16, Y+23	; 0x17
    1388:	10 e0       	ldi	r17, 0x00	; 0
    138a:	20 e0       	ldi	r18, 0x00	; 0
    138c:	30 e0       	ldi	r19, 0x00	; 0
    138e:	70 2e       	mov	r7, r16
    1390:	66 24       	eor	r6, r6
    1392:	55 24       	eor	r5, r5
    1394:	44 24       	eor	r4, r4
    1396:	0e 89       	ldd	r16, Y+22	; 0x16
    1398:	10 e0       	ldi	r17, 0x00	; 0
    139a:	20 e0       	ldi	r18, 0x00	; 0
    139c:	30 e0       	ldi	r19, 0x00	; 0
    139e:	98 01       	movw	r18, r16
    13a0:	11 27       	eor	r17, r17
    13a2:	00 27       	eor	r16, r16
    13a4:	40 2a       	or	r4, r16
    13a6:	51 2a       	or	r5, r17
    13a8:	62 2a       	or	r6, r18
    13aa:	73 2a       	or	r7, r19
    13ac:	2d 89       	ldd	r18, Y+21	; 0x15
    13ae:	30 e0       	ldi	r19, 0x00	; 0
    13b0:	32 2f       	mov	r19, r18
    13b2:	22 27       	eor	r18, r18
    13b4:	89 01       	movw	r16, r18
    13b6:	20 e0       	ldi	r18, 0x00	; 0
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	04 29       	or	r16, r4
    13bc:	15 29       	or	r17, r5
    13be:	26 29       	or	r18, r6
    13c0:	37 29       	or	r19, r7
    13c2:	6c 89       	ldd	r22, Y+20	; 0x14
    13c4:	06 2b       	or	r16, r22
	mclst = (tsect /* Last cluster# + 1 */
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
    13c6:	eb 81       	ldd	r30, Y+3	; 0x03
    13c8:	f0 e0       	ldi	r31, 0x00	; 0
    13ca:	fe 2f       	mov	r31, r30
    13cc:	ee 27       	eor	r30, r30
    13ce:	4e 2b       	or	r20, r30
    13d0:	5f 2b       	or	r21, r31
    13d2:	04 1b       	sub	r16, r20
    13d4:	15 0b       	sbc	r17, r21
    13d6:	21 09       	sbc	r18, r1
    13d8:	31 09       	sbc	r19, r1
    13da:	4d a1       	ldd	r20, Y+37	; 0x25
    13dc:	5e a1       	ldd	r21, Y+38	; 0x26
    13de:	6f a1       	ldd	r22, Y+39	; 0x27
    13e0:	78 a5       	ldd	r23, Y+40	; 0x28
    13e2:	04 1b       	sub	r16, r20
    13e4:	15 0b       	sbc	r17, r21
    13e6:	26 0b       	sbc	r18, r22
    13e8:	37 0b       	sbc	r19, r23
    13ea:	92 95       	swap	r25
    13ec:	82 95       	swap	r24
    13ee:	8f 70       	andi	r24, 0x0F	; 15
    13f0:	89 27       	eor	r24, r25
    13f2:	9f 70       	andi	r25, 0x0F	; 15
    13f4:	89 27       	eor	r24, r25
    13f6:	2c 01       	movw	r4, r24
    13f8:	61 2c       	mov	r6, r1
    13fa:	71 2c       	mov	r7, r1
    13fc:	c9 01       	movw	r24, r18
    13fe:	b8 01       	movw	r22, r16
    1400:	64 19       	sub	r22, r4
    1402:	75 09       	sbc	r23, r5
    1404:	86 09       	sbc	r24, r6
    1406:	97 09       	sbc	r25, r7
	            / fs->csize
    1408:	2a 2f       	mov	r18, r26
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	40 e0       	ldi	r20, 0x00	; 0
    140e:	50 e0       	ldi	r21, 0x00	; 0
    1410:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <__udivmodsi4>
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
	if (!tsect)
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
	mclst = (tsect /* Last cluster# + 1 */
    1414:	da 01       	movw	r26, r20
    1416:	c9 01       	movw	r24, r18
    1418:	02 96       	adiw	r24, 0x02	; 2
    141a:	a1 1d       	adc	r26, r1
    141c:	b1 1d       	adc	r27, r1
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
	            / fs->csize
	        + 2;
	fs->n_fatent = (CLUST)mclst;
    141e:	f7 01       	movw	r30, r14
    1420:	86 83       	std	Z+6, r24	; 0x06
    1422:	97 83       	std	Z+7, r25	; 0x07
    1424:	a0 87       	std	Z+8, r26	; 0x08
    1426:	b1 87       	std	Z+9, r27	; 0x09
	fmt = 0; /* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    1428:	87 3f       	cpi	r24, 0xF7	; 247
    142a:	9f 4f       	sbci	r25, 0xFF	; 255
    142c:	a1 05       	cpc	r26, r1
    142e:	b1 05       	cpc	r27, r1
    1430:	20 f0       	brcs	.+8      	; 0x143a <pf_mount+0x284>
		fmt = FS_FAT32;
    1432:	0f 2e       	mov	r0, r31
    1434:	f3 e0       	ldi	r31, 0x03	; 3
    1436:	df 2e       	mov	r13, r31
    1438:	f0 2d       	mov	r31, r0
	if (!fmt)
    143a:	dd 20       	and	r13, r13
    143c:	09 f4       	brne	.+2      	; 0x1440 <pf_mount+0x28a>
    143e:	45 c0       	rjmp	.+138    	; 0x14ca <pf_mount+0x314>
		return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    1440:	d7 01       	movw	r26, r14
    1442:	dc 92       	st	X, r13

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf + (BPB_RootClus - 13)); /* Root directory start cluster */
    1444:	8b a1       	ldd	r24, Y+35	; 0x23
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	a0 e0       	ldi	r26, 0x00	; 0
    144a:	b0 e0       	ldi	r27, 0x00	; 0
    144c:	78 2f       	mov	r23, r24
    144e:	66 27       	eor	r22, r22
    1450:	55 27       	eor	r21, r21
    1452:	44 27       	eor	r20, r20
    1454:	8a a1       	ldd	r24, Y+34	; 0x22
    1456:	90 e0       	ldi	r25, 0x00	; 0
    1458:	a0 e0       	ldi	r26, 0x00	; 0
    145a:	b0 e0       	ldi	r27, 0x00	; 0
    145c:	dc 01       	movw	r26, r24
    145e:	99 27       	eor	r25, r25
    1460:	88 27       	eor	r24, r24
    1462:	84 2b       	or	r24, r20
    1464:	95 2b       	or	r25, r21
    1466:	a6 2b       	or	r26, r22
    1468:	b7 2b       	or	r27, r23
    146a:	49 a1       	ldd	r20, Y+33	; 0x21
    146c:	50 e0       	ldi	r21, 0x00	; 0
    146e:	54 2f       	mov	r21, r20
    1470:	44 27       	eor	r20, r20
    1472:	60 e0       	ldi	r22, 0x00	; 0
    1474:	70 e0       	ldi	r23, 0x00	; 0
    1476:	84 2b       	or	r24, r20
    1478:	95 2b       	or	r25, r21
    147a:	a6 2b       	or	r26, r22
    147c:	b7 2b       	or	r27, r23
    147e:	28 a1       	ldd	r18, Y+32	; 0x20
    1480:	82 2b       	or	r24, r18
    1482:	f7 01       	movw	r30, r14
    1484:	86 87       	std	Z+14, r24	; 0x0e
    1486:	97 87       	std	Z+15, r25	; 0x0f
    1488:	a0 8b       	std	Z+16, r26	; 0x10
    148a:	b1 8b       	std	Z+17, r27	; 0x11
	else
		fs->dirbase = fs->fatbase + fsize;                   /* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16; /* Data start sector (lba) */
    148c:	4d a1       	ldd	r20, Y+37	; 0x25
    148e:	5e a1       	ldd	r21, Y+38	; 0x26
    1490:	6f a1       	ldd	r22, Y+39	; 0x27
    1492:	78 a5       	ldd	r23, Y+40	; 0x28
    1494:	84 0e       	add	r8, r20
    1496:	95 1e       	adc	r9, r21
    1498:	a6 1e       	adc	r10, r22
    149a:	b7 1e       	adc	r11, r23
    149c:	84 0c       	add	r8, r4
    149e:	95 1c       	adc	r9, r5
    14a0:	a6 1c       	adc	r10, r6
    14a2:	b7 1c       	adc	r11, r7
    14a4:	82 8a       	std	Z+18, r8	; 0x12
    14a6:	93 8a       	std	Z+19, r9	; 0x13
    14a8:	a4 8a       	std	Z+20, r10	; 0x14
    14aa:	b5 8a       	std	Z+21, r11	; 0x15

	fs->flag = 0;
    14ac:	11 82       	std	Z+1, r1	; 0x01
	FatFs    = fs;
    14ae:	f0 92 ce 05 	sts	0x05CE, r15	; 0x8005ce <FatFs+0x1>
    14b2:	e0 92 cd 05 	sts	0x05CD, r14	; 0x8005cd <FatFs>

	return FR_OK;
    14b6:	80 e0       	ldi	r24, 0x00	; 0
    14b8:	09 c0       	rjmp	.+18     	; 0x14cc <pf_mount+0x316>
	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)
	{
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
    14ba:	82 e0       	ldi	r24, 0x02	; 2
    14bc:	07 c0       	rjmp	.+14     	; 0x14cc <pf_mount+0x316>
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
		return FR_DISK_ERR;
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	05 c0       	rjmp	.+10     	; 0x14cc <pf_mount+0x316>
	if (fmt)
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */
    14c2:	86 e0       	ldi	r24, 0x06	; 6
    14c4:	03 c0       	rjmp	.+6      	; 0x14cc <pf_mount+0x316>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
		return FR_DISK_ERR;
    14c6:	81 e0       	ldi	r24, 0x01	; 1
    14c8:	01 c0       	rjmp	.+2      	; 0x14cc <pf_mount+0x316>
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
		fmt = FS_FAT32;
	if (!fmt)
		return FR_NO_FILESYSTEM;
    14ca:	86 e0       	ldi	r24, 0x06	; 6

	fs->flag = 0;
	FatFs    = fs;

	return FR_OK;
}
    14cc:	a8 96       	adiw	r28, 0x28	; 40
    14ce:	0f b6       	in	r0, 0x3f	; 63
    14d0:	f8 94       	cli
    14d2:	de bf       	out	0x3e, r29	; 62
    14d4:	0f be       	out	0x3f, r0	; 63
    14d6:	cd bf       	out	0x3d, r28	; 61
    14d8:	df 91       	pop	r29
    14da:	cf 91       	pop	r28
    14dc:	1f 91       	pop	r17
    14de:	0f 91       	pop	r16
    14e0:	ff 90       	pop	r15
    14e2:	ef 90       	pop	r14
    14e4:	df 90       	pop	r13
    14e6:	bf 90       	pop	r11
    14e8:	af 90       	pop	r10
    14ea:	9f 90       	pop	r9
    14ec:	8f 90       	pop	r8
    14ee:	7f 90       	pop	r7
    14f0:	6f 90       	pop	r6
    14f2:	5f 90       	pop	r5
    14f4:	4f 90       	pop	r4
    14f6:	08 95       	ret

000014f8 <pf_open>:
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT pf_open(const char *path /* Pointer to the file name */
)
 {
    14f8:	0f 93       	push	r16
    14fa:	1f 93       	push	r17
    14fc:	cf 93       	push	r28
    14fe:	df 93       	push	r29
    1500:	cd b7       	in	r28, 0x3d	; 61
    1502:	de b7       	in	r29, 0x3e	; 62
    1504:	ec 97       	sbiw	r28, 0x3c	; 60
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	de bf       	out	0x3e, r29	; 62
    150c:	0f be       	out	0x3f, r0	; 63
    150e:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;
    1510:	00 91 cd 05 	lds	r16, 0x05CD	; 0x8005cd <FatFs>
    1514:	10 91 ce 05 	lds	r17, 0x05CE	; 0x8005ce <FatFs+0x1>

	if (!fs)
    1518:	01 15       	cp	r16, r1
    151a:	11 05       	cpc	r17, r1
    151c:	09 f4       	brne	.+2      	; 0x1520 <pf_open+0x28>
    151e:	4a c0       	rjmp	.+148    	; 0x15b4 <pf_open+0xbc>
    1520:	ac 01       	movw	r20, r24
		return FR_NOT_ENABLED; /* Check file system */

	fs->flag = 0;
    1522:	f8 01       	movw	r30, r16
    1524:	11 82       	std	Z+1, r1	; 0x01
	dj.fn    = sp;
    1526:	ce 01       	movw	r24, r28
    1528:	41 96       	adiw	r24, 0x11	; 17
    152a:	9c 83       	std	Y+4, r25	; 0x04
    152c:	8b 83       	std	Y+3, r24	; 0x03
	res      = follow_path(&dj, dir, path); /* Follow the file path */
    152e:	be 01       	movw	r22, r28
    1530:	63 5e       	subi	r22, 0xE3	; 227
    1532:	7f 4f       	sbci	r23, 0xFF	; 255
    1534:	40 97       	sbiw	r24, 0x10	; 16
    1536:	0e 94 7f 08 	call	0x10fe	; 0x10fe <follow_path>
	if (res != FR_OK)
    153a:	81 11       	cpse	r24, r1
    153c:	40 c0       	rjmp	.+128    	; 0x15be <pf_open+0xc6>
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
    153e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1540:	88 23       	and	r24, r24
    1542:	d1 f1       	breq	.+116    	; 0x15b8 <pf_open+0xc0>
    1544:	88 a5       	ldd	r24, Y+40	; 0x28
    1546:	84 fd       	sbrc	r24, 4
    1548:	39 c0       	rjmp	.+114    	; 0x15bc <pf_open+0xc4>
		return FR_NO_FILE;
	

	fs->org_clust = get_clust(dir);               /* File start cluster */
    154a:	ce 01       	movw	r24, r28
    154c:	4d 96       	adiw	r24, 0x1d	; 29
    154e:	0e 94 3a 06 	call	0xc74	; 0xc74 <get_clust>
    1552:	f8 01       	movw	r30, r16
    1554:	66 8f       	std	Z+30, r22	; 0x1e
    1556:	77 8f       	std	Z+31, r23	; 0x1f
    1558:	80 a3       	std	Z+32, r24	; 0x20
    155a:	91 a3       	std	Z+33, r25	; 0x21
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
    155c:	8c ad       	ldd	r24, Y+60	; 0x3c
    155e:	90 e0       	ldi	r25, 0x00	; 0
    1560:	a0 e0       	ldi	r26, 0x00	; 0
    1562:	b0 e0       	ldi	r27, 0x00	; 0
    1564:	78 2f       	mov	r23, r24
    1566:	66 27       	eor	r22, r22
    1568:	55 27       	eor	r21, r21
    156a:	44 27       	eor	r20, r20
    156c:	9b ad       	ldd	r25, Y+59	; 0x3b
    156e:	89 2f       	mov	r24, r25
    1570:	90 e0       	ldi	r25, 0x00	; 0
    1572:	a0 e0       	ldi	r26, 0x00	; 0
    1574:	b0 e0       	ldi	r27, 0x00	; 0
    1576:	dc 01       	movw	r26, r24
    1578:	99 27       	eor	r25, r25
    157a:	88 27       	eor	r24, r24
    157c:	84 2b       	or	r24, r20
    157e:	95 2b       	or	r25, r21
    1580:	a6 2b       	or	r26, r22
    1582:	b7 2b       	or	r27, r23
    1584:	4a ad       	ldd	r20, Y+58	; 0x3a
    1586:	50 e0       	ldi	r21, 0x00	; 0
    1588:	54 2f       	mov	r21, r20
    158a:	44 27       	eor	r20, r20
    158c:	60 e0       	ldi	r22, 0x00	; 0
    158e:	70 e0       	ldi	r23, 0x00	; 0
    1590:	84 2b       	or	r24, r20
    1592:	95 2b       	or	r25, r21
    1594:	a6 2b       	or	r26, r22
    1596:	b7 2b       	or	r27, r23
    1598:	29 ad       	ldd	r18, Y+57	; 0x39
    159a:	82 2b       	or	r24, r18
    159c:	82 8f       	std	Z+26, r24	; 0x1a
    159e:	93 8f       	std	Z+27, r25	; 0x1b
    15a0:	a4 8f       	std	Z+28, r26	; 0x1c
    15a2:	b5 8f       	std	Z+29, r27	; 0x1d
	fs->fptr      = 0;                            /* File pointer */
    15a4:	16 8a       	std	Z+22, r1	; 0x16
    15a6:	17 8a       	std	Z+23, r1	; 0x17
    15a8:	10 8e       	std	Z+24, r1	; 0x18
    15aa:	11 8e       	std	Z+25, r1	; 0x19
	fs->flag      = FA_OPENED;
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	81 83       	std	Z+1, r24	; 0x01

	return FR_OK;
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	05 c0       	rjmp	.+10     	; 0x15be <pf_open+0xc6>
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED; /* Check file system */
    15b4:	85 e0       	ldi	r24, 0x05	; 5
    15b6:	03 c0       	rjmp	.+6      	; 0x15be <pf_open+0xc6>
	dj.fn    = sp;
	res      = follow_path(&dj, dir, path); /* Follow the file path */
	if (res != FR_OK)
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
		return FR_NO_FILE;
    15b8:	83 e0       	ldi	r24, 0x03	; 3
    15ba:	01 c0       	rjmp	.+2      	; 0x15be <pf_open+0xc6>
    15bc:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
	fs->fptr      = 0;                            /* File pointer */
	fs->flag      = FA_OPENED;

	return FR_OK;
}
    15be:	ec 96       	adiw	r28, 0x3c	; 60
    15c0:	0f b6       	in	r0, 0x3f	; 63
    15c2:	f8 94       	cli
    15c4:	de bf       	out	0x3e, r29	; 62
    15c6:	0f be       	out	0x3f, r0	; 63
    15c8:	cd bf       	out	0x3d, r28	; 61
    15ca:	df 91       	pop	r29
    15cc:	cf 91       	pop	r28
    15ce:	1f 91       	pop	r17
    15d0:	0f 91       	pop	r16
    15d2:	08 95       	ret

000015d4 <pf_read>:

FRESULT pf_read(void *buff, /* Pointer to the read buffer (NULL:Forward data to the stream)*/
                UINT  btr,  /* Number of bytes to read */
                UINT *br    /* Pointer to number of bytes read */
)
{
    15d4:	6f 92       	push	r6
    15d6:	7f 92       	push	r7
    15d8:	8f 92       	push	r8
    15da:	9f 92       	push	r9
    15dc:	af 92       	push	r10
    15de:	bf 92       	push	r11
    15e0:	cf 92       	push	r12
    15e2:	df 92       	push	r13
    15e4:	ef 92       	push	r14
    15e6:	ff 92       	push	r15
    15e8:	0f 93       	push	r16
    15ea:	1f 93       	push	r17
    15ec:	cf 93       	push	r28
    15ee:	df 93       	push	r29
    15f0:	3c 01       	movw	r6, r24
    15f2:	6b 01       	movw	r12, r22
    15f4:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST   clst;
	DWORD   sect, remain;
	UINT    rcnt;
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;
    15f6:	e0 90 cd 05 	lds	r14, 0x05CD	; 0x8005cd <FatFs>
    15fa:	f0 90 ce 05 	lds	r15, 0x05CE	; 0x8005ce <FatFs+0x1>

	*br = 0;
    15fe:	fa 01       	movw	r30, r20
    1600:	11 82       	std	Z+1, r1	; 0x01
    1602:	10 82       	st	Z, r1
	if (!fs)
    1604:	e1 14       	cp	r14, r1
    1606:	f1 04       	cpc	r15, r1
    1608:	09 f4       	brne	.+2      	; 0x160c <pf_read+0x38>
    160a:	b5 c0       	rjmp	.+362    	; 0x1776 <pf_read+0x1a2>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    160c:	f7 01       	movw	r30, r14
    160e:	81 81       	ldd	r24, Z+1	; 0x01
    1610:	80 ff       	sbrs	r24, 0
    1612:	b3 c0       	rjmp	.+358    	; 0x177a <pf_read+0x1a6>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    1614:	82 8d       	ldd	r24, Z+26	; 0x1a
    1616:	93 8d       	ldd	r25, Z+27	; 0x1b
    1618:	a4 8d       	ldd	r26, Z+28	; 0x1c
    161a:	b5 8d       	ldd	r27, Z+29	; 0x1d
    161c:	46 89       	ldd	r20, Z+22	; 0x16
    161e:	57 89       	ldd	r21, Z+23	; 0x17
    1620:	60 8d       	ldd	r22, Z+24	; 0x18
    1622:	71 8d       	ldd	r23, Z+25	; 0x19
    1624:	84 1b       	sub	r24, r20
    1626:	95 0b       	sbc	r25, r21
    1628:	a6 0b       	sbc	r26, r22
    162a:	b7 0b       	sbc	r27, r23
	if (btr > remain)
    162c:	a6 01       	movw	r20, r12
    162e:	60 e0       	ldi	r22, 0x00	; 0
    1630:	70 e0       	ldi	r23, 0x00	; 0
    1632:	84 17       	cp	r24, r20
    1634:	95 07       	cpc	r25, r21
    1636:	a6 07       	cpc	r26, r22
    1638:	b7 07       	cpc	r27, r23
    163a:	08 f4       	brcc	.+2      	; 0x163e <pf_read+0x6a>
		btr = (UINT)remain; /* Truncate btr by remaining bytes */
    163c:	6c 01       	movw	r12, r24
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
		if (rcnt > btr)
			rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    163e:	53 01       	movw	r10, r6
    1640:	94 c0       	rjmp	.+296    	; 0x176a <pf_read+0x196>
	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {                       /* On the sector boundary? */
    1642:	f7 01       	movw	r30, r14
    1644:	86 89       	ldd	r24, Z+22	; 0x16
    1646:	97 89       	ldd	r25, Z+23	; 0x17
    1648:	a0 8d       	ldd	r26, Z+24	; 0x18
    164a:	b1 8d       	ldd	r27, Z+25	; 0x19
    164c:	ac 01       	movw	r20, r24
    164e:	bd 01       	movw	r22, r26
    1650:	51 70       	andi	r21, 0x01	; 1
    1652:	66 27       	eor	r22, r22
    1654:	77 27       	eor	r23, r23
    1656:	45 2b       	or	r20, r21
    1658:	46 2b       	or	r20, r22
    165a:	47 2b       	or	r20, r23
    165c:	09 f0       	breq	.+2      	; 0x1660 <pf_read+0x8c>
    165e:	48 c0       	rjmp	.+144    	; 0x16f0 <pf_read+0x11c>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1660:	c2 81       	ldd	r28, Z+2	; 0x02
    1662:	c1 50       	subi	r28, 0x01	; 1
    1664:	ac 01       	movw	r20, r24
    1666:	bd 01       	movw	r22, r26
    1668:	03 2e       	mov	r0, r19
    166a:	39 e0       	ldi	r19, 0x09	; 9
    166c:	76 95       	lsr	r23
    166e:	67 95       	ror	r22
    1670:	57 95       	ror	r21
    1672:	47 95       	ror	r20
    1674:	3a 95       	dec	r19
    1676:	d1 f7       	brne	.-12     	; 0x166c <pf_read+0x98>
    1678:	30 2d       	mov	r19, r0
    167a:	c4 23       	and	r28, r20
			if (!cs) {                                     /* On the cluster boundary? */
    167c:	f1 f4       	brne	.+60     	; 0x16ba <pf_read+0xe6>
				if (fs->fptr == 0)                         /* On the top of the file? */
    167e:	89 2b       	or	r24, r25
    1680:	8a 2b       	or	r24, r26
    1682:	8b 2b       	or	r24, r27
    1684:	29 f4       	brne	.+10     	; 0x1690 <pf_read+0xbc>
					clst = fs->org_clust;
    1686:	66 8d       	ldd	r22, Z+30	; 0x1e
    1688:	77 8d       	ldd	r23, Z+31	; 0x1f
    168a:	80 a1       	ldd	r24, Z+32	; 0x20
    168c:	91 a1       	ldd	r25, Z+33	; 0x21
    168e:	07 c0       	rjmp	.+14     	; 0x169e <pf_read+0xca>
				else
					clst = get_fat(fs->curr_clust);
    1690:	f7 01       	movw	r30, r14
    1692:	62 a1       	ldd	r22, Z+34	; 0x22
    1694:	73 a1       	ldd	r23, Z+35	; 0x23
    1696:	84 a1       	ldd	r24, Z+36	; 0x24
    1698:	95 a1       	ldd	r25, Z+37	; 0x25
    169a:	0e 94 27 07 	call	0xe4e	; 0xe4e <get_fat>
				if (clst <= 1)
    169e:	62 30       	cpi	r22, 0x02	; 2
    16a0:	71 05       	cpc	r23, r1
    16a2:	81 05       	cpc	r24, r1
    16a4:	91 05       	cpc	r25, r1
    16a6:	20 f4       	brcc	.+8      	; 0x16b0 <pf_read+0xdc>
					ABORT(FR_DISK_ERR);
    16a8:	f7 01       	movw	r30, r14
    16aa:	11 82       	std	Z+1, r1	; 0x01
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	66 c0       	rjmp	.+204    	; 0x177c <pf_read+0x1a8>
				fs->curr_clust = clst; /* Update current cluster */
    16b0:	f7 01       	movw	r30, r14
    16b2:	62 a3       	std	Z+34, r22	; 0x22
    16b4:	73 a3       	std	Z+35, r23	; 0x23
    16b6:	84 a3       	std	Z+36, r24	; 0x24
    16b8:	95 a3       	std	Z+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    16ba:	f7 01       	movw	r30, r14
    16bc:	62 a1       	ldd	r22, Z+34	; 0x22
    16be:	73 a1       	ldd	r23, Z+35	; 0x23
    16c0:	84 a1       	ldd	r24, Z+36	; 0x24
    16c2:	95 a1       	ldd	r25, Z+37	; 0x25
    16c4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <clust2sect>
			if (!sect)
    16c8:	61 15       	cp	r22, r1
    16ca:	71 05       	cpc	r23, r1
    16cc:	81 05       	cpc	r24, r1
    16ce:	91 05       	cpc	r25, r1
    16d0:	21 f4       	brne	.+8      	; 0x16da <pf_read+0x106>
				ABORT(FR_DISK_ERR);
    16d2:	f7 01       	movw	r30, r14
    16d4:	11 82       	std	Z+1, r1	; 0x01
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	51 c0       	rjmp	.+162    	; 0x177c <pf_read+0x1a8>
			fs->dsect = sect + cs;
    16da:	dc 01       	movw	r26, r24
    16dc:	cb 01       	movw	r24, r22
    16de:	8c 0f       	add	r24, r28
    16e0:	91 1d       	adc	r25, r1
    16e2:	a1 1d       	adc	r26, r1
    16e4:	b1 1d       	adc	r27, r1
    16e6:	f7 01       	movw	r30, r14
    16e8:	86 a3       	std	Z+38, r24	; 0x26
    16ea:	97 a3       	std	Z+39, r25	; 0x27
    16ec:	a0 a7       	std	Z+40, r26	; 0x28
    16ee:	b1 a7       	std	Z+41, r27	; 0x29
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
    16f0:	f7 01       	movw	r30, r14
    16f2:	86 89       	ldd	r24, Z+22	; 0x16
    16f4:	97 89       	ldd	r25, Z+23	; 0x17
    16f6:	a0 8d       	ldd	r26, Z+24	; 0x18
    16f8:	b1 8d       	ldd	r27, Z+25	; 0x19
    16fa:	9c 01       	movw	r18, r24
    16fc:	31 70       	andi	r19, 0x01	; 1
    16fe:	c0 e0       	ldi	r28, 0x00	; 0
    1700:	d2 e0       	ldi	r29, 0x02	; 2
    1702:	c2 1b       	sub	r28, r18
    1704:	d3 0b       	sbc	r29, r19
		if (rcnt > btr)
    1706:	cc 16       	cp	r12, r28
    1708:	dd 06       	cpc	r13, r29
    170a:	08 f4       	brcc	.+2      	; 0x170e <pf_read+0x13a>
			rcnt = btr;
    170c:	e6 01       	movw	r28, r12
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    170e:	f7 01       	movw	r30, r14
    1710:	46 a1       	ldd	r20, Z+38	; 0x26
    1712:	57 a1       	ldd	r21, Z+39	; 0x27
    1714:	60 a5       	ldd	r22, Z+40	; 0x28
    1716:	71 a5       	ldd	r23, Z+41	; 0x29
    1718:	61 14       	cp	r6, r1
    171a:	71 04       	cpc	r7, r1
    171c:	19 f4       	brne	.+6      	; 0x1724 <pf_read+0x150>
    171e:	80 e0       	ldi	r24, 0x00	; 0
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	02 c0       	rjmp	.+4      	; 0x1728 <pf_read+0x154>
    1724:	8a 2d       	mov	r24, r10
    1726:	9b 2d       	mov	r25, r11
    1728:	8e 01       	movw	r16, r28
    172a:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
		if (dr)
    172e:	88 23       	and	r24, r24
    1730:	21 f0       	breq	.+8      	; 0x173a <pf_read+0x166>
			ABORT(FR_DISK_ERR);
    1732:	f7 01       	movw	r30, r14
    1734:	11 82       	std	Z+1, r1	; 0x01
    1736:	81 e0       	ldi	r24, 0x01	; 1
    1738:	21 c0       	rjmp	.+66     	; 0x177c <pf_read+0x1a8>
		fs->fptr += rcnt;
    173a:	f7 01       	movw	r30, r14
    173c:	86 89       	ldd	r24, Z+22	; 0x16
    173e:	97 89       	ldd	r25, Z+23	; 0x17
    1740:	a0 8d       	ldd	r26, Z+24	; 0x18
    1742:	b1 8d       	ldd	r27, Z+25	; 0x19
    1744:	8c 0f       	add	r24, r28
    1746:	9d 1f       	adc	r25, r29
    1748:	a1 1d       	adc	r26, r1
    174a:	b1 1d       	adc	r27, r1
    174c:	86 8b       	std	Z+22, r24	; 0x16
    174e:	97 8b       	std	Z+23, r25	; 0x17
    1750:	a0 8f       	std	Z+24, r26	; 0x18
    1752:	b1 8f       	std	Z+25, r27	; 0x19
		rbuff += rcnt; /* Update pointers and counters */
    1754:	ac 0e       	add	r10, r28
    1756:	bd 1e       	adc	r11, r29
		btr -= rcnt;
    1758:	cc 1a       	sub	r12, r28
    175a:	dd 0a       	sbc	r13, r29
		*br += rcnt;
    175c:	f4 01       	movw	r30, r8
    175e:	80 81       	ld	r24, Z
    1760:	91 81       	ldd	r25, Z+1	; 0x01
    1762:	c8 0f       	add	r28, r24
    1764:	d9 1f       	adc	r29, r25
    1766:	d1 83       	std	Z+1, r29	; 0x01
    1768:	c0 83       	st	Z, r28

	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
    176a:	c1 14       	cp	r12, r1
    176c:	d1 04       	cpc	r13, r1
    176e:	09 f0       	breq	.+2      	; 0x1772 <pf_read+0x19e>
    1770:	68 cf       	rjmp	.-304    	; 0x1642 <pf_read+0x6e>
		rbuff += rcnt; /* Update pointers and counters */
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
    1772:	80 e0       	ldi	r24, 0x00	; 0
    1774:	03 c0       	rjmp	.+6      	; 0x177c <pf_read+0x1a8>
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;

	*br = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1776:	85 e0       	ldi	r24, 0x05	; 5
    1778:	01 c0       	rjmp	.+2      	; 0x177c <pf_read+0x1a8>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    177a:	84 e0       	ldi	r24, 0x04	; 4
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
}
    177c:	df 91       	pop	r29
    177e:	cf 91       	pop	r28
    1780:	1f 91       	pop	r17
    1782:	0f 91       	pop	r16
    1784:	ff 90       	pop	r15
    1786:	ef 90       	pop	r14
    1788:	df 90       	pop	r13
    178a:	cf 90       	pop	r12
    178c:	bf 90       	pop	r11
    178e:	af 90       	pop	r10
    1790:	9f 90       	pop	r9
    1792:	8f 90       	pop	r8
    1794:	7f 90       	pop	r7
    1796:	6f 90       	pop	r6
    1798:	08 95       	ret

0000179a <pf_write>:

FRESULT pf_write(const void *buff, /* Pointer to the data to be written */
                 UINT        btw,  /* Number of bytes to write (0:Finalize the current write operation) */
                 UINT *      bw    /* Pointer to number of bytes written */
)
{
    179a:	4f 92       	push	r4
    179c:	5f 92       	push	r5
    179e:	6f 92       	push	r6
    17a0:	7f 92       	push	r7
    17a2:	af 92       	push	r10
    17a4:	bf 92       	push	r11
    17a6:	cf 92       	push	r12
    17a8:	df 92       	push	r13
    17aa:	ef 92       	push	r14
    17ac:	ff 92       	push	r15
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	7c 01       	movw	r14, r24
    17b8:	5b 01       	movw	r10, r22
    17ba:	6a 01       	movw	r12, r20
	CLUST       clst;
	DWORD       sect, remain;
	const BYTE *p = buff;
	BYTE        cs;
	UINT        wcnt;
	FATFS *     fs = FatFs;
    17bc:	c0 91 cd 05 	lds	r28, 0x05CD	; 0x8005cd <FatFs>
    17c0:	d0 91 ce 05 	lds	r29, 0x05CE	; 0x8005ce <FatFs+0x1>

	*bw = 0;
    17c4:	fa 01       	movw	r30, r20
    17c6:	11 82       	std	Z+1, r1	; 0x01
    17c8:	10 82       	st	Z, r1
	if (!fs)
    17ca:	20 97       	sbiw	r28, 0x00	; 0
    17cc:	09 f4       	brne	.+2      	; 0x17d0 <pf_write+0x36>
    17ce:	df c0       	rjmp	.+446    	; 0x198e <pf_write+0x1f4>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    17d0:	89 81       	ldd	r24, Y+1	; 0x01
    17d2:	80 ff       	sbrs	r24, 0
    17d4:	de c0       	rjmp	.+444    	; 0x1992 <pf_write+0x1f8>
		return FR_NOT_OPENED;

	if (!btw) { /* Finalize request */
    17d6:	67 2b       	or	r22, r23
    17d8:	99 f4       	brne	.+38     	; 0x1800 <pf_write+0x66>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0))
    17da:	86 ff       	sbrs	r24, 6
    17dc:	0c c0       	rjmp	.+24     	; 0x17f6 <pf_write+0x5c>
    17de:	40 e0       	ldi	r20, 0x00	; 0
    17e0:	50 e0       	ldi	r21, 0x00	; 0
    17e2:	ba 01       	movw	r22, r20
    17e4:	80 e0       	ldi	r24, 0x00	; 0
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    17ec:	88 23       	and	r24, r24
    17ee:	19 f0       	breq	.+6      	; 0x17f6 <pf_write+0x5c>
			ABORT(FR_DISK_ERR);
    17f0:	19 82       	std	Y+1, r1	; 0x01
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	cf c0       	rjmp	.+414    	; 0x1994 <pf_write+0x1fa>
		fs->flag &= ~FA__WIP;
    17f6:	89 81       	ldd	r24, Y+1	; 0x01
    17f8:	8f 7b       	andi	r24, 0xBF	; 191
    17fa:	89 83       	std	Y+1, r24	; 0x01
		return FR_OK;
    17fc:	80 e0       	ldi	r24, 0x00	; 0
    17fe:	ca c0       	rjmp	.+404    	; 0x1994 <pf_write+0x1fa>
	} else {                       /* Write data request */
		if (!(fs->flag & FA__WIP)) /* Round-down fptr to the sector boundary */
    1800:	86 fd       	sbrc	r24, 6
    1802:	0a c0       	rjmp	.+20     	; 0x1818 <pf_write+0x7e>
			fs->fptr &= 0xFFFFFE00;
    1804:	8e 89       	ldd	r24, Y+22	; 0x16
    1806:	9f 89       	ldd	r25, Y+23	; 0x17
    1808:	a8 8d       	ldd	r26, Y+24	; 0x18
    180a:	b9 8d       	ldd	r27, Y+25	; 0x19
    180c:	88 27       	eor	r24, r24
    180e:	9e 7f       	andi	r25, 0xFE	; 254
    1810:	8e 8b       	std	Y+22, r24	; 0x16
    1812:	9f 8b       	std	Y+23, r25	; 0x17
    1814:	a8 8f       	std	Y+24, r26	; 0x18
    1816:	b9 8f       	std	Y+25, r27	; 0x19
	}
	remain = fs->fsize - fs->fptr;
    1818:	8a 8d       	ldd	r24, Y+26	; 0x1a
    181a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    181c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    181e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1820:	4e 89       	ldd	r20, Y+22	; 0x16
    1822:	5f 89       	ldd	r21, Y+23	; 0x17
    1824:	68 8d       	ldd	r22, Y+24	; 0x18
    1826:	79 8d       	ldd	r23, Y+25	; 0x19
    1828:	84 1b       	sub	r24, r20
    182a:	95 0b       	sbc	r25, r21
    182c:	a6 0b       	sbc	r26, r22
    182e:	b7 0b       	sbc	r27, r23
	if (btw > remain)
    1830:	a5 01       	movw	r20, r10
    1832:	60 e0       	ldi	r22, 0x00	; 0
    1834:	70 e0       	ldi	r23, 0x00	; 0
    1836:	84 17       	cp	r24, r20
    1838:	95 07       	cpc	r25, r21
    183a:	a6 07       	cpc	r26, r22
    183c:	b7 07       	cpc	r27, r23
    183e:	08 f0       	brcs	.+2      	; 0x1842 <pf_write+0xa8>
    1840:	a0 c0       	rjmp	.+320    	; 0x1982 <pf_write+0x1e8>
		btw = (UINT)remain; /* Truncate btw by remaining bytes */
    1842:	5c 01       	movw	r10, r24
    1844:	9e c0       	rjmp	.+316    	; 0x1982 <pf_write+0x1e8>

	while (btw) {                                          /* Repeat until all data transferred */
		if ((UINT)fs->fptr % 512 == 0) {                   /* On the sector boundary? */
    1846:	8e 89       	ldd	r24, Y+22	; 0x16
    1848:	9f 89       	ldd	r25, Y+23	; 0x17
    184a:	a8 8d       	ldd	r26, Y+24	; 0x18
    184c:	b9 8d       	ldd	r27, Y+25	; 0x19
    184e:	9c 01       	movw	r18, r24
    1850:	31 70       	andi	r19, 0x01	; 1
    1852:	23 2b       	or	r18, r19
    1854:	09 f0       	breq	.+2      	; 0x1858 <pf_write+0xbe>
    1856:	4e c0       	rjmp	.+156    	; 0x18f4 <pf_write+0x15a>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1858:	1a 81       	ldd	r17, Y+2	; 0x02
    185a:	11 50       	subi	r17, 0x01	; 1
    185c:	ac 01       	movw	r20, r24
    185e:	bd 01       	movw	r22, r26
    1860:	03 2e       	mov	r0, r19
    1862:	39 e0       	ldi	r19, 0x09	; 9
    1864:	76 95       	lsr	r23
    1866:	67 95       	ror	r22
    1868:	57 95       	ror	r21
    186a:	47 95       	ror	r20
    186c:	3a 95       	dec	r19
    186e:	d1 f7       	brne	.-12     	; 0x1864 <pf_write+0xca>
    1870:	30 2d       	mov	r19, r0
    1872:	14 23       	and	r17, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1874:	d9 f4       	brne	.+54     	; 0x18ac <pf_write+0x112>
				if (fs->fptr == 0)                         /* On the top of the file? */
    1876:	89 2b       	or	r24, r25
    1878:	8a 2b       	or	r24, r26
    187a:	8b 2b       	or	r24, r27
    187c:	29 f4       	brne	.+10     	; 0x1888 <pf_write+0xee>
					clst = fs->org_clust;
    187e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1880:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1882:	88 a1       	ldd	r24, Y+32	; 0x20
    1884:	99 a1       	ldd	r25, Y+33	; 0x21
    1886:	06 c0       	rjmp	.+12     	; 0x1894 <pf_write+0xfa>
				else
					clst = get_fat(fs->curr_clust);
    1888:	6a a1       	ldd	r22, Y+34	; 0x22
    188a:	7b a1       	ldd	r23, Y+35	; 0x23
    188c:	8c a1       	ldd	r24, Y+36	; 0x24
    188e:	9d a1       	ldd	r25, Y+37	; 0x25
    1890:	0e 94 27 07 	call	0xe4e	; 0xe4e <get_fat>
				if (clst <= 1)
    1894:	62 30       	cpi	r22, 0x02	; 2
    1896:	71 05       	cpc	r23, r1
    1898:	81 05       	cpc	r24, r1
    189a:	91 05       	cpc	r25, r1
    189c:	18 f4       	brcc	.+6      	; 0x18a4 <pf_write+0x10a>
					ABORT(FR_DISK_ERR);
    189e:	19 82       	std	Y+1, r1	; 0x01
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	78 c0       	rjmp	.+240    	; 0x1994 <pf_write+0x1fa>
				fs->curr_clust = clst; /* Update current cluster */
    18a4:	6a a3       	std	Y+34, r22	; 0x22
    18a6:	7b a3       	std	Y+35, r23	; 0x23
    18a8:	8c a3       	std	Y+36, r24	; 0x24
    18aa:	9d a3       	std	Y+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    18ac:	6a a1       	ldd	r22, Y+34	; 0x22
    18ae:	7b a1       	ldd	r23, Y+35	; 0x23
    18b0:	8c a1       	ldd	r24, Y+36	; 0x24
    18b2:	9d a1       	ldd	r25, Y+37	; 0x25
    18b4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <clust2sect>
			if (!sect)
    18b8:	61 15       	cp	r22, r1
    18ba:	71 05       	cpc	r23, r1
    18bc:	81 05       	cpc	r24, r1
    18be:	91 05       	cpc	r25, r1
    18c0:	19 f4       	brne	.+6      	; 0x18c8 <pf_write+0x12e>
				ABORT(FR_DISK_ERR);
    18c2:	19 82       	std	Y+1, r1	; 0x01
    18c4:	81 e0       	ldi	r24, 0x01	; 1
    18c6:	66 c0       	rjmp	.+204    	; 0x1994 <pf_write+0x1fa>
			fs->dsect = sect + cs;
    18c8:	ab 01       	movw	r20, r22
    18ca:	bc 01       	movw	r22, r24
    18cc:	41 0f       	add	r20, r17
    18ce:	51 1d       	adc	r21, r1
    18d0:	61 1d       	adc	r22, r1
    18d2:	71 1d       	adc	r23, r1
    18d4:	4e a3       	std	Y+38, r20	; 0x26
    18d6:	5f a3       	std	Y+39, r21	; 0x27
    18d8:	68 a7       	std	Y+40, r22	; 0x28
    18da:	79 a7       	std	Y+41, r23	; 0x29
			if (disk_writep(0, fs->dsect))
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    18e4:	88 23       	and	r24, r24
    18e6:	19 f0       	breq	.+6      	; 0x18ee <pf_write+0x154>
				ABORT(FR_DISK_ERR); /* Initiate a sector write operation */
    18e8:	19 82       	std	Y+1, r1	; 0x01
    18ea:	81 e0       	ldi	r24, 0x01	; 1
    18ec:	53 c0       	rjmp	.+166    	; 0x1994 <pf_write+0x1fa>
			fs->flag |= FA__WIP;
    18ee:	89 81       	ldd	r24, Y+1	; 0x01
    18f0:	80 64       	ori	r24, 0x40	; 64
    18f2:	89 83       	std	Y+1, r24	; 0x01
		}
		wcnt = 512 - (UINT)fs->fptr % 512; /* Number of bytes to write to the sector */
    18f4:	8e 89       	ldd	r24, Y+22	; 0x16
    18f6:	9f 89       	ldd	r25, Y+23	; 0x17
    18f8:	a8 8d       	ldd	r26, Y+24	; 0x18
    18fa:	b9 8d       	ldd	r27, Y+25	; 0x19
    18fc:	91 70       	andi	r25, 0x01	; 1
    18fe:	00 e0       	ldi	r16, 0x00	; 0
    1900:	12 e0       	ldi	r17, 0x02	; 2
    1902:	08 1b       	sub	r16, r24
    1904:	19 0b       	sbc	r17, r25
		if (wcnt > btw)
    1906:	a0 16       	cp	r10, r16
    1908:	b1 06       	cpc	r11, r17
    190a:	08 f4       	brcc	.+2      	; 0x190e <pf_write+0x174>
			wcnt = btw;
    190c:	85 01       	movw	r16, r10
		if (disk_writep(p, wcnt))
    190e:	28 01       	movw	r4, r16
    1910:	61 2c       	mov	r6, r1
    1912:	71 2c       	mov	r7, r1
    1914:	b3 01       	movw	r22, r6
    1916:	a2 01       	movw	r20, r4
    1918:	c7 01       	movw	r24, r14
    191a:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    191e:	88 23       	and	r24, r24
    1920:	19 f0       	breq	.+6      	; 0x1928 <pf_write+0x18e>
			ABORT(FR_DISK_ERR); /* Send data to the sector */
    1922:	19 82       	std	Y+1, r1	; 0x01
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	36 c0       	rjmp	.+108    	; 0x1994 <pf_write+0x1fa>
		fs->fptr += wcnt;
    1928:	8e 89       	ldd	r24, Y+22	; 0x16
    192a:	9f 89       	ldd	r25, Y+23	; 0x17
    192c:	a8 8d       	ldd	r26, Y+24	; 0x18
    192e:	b9 8d       	ldd	r27, Y+25	; 0x19
    1930:	48 0e       	add	r4, r24
    1932:	59 1e       	adc	r5, r25
    1934:	6a 1e       	adc	r6, r26
    1936:	7b 1e       	adc	r7, r27
    1938:	4e 8a       	std	Y+22, r4	; 0x16
    193a:	5f 8a       	std	Y+23, r5	; 0x17
    193c:	68 8e       	std	Y+24, r6	; 0x18
    193e:	79 8e       	std	Y+25, r7	; 0x19
		p += wcnt; /* Update pointers and counters */
    1940:	e0 0e       	add	r14, r16
    1942:	f1 1e       	adc	r15, r17
		btw -= wcnt;
    1944:	a0 1a       	sub	r10, r16
    1946:	b1 0a       	sbc	r11, r17
		*bw += wcnt;
    1948:	f6 01       	movw	r30, r12
    194a:	80 81       	ld	r24, Z
    194c:	91 81       	ldd	r25, Z+1	; 0x01
    194e:	08 0f       	add	r16, r24
    1950:	19 1f       	adc	r17, r25
    1952:	11 83       	std	Z+1, r17	; 0x01
    1954:	00 83       	st	Z, r16
		if ((UINT)fs->fptr % 512 == 0) {
    1956:	8e 89       	ldd	r24, Y+22	; 0x16
    1958:	9f 89       	ldd	r25, Y+23	; 0x17
    195a:	a8 8d       	ldd	r26, Y+24	; 0x18
    195c:	b9 8d       	ldd	r27, Y+25	; 0x19
    195e:	91 70       	andi	r25, 0x01	; 1
    1960:	89 2b       	or	r24, r25
    1962:	79 f4       	brne	.+30     	; 0x1982 <pf_write+0x1e8>
			if (disk_writep(0, 0))
    1964:	40 e0       	ldi	r20, 0x00	; 0
    1966:	50 e0       	ldi	r21, 0x00	; 0
    1968:	ba 01       	movw	r22, r20
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	90 e0       	ldi	r25, 0x00	; 0
    196e:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    1972:	88 23       	and	r24, r24
    1974:	19 f0       	breq	.+6      	; 0x197c <pf_write+0x1e2>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
    1976:	19 82       	std	Y+1, r1	; 0x01
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	0c c0       	rjmp	.+24     	; 0x1994 <pf_write+0x1fa>
			fs->flag &= ~FA__WIP;
    197c:	89 81       	ldd	r24, Y+1	; 0x01
    197e:	8f 7b       	andi	r24, 0xBF	; 191
    1980:	89 83       	std	Y+1, r24	; 0x01
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain)
		btw = (UINT)remain; /* Truncate btw by remaining bytes */

	while (btw) {                                          /* Repeat until all data transferred */
    1982:	a1 14       	cp	r10, r1
    1984:	b1 04       	cpc	r11, r1
    1986:	09 f0       	breq	.+2      	; 0x198a <pf_write+0x1f0>
    1988:	5e cf       	rjmp	.-324    	; 0x1846 <pf_write+0xac>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	03 c0       	rjmp	.+6      	; 0x1994 <pf_write+0x1fa>
	UINT        wcnt;
	FATFS *     fs = FatFs;

	*bw = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    198e:	85 e0       	ldi	r24, 0x05	; 5
    1990:	01 c0       	rjmp	.+2      	; 0x1994 <pf_write+0x1fa>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1992:	84 e0       	ldi	r24, 0x04	; 4
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
}
    1994:	df 91       	pop	r29
    1996:	cf 91       	pop	r28
    1998:	1f 91       	pop	r17
    199a:	0f 91       	pop	r16
    199c:	ff 90       	pop	r15
    199e:	ef 90       	pop	r14
    19a0:	df 90       	pop	r13
    19a2:	cf 90       	pop	r12
    19a4:	bf 90       	pop	r11
    19a6:	af 90       	pop	r10
    19a8:	7f 90       	pop	r7
    19aa:	6f 90       	pop	r6
    19ac:	5f 90       	pop	r5
    19ae:	4f 90       	pop	r4
    19b0:	08 95       	ret

000019b2 <pf_lseek>:
/*-----------------------------------------------------------------------*/
#if _USE_LSEEK

FRESULT pf_lseek(DWORD ofs /* File pointer from top of file */
)
{
    19b2:	4f 92       	push	r4
    19b4:	5f 92       	push	r5
    19b6:	6f 92       	push	r6
    19b8:	7f 92       	push	r7
    19ba:	8f 92       	push	r8
    19bc:	9f 92       	push	r9
    19be:	af 92       	push	r10
    19c0:	bf 92       	push	r11
    19c2:	cf 92       	push	r12
    19c4:	df 92       	push	r13
    19c6:	ef 92       	push	r14
    19c8:	ff 92       	push	r15
    19ca:	cf 93       	push	r28
    19cc:	df 93       	push	r29
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <pf_lseek+0x1e>
    19d0:	00 d0       	rcall	.+0      	; 0x19d2 <pf_lseek+0x20>
    19d2:	00 d0       	rcall	.+0      	; 0x19d4 <pf_lseek+0x22>
    19d4:	cd b7       	in	r28, 0x3d	; 61
    19d6:	de b7       	in	r29, 0x3e	; 62
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;
    19d8:	20 91 cd 05 	lds	r18, 0x05CD	; 0x8005cd <FatFs>
    19dc:	30 91 ce 05 	lds	r19, 0x05CE	; 0x8005ce <FatFs+0x1>
    19e0:	3e 83       	std	Y+6, r19	; 0x06
    19e2:	2d 83       	std	Y+5, r18	; 0x05

	if (!fs)
    19e4:	21 15       	cp	r18, r1
    19e6:	31 05       	cpc	r19, r1
    19e8:	09 f4       	brne	.+2      	; 0x19ec <pf_lseek+0x3a>
    19ea:	f4 c0       	rjmp	.+488    	; 0x1bd4 <pf_lseek+0x222>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    19ec:	d9 01       	movw	r26, r18
    19ee:	11 96       	adiw	r26, 0x01	; 1
    19f0:	2c 91       	ld	r18, X
    19f2:	11 97       	sbiw	r26, 0x01	; 1
    19f4:	20 ff       	sbrs	r18, 0
    19f6:	f0 c0       	rjmp	.+480    	; 0x1bd8 <pf_lseek+0x226>
		return FR_NOT_OPENED;

	if (ofs > fs->fsize)
    19f8:	5a 96       	adiw	r26, 0x1a	; 26
    19fa:	cd 90       	ld	r12, X+
    19fc:	dd 90       	ld	r13, X+
    19fe:	ed 90       	ld	r14, X+
    1a00:	fc 90       	ld	r15, X
    1a02:	5d 97       	sbiw	r26, 0x1d	; 29
    1a04:	c6 16       	cp	r12, r22
    1a06:	d7 06       	cpc	r13, r23
    1a08:	e8 06       	cpc	r14, r24
    1a0a:	f9 06       	cpc	r15, r25
    1a0c:	10 f0       	brcs	.+4      	; 0x1a12 <pf_lseek+0x60>
    1a0e:	6b 01       	movw	r12, r22
    1a10:	7c 01       	movw	r14, r24
		ofs = fs->fsize; /* Clip offset with the file size */
	ifptr    = fs->fptr;
    1a12:	ed 81       	ldd	r30, Y+5	; 0x05
    1a14:	fe 81       	ldd	r31, Y+6	; 0x06
    1a16:	46 88       	ldd	r4, Z+22	; 0x16
    1a18:	57 88       	ldd	r5, Z+23	; 0x17
    1a1a:	60 8c       	ldd	r6, Z+24	; 0x18
    1a1c:	71 8c       	ldd	r7, Z+25	; 0x19
	fs->fptr = 0;
    1a1e:	16 8a       	std	Z+22, r1	; 0x16
    1a20:	17 8a       	std	Z+23, r1	; 0x17
    1a22:	10 8e       	std	Z+24, r1	; 0x18
    1a24:	11 8e       	std	Z+25, r1	; 0x19
	if (ofs > 0) {
    1a26:	c1 14       	cp	r12, r1
    1a28:	d1 04       	cpc	r13, r1
    1a2a:	e1 04       	cpc	r14, r1
    1a2c:	f1 04       	cpc	r15, r1
    1a2e:	09 f4       	brne	.+2      	; 0x1a32 <pf_lseek+0x80>
    1a30:	d5 c0       	rjmp	.+426    	; 0x1bdc <pf_lseek+0x22a>
		bcs = (DWORD)fs->csize * 512;                            /* Cluster size (byte) */
    1a32:	82 80       	ldd	r8, Z+2	; 0x02
    1a34:	91 2c       	mov	r9, r1
    1a36:	a1 2c       	mov	r10, r1
    1a38:	b1 2c       	mov	r11, r1
    1a3a:	07 2e       	mov	r0, r23
    1a3c:	79 e0       	ldi	r23, 0x09	; 9
    1a3e:	88 0c       	add	r8, r8
    1a40:	99 1c       	adc	r9, r9
    1a42:	aa 1c       	adc	r10, r10
    1a44:	bb 1c       	adc	r11, r11
    1a46:	7a 95       	dec	r23
    1a48:	d1 f7       	brne	.-12     	; 0x1a3e <pf_lseek+0x8c>
    1a4a:	70 2d       	mov	r23, r0
		if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
    1a4c:	41 14       	cp	r4, r1
    1a4e:	51 04       	cpc	r5, r1
    1a50:	61 04       	cpc	r6, r1
    1a52:	71 04       	cpc	r7, r1
    1a54:	09 f4       	brne	.+2      	; 0x1a58 <pf_lseek+0xa6>
    1a56:	40 c0       	rjmp	.+128    	; 0x1ad8 <pf_lseek+0x126>
    1a58:	c7 01       	movw	r24, r14
    1a5a:	b6 01       	movw	r22, r12
    1a5c:	61 50       	subi	r22, 0x01	; 1
    1a5e:	71 09       	sbc	r23, r1
    1a60:	81 09       	sbc	r24, r1
    1a62:	91 09       	sbc	r25, r1
    1a64:	a5 01       	movw	r20, r10
    1a66:	94 01       	movw	r18, r8
    1a68:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <__udivmodsi4>
    1a6c:	29 83       	std	Y+1, r18	; 0x01
    1a6e:	3a 83       	std	Y+2, r19	; 0x02
    1a70:	4b 83       	std	Y+3, r20	; 0x03
    1a72:	5c 83       	std	Y+4, r21	; 0x04
    1a74:	b1 e0       	ldi	r27, 0x01	; 1
    1a76:	4b 1a       	sub	r4, r27
    1a78:	51 08       	sbc	r5, r1
    1a7a:	61 08       	sbc	r6, r1
    1a7c:	71 08       	sbc	r7, r1
    1a7e:	c3 01       	movw	r24, r6
    1a80:	b2 01       	movw	r22, r4
    1a82:	a5 01       	movw	r20, r10
    1a84:	94 01       	movw	r18, r8
    1a86:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <__udivmodsi4>
    1a8a:	89 81       	ldd	r24, Y+1	; 0x01
    1a8c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a8e:	ab 81       	ldd	r26, Y+3	; 0x03
    1a90:	bc 81       	ldd	r27, Y+4	; 0x04
    1a92:	82 17       	cp	r24, r18
    1a94:	93 07       	cpc	r25, r19
    1a96:	a4 07       	cpc	r26, r20
    1a98:	b5 07       	cpc	r27, r21
    1a9a:	f0 f0       	brcs	.+60     	; 0x1ad8 <pf_lseek+0x126>
			fs->fptr = (ifptr - 1) & ~(bcs - 1);                 /* start from the current cluster */
    1a9c:	88 27       	eor	r24, r24
    1a9e:	99 27       	eor	r25, r25
    1aa0:	dc 01       	movw	r26, r24
    1aa2:	88 19       	sub	r24, r8
    1aa4:	99 09       	sbc	r25, r9
    1aa6:	aa 09       	sbc	r26, r10
    1aa8:	bb 09       	sbc	r27, r11
    1aaa:	48 22       	and	r4, r24
    1aac:	59 22       	and	r5, r25
    1aae:	6a 22       	and	r6, r26
    1ab0:	7b 22       	and	r7, r27
    1ab2:	ad 81       	ldd	r26, Y+5	; 0x05
    1ab4:	be 81       	ldd	r27, Y+6	; 0x06
    1ab6:	56 96       	adiw	r26, 0x16	; 22
    1ab8:	4d 92       	st	X+, r4
    1aba:	5d 92       	st	X+, r5
    1abc:	6d 92       	st	X+, r6
    1abe:	7c 92       	st	X, r7
    1ac0:	59 97       	sbiw	r26, 0x19	; 25
			ofs -= fs->fptr;
    1ac2:	c4 18       	sub	r12, r4
    1ac4:	d5 08       	sbc	r13, r5
    1ac6:	e6 08       	sbc	r14, r6
    1ac8:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    1aca:	92 96       	adiw	r26, 0x22	; 34
    1acc:	6d 91       	ld	r22, X+
    1ace:	7d 91       	ld	r23, X+
    1ad0:	8d 91       	ld	r24, X+
    1ad2:	9c 91       	ld	r25, X
    1ad4:	95 97       	sbiw	r26, 0x25	; 37
    1ad6:	39 c0       	rjmp	.+114    	; 0x1b4a <pf_lseek+0x198>
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
    1ad8:	ed 81       	ldd	r30, Y+5	; 0x05
    1ada:	fe 81       	ldd	r31, Y+6	; 0x06
    1adc:	66 8d       	ldd	r22, Z+30	; 0x1e
    1ade:	77 8d       	ldd	r23, Z+31	; 0x1f
    1ae0:	80 a1       	ldd	r24, Z+32	; 0x20
    1ae2:	91 a1       	ldd	r25, Z+33	; 0x21
			fs->curr_clust = clst;
    1ae4:	62 a3       	std	Z+34, r22	; 0x22
    1ae6:	73 a3       	std	Z+35, r23	; 0x23
    1ae8:	84 a3       	std	Z+36, r24	; 0x24
    1aea:	95 a3       	std	Z+37, r25	; 0x25
    1aec:	2e c0       	rjmp	.+92     	; 0x1b4a <pf_lseek+0x198>
		}
		while (ofs > bcs) {       /* Cluster following loop */
			clst = get_fat(clst); /* Follow cluster chain */
    1aee:	0e 94 27 07 	call	0xe4e	; 0xe4e <get_fat>
			if (clst <= 1 || clst >= fs->n_fatent)
    1af2:	62 30       	cpi	r22, 0x02	; 2
    1af4:	71 05       	cpc	r23, r1
    1af6:	81 05       	cpc	r24, r1
    1af8:	91 05       	cpc	r25, r1
    1afa:	58 f0       	brcs	.+22     	; 0x1b12 <pf_lseek+0x160>
    1afc:	ed 81       	ldd	r30, Y+5	; 0x05
    1afe:	fe 81       	ldd	r31, Y+6	; 0x06
    1b00:	46 80       	ldd	r4, Z+6	; 0x06
    1b02:	57 80       	ldd	r5, Z+7	; 0x07
    1b04:	60 84       	ldd	r6, Z+8	; 0x08
    1b06:	71 84       	ldd	r7, Z+9	; 0x09
    1b08:	64 15       	cp	r22, r4
    1b0a:	75 05       	cpc	r23, r5
    1b0c:	86 05       	cpc	r24, r6
    1b0e:	97 05       	cpc	r25, r7
    1b10:	30 f0       	brcs	.+12     	; 0x1b1e <pf_lseek+0x16c>
				ABORT(FR_DISK_ERR);
    1b12:	ad 81       	ldd	r26, Y+5	; 0x05
    1b14:	be 81       	ldd	r27, Y+6	; 0x06
    1b16:	11 96       	adiw	r26, 0x01	; 1
    1b18:	1c 92       	st	X, r1
    1b1a:	81 e0       	ldi	r24, 0x01	; 1
    1b1c:	60 c0       	rjmp	.+192    	; 0x1bde <pf_lseek+0x22c>
			fs->curr_clust = clst;
    1b1e:	ed 81       	ldd	r30, Y+5	; 0x05
    1b20:	fe 81       	ldd	r31, Y+6	; 0x06
    1b22:	62 a3       	std	Z+34, r22	; 0x22
    1b24:	73 a3       	std	Z+35, r23	; 0x23
    1b26:	84 a3       	std	Z+36, r24	; 0x24
    1b28:	95 a3       	std	Z+37, r25	; 0x25
			fs->fptr += bcs;
    1b2a:	46 88       	ldd	r4, Z+22	; 0x16
    1b2c:	57 88       	ldd	r5, Z+23	; 0x17
    1b2e:	60 8c       	ldd	r6, Z+24	; 0x18
    1b30:	71 8c       	ldd	r7, Z+25	; 0x19
    1b32:	48 0c       	add	r4, r8
    1b34:	59 1c       	adc	r5, r9
    1b36:	6a 1c       	adc	r6, r10
    1b38:	7b 1c       	adc	r7, r11
    1b3a:	46 8a       	std	Z+22, r4	; 0x16
    1b3c:	57 8a       	std	Z+23, r5	; 0x17
    1b3e:	60 8e       	std	Z+24, r6	; 0x18
    1b40:	71 8e       	std	Z+25, r7	; 0x19
			ofs -= bcs;
    1b42:	c8 18       	sub	r12, r8
    1b44:	d9 08       	sbc	r13, r9
    1b46:	ea 08       	sbc	r14, r10
    1b48:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {       /* Cluster following loop */
    1b4a:	8c 14       	cp	r8, r12
    1b4c:	9d 04       	cpc	r9, r13
    1b4e:	ae 04       	cpc	r10, r14
    1b50:	bf 04       	cpc	r11, r15
    1b52:	68 f2       	brcs	.-102    	; 0x1aee <pf_lseek+0x13c>
				ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    1b54:	ed 81       	ldd	r30, Y+5	; 0x05
    1b56:	fe 81       	ldd	r31, Y+6	; 0x06
    1b58:	86 88       	ldd	r8, Z+22	; 0x16
    1b5a:	97 88       	ldd	r9, Z+23	; 0x17
    1b5c:	a0 8c       	ldd	r10, Z+24	; 0x18
    1b5e:	b1 8c       	ldd	r11, Z+25	; 0x19
    1b60:	c8 0c       	add	r12, r8
    1b62:	d9 1c       	adc	r13, r9
    1b64:	ea 1c       	adc	r14, r10
    1b66:	fb 1c       	adc	r15, r11
    1b68:	c6 8a       	std	Z+22, r12	; 0x16
    1b6a:	d7 8a       	std	Z+23, r13	; 0x17
    1b6c:	e0 8e       	std	Z+24, r14	; 0x18
    1b6e:	f1 8e       	std	Z+25, r15	; 0x19
		sect = clust2sect(clst); /* Current sector */
    1b70:	0e 94 0f 06 	call	0xc1e	; 0xc1e <clust2sect>
		if (!sect)
    1b74:	61 15       	cp	r22, r1
    1b76:	71 05       	cpc	r23, r1
    1b78:	81 05       	cpc	r24, r1
    1b7a:	91 05       	cpc	r25, r1
    1b7c:	29 f4       	brne	.+10     	; 0x1b88 <pf_lseek+0x1d6>
			ABORT(FR_DISK_ERR);
    1b7e:	ed 81       	ldd	r30, Y+5	; 0x05
    1b80:	fe 81       	ldd	r31, Y+6	; 0x06
    1b82:	11 82       	std	Z+1, r1	; 0x01
    1b84:	81 e0       	ldi	r24, 0x01	; 1
    1b86:	2b c0       	rjmp	.+86     	; 0x1bde <pf_lseek+0x22c>
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    1b88:	0b 2e       	mov	r0, r27
    1b8a:	b9 e0       	ldi	r27, 0x09	; 9
    1b8c:	f6 94       	lsr	r15
    1b8e:	e7 94       	ror	r14
    1b90:	d7 94       	ror	r13
    1b92:	c7 94       	ror	r12
    1b94:	ba 95       	dec	r27
    1b96:	d1 f7       	brne	.-12     	; 0x1b8c <pf_lseek+0x1da>
    1b98:	b0 2d       	mov	r27, r0
    1b9a:	ad 81       	ldd	r26, Y+5	; 0x05
    1b9c:	be 81       	ldd	r27, Y+6	; 0x06
    1b9e:	12 96       	adiw	r26, 0x02	; 2
    1ba0:	2c 91       	ld	r18, X
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	21 50       	subi	r18, 0x01	; 1
    1ba6:	31 09       	sbc	r19, r1
    1ba8:	49 01       	movw	r8, r18
    1baa:	33 0f       	add	r19, r19
    1bac:	aa 08       	sbc	r10, r10
    1bae:	bb 08       	sbc	r11, r11
    1bb0:	c8 20       	and	r12, r8
    1bb2:	d9 20       	and	r13, r9
    1bb4:	ea 20       	and	r14, r10
    1bb6:	fb 20       	and	r15, r11
    1bb8:	dc 01       	movw	r26, r24
    1bba:	cb 01       	movw	r24, r22
    1bbc:	8c 0d       	add	r24, r12
    1bbe:	9d 1d       	adc	r25, r13
    1bc0:	ae 1d       	adc	r26, r14
    1bc2:	bf 1d       	adc	r27, r15
    1bc4:	ed 81       	ldd	r30, Y+5	; 0x05
    1bc6:	fe 81       	ldd	r31, Y+6	; 0x06
    1bc8:	86 a3       	std	Z+38, r24	; 0x26
    1bca:	97 a3       	std	Z+39, r25	; 0x27
    1bcc:	a0 a7       	std	Z+40, r26	; 0x28
    1bce:	b1 a7       	std	Z+41, r27	; 0x29
	}

	return FR_OK;
    1bd0:	80 e0       	ldi	r24, 0x00	; 0
    1bd2:	05 c0       	rjmp	.+10     	; 0x1bde <pf_lseek+0x22c>
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1bd4:	85 e0       	ldi	r24, 0x05	; 5
    1bd6:	03 c0       	rjmp	.+6      	; 0x1bde <pf_lseek+0x22c>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1bd8:	84 e0       	ldi	r24, 0x04	; 4
    1bda:	01 c0       	rjmp	.+2      	; 0x1bde <pf_lseek+0x22c>
		if (!sect)
			ABORT(FR_DISK_ERR);
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
    1bdc:	80 e0       	ldi	r24, 0x00	; 0
}
    1bde:	26 96       	adiw	r28, 0x06	; 6
    1be0:	0f b6       	in	r0, 0x3f	; 63
    1be2:	f8 94       	cli
    1be4:	de bf       	out	0x3e, r29	; 62
    1be6:	0f be       	out	0x3f, r0	; 63
    1be8:	cd bf       	out	0x3d, r28	; 61
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	ff 90       	pop	r15
    1bf0:	ef 90       	pop	r14
    1bf2:	df 90       	pop	r13
    1bf4:	cf 90       	pop	r12
    1bf6:	bf 90       	pop	r11
    1bf8:	af 90       	pop	r10
    1bfa:	9f 90       	pop	r9
    1bfc:	8f 90       	pop	r8
    1bfe:	7f 90       	pop	r7
    1c00:	6f 90       	pop	r6
    1c02:	5f 90       	pop	r5
    1c04:	4f 90       	pop	r4
    1c06:	08 95       	ret

00001c08 <__divmodhi4>:
    1c08:	97 fb       	bst	r25, 7
    1c0a:	07 2e       	mov	r0, r23
    1c0c:	16 f4       	brtc	.+4      	; 0x1c12 <__divmodhi4+0xa>
    1c0e:	00 94       	com	r0
    1c10:	07 d0       	rcall	.+14     	; 0x1c20 <__divmodhi4_neg1>
    1c12:	77 fd       	sbrc	r23, 7
    1c14:	09 d0       	rcall	.+18     	; 0x1c28 <__divmodhi4_neg2>
    1c16:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <__udivmodhi4>
    1c1a:	07 fc       	sbrc	r0, 7
    1c1c:	05 d0       	rcall	.+10     	; 0x1c28 <__divmodhi4_neg2>
    1c1e:	3e f4       	brtc	.+14     	; 0x1c2e <__divmodhi4_exit>

00001c20 <__divmodhi4_neg1>:
    1c20:	90 95       	com	r25
    1c22:	81 95       	neg	r24
    1c24:	9f 4f       	sbci	r25, 0xFF	; 255
    1c26:	08 95       	ret

00001c28 <__divmodhi4_neg2>:
    1c28:	70 95       	com	r23
    1c2a:	61 95       	neg	r22
    1c2c:	7f 4f       	sbci	r23, 0xFF	; 255

00001c2e <__divmodhi4_exit>:
    1c2e:	08 95       	ret

00001c30 <__udivmodsi4>:
    1c30:	a1 e2       	ldi	r26, 0x21	; 33
    1c32:	1a 2e       	mov	r1, r26
    1c34:	aa 1b       	sub	r26, r26
    1c36:	bb 1b       	sub	r27, r27
    1c38:	fd 01       	movw	r30, r26
    1c3a:	0d c0       	rjmp	.+26     	; 0x1c56 <__udivmodsi4_ep>

00001c3c <__udivmodsi4_loop>:
    1c3c:	aa 1f       	adc	r26, r26
    1c3e:	bb 1f       	adc	r27, r27
    1c40:	ee 1f       	adc	r30, r30
    1c42:	ff 1f       	adc	r31, r31
    1c44:	a2 17       	cp	r26, r18
    1c46:	b3 07       	cpc	r27, r19
    1c48:	e4 07       	cpc	r30, r20
    1c4a:	f5 07       	cpc	r31, r21
    1c4c:	20 f0       	brcs	.+8      	; 0x1c56 <__udivmodsi4_ep>
    1c4e:	a2 1b       	sub	r26, r18
    1c50:	b3 0b       	sbc	r27, r19
    1c52:	e4 0b       	sbc	r30, r20
    1c54:	f5 0b       	sbc	r31, r21

00001c56 <__udivmodsi4_ep>:
    1c56:	66 1f       	adc	r22, r22
    1c58:	77 1f       	adc	r23, r23
    1c5a:	88 1f       	adc	r24, r24
    1c5c:	99 1f       	adc	r25, r25
    1c5e:	1a 94       	dec	r1
    1c60:	69 f7       	brne	.-38     	; 0x1c3c <__udivmodsi4_loop>
    1c62:	60 95       	com	r22
    1c64:	70 95       	com	r23
    1c66:	80 95       	com	r24
    1c68:	90 95       	com	r25
    1c6a:	9b 01       	movw	r18, r22
    1c6c:	ac 01       	movw	r20, r24
    1c6e:	bd 01       	movw	r22, r26
    1c70:	cf 01       	movw	r24, r30
    1c72:	08 95       	ret

00001c74 <__muluhisi3>:
    1c74:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <__umulhisi3>
    1c78:	a5 9f       	mul	r26, r21
    1c7a:	90 0d       	add	r25, r0
    1c7c:	b4 9f       	mul	r27, r20
    1c7e:	90 0d       	add	r25, r0
    1c80:	a4 9f       	mul	r26, r20
    1c82:	80 0d       	add	r24, r0
    1c84:	91 1d       	adc	r25, r1
    1c86:	11 24       	eor	r1, r1
    1c88:	08 95       	ret

00001c8a <__udivmodhi4>:
    1c8a:	aa 1b       	sub	r26, r26
    1c8c:	bb 1b       	sub	r27, r27
    1c8e:	51 e1       	ldi	r21, 0x11	; 17
    1c90:	07 c0       	rjmp	.+14     	; 0x1ca0 <__udivmodhi4_ep>

00001c92 <__udivmodhi4_loop>:
    1c92:	aa 1f       	adc	r26, r26
    1c94:	bb 1f       	adc	r27, r27
    1c96:	a6 17       	cp	r26, r22
    1c98:	b7 07       	cpc	r27, r23
    1c9a:	10 f0       	brcs	.+4      	; 0x1ca0 <__udivmodhi4_ep>
    1c9c:	a6 1b       	sub	r26, r22
    1c9e:	b7 0b       	sbc	r27, r23

00001ca0 <__udivmodhi4_ep>:
    1ca0:	88 1f       	adc	r24, r24
    1ca2:	99 1f       	adc	r25, r25
    1ca4:	5a 95       	dec	r21
    1ca6:	a9 f7       	brne	.-22     	; 0x1c92 <__udivmodhi4_loop>
    1ca8:	80 95       	com	r24
    1caa:	90 95       	com	r25
    1cac:	bc 01       	movw	r22, r24
    1cae:	cd 01       	movw	r24, r26
    1cb0:	08 95       	ret

00001cb2 <__umulhisi3>:
    1cb2:	a2 9f       	mul	r26, r18
    1cb4:	b0 01       	movw	r22, r0
    1cb6:	b3 9f       	mul	r27, r19
    1cb8:	c0 01       	movw	r24, r0
    1cba:	a3 9f       	mul	r26, r19
    1cbc:	70 0d       	add	r23, r0
    1cbe:	81 1d       	adc	r24, r1
    1cc0:	11 24       	eor	r1, r1
    1cc2:	91 1d       	adc	r25, r1
    1cc4:	b2 9f       	mul	r27, r18
    1cc6:	70 0d       	add	r23, r0
    1cc8:	81 1d       	adc	r24, r1
    1cca:	11 24       	eor	r1, r1
    1ccc:	91 1d       	adc	r25, r1
    1cce:	08 95       	ret

00001cd0 <sprintf>:
    1cd0:	ae e0       	ldi	r26, 0x0E	; 14
    1cd2:	b0 e0       	ldi	r27, 0x00	; 0
    1cd4:	ee e6       	ldi	r30, 0x6E	; 110
    1cd6:	fe e0       	ldi	r31, 0x0E	; 14
    1cd8:	0c 94 29 11 	jmp	0x2252	; 0x2252 <__prologue_saves__+0x1c>
    1cdc:	0d 89       	ldd	r16, Y+21	; 0x15
    1cde:	1e 89       	ldd	r17, Y+22	; 0x16
    1ce0:	86 e0       	ldi	r24, 0x06	; 6
    1ce2:	8c 83       	std	Y+4, r24	; 0x04
    1ce4:	1a 83       	std	Y+2, r17	; 0x02
    1ce6:	09 83       	std	Y+1, r16	; 0x01
    1ce8:	8f ef       	ldi	r24, 0xFF	; 255
    1cea:	9f e7       	ldi	r25, 0x7F	; 127
    1cec:	9e 83       	std	Y+6, r25	; 0x06
    1cee:	8d 83       	std	Y+5, r24	; 0x05
    1cf0:	ae 01       	movw	r20, r28
    1cf2:	47 5e       	subi	r20, 0xE7	; 231
    1cf4:	5f 4f       	sbci	r21, 0xFF	; 255
    1cf6:	6f 89       	ldd	r22, Y+23	; 0x17
    1cf8:	78 8d       	ldd	r23, Y+24	; 0x18
    1cfa:	ce 01       	movw	r24, r28
    1cfc:	01 96       	adiw	r24, 0x01	; 1
    1cfe:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <vfprintf>
    1d02:	ef 81       	ldd	r30, Y+7	; 0x07
    1d04:	f8 85       	ldd	r31, Y+8	; 0x08
    1d06:	e0 0f       	add	r30, r16
    1d08:	f1 1f       	adc	r31, r17
    1d0a:	10 82       	st	Z, r1
    1d0c:	2e 96       	adiw	r28, 0x0e	; 14
    1d0e:	e4 e0       	ldi	r30, 0x04	; 4
    1d10:	0c 94 45 11 	jmp	0x228a	; 0x228a <__epilogue_restores__+0x1c>

00001d14 <vfprintf>:
    1d14:	ab e0       	ldi	r26, 0x0B	; 11
    1d16:	b0 e0       	ldi	r27, 0x00	; 0
    1d18:	e0 e9       	ldi	r30, 0x90	; 144
    1d1a:	fe e0       	ldi	r31, 0x0E	; 14
    1d1c:	0c 94 1b 11 	jmp	0x2236	; 0x2236 <__prologue_saves__>
    1d20:	6c 01       	movw	r12, r24
    1d22:	7b 01       	movw	r14, r22
    1d24:	8a 01       	movw	r16, r20
    1d26:	fc 01       	movw	r30, r24
    1d28:	17 82       	std	Z+7, r1	; 0x07
    1d2a:	16 82       	std	Z+6, r1	; 0x06
    1d2c:	83 81       	ldd	r24, Z+3	; 0x03
    1d2e:	81 ff       	sbrs	r24, 1
    1d30:	cc c1       	rjmp	.+920    	; 0x20ca <vfprintf+0x3b6>
    1d32:	ce 01       	movw	r24, r28
    1d34:	01 96       	adiw	r24, 0x01	; 1
    1d36:	3c 01       	movw	r6, r24
    1d38:	f6 01       	movw	r30, r12
    1d3a:	93 81       	ldd	r25, Z+3	; 0x03
    1d3c:	f7 01       	movw	r30, r14
    1d3e:	93 fd       	sbrc	r25, 3
    1d40:	85 91       	lpm	r24, Z+
    1d42:	93 ff       	sbrs	r25, 3
    1d44:	81 91       	ld	r24, Z+
    1d46:	7f 01       	movw	r14, r30
    1d48:	88 23       	and	r24, r24
    1d4a:	09 f4       	brne	.+2      	; 0x1d4e <vfprintf+0x3a>
    1d4c:	ba c1       	rjmp	.+884    	; 0x20c2 <vfprintf+0x3ae>
    1d4e:	85 32       	cpi	r24, 0x25	; 37
    1d50:	39 f4       	brne	.+14     	; 0x1d60 <vfprintf+0x4c>
    1d52:	93 fd       	sbrc	r25, 3
    1d54:	85 91       	lpm	r24, Z+
    1d56:	93 ff       	sbrs	r25, 3
    1d58:	81 91       	ld	r24, Z+
    1d5a:	7f 01       	movw	r14, r30
    1d5c:	85 32       	cpi	r24, 0x25	; 37
    1d5e:	29 f4       	brne	.+10     	; 0x1d6a <vfprintf+0x56>
    1d60:	b6 01       	movw	r22, r12
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    1d68:	e7 cf       	rjmp	.-50     	; 0x1d38 <vfprintf+0x24>
    1d6a:	91 2c       	mov	r9, r1
    1d6c:	21 2c       	mov	r2, r1
    1d6e:	31 2c       	mov	r3, r1
    1d70:	ff e1       	ldi	r31, 0x1F	; 31
    1d72:	f3 15       	cp	r31, r3
    1d74:	d8 f0       	brcs	.+54     	; 0x1dac <vfprintf+0x98>
    1d76:	8b 32       	cpi	r24, 0x2B	; 43
    1d78:	79 f0       	breq	.+30     	; 0x1d98 <vfprintf+0x84>
    1d7a:	38 f4       	brcc	.+14     	; 0x1d8a <vfprintf+0x76>
    1d7c:	80 32       	cpi	r24, 0x20	; 32
    1d7e:	79 f0       	breq	.+30     	; 0x1d9e <vfprintf+0x8a>
    1d80:	83 32       	cpi	r24, 0x23	; 35
    1d82:	a1 f4       	brne	.+40     	; 0x1dac <vfprintf+0x98>
    1d84:	23 2d       	mov	r18, r3
    1d86:	20 61       	ori	r18, 0x10	; 16
    1d88:	1d c0       	rjmp	.+58     	; 0x1dc4 <vfprintf+0xb0>
    1d8a:	8d 32       	cpi	r24, 0x2D	; 45
    1d8c:	61 f0       	breq	.+24     	; 0x1da6 <vfprintf+0x92>
    1d8e:	80 33       	cpi	r24, 0x30	; 48
    1d90:	69 f4       	brne	.+26     	; 0x1dac <vfprintf+0x98>
    1d92:	23 2d       	mov	r18, r3
    1d94:	21 60       	ori	r18, 0x01	; 1
    1d96:	16 c0       	rjmp	.+44     	; 0x1dc4 <vfprintf+0xb0>
    1d98:	83 2d       	mov	r24, r3
    1d9a:	82 60       	ori	r24, 0x02	; 2
    1d9c:	38 2e       	mov	r3, r24
    1d9e:	e3 2d       	mov	r30, r3
    1da0:	e4 60       	ori	r30, 0x04	; 4
    1da2:	3e 2e       	mov	r3, r30
    1da4:	2a c0       	rjmp	.+84     	; 0x1dfa <vfprintf+0xe6>
    1da6:	f3 2d       	mov	r31, r3
    1da8:	f8 60       	ori	r31, 0x08	; 8
    1daa:	1d c0       	rjmp	.+58     	; 0x1de6 <vfprintf+0xd2>
    1dac:	37 fc       	sbrc	r3, 7
    1dae:	2d c0       	rjmp	.+90     	; 0x1e0a <vfprintf+0xf6>
    1db0:	20 ed       	ldi	r18, 0xD0	; 208
    1db2:	28 0f       	add	r18, r24
    1db4:	2a 30       	cpi	r18, 0x0A	; 10
    1db6:	40 f0       	brcs	.+16     	; 0x1dc8 <vfprintf+0xb4>
    1db8:	8e 32       	cpi	r24, 0x2E	; 46
    1dba:	b9 f4       	brne	.+46     	; 0x1dea <vfprintf+0xd6>
    1dbc:	36 fc       	sbrc	r3, 6
    1dbe:	81 c1       	rjmp	.+770    	; 0x20c2 <vfprintf+0x3ae>
    1dc0:	23 2d       	mov	r18, r3
    1dc2:	20 64       	ori	r18, 0x40	; 64
    1dc4:	32 2e       	mov	r3, r18
    1dc6:	19 c0       	rjmp	.+50     	; 0x1dfa <vfprintf+0xe6>
    1dc8:	36 fe       	sbrs	r3, 6
    1dca:	06 c0       	rjmp	.+12     	; 0x1dd8 <vfprintf+0xc4>
    1dcc:	8a e0       	ldi	r24, 0x0A	; 10
    1dce:	98 9e       	mul	r9, r24
    1dd0:	20 0d       	add	r18, r0
    1dd2:	11 24       	eor	r1, r1
    1dd4:	92 2e       	mov	r9, r18
    1dd6:	11 c0       	rjmp	.+34     	; 0x1dfa <vfprintf+0xe6>
    1dd8:	ea e0       	ldi	r30, 0x0A	; 10
    1dda:	2e 9e       	mul	r2, r30
    1ddc:	20 0d       	add	r18, r0
    1dde:	11 24       	eor	r1, r1
    1de0:	22 2e       	mov	r2, r18
    1de2:	f3 2d       	mov	r31, r3
    1de4:	f0 62       	ori	r31, 0x20	; 32
    1de6:	3f 2e       	mov	r3, r31
    1de8:	08 c0       	rjmp	.+16     	; 0x1dfa <vfprintf+0xe6>
    1dea:	8c 36       	cpi	r24, 0x6C	; 108
    1dec:	21 f4       	brne	.+8      	; 0x1df6 <vfprintf+0xe2>
    1dee:	83 2d       	mov	r24, r3
    1df0:	80 68       	ori	r24, 0x80	; 128
    1df2:	38 2e       	mov	r3, r24
    1df4:	02 c0       	rjmp	.+4      	; 0x1dfa <vfprintf+0xe6>
    1df6:	88 36       	cpi	r24, 0x68	; 104
    1df8:	41 f4       	brne	.+16     	; 0x1e0a <vfprintf+0xf6>
    1dfa:	f7 01       	movw	r30, r14
    1dfc:	93 fd       	sbrc	r25, 3
    1dfe:	85 91       	lpm	r24, Z+
    1e00:	93 ff       	sbrs	r25, 3
    1e02:	81 91       	ld	r24, Z+
    1e04:	7f 01       	movw	r14, r30
    1e06:	81 11       	cpse	r24, r1
    1e08:	b3 cf       	rjmp	.-154    	; 0x1d70 <vfprintf+0x5c>
    1e0a:	98 2f       	mov	r25, r24
    1e0c:	9f 7d       	andi	r25, 0xDF	; 223
    1e0e:	95 54       	subi	r25, 0x45	; 69
    1e10:	93 30       	cpi	r25, 0x03	; 3
    1e12:	28 f4       	brcc	.+10     	; 0x1e1e <vfprintf+0x10a>
    1e14:	0c 5f       	subi	r16, 0xFC	; 252
    1e16:	1f 4f       	sbci	r17, 0xFF	; 255
    1e18:	9f e3       	ldi	r25, 0x3F	; 63
    1e1a:	99 83       	std	Y+1, r25	; 0x01
    1e1c:	0d c0       	rjmp	.+26     	; 0x1e38 <vfprintf+0x124>
    1e1e:	83 36       	cpi	r24, 0x63	; 99
    1e20:	31 f0       	breq	.+12     	; 0x1e2e <vfprintf+0x11a>
    1e22:	83 37       	cpi	r24, 0x73	; 115
    1e24:	71 f0       	breq	.+28     	; 0x1e42 <vfprintf+0x12e>
    1e26:	83 35       	cpi	r24, 0x53	; 83
    1e28:	09 f0       	breq	.+2      	; 0x1e2c <vfprintf+0x118>
    1e2a:	59 c0       	rjmp	.+178    	; 0x1ede <vfprintf+0x1ca>
    1e2c:	21 c0       	rjmp	.+66     	; 0x1e70 <vfprintf+0x15c>
    1e2e:	f8 01       	movw	r30, r16
    1e30:	80 81       	ld	r24, Z
    1e32:	89 83       	std	Y+1, r24	; 0x01
    1e34:	0e 5f       	subi	r16, 0xFE	; 254
    1e36:	1f 4f       	sbci	r17, 0xFF	; 255
    1e38:	88 24       	eor	r8, r8
    1e3a:	83 94       	inc	r8
    1e3c:	91 2c       	mov	r9, r1
    1e3e:	53 01       	movw	r10, r6
    1e40:	13 c0       	rjmp	.+38     	; 0x1e68 <vfprintf+0x154>
    1e42:	28 01       	movw	r4, r16
    1e44:	f2 e0       	ldi	r31, 0x02	; 2
    1e46:	4f 0e       	add	r4, r31
    1e48:	51 1c       	adc	r5, r1
    1e4a:	f8 01       	movw	r30, r16
    1e4c:	a0 80       	ld	r10, Z
    1e4e:	b1 80       	ldd	r11, Z+1	; 0x01
    1e50:	36 fe       	sbrs	r3, 6
    1e52:	03 c0       	rjmp	.+6      	; 0x1e5a <vfprintf+0x146>
    1e54:	69 2d       	mov	r22, r9
    1e56:	70 e0       	ldi	r23, 0x00	; 0
    1e58:	02 c0       	rjmp	.+4      	; 0x1e5e <vfprintf+0x14a>
    1e5a:	6f ef       	ldi	r22, 0xFF	; 255
    1e5c:	7f ef       	ldi	r23, 0xFF	; 255
    1e5e:	c5 01       	movw	r24, r10
    1e60:	0e 94 76 10 	call	0x20ec	; 0x20ec <strnlen>
    1e64:	4c 01       	movw	r8, r24
    1e66:	82 01       	movw	r16, r4
    1e68:	f3 2d       	mov	r31, r3
    1e6a:	ff 77       	andi	r31, 0x7F	; 127
    1e6c:	3f 2e       	mov	r3, r31
    1e6e:	16 c0       	rjmp	.+44     	; 0x1e9c <vfprintf+0x188>
    1e70:	28 01       	movw	r4, r16
    1e72:	22 e0       	ldi	r18, 0x02	; 2
    1e74:	42 0e       	add	r4, r18
    1e76:	51 1c       	adc	r5, r1
    1e78:	f8 01       	movw	r30, r16
    1e7a:	a0 80       	ld	r10, Z
    1e7c:	b1 80       	ldd	r11, Z+1	; 0x01
    1e7e:	36 fe       	sbrs	r3, 6
    1e80:	03 c0       	rjmp	.+6      	; 0x1e88 <vfprintf+0x174>
    1e82:	69 2d       	mov	r22, r9
    1e84:	70 e0       	ldi	r23, 0x00	; 0
    1e86:	02 c0       	rjmp	.+4      	; 0x1e8c <vfprintf+0x178>
    1e88:	6f ef       	ldi	r22, 0xFF	; 255
    1e8a:	7f ef       	ldi	r23, 0xFF	; 255
    1e8c:	c5 01       	movw	r24, r10
    1e8e:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <strnlen_P>
    1e92:	4c 01       	movw	r8, r24
    1e94:	f3 2d       	mov	r31, r3
    1e96:	f0 68       	ori	r31, 0x80	; 128
    1e98:	3f 2e       	mov	r3, r31
    1e9a:	82 01       	movw	r16, r4
    1e9c:	33 fc       	sbrc	r3, 3
    1e9e:	1b c0       	rjmp	.+54     	; 0x1ed6 <vfprintf+0x1c2>
    1ea0:	82 2d       	mov	r24, r2
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	88 16       	cp	r8, r24
    1ea6:	99 06       	cpc	r9, r25
    1ea8:	b0 f4       	brcc	.+44     	; 0x1ed6 <vfprintf+0x1c2>
    1eaa:	b6 01       	movw	r22, r12
    1eac:	80 e2       	ldi	r24, 0x20	; 32
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    1eb4:	2a 94       	dec	r2
    1eb6:	f4 cf       	rjmp	.-24     	; 0x1ea0 <vfprintf+0x18c>
    1eb8:	f5 01       	movw	r30, r10
    1eba:	37 fc       	sbrc	r3, 7
    1ebc:	85 91       	lpm	r24, Z+
    1ebe:	37 fe       	sbrs	r3, 7
    1ec0:	81 91       	ld	r24, Z+
    1ec2:	5f 01       	movw	r10, r30
    1ec4:	b6 01       	movw	r22, r12
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    1ecc:	21 10       	cpse	r2, r1
    1ece:	2a 94       	dec	r2
    1ed0:	21 e0       	ldi	r18, 0x01	; 1
    1ed2:	82 1a       	sub	r8, r18
    1ed4:	91 08       	sbc	r9, r1
    1ed6:	81 14       	cp	r8, r1
    1ed8:	91 04       	cpc	r9, r1
    1eda:	71 f7       	brne	.-36     	; 0x1eb8 <vfprintf+0x1a4>
    1edc:	e8 c0       	rjmp	.+464    	; 0x20ae <vfprintf+0x39a>
    1ede:	84 36       	cpi	r24, 0x64	; 100
    1ee0:	11 f0       	breq	.+4      	; 0x1ee6 <vfprintf+0x1d2>
    1ee2:	89 36       	cpi	r24, 0x69	; 105
    1ee4:	41 f5       	brne	.+80     	; 0x1f36 <vfprintf+0x222>
    1ee6:	f8 01       	movw	r30, r16
    1ee8:	37 fe       	sbrs	r3, 7
    1eea:	07 c0       	rjmp	.+14     	; 0x1efa <vfprintf+0x1e6>
    1eec:	60 81       	ld	r22, Z
    1eee:	71 81       	ldd	r23, Z+1	; 0x01
    1ef0:	82 81       	ldd	r24, Z+2	; 0x02
    1ef2:	93 81       	ldd	r25, Z+3	; 0x03
    1ef4:	0c 5f       	subi	r16, 0xFC	; 252
    1ef6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef8:	08 c0       	rjmp	.+16     	; 0x1f0a <vfprintf+0x1f6>
    1efa:	60 81       	ld	r22, Z
    1efc:	71 81       	ldd	r23, Z+1	; 0x01
    1efe:	07 2e       	mov	r0, r23
    1f00:	00 0c       	add	r0, r0
    1f02:	88 0b       	sbc	r24, r24
    1f04:	99 0b       	sbc	r25, r25
    1f06:	0e 5f       	subi	r16, 0xFE	; 254
    1f08:	1f 4f       	sbci	r17, 0xFF	; 255
    1f0a:	f3 2d       	mov	r31, r3
    1f0c:	ff 76       	andi	r31, 0x6F	; 111
    1f0e:	3f 2e       	mov	r3, r31
    1f10:	97 ff       	sbrs	r25, 7
    1f12:	09 c0       	rjmp	.+18     	; 0x1f26 <vfprintf+0x212>
    1f14:	90 95       	com	r25
    1f16:	80 95       	com	r24
    1f18:	70 95       	com	r23
    1f1a:	61 95       	neg	r22
    1f1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f1e:	8f 4f       	sbci	r24, 0xFF	; 255
    1f20:	9f 4f       	sbci	r25, 0xFF	; 255
    1f22:	f0 68       	ori	r31, 0x80	; 128
    1f24:	3f 2e       	mov	r3, r31
    1f26:	2a e0       	ldi	r18, 0x0A	; 10
    1f28:	30 e0       	ldi	r19, 0x00	; 0
    1f2a:	a3 01       	movw	r20, r6
    1f2c:	0e 94 bd 10 	call	0x217a	; 0x217a <__ultoa_invert>
    1f30:	88 2e       	mov	r8, r24
    1f32:	86 18       	sub	r8, r6
    1f34:	45 c0       	rjmp	.+138    	; 0x1fc0 <vfprintf+0x2ac>
    1f36:	85 37       	cpi	r24, 0x75	; 117
    1f38:	31 f4       	brne	.+12     	; 0x1f46 <vfprintf+0x232>
    1f3a:	23 2d       	mov	r18, r3
    1f3c:	2f 7e       	andi	r18, 0xEF	; 239
    1f3e:	b2 2e       	mov	r11, r18
    1f40:	2a e0       	ldi	r18, 0x0A	; 10
    1f42:	30 e0       	ldi	r19, 0x00	; 0
    1f44:	25 c0       	rjmp	.+74     	; 0x1f90 <vfprintf+0x27c>
    1f46:	93 2d       	mov	r25, r3
    1f48:	99 7f       	andi	r25, 0xF9	; 249
    1f4a:	b9 2e       	mov	r11, r25
    1f4c:	8f 36       	cpi	r24, 0x6F	; 111
    1f4e:	c1 f0       	breq	.+48     	; 0x1f80 <vfprintf+0x26c>
    1f50:	18 f4       	brcc	.+6      	; 0x1f58 <vfprintf+0x244>
    1f52:	88 35       	cpi	r24, 0x58	; 88
    1f54:	79 f0       	breq	.+30     	; 0x1f74 <vfprintf+0x260>
    1f56:	b5 c0       	rjmp	.+362    	; 0x20c2 <vfprintf+0x3ae>
    1f58:	80 37       	cpi	r24, 0x70	; 112
    1f5a:	19 f0       	breq	.+6      	; 0x1f62 <vfprintf+0x24e>
    1f5c:	88 37       	cpi	r24, 0x78	; 120
    1f5e:	21 f0       	breq	.+8      	; 0x1f68 <vfprintf+0x254>
    1f60:	b0 c0       	rjmp	.+352    	; 0x20c2 <vfprintf+0x3ae>
    1f62:	e9 2f       	mov	r30, r25
    1f64:	e0 61       	ori	r30, 0x10	; 16
    1f66:	be 2e       	mov	r11, r30
    1f68:	b4 fe       	sbrs	r11, 4
    1f6a:	0d c0       	rjmp	.+26     	; 0x1f86 <vfprintf+0x272>
    1f6c:	fb 2d       	mov	r31, r11
    1f6e:	f4 60       	ori	r31, 0x04	; 4
    1f70:	bf 2e       	mov	r11, r31
    1f72:	09 c0       	rjmp	.+18     	; 0x1f86 <vfprintf+0x272>
    1f74:	34 fe       	sbrs	r3, 4
    1f76:	0a c0       	rjmp	.+20     	; 0x1f8c <vfprintf+0x278>
    1f78:	29 2f       	mov	r18, r25
    1f7a:	26 60       	ori	r18, 0x06	; 6
    1f7c:	b2 2e       	mov	r11, r18
    1f7e:	06 c0       	rjmp	.+12     	; 0x1f8c <vfprintf+0x278>
    1f80:	28 e0       	ldi	r18, 0x08	; 8
    1f82:	30 e0       	ldi	r19, 0x00	; 0
    1f84:	05 c0       	rjmp	.+10     	; 0x1f90 <vfprintf+0x27c>
    1f86:	20 e1       	ldi	r18, 0x10	; 16
    1f88:	30 e0       	ldi	r19, 0x00	; 0
    1f8a:	02 c0       	rjmp	.+4      	; 0x1f90 <vfprintf+0x27c>
    1f8c:	20 e1       	ldi	r18, 0x10	; 16
    1f8e:	32 e0       	ldi	r19, 0x02	; 2
    1f90:	f8 01       	movw	r30, r16
    1f92:	b7 fe       	sbrs	r11, 7
    1f94:	07 c0       	rjmp	.+14     	; 0x1fa4 <vfprintf+0x290>
    1f96:	60 81       	ld	r22, Z
    1f98:	71 81       	ldd	r23, Z+1	; 0x01
    1f9a:	82 81       	ldd	r24, Z+2	; 0x02
    1f9c:	93 81       	ldd	r25, Z+3	; 0x03
    1f9e:	0c 5f       	subi	r16, 0xFC	; 252
    1fa0:	1f 4f       	sbci	r17, 0xFF	; 255
    1fa2:	06 c0       	rjmp	.+12     	; 0x1fb0 <vfprintf+0x29c>
    1fa4:	60 81       	ld	r22, Z
    1fa6:	71 81       	ldd	r23, Z+1	; 0x01
    1fa8:	80 e0       	ldi	r24, 0x00	; 0
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	0e 5f       	subi	r16, 0xFE	; 254
    1fae:	1f 4f       	sbci	r17, 0xFF	; 255
    1fb0:	a3 01       	movw	r20, r6
    1fb2:	0e 94 bd 10 	call	0x217a	; 0x217a <__ultoa_invert>
    1fb6:	88 2e       	mov	r8, r24
    1fb8:	86 18       	sub	r8, r6
    1fba:	fb 2d       	mov	r31, r11
    1fbc:	ff 77       	andi	r31, 0x7F	; 127
    1fbe:	3f 2e       	mov	r3, r31
    1fc0:	36 fe       	sbrs	r3, 6
    1fc2:	0d c0       	rjmp	.+26     	; 0x1fde <vfprintf+0x2ca>
    1fc4:	23 2d       	mov	r18, r3
    1fc6:	2e 7f       	andi	r18, 0xFE	; 254
    1fc8:	a2 2e       	mov	r10, r18
    1fca:	89 14       	cp	r8, r9
    1fcc:	58 f4       	brcc	.+22     	; 0x1fe4 <vfprintf+0x2d0>
    1fce:	34 fe       	sbrs	r3, 4
    1fd0:	0b c0       	rjmp	.+22     	; 0x1fe8 <vfprintf+0x2d4>
    1fd2:	32 fc       	sbrc	r3, 2
    1fd4:	09 c0       	rjmp	.+18     	; 0x1fe8 <vfprintf+0x2d4>
    1fd6:	83 2d       	mov	r24, r3
    1fd8:	8e 7e       	andi	r24, 0xEE	; 238
    1fda:	a8 2e       	mov	r10, r24
    1fdc:	05 c0       	rjmp	.+10     	; 0x1fe8 <vfprintf+0x2d4>
    1fde:	b8 2c       	mov	r11, r8
    1fe0:	a3 2c       	mov	r10, r3
    1fe2:	03 c0       	rjmp	.+6      	; 0x1fea <vfprintf+0x2d6>
    1fe4:	b8 2c       	mov	r11, r8
    1fe6:	01 c0       	rjmp	.+2      	; 0x1fea <vfprintf+0x2d6>
    1fe8:	b9 2c       	mov	r11, r9
    1fea:	a4 fe       	sbrs	r10, 4
    1fec:	0f c0       	rjmp	.+30     	; 0x200c <vfprintf+0x2f8>
    1fee:	fe 01       	movw	r30, r28
    1ff0:	e8 0d       	add	r30, r8
    1ff2:	f1 1d       	adc	r31, r1
    1ff4:	80 81       	ld	r24, Z
    1ff6:	80 33       	cpi	r24, 0x30	; 48
    1ff8:	21 f4       	brne	.+8      	; 0x2002 <vfprintf+0x2ee>
    1ffa:	9a 2d       	mov	r25, r10
    1ffc:	99 7e       	andi	r25, 0xE9	; 233
    1ffe:	a9 2e       	mov	r10, r25
    2000:	09 c0       	rjmp	.+18     	; 0x2014 <vfprintf+0x300>
    2002:	a2 fe       	sbrs	r10, 2
    2004:	06 c0       	rjmp	.+12     	; 0x2012 <vfprintf+0x2fe>
    2006:	b3 94       	inc	r11
    2008:	b3 94       	inc	r11
    200a:	04 c0       	rjmp	.+8      	; 0x2014 <vfprintf+0x300>
    200c:	8a 2d       	mov	r24, r10
    200e:	86 78       	andi	r24, 0x86	; 134
    2010:	09 f0       	breq	.+2      	; 0x2014 <vfprintf+0x300>
    2012:	b3 94       	inc	r11
    2014:	a3 fc       	sbrc	r10, 3
    2016:	11 c0       	rjmp	.+34     	; 0x203a <vfprintf+0x326>
    2018:	a0 fe       	sbrs	r10, 0
    201a:	06 c0       	rjmp	.+12     	; 0x2028 <vfprintf+0x314>
    201c:	b2 14       	cp	r11, r2
    201e:	88 f4       	brcc	.+34     	; 0x2042 <vfprintf+0x32e>
    2020:	28 0c       	add	r2, r8
    2022:	92 2c       	mov	r9, r2
    2024:	9b 18       	sub	r9, r11
    2026:	0e c0       	rjmp	.+28     	; 0x2044 <vfprintf+0x330>
    2028:	b2 14       	cp	r11, r2
    202a:	60 f4       	brcc	.+24     	; 0x2044 <vfprintf+0x330>
    202c:	b6 01       	movw	r22, r12
    202e:	80 e2       	ldi	r24, 0x20	; 32
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    2036:	b3 94       	inc	r11
    2038:	f7 cf       	rjmp	.-18     	; 0x2028 <vfprintf+0x314>
    203a:	b2 14       	cp	r11, r2
    203c:	18 f4       	brcc	.+6      	; 0x2044 <vfprintf+0x330>
    203e:	2b 18       	sub	r2, r11
    2040:	02 c0       	rjmp	.+4      	; 0x2046 <vfprintf+0x332>
    2042:	98 2c       	mov	r9, r8
    2044:	21 2c       	mov	r2, r1
    2046:	a4 fe       	sbrs	r10, 4
    2048:	10 c0       	rjmp	.+32     	; 0x206a <vfprintf+0x356>
    204a:	b6 01       	movw	r22, r12
    204c:	80 e3       	ldi	r24, 0x30	; 48
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    2054:	a2 fe       	sbrs	r10, 2
    2056:	17 c0       	rjmp	.+46     	; 0x2086 <vfprintf+0x372>
    2058:	a1 fc       	sbrc	r10, 1
    205a:	03 c0       	rjmp	.+6      	; 0x2062 <vfprintf+0x34e>
    205c:	88 e7       	ldi	r24, 0x78	; 120
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	02 c0       	rjmp	.+4      	; 0x2066 <vfprintf+0x352>
    2062:	88 e5       	ldi	r24, 0x58	; 88
    2064:	90 e0       	ldi	r25, 0x00	; 0
    2066:	b6 01       	movw	r22, r12
    2068:	0c c0       	rjmp	.+24     	; 0x2082 <vfprintf+0x36e>
    206a:	8a 2d       	mov	r24, r10
    206c:	86 78       	andi	r24, 0x86	; 134
    206e:	59 f0       	breq	.+22     	; 0x2086 <vfprintf+0x372>
    2070:	a1 fe       	sbrs	r10, 1
    2072:	02 c0       	rjmp	.+4      	; 0x2078 <vfprintf+0x364>
    2074:	8b e2       	ldi	r24, 0x2B	; 43
    2076:	01 c0       	rjmp	.+2      	; 0x207a <vfprintf+0x366>
    2078:	80 e2       	ldi	r24, 0x20	; 32
    207a:	a7 fc       	sbrc	r10, 7
    207c:	8d e2       	ldi	r24, 0x2D	; 45
    207e:	b6 01       	movw	r22, r12
    2080:	90 e0       	ldi	r25, 0x00	; 0
    2082:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    2086:	89 14       	cp	r8, r9
    2088:	38 f4       	brcc	.+14     	; 0x2098 <vfprintf+0x384>
    208a:	b6 01       	movw	r22, r12
    208c:	80 e3       	ldi	r24, 0x30	; 48
    208e:	90 e0       	ldi	r25, 0x00	; 0
    2090:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    2094:	9a 94       	dec	r9
    2096:	f7 cf       	rjmp	.-18     	; 0x2086 <vfprintf+0x372>
    2098:	8a 94       	dec	r8
    209a:	f3 01       	movw	r30, r6
    209c:	e8 0d       	add	r30, r8
    209e:	f1 1d       	adc	r31, r1
    20a0:	80 81       	ld	r24, Z
    20a2:	b6 01       	movw	r22, r12
    20a4:	90 e0       	ldi	r25, 0x00	; 0
    20a6:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    20aa:	81 10       	cpse	r8, r1
    20ac:	f5 cf       	rjmp	.-22     	; 0x2098 <vfprintf+0x384>
    20ae:	22 20       	and	r2, r2
    20b0:	09 f4       	brne	.+2      	; 0x20b4 <vfprintf+0x3a0>
    20b2:	42 ce       	rjmp	.-892    	; 0x1d38 <vfprintf+0x24>
    20b4:	b6 01       	movw	r22, r12
    20b6:	80 e2       	ldi	r24, 0x20	; 32
    20b8:	90 e0       	ldi	r25, 0x00	; 0
    20ba:	0e 94 81 10 	call	0x2102	; 0x2102 <fputc>
    20be:	2a 94       	dec	r2
    20c0:	f6 cf       	rjmp	.-20     	; 0x20ae <vfprintf+0x39a>
    20c2:	f6 01       	movw	r30, r12
    20c4:	86 81       	ldd	r24, Z+6	; 0x06
    20c6:	97 81       	ldd	r25, Z+7	; 0x07
    20c8:	02 c0       	rjmp	.+4      	; 0x20ce <vfprintf+0x3ba>
    20ca:	8f ef       	ldi	r24, 0xFF	; 255
    20cc:	9f ef       	ldi	r25, 0xFF	; 255
    20ce:	2b 96       	adiw	r28, 0x0b	; 11
    20d0:	e2 e1       	ldi	r30, 0x12	; 18
    20d2:	0c 94 37 11 	jmp	0x226e	; 0x226e <__epilogue_restores__>

000020d6 <strnlen_P>:
    20d6:	fc 01       	movw	r30, r24
    20d8:	05 90       	lpm	r0, Z+
    20da:	61 50       	subi	r22, 0x01	; 1
    20dc:	70 40       	sbci	r23, 0x00	; 0
    20de:	01 10       	cpse	r0, r1
    20e0:	d8 f7       	brcc	.-10     	; 0x20d8 <strnlen_P+0x2>
    20e2:	80 95       	com	r24
    20e4:	90 95       	com	r25
    20e6:	8e 0f       	add	r24, r30
    20e8:	9f 1f       	adc	r25, r31
    20ea:	08 95       	ret

000020ec <strnlen>:
    20ec:	fc 01       	movw	r30, r24
    20ee:	61 50       	subi	r22, 0x01	; 1
    20f0:	70 40       	sbci	r23, 0x00	; 0
    20f2:	01 90       	ld	r0, Z+
    20f4:	01 10       	cpse	r0, r1
    20f6:	d8 f7       	brcc	.-10     	; 0x20ee <strnlen+0x2>
    20f8:	80 95       	com	r24
    20fa:	90 95       	com	r25
    20fc:	8e 0f       	add	r24, r30
    20fe:	9f 1f       	adc	r25, r31
    2100:	08 95       	ret

00002102 <fputc>:
    2102:	0f 93       	push	r16
    2104:	1f 93       	push	r17
    2106:	cf 93       	push	r28
    2108:	df 93       	push	r29
    210a:	fb 01       	movw	r30, r22
    210c:	23 81       	ldd	r18, Z+3	; 0x03
    210e:	21 fd       	sbrc	r18, 1
    2110:	03 c0       	rjmp	.+6      	; 0x2118 <fputc+0x16>
    2112:	8f ef       	ldi	r24, 0xFF	; 255
    2114:	9f ef       	ldi	r25, 0xFF	; 255
    2116:	2c c0       	rjmp	.+88     	; 0x2170 <fputc+0x6e>
    2118:	22 ff       	sbrs	r18, 2
    211a:	16 c0       	rjmp	.+44     	; 0x2148 <fputc+0x46>
    211c:	46 81       	ldd	r20, Z+6	; 0x06
    211e:	57 81       	ldd	r21, Z+7	; 0x07
    2120:	24 81       	ldd	r18, Z+4	; 0x04
    2122:	35 81       	ldd	r19, Z+5	; 0x05
    2124:	42 17       	cp	r20, r18
    2126:	53 07       	cpc	r21, r19
    2128:	44 f4       	brge	.+16     	; 0x213a <fputc+0x38>
    212a:	a0 81       	ld	r26, Z
    212c:	b1 81       	ldd	r27, Z+1	; 0x01
    212e:	9d 01       	movw	r18, r26
    2130:	2f 5f       	subi	r18, 0xFF	; 255
    2132:	3f 4f       	sbci	r19, 0xFF	; 255
    2134:	31 83       	std	Z+1, r19	; 0x01
    2136:	20 83       	st	Z, r18
    2138:	8c 93       	st	X, r24
    213a:	26 81       	ldd	r18, Z+6	; 0x06
    213c:	37 81       	ldd	r19, Z+7	; 0x07
    213e:	2f 5f       	subi	r18, 0xFF	; 255
    2140:	3f 4f       	sbci	r19, 0xFF	; 255
    2142:	37 83       	std	Z+7, r19	; 0x07
    2144:	26 83       	std	Z+6, r18	; 0x06
    2146:	14 c0       	rjmp	.+40     	; 0x2170 <fputc+0x6e>
    2148:	8b 01       	movw	r16, r22
    214a:	ec 01       	movw	r28, r24
    214c:	fb 01       	movw	r30, r22
    214e:	00 84       	ldd	r0, Z+8	; 0x08
    2150:	f1 85       	ldd	r31, Z+9	; 0x09
    2152:	e0 2d       	mov	r30, r0
    2154:	09 95       	icall
    2156:	89 2b       	or	r24, r25
    2158:	e1 f6       	brne	.-72     	; 0x2112 <fputc+0x10>
    215a:	d8 01       	movw	r26, r16
    215c:	16 96       	adiw	r26, 0x06	; 6
    215e:	8d 91       	ld	r24, X+
    2160:	9c 91       	ld	r25, X
    2162:	17 97       	sbiw	r26, 0x07	; 7
    2164:	01 96       	adiw	r24, 0x01	; 1
    2166:	17 96       	adiw	r26, 0x07	; 7
    2168:	9c 93       	st	X, r25
    216a:	8e 93       	st	-X, r24
    216c:	16 97       	sbiw	r26, 0x06	; 6
    216e:	ce 01       	movw	r24, r28
    2170:	df 91       	pop	r29
    2172:	cf 91       	pop	r28
    2174:	1f 91       	pop	r17
    2176:	0f 91       	pop	r16
    2178:	08 95       	ret

0000217a <__ultoa_invert>:
    217a:	fa 01       	movw	r30, r20
    217c:	aa 27       	eor	r26, r26
    217e:	28 30       	cpi	r18, 0x08	; 8
    2180:	51 f1       	breq	.+84     	; 0x21d6 <__ultoa_invert+0x5c>
    2182:	20 31       	cpi	r18, 0x10	; 16
    2184:	81 f1       	breq	.+96     	; 0x21e6 <__ultoa_invert+0x6c>
    2186:	e8 94       	clt
    2188:	6f 93       	push	r22
    218a:	6e 7f       	andi	r22, 0xFE	; 254
    218c:	6e 5f       	subi	r22, 0xFE	; 254
    218e:	7f 4f       	sbci	r23, 0xFF	; 255
    2190:	8f 4f       	sbci	r24, 0xFF	; 255
    2192:	9f 4f       	sbci	r25, 0xFF	; 255
    2194:	af 4f       	sbci	r26, 0xFF	; 255
    2196:	b1 e0       	ldi	r27, 0x01	; 1
    2198:	3e d0       	rcall	.+124    	; 0x2216 <__ultoa_invert+0x9c>
    219a:	b4 e0       	ldi	r27, 0x04	; 4
    219c:	3c d0       	rcall	.+120    	; 0x2216 <__ultoa_invert+0x9c>
    219e:	67 0f       	add	r22, r23
    21a0:	78 1f       	adc	r23, r24
    21a2:	89 1f       	adc	r24, r25
    21a4:	9a 1f       	adc	r25, r26
    21a6:	a1 1d       	adc	r26, r1
    21a8:	68 0f       	add	r22, r24
    21aa:	79 1f       	adc	r23, r25
    21ac:	8a 1f       	adc	r24, r26
    21ae:	91 1d       	adc	r25, r1
    21b0:	a1 1d       	adc	r26, r1
    21b2:	6a 0f       	add	r22, r26
    21b4:	71 1d       	adc	r23, r1
    21b6:	81 1d       	adc	r24, r1
    21b8:	91 1d       	adc	r25, r1
    21ba:	a1 1d       	adc	r26, r1
    21bc:	20 d0       	rcall	.+64     	; 0x21fe <__ultoa_invert+0x84>
    21be:	09 f4       	brne	.+2      	; 0x21c2 <__ultoa_invert+0x48>
    21c0:	68 94       	set
    21c2:	3f 91       	pop	r19
    21c4:	2a e0       	ldi	r18, 0x0A	; 10
    21c6:	26 9f       	mul	r18, r22
    21c8:	11 24       	eor	r1, r1
    21ca:	30 19       	sub	r19, r0
    21cc:	30 5d       	subi	r19, 0xD0	; 208
    21ce:	31 93       	st	Z+, r19
    21d0:	de f6       	brtc	.-74     	; 0x2188 <__ultoa_invert+0xe>
    21d2:	cf 01       	movw	r24, r30
    21d4:	08 95       	ret
    21d6:	46 2f       	mov	r20, r22
    21d8:	47 70       	andi	r20, 0x07	; 7
    21da:	40 5d       	subi	r20, 0xD0	; 208
    21dc:	41 93       	st	Z+, r20
    21de:	b3 e0       	ldi	r27, 0x03	; 3
    21e0:	0f d0       	rcall	.+30     	; 0x2200 <__ultoa_invert+0x86>
    21e2:	c9 f7       	brne	.-14     	; 0x21d6 <__ultoa_invert+0x5c>
    21e4:	f6 cf       	rjmp	.-20     	; 0x21d2 <__ultoa_invert+0x58>
    21e6:	46 2f       	mov	r20, r22
    21e8:	4f 70       	andi	r20, 0x0F	; 15
    21ea:	40 5d       	subi	r20, 0xD0	; 208
    21ec:	4a 33       	cpi	r20, 0x3A	; 58
    21ee:	18 f0       	brcs	.+6      	; 0x21f6 <__ultoa_invert+0x7c>
    21f0:	49 5d       	subi	r20, 0xD9	; 217
    21f2:	31 fd       	sbrc	r19, 1
    21f4:	40 52       	subi	r20, 0x20	; 32
    21f6:	41 93       	st	Z+, r20
    21f8:	02 d0       	rcall	.+4      	; 0x21fe <__ultoa_invert+0x84>
    21fa:	a9 f7       	brne	.-22     	; 0x21e6 <__ultoa_invert+0x6c>
    21fc:	ea cf       	rjmp	.-44     	; 0x21d2 <__ultoa_invert+0x58>
    21fe:	b4 e0       	ldi	r27, 0x04	; 4
    2200:	a6 95       	lsr	r26
    2202:	97 95       	ror	r25
    2204:	87 95       	ror	r24
    2206:	77 95       	ror	r23
    2208:	67 95       	ror	r22
    220a:	ba 95       	dec	r27
    220c:	c9 f7       	brne	.-14     	; 0x2200 <__ultoa_invert+0x86>
    220e:	00 97       	sbiw	r24, 0x00	; 0
    2210:	61 05       	cpc	r22, r1
    2212:	71 05       	cpc	r23, r1
    2214:	08 95       	ret
    2216:	9b 01       	movw	r18, r22
    2218:	ac 01       	movw	r20, r24
    221a:	0a 2e       	mov	r0, r26
    221c:	06 94       	lsr	r0
    221e:	57 95       	ror	r21
    2220:	47 95       	ror	r20
    2222:	37 95       	ror	r19
    2224:	27 95       	ror	r18
    2226:	ba 95       	dec	r27
    2228:	c9 f7       	brne	.-14     	; 0x221c <__ultoa_invert+0xa2>
    222a:	62 0f       	add	r22, r18
    222c:	73 1f       	adc	r23, r19
    222e:	84 1f       	adc	r24, r20
    2230:	95 1f       	adc	r25, r21
    2232:	a0 1d       	adc	r26, r0
    2234:	08 95       	ret

00002236 <__prologue_saves__>:
    2236:	2f 92       	push	r2
    2238:	3f 92       	push	r3
    223a:	4f 92       	push	r4
    223c:	5f 92       	push	r5
    223e:	6f 92       	push	r6
    2240:	7f 92       	push	r7
    2242:	8f 92       	push	r8
    2244:	9f 92       	push	r9
    2246:	af 92       	push	r10
    2248:	bf 92       	push	r11
    224a:	cf 92       	push	r12
    224c:	df 92       	push	r13
    224e:	ef 92       	push	r14
    2250:	ff 92       	push	r15
    2252:	0f 93       	push	r16
    2254:	1f 93       	push	r17
    2256:	cf 93       	push	r28
    2258:	df 93       	push	r29
    225a:	cd b7       	in	r28, 0x3d	; 61
    225c:	de b7       	in	r29, 0x3e	; 62
    225e:	ca 1b       	sub	r28, r26
    2260:	db 0b       	sbc	r29, r27
    2262:	0f b6       	in	r0, 0x3f	; 63
    2264:	f8 94       	cli
    2266:	de bf       	out	0x3e, r29	; 62
    2268:	0f be       	out	0x3f, r0	; 63
    226a:	cd bf       	out	0x3d, r28	; 61
    226c:	09 94       	ijmp

0000226e <__epilogue_restores__>:
    226e:	2a 88       	ldd	r2, Y+18	; 0x12
    2270:	39 88       	ldd	r3, Y+17	; 0x11
    2272:	48 88       	ldd	r4, Y+16	; 0x10
    2274:	5f 84       	ldd	r5, Y+15	; 0x0f
    2276:	6e 84       	ldd	r6, Y+14	; 0x0e
    2278:	7d 84       	ldd	r7, Y+13	; 0x0d
    227a:	8c 84       	ldd	r8, Y+12	; 0x0c
    227c:	9b 84       	ldd	r9, Y+11	; 0x0b
    227e:	aa 84       	ldd	r10, Y+10	; 0x0a
    2280:	b9 84       	ldd	r11, Y+9	; 0x09
    2282:	c8 84       	ldd	r12, Y+8	; 0x08
    2284:	df 80       	ldd	r13, Y+7	; 0x07
    2286:	ee 80       	ldd	r14, Y+6	; 0x06
    2288:	fd 80       	ldd	r15, Y+5	; 0x05
    228a:	0c 81       	ldd	r16, Y+4	; 0x04
    228c:	1b 81       	ldd	r17, Y+3	; 0x03
    228e:	aa 81       	ldd	r26, Y+2	; 0x02
    2290:	b9 81       	ldd	r27, Y+1	; 0x01
    2292:	ce 0f       	add	r28, r30
    2294:	d1 1d       	adc	r29, r1
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	f8 94       	cli
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	cd bf       	out	0x3d, r28	; 61
    22a0:	ed 01       	movw	r28, r26
    22a2:	08 95       	ret

000022a4 <_exit>:
    22a4:	f8 94       	cli

000022a6 <__stop_program>:
    22a6:	ff cf       	rjmp	.-2      	; 0x22a6 <__stop_program>
