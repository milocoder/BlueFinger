
SD_kaart4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000bc  00800100  00002298  0000232c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002298  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000319  008001bc  008001bc  000023e8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000023e8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002444  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000190  00000000  00000000  00002480  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000029f0  00000000  00000000  00002610  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001158  00000000  00000000  00005000  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000016c6  00000000  00000000  00006158  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000654  00000000  00000000  00007820  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009f0  00000000  00000000  00007e74  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000025bc  00000000  00000000  00008864  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000168  00000000  00000000  0000ae20  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 28 04 	jmp	0x850	; 0x850 <__vector_10>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_18>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf ef       	ldi	r28, 0xFF	; 255
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e0       	ldi	r26, 0x00	; 0
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	e8 e9       	ldi	r30, 0x98	; 152
      a8:	f2 e2       	ldi	r31, 0x22	; 34
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	ac 3b       	cpi	r26, 0xBC	; 188
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	24 e0       	ldi	r18, 0x04	; 4
      b8:	ac eb       	ldi	r26, 0xBC	; 188
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	a5 3d       	cpi	r26, 0xD5	; 213
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 9c 05 	call	0xb38	; 0xb38 <main>
      ca:	0c 94 4a 11 	jmp	0x2294	; 0x2294 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <initCAN>:

	// Set the MOB's mode to transmission, also activating it.
	CANCDMOB |= (0x01 << CONMOB0);

	return 1;
}
      d2:	e8 ed       	ldi	r30, 0xD8	; 216
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	80 81       	ld	r24, Z
      d8:	81 60       	ori	r24, 0x01	; 1
      da:	80 83       	st	Z, r24
      dc:	86 e0       	ldi	r24, 0x06	; 6
      de:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7f80e2>
      e2:	84 e0       	ldi	r24, 0x04	; 4
      e4:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7f80e3>
      e8:	83 e1       	ldi	r24, 0x13	; 19
      ea:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7f80e4>
      ee:	80 e0       	ldi	r24, 0x00	; 0
      f0:	08 c0       	rjmp	.+16     	; 0x102 <initCAN+0x30>
      f2:	98 2f       	mov	r25, r24
      f4:	92 95       	swap	r25
      f6:	90 7f       	andi	r25, 0xF0	; 240
      f8:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
      fc:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     100:	8f 5f       	subi	r24, 0xFF	; 255
     102:	8f 30       	cpi	r24, 0x0F	; 15
     104:	b0 f3       	brcs	.-20     	; 0xf2 <initCAN+0x20>
     106:	78 94       	sei
     108:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     10c:	80 eb       	ldi	r24, 0xB0	; 176
     10e:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7f80db>
     112:	e8 ed       	ldi	r30, 0xD8	; 216
     114:	f0 e0       	ldi	r31, 0x00	; 0
     116:	80 81       	ld	r24, Z
     118:	82 60       	ori	r24, 0x02	; 2
     11a:	80 83       	st	Z, r24
     11c:	08 95       	ret

0000011e <getFreeMob>:
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	0a c0       	rjmp	.+20     	; 0x136 <getFreeMob+0x18>
     122:	98 2f       	mov	r25, r24
     124:	92 95       	swap	r25
     126:	90 7f       	andi	r25, 0xF0	; 240
     128:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     12c:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     130:	90 7c       	andi	r25, 0xC0	; 192
     132:	21 f0       	breq	.+8      	; 0x13c <getFreeMob+0x1e>
     134:	8f 5f       	subi	r24, 0xFF	; 255
     136:	8f 30       	cpi	r24, 0x0F	; 15
     138:	a0 f3       	brcs	.-24     	; 0x122 <getFreeMob+0x4>
     13a:	8f ef       	ldi	r24, 0xFF	; 255
     13c:	08 95       	ret

0000013e <listenForMessage>:
 * @param[in] id - the provided id
 * @return 0 if no free message objects left, 1 otherwise
 *
 */
uint8_t listenForMessage( uint16_t id, uint8_t expectedLength )
{
     13e:	1f 93       	push	r17
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	ec 01       	movw	r28, r24
     146:	16 2f       	mov	r17, r22
	// Try to get a free MOb
	uint8_t mobIndex = getFreeMob();
     148:	0e 94 8f 00 	call	0x11e	; 0x11e <getFreeMob>

	if( mobIndex == 0xFF )
     14c:	8f 3f       	cpi	r24, 0xFF	; 255
     14e:	09 f4       	brne	.+2      	; 0x152 <listenForMessage+0x14>
     150:	4e c0       	rjmp	.+156    	; 0x1ee <listenForMessage+0xb0>
		// No free Message Objects
		return 0;
	}

	// Point to the free message object
	CANPAGE |= (mobIndex << 4);
     152:	ed ee       	ldi	r30, 0xED	; 237
     154:	f0 e0       	ldi	r31, 0x00	; 0
     156:	90 81       	ld	r25, Z
     158:	48 2f       	mov	r20, r24
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	9a 01       	movw	r18, r20
     15e:	22 95       	swap	r18
     160:	32 95       	swap	r19
     162:	30 7f       	andi	r19, 0xF0	; 240
     164:	32 27       	eor	r19, r18
     166:	20 7f       	andi	r18, 0xF0	; 240
     168:	32 27       	eor	r19, r18
     16a:	29 2b       	or	r18, r25
     16c:	20 83       	st	Z, r18

	// Set the MOb's CAN id to the id to be listened for
	CANIDT4 = 0;
     16e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
	CANIDT3 = 0;
     172:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
	CANIDT2 = id << 5;
     176:	9c 2f       	mov	r25, r28
     178:	92 95       	swap	r25
     17a:	99 0f       	add	r25, r25
     17c:	90 7e       	andi	r25, 0xE0	; 224
     17e:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
	CANIDT1 = id >> 3;
     182:	d6 95       	lsr	r29
     184:	c7 95       	ror	r28
     186:	d6 95       	lsr	r29
     188:	c7 95       	ror	r28
     18a:	d6 95       	lsr	r29
     18c:	c7 95       	ror	r28
     18e:	c0 93 f3 00 	sts	0x00F3, r28	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>

	if( expectedLength > 8 )
     192:	19 30       	cpi	r17, 0x09	; 9
     194:	08 f0       	brcs	.+2      	; 0x198 <listenForMessage+0x5a>
	{
		expectedLength = 8;
     196:	18 e0       	ldi	r17, 0x08	; 8
	}

	// Set the MOb's expected length
	CANCDMOB |= expectedLength;
     198:	ef ee       	ldi	r30, 0xEF	; 239
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	60 81       	ld	r22, Z
     19e:	61 2b       	or	r22, r17
     1a0:	60 83       	st	Z, r22

	// Enable interrupts for this MOb
	if( mobIndex < 8 )
     1a2:	88 30       	cpi	r24, 0x08	; 8
     1a4:	78 f4       	brcc	.+30     	; 0x1c4 <listenForMessage+0x86>
	{
		CANIE2 |= (1 << mobIndex);
     1a6:	ee ed       	ldi	r30, 0xDE	; 222
     1a8:	f0 e0       	ldi	r31, 0x00	; 0
     1aa:	40 81       	ld	r20, Z
     1ac:	21 e0       	ldi	r18, 0x01	; 1
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	b9 01       	movw	r22, r18
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <listenForMessage+0x7a>
     1b4:	66 0f       	add	r22, r22
     1b6:	77 1f       	adc	r23, r23
     1b8:	8a 95       	dec	r24
     1ba:	e2 f7       	brpl	.-8      	; 0x1b4 <listenForMessage+0x76>
     1bc:	cb 01       	movw	r24, r22
     1be:	84 2b       	or	r24, r20
     1c0:	80 83       	st	Z, r24
     1c2:	0e c0       	rjmp	.+28     	; 0x1e0 <listenForMessage+0xa2>
	}
	else
	{
		CANIE1 |= (1 << (mobIndex-8));
     1c4:	ef ed       	ldi	r30, 0xDF	; 223
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	20 81       	ld	r18, Z
     1ca:	48 50       	subi	r20, 0x08	; 8
     1cc:	51 09       	sbc	r21, r1
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <listenForMessage+0x9a>
     1d4:	88 0f       	add	r24, r24
     1d6:	99 1f       	adc	r25, r25
     1d8:	4a 95       	dec	r20
     1da:	e2 f7       	brpl	.-8      	; 0x1d4 <listenForMessage+0x96>
     1dc:	82 2b       	or	r24, r18
     1de:	80 83       	st	Z, r24
	}

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);
     1e0:	ef ee       	ldi	r30, 0xEF	; 239
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	80 68       	ori	r24, 0x80	; 128
     1e8:	80 83       	st	Z, r24

	return 1;
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <listenForMessage+0xb2>
	uint8_t mobIndex = getFreeMob();

	if( mobIndex == 0xFF )
	{
		// No free Message Objects
		return 0;
     1ee:	80 e0       	ldi	r24, 0x00	; 0

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);

	return 1;
}
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	1f 91       	pop	r17
     1f6:	08 95       	ret

000001f8 <getMessage>:
 * @param[out] message - message data to fill
 * @return 1 if message was filled, 0 otherwise
 *
 */
uint8_t getMessage( CANMessage * message )
{
     1f8:	dc 01       	movw	r26, r24
	// Default to no message available
	uint8_t messageAvailable = 0;

	if( serviceIndex != bufIndex )
     1fa:	e0 91 be 01 	lds	r30, 0x01BE	; 0x8001be <serviceIndex>
     1fe:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <bufIndex>
     202:	e8 17       	cp	r30, r24
     204:	09 f4       	brne	.+2      	; 0x208 <getMessage+0x10>
     206:	41 c0       	rjmp	.+130    	; 0x28a <getMessage+0x92>
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
     208:	2b e0       	ldi	r18, 0x0B	; 11
     20a:	2e 9f       	mul	r18, r30
     20c:	f0 01       	movw	r30, r0
     20e:	11 24       	eor	r1, r1
     210:	e1 53       	subi	r30, 0x31	; 49
     212:	fc 4f       	sbci	r31, 0xFC	; 252
     214:	30 81       	ld	r19, Z
     216:	81 81       	ldd	r24, Z+1	; 0x01
     218:	98 2f       	mov	r25, r24
     21a:	97 70       	andi	r25, 0x07	; 7
     21c:	3c 93       	st	X, r19
     21e:	11 96       	adiw	r26, 0x01	; 1
     220:	8c 91       	ld	r24, X
     222:	11 97       	sbiw	r26, 0x01	; 1
     224:	88 7f       	andi	r24, 0xF8	; 248
     226:	89 2b       	or	r24, r25
     228:	11 96       	adiw	r26, 0x01	; 1
     22a:	8c 93       	st	X, r24
     22c:	11 97       	sbiw	r26, 0x01	; 1
		message->length = messageBuffer[ serviceIndex ].length;
     22e:	60 91 be 01 	lds	r22, 0x01BE	; 0x8001be <serviceIndex>
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	26 9f       	mul	r18, r22
     236:	f0 01       	movw	r30, r0
     238:	27 9f       	mul	r18, r23
     23a:	f0 0d       	add	r31, r0
     23c:	11 24       	eor	r1, r1
     23e:	e1 53       	subi	r30, 0x31	; 49
     240:	fc 4f       	sbci	r31, 0xFC	; 252
     242:	82 85       	ldd	r24, Z+10	; 0x0a
     244:	1a 96       	adiw	r26, 0x0a	; 10
     246:	8c 93       	st	X, r24
     248:	1a 97       	sbiw	r26, 0x0a	; 10

		for( uint8_t i = 0; i < message->length; ++i )
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	12 c0       	rjmp	.+36     	; 0x272 <getMessage+0x7a>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
     24e:	29 2f       	mov	r18, r25
     250:	30 e0       	ldi	r19, 0x00	; 0
     252:	4b e0       	ldi	r20, 0x0B	; 11
     254:	46 9f       	mul	r20, r22
     256:	f0 01       	movw	r30, r0
     258:	47 9f       	mul	r20, r23
     25a:	f0 0d       	add	r31, r0
     25c:	11 24       	eor	r1, r1
     25e:	e1 53       	subi	r30, 0x31	; 49
     260:	fc 4f       	sbci	r31, 0xFC	; 252
     262:	e2 0f       	add	r30, r18
     264:	f3 1f       	adc	r31, r19
     266:	42 81       	ldd	r20, Z+2	; 0x02
     268:	fd 01       	movw	r30, r26
     26a:	e2 0f       	add	r30, r18
     26c:	f3 1f       	adc	r31, r19
     26e:	42 83       	std	Z+2, r20	; 0x02
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
		message->length = messageBuffer[ serviceIndex ].length;

		for( uint8_t i = 0; i < message->length; ++i )
     270:	9f 5f       	subi	r25, 0xFF	; 255
     272:	98 17       	cp	r25, r24
     274:	60 f3       	brcs	.-40     	; 0x24e <getMessage+0x56>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
		}

		// Increment the index pointing to the next message to be serviced
		serviceIndex = (serviceIndex + 1) % MESSAGE_BUFFER_LENGTH;
     276:	cb 01       	movw	r24, r22
     278:	01 96       	adiw	r24, 0x01	; 1
     27a:	64 e1       	ldi	r22, 0x14	; 20
     27c:	70 e0       	ldi	r23, 0x00	; 0
     27e:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <__divmodhi4>
     282:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <serviceIndex>

		messageAvailable = 1;
     286:	81 e0       	ldi	r24, 0x01	; 1
     288:	08 95       	ret
 *
 */
uint8_t getMessage( CANMessage * message )
{
	// Default to no message available
	uint8_t messageAvailable = 0;
     28a:	80 e0       	ldi	r24, 0x00	; 0

		messageAvailable = 1;
	}

	return messageAvailable;
}
     28c:	08 95       	ret

0000028e <__vector_18>:
 * Note that the NO_BLOCK attribute is not applied here, so while this is running,
 * all interrupts are blocked.
 *
 */
ISR( CANIT_vect )
{
     28e:	1f 92       	push	r1
     290:	0f 92       	push	r0
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	0f 92       	push	r0
     296:	11 24       	eor	r1, r1
     298:	2f 93       	push	r18
     29a:	3f 93       	push	r19
     29c:	4f 93       	push	r20
     29e:	5f 93       	push	r21
     2a0:	6f 93       	push	r22
     2a2:	7f 93       	push	r23
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	cf 93       	push	r28
     2ae:	ef 93       	push	r30
     2b0:	ff 93       	push	r31
	// **Save off CANPAGE to prevent application code bugs**
	uint8_t canPage = CANPAGE;
     2b2:	c0 91 ed 00 	lds	r28, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     2b6:	87 c0       	rjmp	.+270    	; 0x3c6 <__vector_18+0x138>
	{
		// Point to the Message Object that needs to be serviced
		CANPAGE = CANHPMOB & 0xF0;
     2b8:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     2bc:	80 7f       	andi	r24, 0xF0	; 240
     2be:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

		// Service the correct kind of interrupt
		// Transmit Interrupts
		if( CANSTMOB & (1 << TXOK) )
     2c2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2c6:	86 ff       	sbrs	r24, 6
     2c8:	0c c0       	rjmp	.+24     	; 0x2e2 <__vector_18+0x54>
		{
			// Acknowledge the interrupt
			CANSTMOB = 0;
     2ca:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			// Free up the MOb
			CANCDMOB = 0;
     2ce:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>

			// Determine the MOb index
			uint8_t mob = (CANPAGE & 0xF0) >> 8;
     2d2:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

			// Disable interrupts for this MOb
			if( mob < 8 )
			{
				CANIE2 &= ~(1 << mob);
     2d6:	ee ed       	ldi	r30, 0xDE	; 222
     2d8:	f0 e0       	ldi	r31, 0x00	; 0
     2da:	80 81       	ld	r24, Z
     2dc:	8e 7f       	andi	r24, 0xFE	; 254
     2de:	80 83       	st	Z, r24
     2e0:	72 c0       	rjmp	.+228    	; 0x3c6 <__vector_18+0x138>
			{
				CANIE1 &= ~(1 << (mob-8));
			}
		}
		// Receive Interrupts
		else if ( CANSTMOB & (1 << RXOK) )
     2e2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2e6:	85 ff       	sbrs	r24, 5
     2e8:	62 c0       	rjmp	.+196    	; 0x3ae <__vector_18+0x120>
		{
			// Default to impossible ID
			uint16_t id = 0xFFFF;

			// Load the message data into a free message buffer object
			if( CANCDMOB & (1 << IDE) )
     2ea:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     2ee:	84 ff       	sbrs	r24, 4
     2f0:	0e c0       	rjmp	.+28     	; 0x30e <__vector_18+0x80>
			{
				// Message type is CAN 2.0B
				id = (CANIDT4 >> 3) | ((CANIDT3 & 0x7F) << 5); 
     2f2:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     2f6:	86 95       	lsr	r24
     2f8:	86 95       	lsr	r24
     2fa:	86 95       	lsr	r24
     2fc:	40 91 f1 00 	lds	r20, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     300:	4f 77       	andi	r20, 0x7F	; 127
     302:	90 e2       	ldi	r25, 0x20	; 32
     304:	49 9f       	mul	r20, r25
     306:	a0 01       	movw	r20, r0
     308:	11 24       	eor	r1, r1
     30a:	48 2b       	or	r20, r24
     30c:	0f c0       	rjmp	.+30     	; 0x32c <__vector_18+0x9e>
			}
			else
			{
				// Message type is CAN 2.0A
				id = (CANIDT2 >> 5) | (((uint16_t)CANIDT1 << 3));
     30e:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     312:	82 95       	swap	r24
     314:	86 95       	lsr	r24
     316:	87 70       	andi	r24, 0x07	; 7
     318:	40 91 f3 00 	lds	r20, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     31c:	50 e0       	ldi	r21, 0x00	; 0
     31e:	44 0f       	add	r20, r20
     320:	55 1f       	adc	r21, r21
     322:	44 0f       	add	r20, r20
     324:	55 1f       	adc	r21, r21
     326:	44 0f       	add	r20, r20
     328:	55 1f       	adc	r21, r21
     32a:	48 2b       	or	r20, r24
			}

			messageBuffer[bufIndex].id = id;
     32c:	20 91 bd 01 	lds	r18, 0x01BD	; 0x8001bd <bufIndex>
     330:	30 e0       	ldi	r19, 0x00	; 0
     332:	8b e0       	ldi	r24, 0x0B	; 11
     334:	82 9f       	mul	r24, r18
     336:	f0 01       	movw	r30, r0
     338:	83 9f       	mul	r24, r19
     33a:	f0 0d       	add	r31, r0
     33c:	11 24       	eor	r1, r1
     33e:	e1 53       	subi	r30, 0x31	; 49
     340:	fc 4f       	sbci	r31, 0xFC	; 252
     342:	40 83       	st	Z, r20
     344:	95 2f       	mov	r25, r21
     346:	97 70       	andi	r25, 0x07	; 7
     348:	81 81       	ldd	r24, Z+1	; 0x01
     34a:	88 7f       	andi	r24, 0xF8	; 248
     34c:	89 2b       	or	r24, r25
     34e:	81 83       	std	Z+1, r24	; 0x01

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;
     350:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     354:	8f 70       	andi	r24, 0x0F	; 15
     356:	82 87       	std	Z+10, r24	; 0x0a

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	0e c0       	rjmp	.+28     	; 0x378 <__vector_18+0xea>
			{
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
     35c:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7f80fa>
     360:	4b e0       	ldi	r20, 0x0B	; 11
     362:	42 9f       	mul	r20, r18
     364:	f0 01       	movw	r30, r0
     366:	43 9f       	mul	r20, r19
     368:	f0 0d       	add	r31, r0
     36a:	11 24       	eor	r1, r1
     36c:	e1 53       	subi	r30, 0x31	; 49
     36e:	fc 4f       	sbci	r31, 0xFC	; 252
     370:	e9 0f       	add	r30, r25
     372:	f1 1d       	adc	r31, r1
     374:	82 83       	std	Z+2, r24	; 0x02
			messageBuffer[bufIndex].id = id;

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     376:	9f 5f       	subi	r25, 0xFF	; 255
     378:	8b e0       	ldi	r24, 0x0B	; 11
     37a:	82 9f       	mul	r24, r18
     37c:	f0 01       	movw	r30, r0
     37e:	83 9f       	mul	r24, r19
     380:	f0 0d       	add	r31, r0
     382:	11 24       	eor	r1, r1
     384:	e1 53       	subi	r30, 0x31	; 49
     386:	fc 4f       	sbci	r31, 0xFC	; 252
     388:	82 85       	ldd	r24, Z+10	; 0x0a
     38a:	98 17       	cp	r25, r24
     38c:	38 f3       	brcs	.-50     	; 0x35c <__vector_18+0xce>
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
			}

			bufIndex = (bufIndex + 1) % MESSAGE_BUFFER_LENGTH;
     38e:	c9 01       	movw	r24, r18
     390:	01 96       	adiw	r24, 0x01	; 1
     392:	64 e1       	ldi	r22, 0x14	; 20
     394:	70 e0       	ldi	r23, 0x00	; 0
     396:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <__divmodhi4>
     39a:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <bufIndex>

			// Acknowledge the interrupt
			CANSTMOB = 0;
     39e:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			CANCDMOB |= (2 << CONMOB0);
     3a2:	ef ee       	ldi	r30, 0xEF	; 239
     3a4:	f0 e0       	ldi	r31, 0x00	; 0
     3a6:	80 81       	ld	r24, Z
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 83       	st	Z, r24
     3ac:	0c c0       	rjmp	.+24     	; 0x3c6 <__vector_18+0x138>
			
		}
		else if ( CANGIT & ~(1 << CANIT) )
     3ae:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	89 2b       	or	r24, r25
     3b8:	31 f0       	breq	.+12     	; 0x3c6 <__vector_18+0x138>
		{
			// Preserve the last error received
			lastError = CANGIT;
     3ba:	ea ed       	ldi	r30, 0xDA	; 218
     3bc:	f0 e0       	ldi	r31, 0x00	; 0
     3be:	80 81       	ld	r24, Z
     3c0:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <__data_end>

			// Clear the error
			CANGIT = 0;
     3c4:	10 82       	st	Z, r1
	uint8_t canPage = CANPAGE;

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     3c6:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     3ca:	82 95       	swap	r24
     3cc:	8f 70       	andi	r24, 0x0F	; 15
     3ce:	8f 30       	cpi	r24, 0x0F	; 15
     3d0:	09 f0       	breq	.+2      	; 0x3d4 <__vector_18+0x146>
     3d2:	72 cf       	rjmp	.-284    	; 0x2b8 <__vector_18+0x2a>
			CANGIT = 0;
		}
	}

	// Restore CANPAGE register to where application code had it before interrupt
	CANPAGE = canPage;
     3d4:	c0 93 ed 00 	sts	0x00ED, r28	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     3d8:	ff 91       	pop	r31
     3da:	ef 91       	pop	r30
     3dc:	cf 91       	pop	r28
     3de:	bf 91       	pop	r27
     3e0:	af 91       	pop	r26
     3e2:	9f 91       	pop	r25
     3e4:	8f 91       	pop	r24
     3e6:	7f 91       	pop	r23
     3e8:	6f 91       	pop	r22
     3ea:	5f 91       	pop	r21
     3ec:	4f 91       	pop	r20
     3ee:	3f 91       	pop	r19
     3f0:	2f 91       	pop	r18
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0
     3f8:	1f 90       	pop	r1
     3fa:	18 95       	reti

000003fc <init_spi>:
//

static void init_spi(void)
{
	/* Set MOSI and SCK output, all others input */
	DDR_SPI |= ((1 << MOSI) | (1 << SCK) | (1 << CS));
     3fc:	84 b1       	in	r24, 0x04	; 4
     3fe:	87 60       	ori	r24, 0x07	; 7
     400:	84 b9       	out	0x04, r24	; 4
	
	// enable pull up resistor in MISO
	PORTB |= (1 << MISO);
     402:	85 b1       	in	r24, 0x05	; 5
     404:	88 60       	ori	r24, 0x08	; 8
     406:	85 b9       	out	0x05, r24	; 5
	
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPR0));
     408:	8c b5       	in	r24, 0x2c	; 44
     40a:	81 65       	ori	r24, 0x51	; 81
     40c:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<CS); 				//hoog maken CS	
     40e:	85 b1       	in	r24, 0x05	; 5
     410:	81 60       	ori	r24, 0x01	; 1
     412:	85 b9       	out	0x05, r24	; 5
     414:	08 95       	ret

00000416 <xmit_spi>:
}

static BYTE xmit_spi(BYTE data)
{
	PORTB &= ~(1<<CS); //laag maken
     416:	95 b1       	in	r25, 0x05	; 5
     418:	9e 7f       	andi	r25, 0xFE	; 254
     41a:	95 b9       	out	0x05, r25	; 5
	/* Start transmission */
	SPDR = data;
     41c:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     41e:	0d b4       	in	r0, 0x2d	; 45
     420:	07 fe       	sbrs	r0, 7
     422:	fd cf       	rjmp	.-6      	; 0x41e <xmit_spi+0x8>
	PORTB |= (1<<CS);		//hoog maken CS
     424:	85 b1       	in	r24, 0x05	; 5
     426:	81 60       	ori	r24, 0x01	; 1
     428:	85 b9       	out	0x05, r24	; 5
	
	return SPDR; 
     42a:	8e b5       	in	r24, 0x2e	; 46
}
     42c:	08 95       	ret

0000042e <rcv_spi>:

static BYTE rcv_spi(void)
{
	return xmit_spi(0xFF);
     42e:	8f ef       	ldi	r24, 0xFF	; 255
     430:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
}
     434:	08 95       	ret

00000436 <send_cmd>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static BYTE send_cmd(BYTE  cmd, /* 1st byte (Start + Index) */
                     DWORD arg ) /* Argument (32 bits) */
{
     436:	ff 92       	push	r15
     438:	0f 93       	push	r16
     43a:	1f 93       	push	r17
     43c:	cf 93       	push	r28
     43e:	df 93       	push	r29
     440:	c8 2f       	mov	r28, r24
     442:	d4 2f       	mov	r29, r20
     444:	15 2f       	mov	r17, r21
     446:	06 2f       	mov	r16, r22
     448:	f7 2e       	mov	r15, r23
	BYTE n, res;

	if (cmd & 0x80) { /* ACMD<n> is the command sequence of CMD55-CMD<n> */
     44a:	88 23       	and	r24, r24
     44c:	4c f4       	brge	.+18     	; 0x460 <send_cmd+0x2a>
		cmd &= 0x7F;
     44e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	50 e0       	ldi	r21, 0x00	; 0
     454:	ba 01       	movw	r22, r20
     456:	87 e7       	ldi	r24, 0x77	; 119
     458:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
		if (res > 1)
     45c:	82 30       	cpi	r24, 0x02	; 2
     45e:	50 f5       	brcc	.+84     	; 0x4b4 <send_cmd+0x7e>
			return res;
	}

	/* Select the card */
	DESELECT();
     460:	85 b1       	in	r24, 0x05	; 5
     462:	81 60       	ori	r24, 0x01	; 1
     464:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     466:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	SELECT();
     46a:	85 b1       	in	r24, 0x05	; 5
     46c:	8e 7f       	andi	r24, 0xFE	; 254
     46e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     470:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	/* Send a command packet */
	xmit_spi(cmd);               /* Start + Command index */
     474:	8c 2f       	mov	r24, r28
     476:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
     47a:	8f 2d       	mov	r24, r15
     47c:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
     480:	80 2f       	mov	r24, r16
     482:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
     486:	81 2f       	mov	r24, r17
     488:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
     48c:	8d 2f       	mov	r24, r29
     48e:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	n = 0x01;                    /* Dummy CRC + Stop */
	if (cmd == CMD0)
     492:	c0 34       	cpi	r28, 0x40	; 64
     494:	11 f0       	breq	.+4      	; 0x49a <send_cmd+0x64>
	xmit_spi(cmd);               /* Start + Command index */
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
	n = 0x01;                    /* Dummy CRC + Stop */
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	01 c0       	rjmp	.+2      	; 0x49c <send_cmd+0x66>
	if (cmd == CMD0)
		n = 0x95; /* Valid CRC for CMD0(0) */
     49a:	85 e9       	ldi	r24, 0x95	; 149
	if (cmd == CMD8)
     49c:	c8 34       	cpi	r28, 0x48	; 72
     49e:	09 f4       	brne	.+2      	; 0x4a2 <send_cmd+0x6c>
		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
     4a0:	87 e8       	ldi	r24, 0x87	; 135
	xmit_spi(n);
     4a2:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>

	/* Receive a command response */
	n = 10; /* Wait for a valid response in timeout of 10 attempts */
     4a6:	ca e0       	ldi	r28, 0x0A	; 10
	do {
		res = rcv_spi();
     4a8:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	} while ((res & 0x80) && --n);
     4ac:	88 23       	and	r24, r24
     4ae:	14 f4       	brge	.+4      	; 0x4b4 <send_cmd+0x7e>
     4b0:	c1 50       	subi	r28, 0x01	; 1
     4b2:	d1 f7       	brne	.-12     	; 0x4a8 <send_cmd+0x72>

	return res; /* Return with the response value */
}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	1f 91       	pop	r17
     4ba:	0f 91       	pop	r16
     4bc:	ff 90       	pop	r15
     4be:	08 95       	ret

000004c0 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(void)
{
     4c0:	ef 92       	push	r14
     4c2:	ff 92       	push	r15
     4c4:	0f 93       	push	r16
     4c6:	1f 93       	push	r17
     4c8:	cf 93       	push	r28
     4ca:	df 93       	push	r29
     4cc:	00 d0       	rcall	.+0      	; 0x4ce <disk_initialize+0xe>
     4ce:	00 d0       	rcall	.+0      	; 0x4d0 <disk_initialize+0x10>
     4d0:	cd b7       	in	r28, 0x3d	; 61
     4d2:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING)
     4d4:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     4d8:	81 11       	cpse	r24, r1
     4da:	84 b1       	in	r24, 0x04	; 4
		disk_writep(0, 0); /* Finalize write process if it is in progress */
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
     4dc:	0e 94 fe 01 	call	0x3fc	; 0x3fc <init_spi>
	DESELECT();
     4e0:	85 b1       	in	r24, 0x05	; 5
     4e2:	81 60       	ori	r24, 0x01	; 1
     4e4:	85 b9       	out	0x05, r24	; 5
	for (n = 10; n; n--)
     4e6:	1a e0       	ldi	r17, 0x0A	; 10
     4e8:	03 c0       	rjmp	.+6      	; 0x4f0 <disk_initialize+0x30>
		rcv_spi(); /* 80 dummy clocks with CS=H */
     4ea:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
     4ee:	11 50       	subi	r17, 0x01	; 1
     4f0:	11 11       	cpse	r17, r1
     4f2:	fb cf       	rjmp	.-10     	; 0x4ea <disk_initialize+0x2a>
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
     4f4:	40 e0       	ldi	r20, 0x00	; 0
     4f6:	50 e0       	ldi	r21, 0x00	; 0
     4f8:	ba 01       	movw	r22, r20
     4fa:	80 e4       	ldi	r24, 0x40	; 64
     4fc:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     500:	81 30       	cpi	r24, 0x01	; 1
     502:	09 f0       	breq	.+2      	; 0x506 <disk_initialize+0x46>
     504:	9b c0       	rjmp	.+310    	; 0x63c <disk_initialize+0x17c>
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
     506:	4a ea       	ldi	r20, 0xAA	; 170
     508:	51 e0       	ldi	r21, 0x01	; 1
     50a:	60 e0       	ldi	r22, 0x00	; 0
     50c:	70 e0       	ldi	r23, 0x00	; 0
     50e:	88 e4       	ldi	r24, 0x48	; 72
     510:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     514:	81 30       	cpi	r24, 0x01	; 1
     516:	09 f0       	breq	.+2      	; 0x51a <disk_initialize+0x5a>
     518:	59 c0       	rjmp	.+178    	; 0x5cc <disk_initialize+0x10c>
     51a:	0d c0       	rjmp	.+26     	; 0x536 <disk_initialize+0x76>
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
     51c:	e0 2e       	mov	r14, r16
     51e:	f1 2c       	mov	r15, r1
     520:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     524:	e1 e0       	ldi	r30, 0x01	; 1
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	ec 0f       	add	r30, r28
     52a:	fd 1f       	adc	r31, r29
     52c:	ee 0d       	add	r30, r14
     52e:	ff 1d       	adc	r31, r15
     530:	80 83       	st	Z, r24
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
     532:	0f 5f       	subi	r16, 0xFF	; 255
     534:	01 c0       	rjmp	.+2      	; 0x538 <disk_initialize+0x78>
     536:	01 2f       	mov	r16, r17
     538:	04 30       	cpi	r16, 0x04	; 4
     53a:	80 f3       	brcs	.-32     	; 0x51c <disk_initialize+0x5c>
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
     53c:	8b 81       	ldd	r24, Y+3	; 0x03
     53e:	81 30       	cpi	r24, 0x01	; 1
     540:	09 f0       	breq	.+2      	; 0x544 <disk_initialize+0x84>
     542:	7e c0       	rjmp	.+252    	; 0x640 <disk_initialize+0x180>
     544:	8c 81       	ldd	r24, Y+4	; 0x04
     546:	8a 3a       	cpi	r24, 0xAA	; 170
     548:	61 f0       	breq	.+24     	; 0x562 <disk_initialize+0xa2>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     54a:	f1 2c       	mov	r15, r1
     54c:	84 c0       	rjmp	.+264    	; 0x656 <disk_initialize+0x196>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     54e:	8f e8       	ldi	r24, 0x8F	; 143
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	01 97       	sbiw	r24, 0x01	; 1
     554:	f1 f7       	brne	.-4      	; 0x552 <disk_initialize+0x92>
     556:	00 c0       	rjmp	.+0      	; 0x558 <disk_initialize+0x98>
     558:	00 00       	nop
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
     55a:	91 e0       	ldi	r25, 0x01	; 1
     55c:	e9 1a       	sub	r14, r25
     55e:	f1 08       	sbc	r15, r1
     560:	06 c0       	rjmp	.+12     	; 0x56e <disk_initialize+0xae>
     562:	0f 2e       	mov	r0, r31
     564:	f0 e1       	ldi	r31, 0x10	; 16
     566:	ef 2e       	mov	r14, r31
     568:	f7 e2       	ldi	r31, 0x27	; 39
     56a:	ff 2e       	mov	r15, r31
     56c:	f0 2d       	mov	r31, r0
     56e:	e1 14       	cp	r14, r1
     570:	f1 04       	cpc	r15, r1
     572:	49 f0       	breq	.+18     	; 0x586 <disk_initialize+0xc6>
     574:	40 e0       	ldi	r20, 0x00	; 0
     576:	50 e0       	ldi	r21, 0x00	; 0
     578:	60 e0       	ldi	r22, 0x00	; 0
     57a:	70 e4       	ldi	r23, 0x40	; 64
     57c:	89 ee       	ldi	r24, 0xE9	; 233
     57e:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     582:	81 11       	cpse	r24, r1
     584:	e4 cf       	rjmp	.-56     	; 0x54e <disk_initialize+0x8e>
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
     586:	ef 28       	or	r14, r15
     588:	09 f4       	brne	.+2      	; 0x58c <disk_initialize+0xcc>
     58a:	5c c0       	rjmp	.+184    	; 0x644 <disk_initialize+0x184>
     58c:	40 e0       	ldi	r20, 0x00	; 0
     58e:	50 e0       	ldi	r21, 0x00	; 0
     590:	ba 01       	movw	r22, r20
     592:	8a e7       	ldi	r24, 0x7A	; 122
     594:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	71 f0       	breq	.+28     	; 0x5b8 <disk_initialize+0xf8>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     59c:	f1 2c       	mov	r15, r1
     59e:	5b c0       	rjmp	.+182    	; 0x656 <disk_initialize+0x196>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
     5a0:	e1 2e       	mov	r14, r17
     5a2:	f1 2c       	mov	r15, r1
     5a4:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     5a8:	e1 e0       	ldi	r30, 0x01	; 1
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	ec 0f       	add	r30, r28
     5ae:	fd 1f       	adc	r31, r29
     5b0:	ee 0d       	add	r30, r14
     5b2:	ff 1d       	adc	r31, r15
     5b4:	80 83       	st	Z, r24
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
     5b6:	1f 5f       	subi	r17, 0xFF	; 255
     5b8:	14 30       	cpi	r17, 0x04	; 4
     5ba:	90 f3       	brcs	.-28     	; 0x5a0 <disk_initialize+0xe0>
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     5bc:	89 81       	ldd	r24, Y+1	; 0x01
     5be:	86 ff       	sbrs	r24, 6
     5c0:	43 c0       	rjmp	.+134    	; 0x648 <disk_initialize+0x188>
     5c2:	0f 2e       	mov	r0, r31
     5c4:	fc e0       	ldi	r31, 0x0C	; 12
     5c6:	ff 2e       	mov	r15, r31
     5c8:	f0 2d       	mov	r31, r0
     5ca:	45 c0       	rjmp	.+138    	; 0x656 <disk_initialize+0x196>
				}
			}
		} else { /* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) {
     5cc:	40 e0       	ldi	r20, 0x00	; 0
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	ba 01       	movw	r22, r20
     5d2:	89 ee       	ldi	r24, 0xE9	; 233
     5d4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     5d8:	82 30       	cpi	r24, 0x02	; 2
     5da:	40 f4       	brcc	.+16     	; 0x5ec <disk_initialize+0x12c>
				ty  = CT_SD1;
     5dc:	68 94       	set
     5de:	ff 24       	eor	r15, r15
     5e0:	f1 f8       	bld	r15, 1
				cmd = ACMD41; /* SDv1 */
     5e2:	0f 2e       	mov	r0, r31
     5e4:	f9 ee       	ldi	r31, 0xE9	; 233
     5e6:	ef 2e       	mov	r14, r31
     5e8:	f0 2d       	mov	r31, r0
     5ea:	06 c0       	rjmp	.+12     	; 0x5f8 <disk_initialize+0x138>
			} else {
				ty  = CT_MMC;
     5ec:	ff 24       	eor	r15, r15
     5ee:	f3 94       	inc	r15
				cmd = CMD1; /* MMCv3 */
     5f0:	0f 2e       	mov	r0, r31
     5f2:	f1 e4       	ldi	r31, 0x41	; 65
     5f4:	ef 2e       	mov	r14, r31
     5f6:	f0 2d       	mov	r31, r0
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
     5f8:	00 e1       	ldi	r16, 0x10	; 16
     5fa:	17 e2       	ldi	r17, 0x27	; 39
     5fc:	08 c0       	rjmp	.+16     	; 0x60e <disk_initialize+0x14e>
     5fe:	8f e8       	ldi	r24, 0x8F	; 143
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	01 97       	sbiw	r24, 0x01	; 1
     604:	f1 f7       	brne	.-4      	; 0x602 <disk_initialize+0x142>
     606:	00 c0       	rjmp	.+0      	; 0x608 <disk_initialize+0x148>
     608:	00 00       	nop
     60a:	01 50       	subi	r16, 0x01	; 1
     60c:	11 09       	sbc	r17, r1
     60e:	01 15       	cp	r16, r1
     610:	11 05       	cpc	r17, r1
     612:	41 f0       	breq	.+16     	; 0x624 <disk_initialize+0x164>
     614:	40 e0       	ldi	r20, 0x00	; 0
     616:	50 e0       	ldi	r21, 0x00	; 0
     618:	ba 01       	movw	r22, r20
     61a:	8e 2d       	mov	r24, r14
     61c:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     620:	81 11       	cpse	r24, r1
     622:	ed cf       	rjmp	.-38     	; 0x5fe <disk_initialize+0x13e>
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
     624:	01 2b       	or	r16, r17
     626:	a1 f0       	breq	.+40     	; 0x650 <disk_initialize+0x190>
     628:	40 e0       	ldi	r20, 0x00	; 0
     62a:	52 e0       	ldi	r21, 0x02	; 2
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 e5       	ldi	r24, 0x50	; 80
     632:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     636:	81 11       	cpse	r24, r1
     638:	0d c0       	rjmp	.+26     	; 0x654 <disk_initialize+0x194>
     63a:	0d c0       	rjmp	.+26     	; 0x656 <disk_initialize+0x196>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     63c:	f1 2c       	mov	r15, r1
     63e:	0b c0       	rjmp	.+22     	; 0x656 <disk_initialize+0x196>
     640:	f1 2c       	mov	r15, r1
     642:	09 c0       	rjmp	.+18     	; 0x656 <disk_initialize+0x196>
     644:	f1 2c       	mov	r15, r1
     646:	07 c0       	rjmp	.+14     	; 0x656 <disk_initialize+0x196>
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     648:	68 94       	set
     64a:	ff 24       	eor	r15, r15
     64c:	f2 f8       	bld	r15, 2
     64e:	03 c0       	rjmp	.+6      	; 0x656 <disk_initialize+0x196>
				cmd = CMD1; /* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
				ty = 0;
     650:	f1 2c       	mov	r15, r1
     652:	01 c0       	rjmp	.+2      	; 0x656 <disk_initialize+0x196>
     654:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     656:	f0 92 c1 01 	sts	0x01C1, r15	; 0x8001c1 <CardType>
	DESELECT();
     65a:	85 b1       	in	r24, 0x05	; 5
     65c:	81 60       	ori	r24, 0x01	; 1
     65e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     660:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return ty ? 0 : STA_NOINIT;
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	f1 10       	cpse	r15, r1
     668:	80 e0       	ldi	r24, 0x00	; 0
}
     66a:	0f 90       	pop	r0
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	0f 90       	pop	r0
     672:	df 91       	pop	r29
     674:	cf 91       	pop	r28
     676:	1f 91       	pop	r17
     678:	0f 91       	pop	r16
     67a:	ff 90       	pop	r15
     67c:	ef 90       	pop	r14
     67e:	08 95       	ret

00000680 <disk_readp>:
DRESULT disk_readp(BYTE *buff,   /* Pointer to the read buffer (NULL:Forward to the stream) */
                   DWORD sector, /* Sector number (LBA) */
                   UINT  offset, /* Byte offset to read from (0..511) */
                   UINT  count   /* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
     680:	af 92       	push	r10
     682:	bf 92       	push	r11
     684:	cf 92       	push	r12
     686:	df 92       	push	r13
     688:	ef 92       	push	r14
     68a:	ff 92       	push	r15
     68c:	0f 93       	push	r16
     68e:	1f 93       	push	r17
     690:	cf 93       	push	r28
     692:	df 93       	push	r29
     694:	6c 01       	movw	r12, r24
     696:	79 01       	movw	r14, r18
	DRESULT res;
	BYTE    rc;
	UINT    bc;

	if (!(CardType & CT_BLOCK))
     698:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     69c:	83 fd       	sbrc	r24, 3
     69e:	09 c0       	rjmp	.+18     	; 0x6b2 <disk_readp+0x32>
		sector *= 512; /* Convert to byte address if needed */
     6a0:	03 2e       	mov	r0, r19
     6a2:	39 e0       	ldi	r19, 0x09	; 9
     6a4:	44 0f       	add	r20, r20
     6a6:	55 1f       	adc	r21, r21
     6a8:	66 1f       	adc	r22, r22
     6aa:	77 1f       	adc	r23, r23
     6ac:	3a 95       	dec	r19
     6ae:	d1 f7       	brne	.-12     	; 0x6a4 <disk_readp+0x24>
     6b0:	30 2d       	mov	r19, r0

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
     6b2:	81 e5       	ldi	r24, 0x51	; 81
     6b4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     6b8:	81 11       	cpse	r24, r1
     6ba:	31 c0       	rjmp	.+98     	; 0x71e <disk_readp+0x9e>

		// bc = 40000;	/* Time counter */
		do { /* Wait for response */
			rc = rcv_spi();
     6bc:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		} while (rc == 0xFF);
     6c0:	8f 3f       	cpi	r24, 0xFF	; 255
     6c2:	e1 f3       	breq	.-8      	; 0x6bc <disk_readp+0x3c>

		if (rc == 0xFE) { /* A data packet arrived */
     6c4:	8e 3f       	cpi	r24, 0xFE	; 254
     6c6:	69 f5       	brne	.+90     	; 0x722 <disk_readp+0xa2>

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */
     6c8:	cc 27       	eor	r28, r28
     6ca:	dd 27       	eor	r29, r29
     6cc:	ce 19       	sub	r28, r14
     6ce:	df 09       	sbc	r29, r15
     6d0:	c0 1b       	sub	r28, r16
     6d2:	d1 0b       	sbc	r29, r17
     6d4:	ce 5f       	subi	r28, 0xFE	; 254
     6d6:	dd 4f       	sbci	r29, 0xFD	; 253

			/* Skip leading bytes */
			while (offset--)
     6d8:	03 c0       	rjmp	.+6      	; 0x6e0 <disk_readp+0x60>
				rcv_spi();
     6da:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		if (rc == 0xFE) { /* A data packet arrived */

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */

			/* Skip leading bytes */
			while (offset--)
     6de:	75 01       	movw	r14, r10
     6e0:	57 01       	movw	r10, r14
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	a8 1a       	sub	r10, r24
     6e6:	b1 08       	sbc	r11, r1
     6e8:	ef 28       	or	r14, r15
     6ea:	b9 f7       	brne	.-18     	; 0x6da <disk_readp+0x5a>
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
     6ec:	c1 14       	cp	r12, r1
     6ee:	d1 04       	cpc	r13, r1
     6f0:	69 f0       	breq	.+26     	; 0x70c <disk_readp+0x8c>
				do {
					*buff++ = rcv_spi();
     6f2:	76 01       	movw	r14, r12
     6f4:	ef ef       	ldi	r30, 0xFF	; 255
     6f6:	ee 1a       	sub	r14, r30
     6f8:	fe 0a       	sbc	r15, r30
     6fa:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     6fe:	f6 01       	movw	r30, r12
     700:	80 83       	st	Z, r24
				} while (--count);
     702:	01 50       	subi	r16, 0x01	; 1
     704:	11 09       	sbc	r17, r1
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
				do {
					*buff++ = rcv_spi();
     706:	67 01       	movw	r12, r14
				} while (--count);
     708:	a1 f7       	brne	.-24     	; 0x6f2 <disk_readp+0x72>
     70a:	03 c0       	rjmp	.+6      	; 0x712 <disk_readp+0x92>
			} else { /* Forward data to the outgoing stream */
				do {
					// FORWARD(rcv_spi());
				} while (--count);
     70c:	01 50       	subi	r16, 0x01	; 1
     70e:	11 09       	sbc	r17, r1
     710:	e9 f7       	brne	.-6      	; 0x70c <disk_readp+0x8c>
			}

			/* Skip trailing bytes and CRC */
			do
				rcv_spi();
     712:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
			while (--bc);
     716:	21 97       	sbiw	r28, 0x01	; 1
     718:	e1 f7       	brne	.-8      	; 0x712 <disk_readp+0x92>

			res = RES_OK;
     71a:	c0 e0       	ldi	r28, 0x00	; 0
     71c:	03 c0       	rjmp	.+6      	; 0x724 <disk_readp+0xa4>
	UINT    bc;

	if (!(CardType & CT_BLOCK))
		sector *= 512; /* Convert to byte address if needed */

	res = RES_ERROR;
     71e:	c1 e0       	ldi	r28, 0x01	; 1
     720:	01 c0       	rjmp	.+2      	; 0x724 <disk_readp+0xa4>
     722:	c1 e0       	ldi	r28, 0x01	; 1

			res = RES_OK;
		}
	}

	DESELECT();
     724:	85 b1       	in	r24, 0x05	; 5
     726:	81 60       	ori	r24, 0x01	; 1
     728:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     72a:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return res;
}
     72e:	8c 2f       	mov	r24, r28
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	df 90       	pop	r13
     73e:	cf 90       	pop	r12
     740:	bf 90       	pop	r11
     742:	af 90       	pop	r10
     744:	08 95       	ret

00000746 <disk_writep>:

#if _USE_WRITE
DRESULT disk_writep(const BYTE *buff, /* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
                    DWORD       sc    /* Number of bytes to send, Sector number (LBA) or zero */
)
{
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	fc 01       	movw	r30, r24
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
     750:	89 2b       	or	r24, r25
     752:	f1 f0       	breq	.+60     	; 0x790 <disk_writep+0x4a>
		bc = sc;
     754:	ea 01       	movw	r28, r20
		while (bc && wc) { /* Send data bytes to the card */
     756:	11 c0       	rjmp	.+34     	; 0x77a <disk_writep+0x34>
			xmit_spi(*buff++);
     758:	8f 01       	movw	r16, r30
     75a:	0f 5f       	subi	r16, 0xFF	; 255
     75c:	1f 4f       	sbci	r17, 0xFF	; 255
     75e:	80 81       	ld	r24, Z
     760:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
			wc--;
     764:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     768:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     76c:	01 97       	sbiw	r24, 0x01	; 1
     76e:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <wc.1882+0x1>
     772:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <wc.1882>
			bc--;
     776:	21 97       	sbiw	r28, 0x01	; 1
	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
     778:	f8 01       	movw	r30, r16

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
     77a:	20 97       	sbiw	r28, 0x00	; 0
     77c:	09 f4       	brne	.+2      	; 0x780 <disk_writep+0x3a>
     77e:	5f c0       	rjmp	.+190    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
     780:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     784:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     788:	89 2b       	or	r24, r25
     78a:	31 f7       	brne	.-52     	; 0x758 <disk_writep+0x12>
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     78c:	c0 e0       	ldi	r28, 0x00	; 0
     78e:	5a c0       	rjmp	.+180    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
	} else {
		if (sc) { /* Initiate sector write process */
     790:	41 15       	cp	r20, r1
     792:	51 05       	cpc	r21, r1
     794:	61 05       	cpc	r22, r1
     796:	71 05       	cpc	r23, r1
     798:	01 f1       	breq	.+64     	; 0x7da <disk_writep+0x94>
			if (!(CardType & CT_BLOCK))
     79a:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     79e:	83 fd       	sbrc	r24, 3
     7a0:	09 c0       	rjmp	.+18     	; 0x7b4 <disk_writep+0x6e>
				sc *= 512;                  /* Convert to byte address if needed */
     7a2:	03 2e       	mov	r0, r19
     7a4:	39 e0       	ldi	r19, 0x09	; 9
     7a6:	44 0f       	add	r20, r20
     7a8:	55 1f       	adc	r21, r21
     7aa:	66 1f       	adc	r22, r22
     7ac:	77 1f       	adc	r23, r23
     7ae:	3a 95       	dec	r19
     7b0:	d1 f7       	brne	.-12     	; 0x7a6 <disk_writep+0x60>
     7b2:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sc) == 0) { /* WRITE_SINGLE_BLOCK */
     7b4:	88 e5       	ldi	r24, 0x58	; 88
     7b6:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     7ba:	81 11       	cpse	r24, r1
     7bc:	42 c0       	rjmp	.+132    	; 0x842 <__DATA_REGION_LENGTH__+0x42>
				xmit_spi(0xFF);
     7be:	8f ef       	ldi	r24, 0xFF	; 255
     7c0:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				xmit_spi(0xFE); /* Data block header */
     7c4:	8e ef       	ldi	r24, 0xFE	; 254
     7c6:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	92 e0       	ldi	r25, 0x02	; 2
     7ce:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <wc.1882+0x1>
     7d2:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <wc.1882>
				res = RES_OK;
     7d6:	c0 e0       	ldi	r28, 0x00	; 0
     7d8:	35 c0       	rjmp	.+106    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
     7da:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     7de:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     7e2:	02 96       	adiw	r24, 0x02	; 2
			while (bc--) {
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <disk_writep+0xa8>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
     7e6:	80 e0       	ldi	r24, 0x00	; 0
     7e8:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
				res = RES_OK;
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
			while (bc--) {
     7ec:	ce 01       	movw	r24, r28
     7ee:	ec 01       	movw	r28, r24
     7f0:	21 97       	sbiw	r28, 0x01	; 1
     7f2:	89 2b       	or	r24, r25
     7f4:	c1 f7       	brne	.-16     	; 0x7e6 <disk_writep+0xa0>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
			}
			do {
				res = rcv_spi();
     7f6:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     7fa:	c8 2f       	mov	r28, r24
			} while (res == 0xFF);
     7fc:	8f 3f       	cpi	r24, 0xFF	; 255
     7fe:	d9 f3       	breq	.-10     	; 0x7f6 <disk_writep+0xb0>
			if ((res & 0x1F) == 0x05) { /* Receive data resp and wait for end of write process in timeout of 500ms */
     800:	8f 71       	andi	r24, 0x1F	; 31
     802:	85 30       	cpi	r24, 0x05	; 5
     804:	b1 f4       	brne	.+44     	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     806:	09 c0       	rjmp	.+18     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     808:	8f e8       	ldi	r24, 0x8F	; 143
     80a:	91 e0       	ldi	r25, 0x01	; 1
     80c:	01 97       	sbiw	r24, 0x01	; 1
     80e:	f1 f7       	brne	.-4      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     810:	00 c0       	rjmp	.+0      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
     812:	00 00       	nop
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--) /* Wait for ready */
     814:	01 50       	subi	r16, 0x01	; 1
     816:	11 09       	sbc	r17, r1
     818:	02 c0       	rjmp	.+4      	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     81a:	08 e8       	ldi	r16, 0x88	; 136
     81c:	13 e1       	ldi	r17, 0x13	; 19
     81e:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     822:	8f 3f       	cpi	r24, 0xFF	; 255
     824:	19 f0       	breq	.+6      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     826:	01 15       	cp	r16, r1
     828:	11 05       	cpc	r17, r1
     82a:	71 f7       	brne	.-36     	; 0x808 <__DATA_REGION_LENGTH__+0x8>
					_delay_us(100);
				if (bc)
     82c:	01 2b       	or	r16, r17
     82e:	09 f0       	breq	.+2      	; 0x832 <__DATA_REGION_LENGTH__+0x32>
					res = RES_OK;
     830:	c0 e0       	ldi	r28, 0x00	; 0
			}
			DESELECT();
     832:	85 b1       	in	r24, 0x05	; 5
     834:	81 60       	ori	r24, 0x01	; 1
     836:	85 b9       	out	0x05, r24	; 5
			rcv_spi();
     838:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     83c:	03 c0       	rjmp	.+6      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     83e:	c0 e0       	ldi	r28, 0x00	; 0
     840:	01 c0       	rjmp	.+2      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
{
	DRESULT     res;
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;
     842:	c1 e0       	ldi	r28, 0x01	; 1
			rcv_spi();
		}
	}

	return res;
}
     844:	8c 2f       	mov	r24, r28
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	1f 91       	pop	r17
     84c:	0f 91       	pop	r16
     84e:	08 95       	ret

00000850 <__vector_10>:
void start_log_message(void);
unsigned long find_offset(void);
void writeToCard(void);

ISR(TIMER2_OVF_vect)
{
     850:	1f 92       	push	r1
     852:	0f 92       	push	r0
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	0f 92       	push	r0
     858:	11 24       	eor	r1, r1
     85a:	8f 93       	push	r24
     85c:	9f 93       	push	r25
	overflowCounter++;
     85e:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <overflowCounter>
     862:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <overflowCounter+0x1>
     866:	01 96       	adiw	r24, 0x01	; 1
     868:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <overflowCounter+0x1>
     86c:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <overflowCounter>
	TCNT2 = 0x00;
     870:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
}
     874:	9f 91       	pop	r25
     876:	8f 91       	pop	r24
     878:	0f 90       	pop	r0
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	0f 90       	pop	r0
     87e:	1f 90       	pop	r1
     880:	18 95       	reti

00000882 <init_timer>:
	}
}

void init_timer(void)
{	
	TCNT2 = 0x00; // start counting at 0
     882:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
	TCCR2A = ((1 << CS22) | (1 << CS21) | (1 << CS20)); // prescaler op 1024
     886:	87 e0       	ldi	r24, 0x07	; 7
     888:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
	TIMSK2 = (1 << TOIE2);
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7f8070>
     892:	08 95       	ret

00000894 <fill_buffer>:
}


void fill_buffer(void)
{
     894:	0f 93       	push	r16
     896:	1f 93       	push	r17
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
     89c:	cd b7       	in	r28, 0x3d	; 61
     89e:	de b7       	in	r29, 0x3e	; 62
     8a0:	6a 97       	sbiw	r28, 0x1a	; 26
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	de bf       	out	0x3e, r29	; 62
     8a8:	0f be       	out	0x3f, r0	; 63
     8aa:	cd bf       	out	0x3d, r28	; 61
	write_buffer[bufferAmt++] = '\n';
     8ac:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     8b0:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     8b4:	9c 01       	movw	r18, r24
     8b6:	2f 5f       	subi	r18, 0xFF	; 255
     8b8:	3f 4f       	sbci	r19, 0xFF	; 255
     8ba:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     8be:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     8c2:	fc 01       	movw	r30, r24
     8c4:	e3 53       	subi	r30, 0x33	; 51
     8c6:	fe 4f       	sbci	r31, 0xFE	; 254
     8c8:	2a e0       	ldi	r18, 0x0A	; 10
     8ca:	20 83       	st	Z, r18
	
	CANMessage bericht;
	int resultaat = getMessage(&bericht); // returnt 0 als het niet lukt om bericht uit te lezen, anders returnt 1
     8cc:	ce 01       	movw	r24, r28
     8ce:	01 96       	adiw	r24, 0x01	; 1
     8d0:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <getMessage>
	if(resultaat == 0)
     8d4:	88 23       	and	r24, r24
     8d6:	b9 f0       	breq	.+46     	; 0x906 <__stack+0x7>
     8d8:	1c c0       	rjmp	.+56     	; 0x912 <__stack+0x13>
		// geen bericht ontvangen > can-bus werkt niet
		const char* string = "GEEN DATA ONTVANGEN";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
		{
			write_buffer[bufferAmt++] = string[i];
     8da:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     8de:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     8e2:	ac 01       	movw	r20, r24
     8e4:	4f 5f       	subi	r20, 0xFF	; 255
     8e6:	5f 4f       	sbci	r21, 0xFF	; 255
     8e8:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <bufferAmt+0x1>
     8ec:	40 93 c9 01 	sts	0x01C9, r20	; 0x8001c9 <bufferAmt>
     8f0:	f9 01       	movw	r30, r18
     8f2:	e0 50       	subi	r30, 0x00	; 0
     8f4:	ff 4f       	sbci	r31, 0xFF	; 255
     8f6:	40 81       	ld	r20, Z
     8f8:	fc 01       	movw	r30, r24
     8fa:	e3 53       	subi	r30, 0x33	; 51
     8fc:	fe 4f       	sbci	r31, 0xFE	; 254
     8fe:	40 83       	st	Z, r20
	if(resultaat == 0)
	{
		// geen bericht ontvangen > can-bus werkt niet
		const char* string = "GEEN DATA ONTVANGEN";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
     900:	2f 5f       	subi	r18, 0xFF	; 255
     902:	3f 4f       	sbci	r19, 0xFF	; 255
     904:	02 c0       	rjmp	.+4      	; 0x90a <__stack+0xb>
     906:	20 e0       	ldi	r18, 0x00	; 0
     908:	30 e0       	ldi	r19, 0x00	; 0
     90a:	23 31       	cpi	r18, 0x13	; 19
     90c:	31 05       	cpc	r19, r1
     90e:	2c f3       	brlt	.-54     	; 0x8da <fill_buffer+0x46>
     910:	42 c0       	rjmp	.+132    	; 0x996 <__stack+0x97>
			write_buffer[bufferAmt++] = string[i];
		}
	} else 
	{
		// bericht ontvangen > schrijf data naar buffer
		if(bericht.id == CAN_ID_SNELHEIDSMETER)
     912:	89 81       	ldd	r24, Y+1	; 0x01
     914:	2a 81       	ldd	r18, Y+2	; 0x02
     916:	92 2f       	mov	r25, r18
     918:	97 70       	andi	r25, 0x07	; 7
     91a:	40 97       	sbiw	r24, 0x10	; 16
     91c:	e1 f5       	brne	.+120    	; 0x996 <__stack+0x97>
		{
			int val1 = bericht.data[0];
     91e:	8b 81       	ldd	r24, Y+3	; 0x03
			int val2 = bericht.data[1];
     920:	9c 81       	ldd	r25, Y+4	; 0x04
			char zin[15];
			sprintf(zin, "snelheid: %d.%d", val1, val2); 			
     922:	1f 92       	push	r1
     924:	9f 93       	push	r25
     926:	1f 92       	push	r1
     928:	8f 93       	push	r24
     92a:	84 e1       	ldi	r24, 0x14	; 20
     92c:	91 e0       	ldi	r25, 0x01	; 1
     92e:	9f 93       	push	r25
     930:	8f 93       	push	r24
     932:	8e 01       	movw	r16, r28
     934:	04 5f       	subi	r16, 0xF4	; 244
     936:	1f 4f       	sbci	r17, 0xFF	; 255
     938:	1f 93       	push	r17
     93a:	0f 93       	push	r16
     93c:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <sprintf>
			int length = strlen(zin);
     940:	f8 01       	movw	r30, r16
     942:	01 90       	ld	r0, Z+
     944:	00 20       	and	r0, r0
     946:	e9 f7       	brne	.-6      	; 0x942 <__stack+0x43>
     948:	31 97       	sbiw	r30, 0x01	; 1
     94a:	bf 01       	movw	r22, r30
     94c:	60 1b       	sub	r22, r16
     94e:	71 0b       	sbc	r23, r17
			for (int i = 0; i < length; i++)
     950:	0f b6       	in	r0, 0x3f	; 63
     952:	f8 94       	cli
     954:	de bf       	out	0x3e, r29	; 62
     956:	0f be       	out	0x3f, r0	; 63
     958:	cd bf       	out	0x3d, r28	; 61
     95a:	20 e0       	ldi	r18, 0x00	; 0
     95c:	30 e0       	ldi	r19, 0x00	; 0
     95e:	18 c0       	rjmp	.+48     	; 0x990 <__stack+0x91>
			{
				write_buffer[bufferAmt++] = zin[i];
     960:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     964:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     968:	ac 01       	movw	r20, r24
     96a:	4f 5f       	subi	r20, 0xFF	; 255
     96c:	5f 4f       	sbci	r21, 0xFF	; 255
     96e:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <bufferAmt+0x1>
     972:	40 93 c9 01 	sts	0x01C9, r20	; 0x8001c9 <bufferAmt>
     976:	ec e0       	ldi	r30, 0x0C	; 12
     978:	f0 e0       	ldi	r31, 0x00	; 0
     97a:	ec 0f       	add	r30, r28
     97c:	fd 1f       	adc	r31, r29
     97e:	e2 0f       	add	r30, r18
     980:	f3 1f       	adc	r31, r19
     982:	40 81       	ld	r20, Z
     984:	fc 01       	movw	r30, r24
     986:	e3 53       	subi	r30, 0x33	; 51
     988:	fe 4f       	sbci	r31, 0xFE	; 254
     98a:	40 83       	st	Z, r20
			int val1 = bericht.data[0];
			int val2 = bericht.data[1];
			char zin[15];
			sprintf(zin, "snelheid: %d.%d", val1, val2); 			
			int length = strlen(zin);
			for (int i = 0; i < length; i++)
     98c:	2f 5f       	subi	r18, 0xFF	; 255
     98e:	3f 4f       	sbci	r19, 0xFF	; 255
     990:	26 17       	cp	r18, r22
     992:	37 07       	cpc	r19, r23
     994:	2c f3       	brlt	.-54     	; 0x960 <__stack+0x61>
	
			
		// if statement hierboven kan herhaald worden voor andere ID's.
	}
	
	if(bufferAmt>=(512-30)) // sectorgrootte van 512 bytes - ongeveer 30 bytes (iets meer dan 2 lines)
     996:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     99a:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     99e:	82 3e       	cpi	r24, 0xE2	; 226
     9a0:	91 40       	sbci	r25, 0x01	; 1
     9a2:	3c f0       	brlt	.+14     	; 0x9b2 <__stack+0xb3>
	{
			
		bufferAmt = 0;
     9a4:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <bufferAmt+0x1>
     9a8:	10 92 c9 01 	sts	0x01C9, r1	; 0x8001c9 <bufferAmt>
		startWriting = true; // als dit op true staat gaat de microcontroller in de main>while(logging) in de if-statement en vult vanaf daar de sd-kaart 
     9ac:	81 e0       	ldi	r24, 0x01	; 1
     9ae:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <startWriting>
	}
}
     9b2:	6a 96       	adiw	r28, 0x1a	; 26
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	de bf       	out	0x3e, r29	; 62
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	cd bf       	out	0x3d, r28	; 61
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	08 95       	ret

000009c8 <writeToCard>:


void writeToCard(void)
{
	// Set file pointer to beginning of sector 
	pf_lseek(curOffset); // offset van 0 is te vinden in sector 8448 van de sd-kaart
     9c8:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <curOffset>
     9cc:	70 91 c3 01 	lds	r23, 0x01C3	; 0x8001c3 <curOffset+0x1>
     9d0:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <curOffset+0x2>
     9d4:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <curOffset+0x3>
     9d8:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <pf_lseek>
	// Write buffer 
	pf_write(write_buffer, BUFFER_SIZE, &byte_counter);
     9dc:	4b ec       	ldi	r20, 0xCB	; 203
     9de:	51 e0       	ldi	r21, 0x01	; 1
     9e0:	60 e0       	ldi	r22, 0x00	; 0
     9e2:	72 e0       	ldi	r23, 0x02	; 2
     9e4:	8d ec       	ldi	r24, 0xCD	; 205
     9e6:	91 e0       	ldi	r25, 0x01	; 1
     9e8:	0e 94 c5 0b 	call	0x178a	; 0x178a <pf_write>
	if (byte_counter < BUFFER_SIZE) {
		// End of file 
	}
	// Finalize write 
	pf_write(0, 0, &byte_counter);
     9ec:	4b ec       	ldi	r20, 0xCB	; 203
     9ee:	51 e0       	ldi	r21, 0x01	; 1
     9f0:	60 e0       	ldi	r22, 0x00	; 0
     9f2:	70 e0       	ldi	r23, 0x00	; 0
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	0e 94 c5 0b 	call	0x178a	; 0x178a <pf_write>
	// Reset file pointer to beginning of sector 1 
	pf_lseek(curOffset);
     9fc:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <curOffset>
     a00:	70 91 c3 01 	lds	r23, 0x01C3	; 0x8001c3 <curOffset+0x1>
     a04:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <curOffset+0x2>
     a08:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <curOffset+0x3>
     a0c:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <pf_lseek>
     a10:	08 95       	ret

00000a12 <find_offset>:
	}
	*/
}

unsigned long find_offset(void)
{
     a12:	cf 92       	push	r12
     a14:	df 92       	push	r13
     a16:	ef 92       	push	r14
     a18:	ff 92       	push	r15
     a1a:	cf 93       	push	r28
     a1c:	df 93       	push	r29
     a1e:	00 d0       	rcall	.+0      	; 0xa20 <find_offset+0xe>
     a20:	1f 92       	push	r1
     a22:	cd b7       	in	r28, 0x3d	; 61
     a24:	de b7       	in	r29, 0x3e	; 62
	// begin bij sector 0. kijk naar waarde 1e char. als die erop wijst dat de sector al geschreven is, ga naar sector 1. ga zo door. return offset als sector leeg lijkt te zijn
	uint8_t read_first[1]  = {};
     a26:	19 82       	std	Y+1, r1	; 0x01
	UINT bytecounter = 1;
     a28:	81 e0       	ldi	r24, 0x01	; 1
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	9b 83       	std	Y+3, r25	; 0x03
     a2e:	8a 83       	std	Y+2, r24	; 0x02
	unsigned long tempOffset = 0;
     a30:	c1 2c       	mov	r12, r1
     a32:	d1 2c       	mov	r13, r1
     a34:	76 01       	movw	r14, r12
	unsigned long maxOffset = 51200; // als hij geen lege sector kan vinden na de 1e 100 sectoren
	while(1)
	{
		pf_lseek(tempOffset);
     a36:	c7 01       	movw	r24, r14
     a38:	b6 01       	movw	r22, r12
     a3a:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <pf_lseek>
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
     a3e:	ae 01       	movw	r20, r28
     a40:	4e 5f       	subi	r20, 0xFE	; 254
     a42:	5f 4f       	sbci	r21, 0xFF	; 255
     a44:	61 e0       	ldi	r22, 0x01	; 1
     a46:	70 e0       	ldi	r23, 0x00	; 0
     a48:	ce 01       	movw	r24, r28
     a4a:	01 96       	adiw	r24, 0x01	; 1
     a4c:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <pf_read>
		if(read_first[0] == 32)
     a50:	89 81       	ldd	r24, Y+1	; 0x01
     a52:	80 32       	cpi	r24, 0x20	; 32
     a54:	79 f0       	breq	.+30     	; 0xa74 <find_offset+0x62>
		{
			return tempOffset;
		} else {
			tempOffset += 512;
     a56:	82 e0       	ldi	r24, 0x02	; 2
     a58:	d8 0e       	add	r13, r24
     a5a:	e1 1c       	adc	r14, r1
     a5c:	f1 1c       	adc	r15, r1
			if(tempOffset >= maxOffset)
     a5e:	c1 14       	cp	r12, r1
     a60:	88 ec       	ldi	r24, 0xC8	; 200
     a62:	d8 06       	cpc	r13, r24
     a64:	e1 04       	cpc	r14, r1
     a66:	f1 04       	cpc	r15, r1
     a68:	30 f3       	brcs	.-52     	; 0xa36 <find_offset+0x24>
			break;
		}
	}
	return 0;
     a6a:	60 e0       	ldi	r22, 0x00	; 0
     a6c:	70 e0       	ldi	r23, 0x00	; 0
     a6e:	80 e0       	ldi	r24, 0x00	; 0
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	04 c0       	rjmp	.+8      	; 0xa7c <find_offset+0x6a>
	{
		pf_lseek(tempOffset);
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
		if(read_first[0] == 32)
		{
			return tempOffset;
     a74:	6c 2d       	mov	r22, r12
     a76:	7d 2d       	mov	r23, r13
     a78:	8e 2d       	mov	r24, r14
     a7a:	9f 2d       	mov	r25, r15
			if(tempOffset >= maxOffset)
			break;
		}
	}
	return 0;
}
     a7c:	0f 90       	pop	r0
     a7e:	0f 90       	pop	r0
     a80:	0f 90       	pop	r0
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	ff 90       	pop	r15
     a88:	ef 90       	pop	r14
     a8a:	df 90       	pop	r13
     a8c:	cf 90       	pop	r12
     a8e:	08 95       	ret

00000a90 <start_log_message>:

void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
     a90:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     a94:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     a98:	9c 01       	movw	r18, r24
     a9a:	2f 5f       	subi	r18, 0xFF	; 255
     a9c:	3f 4f       	sbci	r19, 0xFF	; 255
     a9e:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     aa2:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     aa6:	fc 01       	movw	r30, r24
     aa8:	e3 53       	subi	r30, 0x33	; 51
     aaa:	fe 4f       	sbci	r31, 0xFE	; 254
     aac:	2a e0       	ldi	r18, 0x0A	; 10
     aae:	20 83       	st	Z, r18
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     ab0:	20 e0       	ldi	r18, 0x00	; 0
     ab2:	30 e0       	ldi	r19, 0x00	; 0
     ab4:	15 c0       	rjmp	.+42     	; 0xae0 <start_log_message+0x50>
	{
		write_buffer[bufferAmt++] = string[i];
     ab6:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     aba:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     abe:	ac 01       	movw	r20, r24
     ac0:	4f 5f       	subi	r20, 0xFF	; 255
     ac2:	5f 4f       	sbci	r21, 0xFF	; 255
     ac4:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <bufferAmt+0x1>
     ac8:	40 93 c9 01 	sts	0x01C9, r20	; 0x8001c9 <bufferAmt>
     acc:	f9 01       	movw	r30, r18
     ace:	ec 5d       	subi	r30, 0xDC	; 220
     ad0:	fe 4f       	sbci	r31, 0xFE	; 254
     ad2:	40 81       	ld	r20, Z
     ad4:	fc 01       	movw	r30, r24
     ad6:	e3 53       	subi	r30, 0x33	; 51
     ad8:	fe 4f       	sbci	r31, 0xFE	; 254
     ada:	40 83       	st	Z, r20
void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     adc:	2f 5f       	subi	r18, 0xFF	; 255
     ade:	3f 4f       	sbci	r19, 0xFF	; 255
     ae0:	2e 30       	cpi	r18, 0x0E	; 14
     ae2:	31 05       	cpc	r19, r1
     ae4:	44 f3       	brlt	.-48     	; 0xab6 <start_log_message+0x26>
	{
		write_buffer[bufferAmt++] = string[i];
	}
	write_buffer[bufferAmt++] = '\n';
     ae6:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     aea:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     aee:	9c 01       	movw	r18, r24
     af0:	2f 5f       	subi	r18, 0xFF	; 255
     af2:	3f 4f       	sbci	r19, 0xFF	; 255
     af4:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     af8:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     afc:	fc 01       	movw	r30, r24
     afe:	e3 53       	subi	r30, 0x33	; 51
     b00:	fe 4f       	sbci	r31, 0xFE	; 254
     b02:	2a e0       	ldi	r18, 0x0A	; 10
     b04:	20 83       	st	Z, r18
     b06:	08 95       	ret

00000b08 <init_sd_card>:
	DSTATUS status;
	FRESULT result;
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
     b08:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
		if (status != 0) {
     b0c:	81 11       	cpse	r24, r1
     b0e:	07 c0       	rjmp	.+14     	; 0xb1e <init_sd_card+0x16>
			ERROR = 1; 
		} else {
			ERROR = 0;			
			// Set SPI clock faster after initialization 
			SPCR = (1<<MSTR) | (1<<SPE);
     b10:	80 e5       	ldi	r24, 0x50	; 80
     b12:	8c bd       	out	0x2c, r24	; 44
			//SPCR = (1<<MSTR) | (0<<SPR1) | (0<<SPR0) | (1<<SPE);
			SPSR = (1<<SPI2X); 		
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	8d bd       	out	0x2d, r24	; 45
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
		} else {
			ERROR = 0;			
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	02 c0       	rjmp	.+4      	; 0xb22 <init_sd_card+0x1a>
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
     b1e:	81 e0       	ldi	r24, 0x01	; 1
     b20:	90 e0       	ldi	r25, 0x00	; 0
			//SPR1 en 0 op 0 SPI clock set to fck/4 (blaz. 174)
			//MSTR, in mastermode zetten
			//SPE, SPI enable maken.
			//SPI2X, het verdubbelen van de snelheid.			
		}
	} while (ERROR == 1);
     b22:	01 97       	sbiw	r24, 0x01	; 1
     b24:	89 f3       	breq	.-30     	; 0xb08 <init_sd_card>

	// Mount volume 
	result = pf_mount(&file_system);
     b26:	8b ea       	ldi	r24, 0xAB	; 171
     b28:	94 e0       	ldi	r25, 0x04	; 4
     b2a:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <pf_mount>
	if (result != FR_OK) {} // error

	// Open file 
	result = pf_open("LOG.txt");
     b2e:	83 e3       	ldi	r24, 0x33	; 51
     b30:	91 e0       	ldi	r25, 0x01	; 1
     b32:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <pf_open>
     b36:	08 95       	ret

00000b38 <main>:
	
int main(void)
{	
	_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | (1<<CLKPS1)));
	//_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | ((0<<CLKPS3) | (0<<CLKPS2) | (1<<CLKPS1) | (0<<CLKPS0))));
	init_sd_card(); // initialize sd-card
     b38:	0e 94 84 05 	call	0xb08	; 0xb08 <init_sd_card>
	sei();
     b3c:	78 94       	sei
	initCAN(); // init can-bus
     b3e:	0e 94 69 00 	call	0xd2	; 0xd2 <initCAN>
	listenForMessage(CAN_ID_SNELHEIDSMETER, 8);
     b42:	68 e0       	ldi	r22, 0x08	; 8
     b44:	80 e1       	ldi	r24, 0x10	; 16
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	0e 94 9f 00 	call	0x13e	; 0x13e <listenForMessage>
	init_timer();
     b4c:	0e 94 41 04 	call	0x882	; 0x882 <init_timer>
	curOffset = find_offset(); // returnt offset van eerstvolgende lege sector
     b50:	0e 94 09 05 	call	0xa12	; 0xa12 <find_offset>
     b54:	60 93 c2 01 	sts	0x01C2, r22	; 0x8001c2 <curOffset>
     b58:	70 93 c3 01 	sts	0x01C3, r23	; 0x8001c3 <curOffset+0x1>
     b5c:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <curOffset+0x2>
     b60:	90 93 c5 01 	sts	0x01C5, r25	; 0x8001c5 <curOffset+0x3>
	start_log_message(); // schrijf start log bericht naar de kaart zodat je kan zien wanneer de auto opnieuw aan is gezet
     b64:	0e 94 48 05 	call	0xa90	; 0xa90 <start_log_message>
	while(1)
	{
		if(overflowCounter>=61) // 61 komt van 16.000.000 / 1024 (klokfrequentie / timer2prescaler) =  15625. 15625 / 256 (8 bit timer) = 61
     b68:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <overflowCounter>
     b6c:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <overflowCounter+0x1>
     b70:	cd 97       	sbiw	r24, 0x3d	; 61
     b72:	34 f0       	brlt	.+12     	; 0xb80 <main+0x48>
		{
			fill_buffer();
     b74:	0e 94 4a 04 	call	0x894	; 0x894 <fill_buffer>
			overflowCounter = 0;
     b78:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <overflowCounter+0x1>
     b7c:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <overflowCounter>
		}
		
		if(startWriting)
     b80:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <startWriting>
     b84:	88 23       	and	r24, r24
     b86:	81 f3       	breq	.-32     	; 0xb68 <main+0x30>
		{
			PORTC ^= (1 << PC0); // toggle ter indicatie op oscilloscoop
     b88:	98 b1       	in	r25, 0x08	; 8
     b8a:	81 e0       	ldi	r24, 0x01	; 1
     b8c:	89 27       	eor	r24, r25
     b8e:	88 b9       	out	0x08, r24	; 8
			writeToCard(); // schrijf buffer op kaart
     b90:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <writeToCard>
			curOffset += 512; // zet pointer naar volgende sector
     b94:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <curOffset>
     b98:	90 91 c3 01 	lds	r25, 0x01C3	; 0x8001c3 <curOffset+0x1>
     b9c:	a0 91 c4 01 	lds	r26, 0x01C4	; 0x8001c4 <curOffset+0x2>
     ba0:	b0 91 c5 01 	lds	r27, 0x01C5	; 0x8001c5 <curOffset+0x3>
     ba4:	9e 5f       	subi	r25, 0xFE	; 254
     ba6:	af 4f       	sbci	r26, 0xFF	; 255
     ba8:	bf 4f       	sbci	r27, 0xFF	; 255
     baa:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <curOffset>
     bae:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <curOffset+0x1>
     bb2:	a0 93 c4 01 	sts	0x01C4, r26	; 0x8001c4 <curOffset+0x2>
     bb6:	b0 93 c5 01 	sts	0x01C5, r27	; 0x8001c5 <curOffset+0x3>
			startWriting = false;
     bba:	10 92 c6 01 	sts	0x01C6, r1	; 0x8001c6 <startWriting>
     bbe:	d4 cf       	rjmp	.-88     	; 0xb68 <main+0x30>

00000bc0 <mem_set>:

static FATFS *FatFs; /* Pointer to the file system object (logical drive) */

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
     bc0:	fc 01       	movw	r30, r24
	char *d = (char *)dst;
	while (cnt--)
     bc2:	03 c0       	rjmp	.+6      	; 0xbca <mem_set+0xa>
		*d++ = (char)val;
     bc4:	60 83       	st	Z, r22

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     bc6:	ac 01       	movw	r20, r24
		*d++ = (char)val;
     bc8:	31 96       	adiw	r30, 0x01	; 1

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     bca:	ca 01       	movw	r24, r20
     bcc:	01 97       	sbiw	r24, 0x01	; 1
     bce:	45 2b       	or	r20, r21
     bd0:	c9 f7       	brne	.-14     	; 0xbc4 <mem_set+0x4>
		*d++ = (char)val;
}
     bd2:	08 95       	ret

00000bd4 <mem_cmp>:

/* Compare memory to memory */
static int mem_cmp(const void *dst, const void *src, int cnt)
{
     bd4:	cf 93       	push	r28
     bd6:	df 93       	push	r29
     bd8:	dc 01       	movw	r26, r24
     bda:	fb 01       	movw	r30, r22
	const char *d = (const char *)dst, *s = (const char *)src;
	int         r = 0;
     bdc:	80 e0       	ldi	r24, 0x00	; 0
     bde:	90 e0       	ldi	r25, 0x00	; 0
	while (cnt-- && (r = *d++ - *s++) == 0)
     be0:	02 c0       	rjmp	.+4      	; 0xbe6 <mem_cmp+0x12>
     be2:	fb 01       	movw	r30, r22
     be4:	de 01       	movw	r26, r28
     be6:	9a 01       	movw	r18, r20
     be8:	21 50       	subi	r18, 0x01	; 1
     bea:	31 09       	sbc	r19, r1
     bec:	45 2b       	or	r20, r21
     bee:	61 f0       	breq	.+24     	; 0xc08 <mem_cmp+0x34>
     bf0:	ed 01       	movw	r28, r26
     bf2:	21 96       	adiw	r28, 0x01	; 1
     bf4:	8c 91       	ld	r24, X
     bf6:	90 e0       	ldi	r25, 0x00	; 0
     bf8:	bf 01       	movw	r22, r30
     bfa:	6f 5f       	subi	r22, 0xFF	; 255
     bfc:	7f 4f       	sbci	r23, 0xFF	; 255
     bfe:	40 81       	ld	r20, Z
     c00:	84 1b       	sub	r24, r20
     c02:	91 09       	sbc	r25, r1
     c04:	a9 01       	movw	r20, r18
     c06:	69 f3       	breq	.-38     	; 0xbe2 <mem_cmp+0xe>
		;
	return r;
}
     c08:	df 91       	pop	r29
     c0a:	cf 91       	pop	r28
     c0c:	08 95       	ret

00000c0e <clust2sect>:
/*-----------------------------------------------------------------------*/

static DWORD clust2sect(           /* !=0: Sector number, 0: Failed - invalid cluster# */
                        CLUST clst /* Cluster# to be converted */
)
{
     c0e:	0f 93       	push	r16
     c10:	1f 93       	push	r17
	FATFS *fs = FatFs;
     c12:	e0 91 cd 03 	lds	r30, 0x03CD	; 0x8003cd <FatFs>
     c16:	f0 91 ce 03 	lds	r31, 0x03CE	; 0x8003ce <FatFs+0x1>

	clst -= 2;
     c1a:	9b 01       	movw	r18, r22
     c1c:	ac 01       	movw	r20, r24
     c1e:	22 50       	subi	r18, 0x02	; 2
     c20:	31 09       	sbc	r19, r1
     c22:	41 09       	sbc	r20, r1
     c24:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2))
     c26:	86 81       	ldd	r24, Z+6	; 0x06
     c28:	97 81       	ldd	r25, Z+7	; 0x07
     c2a:	a0 85       	ldd	r26, Z+8	; 0x08
     c2c:	b1 85       	ldd	r27, Z+9	; 0x09
     c2e:	02 97       	sbiw	r24, 0x02	; 2
     c30:	a1 09       	sbc	r26, r1
     c32:	b1 09       	sbc	r27, r1
     c34:	28 17       	cp	r18, r24
     c36:	39 07       	cpc	r19, r25
     c38:	4a 07       	cpc	r20, r26
     c3a:	5b 07       	cpc	r21, r27
     c3c:	68 f4       	brcc	.+26     	; 0xc58 <clust2sect+0x4a>
		return 0; /* Invalid cluster# */
	return (DWORD)clst * fs->csize + fs->database;
     c3e:	a2 81       	ldd	r26, Z+2	; 0x02
     c40:	b0 e0       	ldi	r27, 0x00	; 0
     c42:	0e 94 32 0e 	call	0x1c64	; 0x1c64 <__muluhisi3>
     c46:	02 89       	ldd	r16, Z+18	; 0x12
     c48:	13 89       	ldd	r17, Z+19	; 0x13
     c4a:	24 89       	ldd	r18, Z+20	; 0x14
     c4c:	35 89       	ldd	r19, Z+21	; 0x15
     c4e:	60 0f       	add	r22, r16
     c50:	71 1f       	adc	r23, r17
     c52:	82 1f       	adc	r24, r18
     c54:	93 1f       	adc	r25, r19
     c56:	03 c0       	rjmp	.+6      	; 0xc5e <clust2sect+0x50>
{
	FATFS *fs = FatFs;

	clst -= 2;
	if (clst >= (fs->n_fatent - 2))
		return 0; /* Invalid cluster# */
     c58:	60 e0       	ldi	r22, 0x00	; 0
     c5a:	70 e0       	ldi	r23, 0x00	; 0
     c5c:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	08 95       	ret

00000c64 <get_clust>:

static CLUST get_clust(BYTE *dir /* Pointer to directory entry */
)
{
     c64:	0f 93       	push	r16
     c66:	1f 93       	push	r17
     c68:	fc 01       	movw	r30, r24
	FATFS *fs   = FatFs;
	CLUST  clst = 0;

	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
		clst = LD_WORD(dir + DIR_FstClusHI);
     c6a:	65 89       	ldd	r22, Z+21	; 0x15
     c6c:	70 e0       	ldi	r23, 0x00	; 0
     c6e:	76 2f       	mov	r23, r22
     c70:	66 27       	eor	r22, r22
     c72:	84 89       	ldd	r24, Z+20	; 0x14
     c74:	68 2b       	or	r22, r24
     c76:	cb 01       	movw	r24, r22
     c78:	a0 e0       	ldi	r26, 0x00	; 0
     c7a:	b0 e0       	ldi	r27, 0x00	; 0
		clst <<= 16;
     c7c:	bc 01       	movw	r22, r24
     c7e:	55 27       	eor	r21, r21
     c80:	44 27       	eor	r20, r20
	}
	clst |= LD_WORD(dir + DIR_FstClusLO);
     c82:	83 8d       	ldd	r24, Z+27	; 0x1b
     c84:	90 e0       	ldi	r25, 0x00	; 0
     c86:	98 2f       	mov	r25, r24
     c88:	88 27       	eor	r24, r24
     c8a:	22 8d       	ldd	r18, Z+26	; 0x1a
     c8c:	82 2b       	or	r24, r18
     c8e:	a0 e0       	ldi	r26, 0x00	; 0
     c90:	b0 e0       	ldi	r27, 0x00	; 0
     c92:	8c 01       	movw	r16, r24
     c94:	9d 01       	movw	r18, r26
     c96:	04 2b       	or	r16, r20
     c98:	15 2b       	or	r17, r21
     c9a:	26 2b       	or	r18, r22
     c9c:	37 2b       	or	r19, r23
     c9e:	c9 01       	movw	r24, r18
     ca0:	b8 01       	movw	r22, r16

	return clst;
}
     ca2:	1f 91       	pop	r17
     ca4:	0f 91       	pop	r16
     ca6:	08 95       	ret

00000ca8 <dir_rewind>:
/* Directory handling - Rewind directory index                           */
/*-----------------------------------------------------------------------*/

static FRESULT dir_rewind(DIR *dj /* Pointer to directory object */
)
{
     ca8:	0f 93       	push	r16
     caa:	1f 93       	push	r17
     cac:	cf 93       	push	r28
     cae:	df 93       	push	r29
     cb0:	fc 01       	movw	r30, r24
	CLUST  clst;
	FATFS *fs = FatFs;
     cb2:	a0 91 cd 03 	lds	r26, 0x03CD	; 0x8003cd <FatFs>
     cb6:	b0 91 ce 03 	lds	r27, 0x03CE	; 0x8003ce <FatFs+0x1>

	dj->index = 0;
     cba:	11 82       	std	Z+1, r1	; 0x01
     cbc:	10 82       	st	Z, r1
	clst      = dj->sclust;
     cbe:	64 81       	ldd	r22, Z+4	; 0x04
     cc0:	75 81       	ldd	r23, Z+5	; 0x05
     cc2:	86 81       	ldd	r24, Z+6	; 0x06
     cc4:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
     cc6:	61 30       	cpi	r22, 0x01	; 1
     cc8:	71 05       	cpc	r23, r1
     cca:	81 05       	cpc	r24, r1
     ccc:	91 05       	cpc	r25, r1
     cce:	19 f1       	breq	.+70     	; 0xd16 <dir_rewind+0x6e>
     cd0:	16 96       	adiw	r26, 0x06	; 6
     cd2:	0d 91       	ld	r16, X+
     cd4:	1d 91       	ld	r17, X+
     cd6:	2d 91       	ld	r18, X+
     cd8:	3c 91       	ld	r19, X
     cda:	19 97       	sbiw	r26, 0x09	; 9
     cdc:	60 17       	cp	r22, r16
     cde:	71 07       	cpc	r23, r17
     ce0:	82 07       	cpc	r24, r18
     ce2:	93 07       	cpc	r25, r19
     ce4:	d0 f4       	brcc	.+52     	; 0xd1a <dir_rewind+0x72>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst
     ce6:	61 15       	cp	r22, r1
     ce8:	71 05       	cpc	r23, r1
     cea:	81 05       	cpc	r24, r1
     cec:	91 05       	cpc	r25, r1
     cee:	31 f4       	brne	.+12     	; 0xcfc <dir_rewind+0x54>
	    && (_FS_32ONLY || fs->fs_type == FS_FAT32)) /* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
     cf0:	1e 96       	adiw	r26, 0x0e	; 14
     cf2:	6d 91       	ld	r22, X+
     cf4:	7d 91       	ld	r23, X+
     cf6:	8d 91       	ld	r24, X+
     cf8:	9c 91       	ld	r25, X
     cfa:	51 97       	sbiw	r26, 0x11	; 17
     cfc:	ef 01       	movw	r28, r30
	dj->clust = clst;                                                  /* Current cluster */
     cfe:	60 87       	std	Z+8, r22	; 0x08
     d00:	71 87       	std	Z+9, r23	; 0x09
     d02:	82 87       	std	Z+10, r24	; 0x0a
     d04:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */
     d06:	0e 94 07 06 	call	0xc0e	; 0xc0e <clust2sect>
     d0a:	6c 87       	std	Y+12, r22	; 0x0c
     d0c:	7d 87       	std	Y+13, r23	; 0x0d
     d0e:	8e 87       	std	Y+14, r24	; 0x0e
     d10:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK; /* Seek succeeded */
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	03 c0       	rjmp	.+6      	; 0xd1c <dir_rewind+0x74>
	FATFS *fs = FatFs;

	dj->index = 0;
	clst      = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
		return FR_DISK_ERR;
     d16:	81 e0       	ldi	r24, 0x01	; 1
     d18:	01 c0       	rjmp	.+2      	; 0xd1c <dir_rewind+0x74>
     d1a:	81 e0       	ldi	r24, 0x01	; 1
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;                                                  /* Current cluster */
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */

	return FR_OK; /* Seek succeeded */
}
     d1c:	df 91       	pop	r29
     d1e:	cf 91       	pop	r28
     d20:	1f 91       	pop	r17
     d22:	0f 91       	pop	r16
     d24:	08 95       	ret

00000d26 <create_name>:
/*-----------------------------------------------------------------------*/

static FRESULT create_name(DIR *        dj,  /* Pointer to the directory object */
                           const char **path /* Pointer to pointer to the segment in the path string */
)
{
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	eb 01       	movw	r28, r22
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
     d30:	fc 01       	movw	r30, r24
     d32:	02 81       	ldd	r16, Z+2	; 0x02
     d34:	13 81       	ldd	r17, Z+3	; 0x03
	mem_set(sfn, ' ', 11);
     d36:	4b e0       	ldi	r20, 0x0B	; 11
     d38:	50 e0       	ldi	r21, 0x00	; 0
     d3a:	60 e2       	ldi	r22, 0x20	; 32
     d3c:	70 e0       	ldi	r23, 0x00	; 0
     d3e:	c8 01       	movw	r24, r16
     d40:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <mem_set>
	si = i = 0;
	ni     = 8;
	p      = *path;
     d44:	28 81       	ld	r18, Y
     d46:	39 81       	ldd	r19, Y+1	; 0x01
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0;
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	80 e0       	ldi	r24, 0x00	; 0
	ni     = 8;
     d4c:	58 e0       	ldi	r21, 0x08	; 8
     d4e:	01 c0       	rjmp	.+2      	; 0xd52 <create_name+0x2c>
     d50:	84 2f       	mov	r24, r20
	p      = *path;
	for (;;) {
		c = p[si++];
     d52:	41 e0       	ldi	r20, 0x01	; 1
     d54:	48 0f       	add	r20, r24
     d56:	f9 01       	movw	r30, r18
     d58:	e8 0f       	add	r30, r24
     d5a:	f1 1d       	adc	r31, r1
     d5c:	e0 81       	ld	r30, Z
		if (c <= ' ' || c == '/')
     d5e:	e1 32       	cpi	r30, 0x21	; 33
     d60:	f0 f0       	brcs	.+60     	; 0xd9e <create_name+0x78>
     d62:	ef 32       	cpi	r30, 0x2F	; 47
     d64:	e1 f0       	breq	.+56     	; 0xd9e <create_name+0x78>
			break; /* Break on end of segment */
		if (c == '.' || i >= ni) {
     d66:	ee 32       	cpi	r30, 0x2E	; 46
     d68:	11 f0       	breq	.+4      	; 0xd6e <create_name+0x48>
     d6a:	95 17       	cp	r25, r21
     d6c:	38 f0       	brcs	.+14     	; 0xd7c <create_name+0x56>
			if (ni != 8 || c != '.')
     d6e:	58 30       	cpi	r21, 0x08	; 8
     d70:	b1 f4       	brne	.+44     	; 0xd9e <create_name+0x78>
     d72:	ee 32       	cpi	r30, 0x2E	; 46
     d74:	a1 f4       	brne	.+40     	; 0xd9e <create_name+0x78>
				break;
			i  = 8;
     d76:	98 e0       	ldi	r25, 0x08	; 8
			ni = 11;
     d78:	5b e0       	ldi	r21, 0x0B	; 11
     d7a:	ea cf       	rjmp	.-44     	; 0xd50 <create_name+0x2a>
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80) /* To upper extended char (SBCS) */
     d7c:	ee 23       	and	r30, r30
     d7e:	24 f4       	brge	.+8      	; 0xd88 <create_name+0x62>
			c = cvt[c - 0x80];
     d80:	f0 e0       	ldi	r31, 0x00	; 0
     d82:	e5 54       	subi	r30, 0x45	; 69
     d84:	ff 4f       	sbci	r31, 0xFF	; 255
     d86:	e0 81       	ld	r30, Z
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{ /* Single byte code */
			if (_USE_LCC && IsLower(c))
     d88:	8f e9       	ldi	r24, 0x9F	; 159
     d8a:	8e 0f       	add	r24, r30
     d8c:	8a 31       	cpi	r24, 0x1A	; 26
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <create_name+0x6c>
				c -= 0x20; /* toupper */
     d90:	e0 52       	subi	r30, 0x20	; 32
			sfn[i++] = c;
     d92:	d8 01       	movw	r26, r16
     d94:	a9 0f       	add	r26, r25
     d96:	b1 1d       	adc	r27, r1
     d98:	ec 93       	st	X, r30
     d9a:	9f 5f       	subi	r25, 0xFF	; 255
     d9c:	d9 cf       	rjmp	.-78     	; 0xd50 <create_name+0x2a>
		}
	}
	*path = &p[si]; /* Rerurn pointer to the next segment */
     d9e:	24 0f       	add	r18, r20
     da0:	31 1d       	adc	r19, r1
     da2:	39 83       	std	Y+1, r19	; 0x01
     da4:	28 83       	st	Y, r18

	sfn[11] = (c <= ' ') ? 1 : 0; /* Set last segment flag if end of path */
     da6:	81 e0       	ldi	r24, 0x01	; 1
     da8:	e1 32       	cpi	r30, 0x21	; 33
     daa:	08 f0       	brcs	.+2      	; 0xdae <create_name+0x88>
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	f8 01       	movw	r30, r16
     db0:	83 87       	std	Z+11, r24	; 0x0b

	return FR_OK;
}
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	1f 91       	pop	r17
     dba:	0f 91       	pop	r16
     dbc:	08 95       	ret

00000dbe <check_fs>:

static BYTE check_fs(/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     dbe:	cf 92       	push	r12
     dc0:	df 92       	push	r13
     dc2:	ef 92       	push	r14
     dc4:	ff 92       	push	r15
     dc6:	0f 93       	push	r16
     dc8:	1f 93       	push	r17
     dca:	cf 93       	push	r28
     dcc:	df 93       	push	r29
     dce:	ec 01       	movw	r28, r24
     dd0:	6a 01       	movw	r12, r20
     dd2:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
     dd4:	02 e0       	ldi	r16, 0x02	; 2
     dd6:	10 e0       	ldi	r17, 0x00	; 0
     dd8:	2e ef       	ldi	r18, 0xFE	; 254
     dda:	31 e0       	ldi	r19, 0x01	; 1
     ddc:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     de0:	81 11       	cpse	r24, r1
     de2:	1d c0       	rjmp	.+58     	; 0xe1e <check_fs+0x60>
		return 3;
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
     de4:	89 81       	ldd	r24, Y+1	; 0x01
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	98 2f       	mov	r25, r24
     dea:	88 27       	eor	r24, r24
     dec:	28 81       	ld	r18, Y
     dee:	82 2b       	or	r24, r18
     df0:	85 35       	cpi	r24, 0x55	; 85
     df2:	9a 4a       	sbci	r25, 0xAA	; 170
     df4:	b1 f4       	brne	.+44     	; 0xe22 <check_fs+0x64>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
     df6:	22 e5       	ldi	r18, 0x52	; 82
     df8:	30 e0       	ldi	r19, 0x00	; 0
     dfa:	b7 01       	movw	r22, r14
     dfc:	a6 01       	movw	r20, r12
     dfe:	ce 01       	movw	r24, r28
     e00:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     e04:	81 11       	cpse	r24, r1
     e06:	0f c0       	rjmp	.+30     	; 0xe26 <check_fs+0x68>
     e08:	89 81       	ldd	r24, Y+1	; 0x01
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	98 2f       	mov	r25, r24
     e0e:	88 27       	eor	r24, r24
     e10:	28 81       	ld	r18, Y
     e12:	82 2b       	or	r24, r18
     e14:	86 34       	cpi	r24, 0x46	; 70
     e16:	91 44       	sbci	r25, 0x41	; 65
     e18:	41 f0       	breq	.+16     	; 0xe2a <check_fs+0x6c>
		return 0;
	return 1;
     e1a:	81 e0       	ldi	r24, 0x01	; 1
     e1c:	07 c0       	rjmp	.+14     	; 0xe2c <check_fs+0x6e>
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
		return 3;
     e1e:	83 e0       	ldi	r24, 0x03	; 3
     e20:	05 c0       	rjmp	.+10     	; 0xe2c <check_fs+0x6e>
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
		return 2;
     e22:	82 e0       	ldi	r24, 0x02	; 2
     e24:	03 c0       	rjmp	.+6      	; 0xe2c <check_fs+0x6e>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
	return 1;
     e26:	81 e0       	ldi	r24, 0x01	; 1
     e28:	01 c0       	rjmp	.+2      	; 0xe2c <check_fs+0x6e>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
     e2a:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	ff 90       	pop	r15
     e36:	ef 90       	pop	r14
     e38:	df 90       	pop	r13
     e3a:	cf 90       	pop	r12
     e3c:	08 95       	ret

00000e3e <get_fat>:
/*-----------------------------------------------------------------------*/

static CLUST get_fat(           /* 1:IO error, Else:Cluster status */
                     CLUST clst /* Cluster# to get the link information */
)
{
     e3e:	cf 92       	push	r12
     e40:	df 92       	push	r13
     e42:	ef 92       	push	r14
     e44:	ff 92       	push	r15
     e46:	0f 93       	push	r16
     e48:	1f 93       	push	r17
     e4a:	cf 93       	push	r28
     e4c:	df 93       	push	r29
     e4e:	00 d0       	rcall	.+0      	; 0xe50 <get_fat+0x12>
     e50:	00 d0       	rcall	.+0      	; 0xe52 <get_fat+0x14>
     e52:	cd b7       	in	r28, 0x3d	; 61
     e54:	de b7       	in	r29, 0x3e	; 62
	BYTE   buf[4];
	FATFS *fs = FatFs;
     e56:	e0 91 cd 03 	lds	r30, 0x03CD	; 0x8003cd <FatFs>
     e5a:	f0 91 ce 03 	lds	r31, 0x03CE	; 0x8003ce <FatFs+0x1>

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
     e5e:	62 30       	cpi	r22, 0x02	; 2
     e60:	71 05       	cpc	r23, r1
     e62:	81 05       	cpc	r24, r1
     e64:	91 05       	cpc	r25, r1
     e66:	08 f4       	brcc	.+2      	; 0xe6a <get_fat+0x2c>
     e68:	56 c0       	rjmp	.+172    	; 0xf16 <get_fat+0xd8>
     e6a:	06 81       	ldd	r16, Z+6	; 0x06
     e6c:	17 81       	ldd	r17, Z+7	; 0x07
     e6e:	20 85       	ldd	r18, Z+8	; 0x08
     e70:	31 85       	ldd	r19, Z+9	; 0x09
     e72:	60 17       	cp	r22, r16
     e74:	71 07       	cpc	r23, r17
     e76:	82 07       	cpc	r24, r18
     e78:	93 07       	cpc	r25, r19
     e7a:	08 f0       	brcs	.+2      	; 0xe7e <get_fat+0x40>
     e7c:	51 c0       	rjmp	.+162    	; 0xf20 <get_fat+0xe2>
		return 1;

	switch (fs->fs_type) {
     e7e:	20 81       	ld	r18, Z
     e80:	23 30       	cpi	r18, 0x03	; 3
     e82:	09 f0       	breq	.+2      	; 0xe86 <get_fat+0x48>
     e84:	52 c0       	rjmp	.+164    	; 0xf2a <get_fat+0xec>
     e86:	dc 01       	movw	r26, r24
     e88:	cb 01       	movw	r24, r22
			break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32:
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4))
     e8a:	9c 01       	movw	r18, r24
     e8c:	2f 77       	andi	r18, 0x7F	; 127
     e8e:	33 27       	eor	r19, r19
     e90:	c2 84       	ldd	r12, Z+10	; 0x0a
     e92:	d3 84       	ldd	r13, Z+11	; 0x0b
     e94:	e4 84       	ldd	r14, Z+12	; 0x0c
     e96:	f5 84       	ldd	r15, Z+13	; 0x0d
     e98:	68 94       	set
     e9a:	16 f8       	bld	r1, 6
     e9c:	b6 95       	lsr	r27
     e9e:	a7 95       	ror	r26
     ea0:	97 95       	ror	r25
     ea2:	87 95       	ror	r24
     ea4:	16 94       	lsr	r1
     ea6:	d1 f7       	brne	.-12     	; 0xe9c <get_fat+0x5e>
     ea8:	22 0f       	add	r18, r18
     eaa:	33 1f       	adc	r19, r19
     eac:	22 0f       	add	r18, r18
     eae:	33 1f       	adc	r19, r19
     eb0:	b7 01       	movw	r22, r14
     eb2:	a6 01       	movw	r20, r12
     eb4:	48 0f       	add	r20, r24
     eb6:	59 1f       	adc	r21, r25
     eb8:	6a 1f       	adc	r22, r26
     eba:	7b 1f       	adc	r23, r27
     ebc:	04 e0       	ldi	r16, 0x04	; 4
     ebe:	10 e0       	ldi	r17, 0x00	; 0
     ec0:	ce 01       	movw	r24, r28
     ec2:	01 96       	adiw	r24, 0x01	; 1
     ec4:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     ec8:	81 11       	cpse	r24, r1
     eca:	34 c0       	rjmp	.+104    	; 0xf34 <get_fat+0xf6>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
     ecc:	8c 81       	ldd	r24, Y+4	; 0x04
     ece:	90 e0       	ldi	r25, 0x00	; 0
     ed0:	a0 e0       	ldi	r26, 0x00	; 0
     ed2:	b0 e0       	ldi	r27, 0x00	; 0
     ed4:	78 2f       	mov	r23, r24
     ed6:	66 27       	eor	r22, r22
     ed8:	55 27       	eor	r21, r21
     eda:	44 27       	eor	r20, r20
     edc:	9b 81       	ldd	r25, Y+3	; 0x03
     ede:	89 2f       	mov	r24, r25
     ee0:	90 e0       	ldi	r25, 0x00	; 0
     ee2:	a0 e0       	ldi	r26, 0x00	; 0
     ee4:	b0 e0       	ldi	r27, 0x00	; 0
     ee6:	dc 01       	movw	r26, r24
     ee8:	99 27       	eor	r25, r25
     eea:	88 27       	eor	r24, r24
     eec:	84 2b       	or	r24, r20
     eee:	95 2b       	or	r25, r21
     ef0:	a6 2b       	or	r26, r22
     ef2:	b7 2b       	or	r27, r23
     ef4:	6a 81       	ldd	r22, Y+2	; 0x02
     ef6:	70 e0       	ldi	r23, 0x00	; 0
     ef8:	76 2f       	mov	r23, r22
     efa:	66 27       	eor	r22, r22
     efc:	ab 01       	movw	r20, r22
     efe:	60 e0       	ldi	r22, 0x00	; 0
     f00:	70 e0       	ldi	r23, 0x00	; 0
     f02:	84 2b       	or	r24, r20
     f04:	95 2b       	or	r25, r21
     f06:	a6 2b       	or	r26, r22
     f08:	b7 2b       	or	r27, r23
     f0a:	29 81       	ldd	r18, Y+1	; 0x01
     f0c:	82 2b       	or	r24, r18
     f0e:	bc 01       	movw	r22, r24
     f10:	cd 01       	movw	r24, r26
     f12:	9f 70       	andi	r25, 0x0F	; 15
     f14:	13 c0       	rjmp	.+38     	; 0xf3c <get_fat+0xfe>
{
	BYTE   buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
		return 1;
     f16:	61 e0       	ldi	r22, 0x01	; 1
     f18:	70 e0       	ldi	r23, 0x00	; 0
     f1a:	80 e0       	ldi	r24, 0x00	; 0
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	0e c0       	rjmp	.+28     	; 0xf3c <get_fat+0xfe>
     f20:	61 e0       	ldi	r22, 0x01	; 1
     f22:	70 e0       	ldi	r23, 0x00	; 0
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	90 e0       	ldi	r25, 0x00	; 0
     f28:	09 c0       	rjmp	.+18     	; 0xf3c <get_fat+0xfe>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1; /* An error occured at the disk I/O layer */
     f2a:	61 e0       	ldi	r22, 0x01	; 1
     f2c:	70 e0       	ldi	r23, 0x00	; 0
     f2e:	80 e0       	ldi	r24, 0x00	; 0
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	04 c0       	rjmp	.+8      	; 0xf3c <get_fat+0xfe>
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	70 e0       	ldi	r23, 0x00	; 0
     f38:	80 e0       	ldi	r24, 0x00	; 0
     f3a:	90 e0       	ldi	r25, 0x00	; 0
}
     f3c:	0f 90       	pop	r0
     f3e:	0f 90       	pop	r0
     f40:	0f 90       	pop	r0
     f42:	0f 90       	pop	r0
     f44:	df 91       	pop	r29
     f46:	cf 91       	pop	r28
     f48:	1f 91       	pop	r17
     f4a:	0f 91       	pop	r16
     f4c:	ff 90       	pop	r15
     f4e:	ef 90       	pop	r14
     f50:	df 90       	pop	r13
     f52:	cf 90       	pop	r12
     f54:	08 95       	ret

00000f56 <dir_next>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_next(        /* FR_OK:Succeeded, FR_NO_FILE:End of table */
                        DIR *dj /* Pointer to directory object */
)
{
     f56:	cf 92       	push	r12
     f58:	df 92       	push	r13
     f5a:	ef 92       	push	r14
     f5c:	ff 92       	push	r15
     f5e:	0f 93       	push	r16
     f60:	1f 93       	push	r17
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
	CLUST  clst;
	WORD   i;
	FATFS *fs = FatFs;
     f66:	e0 90 cd 03 	lds	r14, 0x03CD	; 0x8003cd <FatFs>
     f6a:	f0 90 ce 03 	lds	r15, 0x03CE	; 0x8003ce <FatFs+0x1>

	i = dj->index + 1;
     f6e:	fc 01       	movw	r30, r24
     f70:	c0 81       	ld	r28, Z
     f72:	d1 81       	ldd	r29, Z+1	; 0x01
     f74:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
     f76:	09 f4       	brne	.+2      	; 0xf7a <dir_next+0x24>
     f78:	5c c0       	rjmp	.+184    	; 0x1032 <dir_next+0xdc>
     f7a:	44 85       	ldd	r20, Z+12	; 0x0c
     f7c:	55 85       	ldd	r21, Z+13	; 0x0d
     f7e:	66 85       	ldd	r22, Z+14	; 0x0e
     f80:	77 85       	ldd	r23, Z+15	; 0x0f
     f82:	41 15       	cp	r20, r1
     f84:	51 05       	cpc	r21, r1
     f86:	61 05       	cpc	r22, r1
     f88:	71 05       	cpc	r23, r1
     f8a:	09 f4       	brne	.+2      	; 0xf8e <dir_next+0x38>
     f8c:	54 c0       	rjmp	.+168    	; 0x1036 <dir_next+0xe0>
     f8e:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i % 16)) { /* Sector changed? */
     f90:	ce 01       	movw	r24, r28
     f92:	8f 70       	andi	r24, 0x0F	; 15
     f94:	99 27       	eor	r25, r25
     f96:	89 2b       	or	r24, r25
     f98:	09 f0       	breq	.+2      	; 0xf9c <dir_next+0x46>
     f9a:	46 c0       	rjmp	.+140    	; 0x1028 <dir_next+0xd2>
		dj->sect++;  /* Next sector */
     f9c:	4f 5f       	subi	r20, 0xFF	; 255
     f9e:	5f 4f       	sbci	r21, 0xFF	; 255
     fa0:	6f 4f       	sbci	r22, 0xFF	; 255
     fa2:	7f 4f       	sbci	r23, 0xFF	; 255
     fa4:	44 87       	std	Z+12, r20	; 0x0c
     fa6:	55 87       	std	Z+13, r21	; 0x0d
     fa8:	66 87       	std	Z+14, r22	; 0x0e
     faa:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {       /* Static table */
     fac:	40 85       	ldd	r20, Z+8	; 0x08
     fae:	51 85       	ldd	r21, Z+9	; 0x09
     fb0:	62 85       	ldd	r22, Z+10	; 0x0a
     fb2:	73 85       	ldd	r23, Z+11	; 0x0b
     fb4:	41 15       	cp	r20, r1
     fb6:	51 05       	cpc	r21, r1
     fb8:	61 05       	cpc	r22, r1
     fba:	71 05       	cpc	r23, r1
     fbc:	39 f4       	brne	.+14     	; 0xfcc <dir_next+0x76>
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
     fbe:	f7 01       	movw	r30, r14
     fc0:	84 81       	ldd	r24, Z+4	; 0x04
     fc2:	95 81       	ldd	r25, Z+5	; 0x05
     fc4:	c8 17       	cp	r28, r24
     fc6:	d9 07       	cpc	r29, r25
     fc8:	c0 f5       	brcc	.+112    	; 0x103a <dir_next+0xe4>
     fca:	2e c0       	rjmp	.+92     	; 0x1028 <dir_next+0xd2>
				return FR_NO_FILE;
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
     fcc:	f7 01       	movw	r30, r14
     fce:	82 81       	ldd	r24, Z+2	; 0x02
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	01 97       	sbiw	r24, 0x01	; 1
     fd4:	9e 01       	movw	r18, r28
     fd6:	32 95       	swap	r19
     fd8:	22 95       	swap	r18
     fda:	2f 70       	andi	r18, 0x0F	; 15
     fdc:	23 27       	eor	r18, r19
     fde:	3f 70       	andi	r19, 0x0F	; 15
     fe0:	23 27       	eor	r18, r19
     fe2:	82 23       	and	r24, r18
     fe4:	93 23       	and	r25, r19
     fe6:	89 2b       	or	r24, r25
     fe8:	f9 f4       	brne	.+62     	; 0x1028 <dir_next+0xd2>
				clst = get_fat(dj->clust);           /* Get next cluster */
     fea:	cb 01       	movw	r24, r22
     fec:	ba 01       	movw	r22, r20
     fee:	0e 94 1f 07 	call	0xe3e	; 0xe3e <get_fat>
				if (clst <= 1)
     ff2:	62 30       	cpi	r22, 0x02	; 2
     ff4:	71 05       	cpc	r23, r1
     ff6:	81 05       	cpc	r24, r1
     ff8:	91 05       	cpc	r25, r1
     ffa:	08 f1       	brcs	.+66     	; 0x103e <dir_next+0xe8>
					return FR_DISK_ERR;
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
     ffc:	f7 01       	movw	r30, r14
     ffe:	c6 80       	ldd	r12, Z+6	; 0x06
    1000:	d7 80       	ldd	r13, Z+7	; 0x07
    1002:	e0 84       	ldd	r14, Z+8	; 0x08
    1004:	f1 84       	ldd	r15, Z+9	; 0x09
    1006:	6c 15       	cp	r22, r12
    1008:	7d 05       	cpc	r23, r13
    100a:	8e 05       	cpc	r24, r14
    100c:	9f 05       	cpc	r25, r15
    100e:	c8 f4       	brcc	.+50     	; 0x1042 <dir_next+0xec>
					return FR_NO_FILE;    /* Report EOT */
				dj->clust = clst;         /* Initialize data for new cluster */
    1010:	f8 01       	movw	r30, r16
    1012:	60 87       	std	Z+8, r22	; 0x08
    1014:	71 87       	std	Z+9, r23	; 0x09
    1016:	82 87       	std	Z+10, r24	; 0x0a
    1018:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect  = clust2sect(clst);
    101a:	0e 94 07 06 	call	0xc0e	; 0xc0e <clust2sect>
    101e:	f8 01       	movw	r30, r16
    1020:	64 87       	std	Z+12, r22	; 0x0c
    1022:	75 87       	std	Z+13, r23	; 0x0d
    1024:	86 87       	std	Z+14, r24	; 0x0e
    1026:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
    1028:	f8 01       	movw	r30, r16
    102a:	d1 83       	std	Z+1, r29	; 0x01
    102c:	c0 83       	st	Z, r28

	return FR_OK;
    102e:	80 e0       	ldi	r24, 0x00	; 0
    1030:	09 c0       	rjmp	.+18     	; 0x1044 <dir_next+0xee>
	WORD   i;
	FATFS *fs = FatFs;

	i = dj->index + 1;
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    1032:	83 e0       	ldi	r24, 0x03	; 3
    1034:	07 c0       	rjmp	.+14     	; 0x1044 <dir_next+0xee>
    1036:	83 e0       	ldi	r24, 0x03	; 3
    1038:	05 c0       	rjmp	.+10     	; 0x1044 <dir_next+0xee>
	if (!(i % 16)) { /* Sector changed? */
		dj->sect++;  /* Next sector */

		if (dj->clust == 0) {       /* Static table */
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
				return FR_NO_FILE;
    103a:	83 e0       	ldi	r24, 0x03	; 3
    103c:	03 c0       	rjmp	.+6      	; 0x1044 <dir_next+0xee>
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
				clst = get_fat(dj->clust);           /* Get next cluster */
				if (clst <= 1)
					return FR_DISK_ERR;
    103e:	81 e0       	ldi	r24, 0x01	; 1
    1040:	01 c0       	rjmp	.+2      	; 0x1044 <dir_next+0xee>
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
					return FR_NO_FILE;    /* Report EOT */
    1042:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
    1044:	df 91       	pop	r29
    1046:	cf 91       	pop	r28
    1048:	1f 91       	pop	r17
    104a:	0f 91       	pop	r16
    104c:	ff 90       	pop	r15
    104e:	ef 90       	pop	r14
    1050:	df 90       	pop	r13
    1052:	cf 90       	pop	r12
    1054:	08 95       	ret

00001056 <dir_find>:
/*-----------------------------------------------------------------------*/

	static FRESULT dir_find(DIR * dj, /* Pointer to the directory object linked to the file name */
							BYTE *dir /* 32-byte working buffer */
	)
	{
    1056:	cf 92       	push	r12
    1058:	df 92       	push	r13
    105a:	ff 92       	push	r15
    105c:	0f 93       	push	r16
    105e:	1f 93       	push	r17
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	ec 01       	movw	r28, r24
    1066:	6b 01       	movw	r12, r22
		FRESULT res;
		BYTE    c;

		res = dir_rewind(dj); /* Rewind directory object */
    1068:	0e 94 54 06 	call	0xca8	; 0xca8 <dir_rewind>
		if (res != FR_OK)
    106c:	81 11       	cpse	r24, r1
    106e:	37 c0       	rjmp	.+110    	; 0x10de <dir_find+0x88>
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    1070:	28 81       	ld	r18, Y
    1072:	39 81       	ldd	r19, Y+1	; 0x01
    1074:	2f 70       	andi	r18, 0x0F	; 15
    1076:	33 27       	eor	r19, r19
    1078:	22 0f       	add	r18, r18
    107a:	33 1f       	adc	r19, r19
    107c:	22 95       	swap	r18
    107e:	32 95       	swap	r19
    1080:	30 7f       	andi	r19, 0xF0	; 240
    1082:	32 27       	eor	r19, r18
    1084:	20 7f       	andi	r18, 0xF0	; 240
    1086:	32 27       	eor	r19, r18
    1088:	4c 85       	ldd	r20, Y+12	; 0x0c
    108a:	5d 85       	ldd	r21, Y+13	; 0x0d
    108c:	6e 85       	ldd	r22, Y+14	; 0x0e
    108e:	7f 85       	ldd	r23, Y+15	; 0x0f
    1090:	00 e2       	ldi	r16, 0x20	; 32
    1092:	10 e0       	ldi	r17, 0x00	; 0
    1094:	c6 01       	movw	r24, r12
    1096:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
					  ? FR_DISK_ERR
					  : FR_OK;
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	81 11       	cpse	r24, r1
    109e:	01 c0       	rjmp	.+2      	; 0x10a2 <dir_find+0x4c>
    10a0:	90 e0       	ldi	r25, 0x00	; 0
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10a2:	f9 2e       	mov	r15, r25
					  ? FR_DISK_ERR
					  : FR_OK;
			if (res != FR_OK)
    10a4:	91 11       	cpse	r25, r1
    10a6:	16 c0       	rjmp	.+44     	; 0x10d4 <dir_find+0x7e>
				break;
			c = dir[DIR_Name]; /* First character */
    10a8:	f6 01       	movw	r30, r12
    10aa:	80 81       	ld	r24, Z
			if (c == 0) { ///// hieerrr fout misschien
    10ac:	88 23       	and	r24, r24
    10ae:	a1 f0       	breq	.+40     	; 0x10d8 <dir_find+0x82>
				res = FR_NO_FILE;
				break;
			}                                                           /* Reached to end of table */
			if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    10b0:	83 85       	ldd	r24, Z+11	; 0x0b
    10b2:	83 fd       	sbrc	r24, 3
    10b4:	09 c0       	rjmp	.+18     	; 0x10c8 <dir_find+0x72>
    10b6:	6a 81       	ldd	r22, Y+2	; 0x02
    10b8:	7b 81       	ldd	r23, Y+3	; 0x03
    10ba:	4b e0       	ldi	r20, 0x0B	; 11
    10bc:	50 e0       	ldi	r21, 0x00	; 0
    10be:	c6 01       	movw	r24, r12
    10c0:	0e 94 ea 05 	call	0xbd4	; 0xbd4 <mem_cmp>
    10c4:	89 2b       	or	r24, r25
    10c6:	51 f0       	breq	.+20     	; 0x10dc <dir_find+0x86>
				break;
			res = dir_next(dj); /* Next entry */
    10c8:	ce 01       	movw	r24, r28
    10ca:	0e 94 ab 07 	call	0xf56	; 0xf56 <dir_next>
		} while (res == FR_OK);
    10ce:	88 23       	and	r24, r24
    10d0:	79 f2       	breq	.-98     	; 0x1070 <dir_find+0x1a>
    10d2:	05 c0       	rjmp	.+10     	; 0x10de <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10d4:	89 2f       	mov	r24, r25
    10d6:	03 c0       	rjmp	.+6      	; 0x10de <dir_find+0x88>
					  : FR_OK;
			if (res != FR_OK)
				break;
			c = dir[DIR_Name]; /* First character */
			if (c == 0) { ///// hieerrr fout misschien
				res = FR_NO_FILE;
    10d8:	83 e0       	ldi	r24, 0x03	; 3
    10da:	01 c0       	rjmp	.+2      	; 0x10de <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10dc:	8f 2d       	mov	r24, r15
				break;
			res = dir_next(dj); /* Next entry */
		} while (res == FR_OK);

		return res;
	}
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	1f 91       	pop	r17
    10e4:	0f 91       	pop	r16
    10e6:	ff 90       	pop	r15
    10e8:	df 90       	pop	r13
    10ea:	cf 90       	pop	r12
    10ec:	08 95       	ret

000010ee <follow_path>:
static FRESULT follow_path(                 /* FR_OK(0): successful, !=0: error code */
                           DIR *       dj,  /* Directory object to return last directory and found object */
                           BYTE *      dir, /* 32-byte working buffer */
                           const char *path /* Full-path string to find a file or directory */
)
{
    10ee:	ef 92       	push	r14
    10f0:	ff 92       	push	r15
    10f2:	0f 93       	push	r16
    10f4:	1f 93       	push	r17
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <follow_path+0xe>
    10fc:	cd b7       	in	r28, 0x3d	; 61
    10fe:	de b7       	in	r29, 0x3e	; 62
    1100:	8c 01       	movw	r16, r24
    1102:	7b 01       	movw	r14, r22
    1104:	5a 83       	std	Y+2, r21	; 0x02
    1106:	49 83       	std	Y+1, r20	; 0x01
	FRESULT res;

	while (*path == ' ')
    1108:	03 c0       	rjmp	.+6      	; 0x1110 <follow_path+0x22>
		path++; /* Strip leading spaces */
    110a:	31 96       	adiw	r30, 0x01	; 1
    110c:	fa 83       	std	Y+2, r31	; 0x02
    110e:	e9 83       	std	Y+1, r30	; 0x01
                           const char *path /* Full-path string to find a file or directory */
)
{
	FRESULT res;

	while (*path == ' ')
    1110:	e9 81       	ldd	r30, Y+1	; 0x01
    1112:	fa 81       	ldd	r31, Y+2	; 0x02
    1114:	80 81       	ld	r24, Z
    1116:	80 32       	cpi	r24, 0x20	; 32
    1118:	c1 f3       	breq	.-16     	; 0x110a <follow_path+0x1c>
		path++; /* Strip leading spaces */
	if (*path == '/')
    111a:	8f 32       	cpi	r24, 0x2F	; 47
    111c:	19 f4       	brne	.+6      	; 0x1124 <follow_path+0x36>
		path++;     /* Strip heading separator if exist */
    111e:	31 96       	adiw	r30, 0x01	; 1
    1120:	fa 83       	std	Y+2, r31	; 0x02
    1122:	e9 83       	std	Y+1, r30	; 0x01
	dj->sclust = 0; /* Set start directory (always root dir) */
    1124:	d8 01       	movw	r26, r16
    1126:	14 96       	adiw	r26, 0x04	; 4
    1128:	1d 92       	st	X+, r1
    112a:	1d 92       	st	X+, r1
    112c:	1d 92       	st	X+, r1
    112e:	1c 92       	st	X, r1
    1130:	17 97       	sbiw	r26, 0x07	; 7

	if ((BYTE)*path < ' ') { /* Null path means the root directory */
    1132:	e9 81       	ldd	r30, Y+1	; 0x01
    1134:	fa 81       	ldd	r31, Y+2	; 0x02
    1136:	80 81       	ld	r24, Z
    1138:	80 32       	cpi	r24, 0x20	; 32
    113a:	30 f4       	brcc	.+12     	; 0x1148 <follow_path+0x5a>
		res    = dir_rewind(dj);
    113c:	c8 01       	movw	r24, r16
    113e:	0e 94 54 06 	call	0xca8	; 0xca8 <dir_rewind>
		dir[0] = 0;
    1142:	f7 01       	movw	r30, r14
    1144:	10 82       	st	Z, r1
    1146:	26 c0       	rjmp	.+76     	; 0x1194 <follow_path+0xa6>

	} else { /* Follow path */
		for (;;) {
			res = create_name(dj, &path); /* Get a segment */
    1148:	be 01       	movw	r22, r28
    114a:	6f 5f       	subi	r22, 0xFF	; 255
    114c:	7f 4f       	sbci	r23, 0xFF	; 255
    114e:	c8 01       	movw	r24, r16
    1150:	0e 94 93 06 	call	0xd26	; 0xd26 <create_name>
			if (res != FR_OK)
    1154:	81 11       	cpse	r24, r1
    1156:	1e c0       	rjmp	.+60     	; 0x1194 <follow_path+0xa6>
				break;
			res = dir_find(dj, dir); /* Find it */ // het gaat denk ik hier fout
    1158:	b7 01       	movw	r22, r14
    115a:	c8 01       	movw	r24, r16
    115c:	0e 94 2b 08 	call	0x1056	; 0x1056 <dir_find>
			if (res != FR_OK)
    1160:	81 11       	cpse	r24, r1
    1162:	18 c0       	rjmp	.+48     	; 0x1194 <follow_path+0xa6>
				break; /* Could not find the object */
			if (dj->fn[11])
    1164:	d8 01       	movw	r26, r16
    1166:	12 96       	adiw	r26, 0x02	; 2
    1168:	ed 91       	ld	r30, X+
    116a:	fc 91       	ld	r31, X
    116c:	13 97       	sbiw	r26, 0x03	; 3
    116e:	93 85       	ldd	r25, Z+11	; 0x0b
    1170:	91 11       	cpse	r25, r1
    1172:	10 c0       	rjmp	.+32     	; 0x1194 <follow_path+0xa6>
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
    1174:	f7 01       	movw	r30, r14
    1176:	83 85       	ldd	r24, Z+11	; 0x0b
    1178:	84 ff       	sbrs	r24, 4
    117a:	0b c0       	rjmp	.+22     	; 0x1192 <follow_path+0xa4>
				res = FR_NO_FILE;
				break;
			}
			dj->sclust = get_clust(dir); /* Follow next */
    117c:	c7 01       	movw	r24, r14
    117e:	0e 94 32 06 	call	0xc64	; 0xc64 <get_clust>
    1182:	d8 01       	movw	r26, r16
    1184:	14 96       	adiw	r26, 0x04	; 4
    1186:	6d 93       	st	X+, r22
    1188:	7d 93       	st	X+, r23
    118a:	8d 93       	st	X+, r24
    118c:	9c 93       	st	X, r25
    118e:	17 97       	sbiw	r26, 0x07	; 7
		}
    1190:	db cf       	rjmp	.-74     	; 0x1148 <follow_path+0x5a>
			if (res != FR_OK)
				break; /* Could not find the object */
			if (dj->fn[11])
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE;
    1192:	83 e0       	ldi	r24, 0x03	; 3
			dj->sclust = get_clust(dir); /* Follow next */
		}
	}

	return res;
}
    1194:	0f 90       	pop	r0
    1196:	0f 90       	pop	r0
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	1f 91       	pop	r17
    119e:	0f 91       	pop	r16
    11a0:	ff 90       	pop	r15
    11a2:	ef 90       	pop	r14
    11a4:	08 95       	ret

000011a6 <pf_mount>:
/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount(FATFS *fs /* Pointer to new file system object */)
{
    11a6:	4f 92       	push	r4
    11a8:	5f 92       	push	r5
    11aa:	6f 92       	push	r6
    11ac:	7f 92       	push	r7
    11ae:	8f 92       	push	r8
    11b0:	9f 92       	push	r9
    11b2:	af 92       	push	r10
    11b4:	bf 92       	push	r11
    11b6:	df 92       	push	r13
    11b8:	ef 92       	push	r14
    11ba:	ff 92       	push	r15
    11bc:	0f 93       	push	r16
    11be:	1f 93       	push	r17
    11c0:	cf 93       	push	r28
    11c2:	df 93       	push	r29
    11c4:	cd b7       	in	r28, 0x3d	; 61
    11c6:	de b7       	in	r29, 0x3e	; 62
    11c8:	a8 97       	sbiw	r28, 0x28	; 40
    11ca:	0f b6       	in	r0, 0x3f	; 63
    11cc:	f8 94       	cli
    11ce:	de bf       	out	0x3e, r29	; 62
    11d0:	0f be       	out	0x3f, r0	; 63
    11d2:	cd bf       	out	0x3d, r28	; 61
    11d4:	7c 01       	movw	r14, r24
	BYTE  fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;

	FatFs = 0;
    11d6:	10 92 ce 03 	sts	0x03CE, r1	; 0x8003ce <FatFs+0x1>
    11da:	10 92 cd 03 	sts	0x03CD, r1	; 0x8003cd <FatFs>

	if (disk_initialize() & STA_NOINIT)
    11de:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
    11e2:	80 fd       	sbrc	r24, 0
    11e4:	62 c1       	rjmp	.+708    	; 0x14aa <pf_mount+0x304>
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
    11e6:	40 e0       	ldi	r20, 0x00	; 0
    11e8:	50 e0       	ldi	r21, 0x00	; 0
    11ea:	ba 01       	movw	r22, r20
    11ec:	ce 01       	movw	r24, r28
    11ee:	01 96       	adiw	r24, 0x01	; 1
    11f0:	0e 94 df 06 	call	0xdbe	; 0xdbe <check_fs>
    11f4:	d8 2e       	mov	r13, r24
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
    11f6:	21 e0       	ldi	r18, 0x01	; 1
    11f8:	82 13       	cpse	r24, r18
    11fa:	38 c0       	rjmp	.+112    	; 0x126c <pf_mount+0xc6>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
    11fc:	00 e1       	ldi	r16, 0x10	; 16
    11fe:	10 e0       	ldi	r17, 0x00	; 0
    1200:	2e eb       	ldi	r18, 0xBE	; 190
    1202:	31 e0       	ldi	r19, 0x01	; 1
    1204:	40 e0       	ldi	r20, 0x00	; 0
    1206:	50 e0       	ldi	r21, 0x00	; 0
    1208:	ba 01       	movw	r22, r20
    120a:	ce 01       	movw	r24, r28
    120c:	01 96       	adiw	r24, 0x01	; 1
    120e:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    1212:	81 11       	cpse	r24, r1
    1214:	2f c0       	rjmp	.+94     	; 0x1274 <pf_mount+0xce>
			fmt = 3;
		} else {
			if (buf[4]) {                     /* Is the partition existing? */
    1216:	8d 81       	ldd	r24, Y+5	; 0x05
    1218:	88 23       	and	r24, r24
    121a:	a1 f1       	breq	.+104    	; 0x1284 <pf_mount+0xde>
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
    121c:	8c 84       	ldd	r8, Y+12	; 0x0c
    121e:	91 2c       	mov	r9, r1
    1220:	a1 2c       	mov	r10, r1
    1222:	b1 2c       	mov	r11, r1
    1224:	b8 2c       	mov	r11, r8
    1226:	aa 24       	eor	r10, r10
    1228:	99 24       	eor	r9, r9
    122a:	88 24       	eor	r8, r8
    122c:	9b 85       	ldd	r25, Y+11	; 0x0b
    122e:	89 2f       	mov	r24, r25
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	a0 e0       	ldi	r26, 0x00	; 0
    1234:	b0 e0       	ldi	r27, 0x00	; 0
    1236:	dc 01       	movw	r26, r24
    1238:	99 27       	eor	r25, r25
    123a:	88 27       	eor	r24, r24
    123c:	88 29       	or	r24, r8
    123e:	99 29       	or	r25, r9
    1240:	aa 29       	or	r26, r10
    1242:	bb 29       	or	r27, r11
    1244:	8a 84       	ldd	r8, Y+10	; 0x0a
    1246:	91 2c       	mov	r9, r1
    1248:	98 2c       	mov	r9, r8
    124a:	88 24       	eor	r8, r8
    124c:	a1 2c       	mov	r10, r1
    124e:	b1 2c       	mov	r11, r1
    1250:	88 2a       	or	r8, r24
    1252:	99 2a       	or	r9, r25
    1254:	aa 2a       	or	r10, r26
    1256:	bb 2a       	or	r11, r27
    1258:	89 85       	ldd	r24, Y+9	; 0x09
    125a:	88 2a       	or	r8, r24
				fmt   = check_fs(buf, bsect); /* Check the partition */
    125c:	b5 01       	movw	r22, r10
    125e:	a4 01       	movw	r20, r8
    1260:	ce 01       	movw	r24, r28
    1262:	01 96       	adiw	r24, 0x01	; 1
    1264:	0e 94 df 06 	call	0xdbe	; 0xdbe <check_fs>
    1268:	d8 2e       	mov	r13, r24
    126a:	0f c0       	rjmp	.+30     	; 0x128a <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    126c:	81 2c       	mov	r8, r1
    126e:	91 2c       	mov	r9, r1
    1270:	54 01       	movw	r10, r8
    1272:	0b c0       	rjmp	.+22     	; 0x128a <pf_mount+0xe4>
    1274:	81 2c       	mov	r8, r1
    1276:	91 2c       	mov	r9, r1
    1278:	54 01       	movw	r10, r8
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
			fmt = 3;
    127a:	0f 2e       	mov	r0, r31
    127c:	f3 e0       	ldi	r31, 0x03	; 3
    127e:	df 2e       	mov	r13, r31
    1280:	f0 2d       	mov	r31, r0
    1282:	03 c0       	rjmp	.+6      	; 0x128a <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1284:	81 2c       	mov	r8, r1
    1286:	91 2c       	mov	r9, r1
    1288:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
    128a:	43 e0       	ldi	r20, 0x03	; 3
    128c:	d4 16       	cp	r13, r20
    128e:	09 f4       	brne	.+2      	; 0x1292 <pf_mount+0xec>
    1290:	0e c1       	rjmp	.+540    	; 0x14ae <pf_mount+0x308>
		return FR_DISK_ERR;
	if (fmt)
    1292:	d1 10       	cpse	r13, r1
    1294:	0e c1       	rjmp	.+540    	; 0x14b2 <pf_mount+0x30c>
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
    1296:	04 e2       	ldi	r16, 0x24	; 36
    1298:	10 e0       	ldi	r17, 0x00	; 0
    129a:	2d e0       	ldi	r18, 0x0D	; 13
    129c:	30 e0       	ldi	r19, 0x00	; 0
    129e:	b5 01       	movw	r22, r10
    12a0:	a4 01       	movw	r20, r8
    12a2:	ce 01       	movw	r24, r28
    12a4:	01 96       	adiw	r24, 0x01	; 1
    12a6:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    12aa:	81 11       	cpse	r24, r1
    12ac:	04 c1       	rjmp	.+520    	; 0x14b6 <pf_mount+0x310>
		return FR_DISK_ERR;

	fsize = LD_WORD(buf + BPB_FATSz16 - 13); /* Number of sectors per FAT */
    12ae:	2b 85       	ldd	r18, Y+11	; 0x0b
    12b0:	30 e0       	ldi	r19, 0x00	; 0
    12b2:	32 2f       	mov	r19, r18
    12b4:	22 27       	eor	r18, r18
    12b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    12b8:	28 2b       	or	r18, r24
    12ba:	40 e0       	ldi	r20, 0x00	; 0
    12bc:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize)
    12be:	21 15       	cp	r18, r1
    12c0:	31 05       	cpc	r19, r1
    12c2:	41 05       	cpc	r20, r1
    12c4:	51 05       	cpc	r21, r1
    12c6:	21 f5       	brne	.+72     	; 0x1310 <pf_mount+0x16a>
		fsize = LD_DWORD(buf + BPB_FATSz32 - 13);
    12c8:	2b 8d       	ldd	r18, Y+27	; 0x1b
    12ca:	82 2f       	mov	r24, r18
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	a0 e0       	ldi	r26, 0x00	; 0
    12d0:	b0 e0       	ldi	r27, 0x00	; 0
    12d2:	78 2f       	mov	r23, r24
    12d4:	66 27       	eor	r22, r22
    12d6:	55 27       	eor	r21, r21
    12d8:	44 27       	eor	r20, r20
    12da:	9a 8d       	ldd	r25, Y+26	; 0x1a
    12dc:	89 2f       	mov	r24, r25
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	a0 e0       	ldi	r26, 0x00	; 0
    12e2:	b0 e0       	ldi	r27, 0x00	; 0
    12e4:	dc 01       	movw	r26, r24
    12e6:	99 27       	eor	r25, r25
    12e8:	88 27       	eor	r24, r24
    12ea:	84 2b       	or	r24, r20
    12ec:	95 2b       	or	r25, r21
    12ee:	a6 2b       	or	r26, r22
    12f0:	b7 2b       	or	r27, r23
    12f2:	29 8d       	ldd	r18, Y+25	; 0x19
    12f4:	30 e0       	ldi	r19, 0x00	; 0
    12f6:	32 2f       	mov	r19, r18
    12f8:	22 27       	eor	r18, r18
    12fa:	a9 01       	movw	r20, r18
    12fc:	60 e0       	ldi	r22, 0x00	; 0
    12fe:	70 e0       	ldi	r23, 0x00	; 0
    1300:	48 2b       	or	r20, r24
    1302:	59 2b       	or	r21, r25
    1304:	6a 2b       	or	r22, r26
    1306:	7b 2b       	or	r23, r27
    1308:	88 8d       	ldd	r24, Y+24	; 0x18
    130a:	9a 01       	movw	r18, r20
    130c:	ab 01       	movw	r20, r22
    130e:	28 2b       	or	r18, r24

	fsize *= buf[BPB_NumFATs - 13];                             /* Number of sectors in FAT area */
    1310:	ac 81       	ldd	r26, Y+4	; 0x04
    1312:	b0 e0       	ldi	r27, 0x00	; 0
    1314:	0e 94 32 0e 	call	0x1c64	; 0x1c64 <__muluhisi3>
    1318:	6d a3       	std	Y+37, r22	; 0x25
    131a:	7e a3       	std	Y+38, r23	; 0x26
    131c:	8f a3       	std	Y+39, r24	; 0x27
    131e:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase   = bsect + LD_WORD(buf + BPB_RsvdSecCnt - 13); /* FAT start sector (lba) */
    1320:	8b 81       	ldd	r24, Y+3	; 0x03
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	98 2f       	mov	r25, r24
    1326:	88 27       	eor	r24, r24
    1328:	4a 81       	ldd	r20, Y+2	; 0x02
    132a:	50 e0       	ldi	r21, 0x00	; 0
    132c:	84 2b       	or	r24, r20
    132e:	95 2b       	or	r25, r21
    1330:	88 0e       	add	r8, r24
    1332:	99 1e       	adc	r9, r25
    1334:	a1 1c       	adc	r10, r1
    1336:	b1 1c       	adc	r11, r1
    1338:	d7 01       	movw	r26, r14
    133a:	1a 96       	adiw	r26, 0x0a	; 10
    133c:	8d 92       	st	X+, r8
    133e:	9d 92       	st	X+, r9
    1340:	ad 92       	st	X+, r10
    1342:	bc 92       	st	X, r11
    1344:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
    1346:	a9 81       	ldd	r26, Y+1	; 0x01
    1348:	f7 01       	movw	r30, r14
    134a:	a2 83       	std	Z+2, r26	; 0x02
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
    134c:	8e 81       	ldd	r24, Y+6	; 0x06
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	98 2f       	mov	r25, r24
    1352:	88 27       	eor	r24, r24
    1354:	2d 81       	ldd	r18, Y+5	; 0x05
    1356:	82 2b       	or	r24, r18
    1358:	95 83       	std	Z+5, r25	; 0x05
    135a:	84 83       	std	Z+4, r24	; 0x04
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
    135c:	08 85       	ldd	r16, Y+8	; 0x08
    135e:	10 e0       	ldi	r17, 0x00	; 0
    1360:	10 2f       	mov	r17, r16
    1362:	00 27       	eor	r16, r16
    1364:	2f 81       	ldd	r18, Y+7	; 0x07
    1366:	02 2b       	or	r16, r18
    1368:	20 e0       	ldi	r18, 0x00	; 0
    136a:	30 e0       	ldi	r19, 0x00	; 0
	if (!tsect)
    136c:	01 15       	cp	r16, r1
    136e:	11 05       	cpc	r17, r1
    1370:	21 05       	cpc	r18, r1
    1372:	31 05       	cpc	r19, r1
    1374:	01 f5       	brne	.+64     	; 0x13b6 <pf_mount+0x210>
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
    1376:	0f 89       	ldd	r16, Y+23	; 0x17
    1378:	10 e0       	ldi	r17, 0x00	; 0
    137a:	20 e0       	ldi	r18, 0x00	; 0
    137c:	30 e0       	ldi	r19, 0x00	; 0
    137e:	70 2e       	mov	r7, r16
    1380:	66 24       	eor	r6, r6
    1382:	55 24       	eor	r5, r5
    1384:	44 24       	eor	r4, r4
    1386:	0e 89       	ldd	r16, Y+22	; 0x16
    1388:	10 e0       	ldi	r17, 0x00	; 0
    138a:	20 e0       	ldi	r18, 0x00	; 0
    138c:	30 e0       	ldi	r19, 0x00	; 0
    138e:	98 01       	movw	r18, r16
    1390:	11 27       	eor	r17, r17
    1392:	00 27       	eor	r16, r16
    1394:	40 2a       	or	r4, r16
    1396:	51 2a       	or	r5, r17
    1398:	62 2a       	or	r6, r18
    139a:	73 2a       	or	r7, r19
    139c:	2d 89       	ldd	r18, Y+21	; 0x15
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	32 2f       	mov	r19, r18
    13a2:	22 27       	eor	r18, r18
    13a4:	89 01       	movw	r16, r18
    13a6:	20 e0       	ldi	r18, 0x00	; 0
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	04 29       	or	r16, r4
    13ac:	15 29       	or	r17, r5
    13ae:	26 29       	or	r18, r6
    13b0:	37 29       	or	r19, r7
    13b2:	6c 89       	ldd	r22, Y+20	; 0x14
    13b4:	06 2b       	or	r16, r22
	mclst = (tsect /* Last cluster# + 1 */
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
    13b6:	eb 81       	ldd	r30, Y+3	; 0x03
    13b8:	f0 e0       	ldi	r31, 0x00	; 0
    13ba:	fe 2f       	mov	r31, r30
    13bc:	ee 27       	eor	r30, r30
    13be:	4e 2b       	or	r20, r30
    13c0:	5f 2b       	or	r21, r31
    13c2:	04 1b       	sub	r16, r20
    13c4:	15 0b       	sbc	r17, r21
    13c6:	21 09       	sbc	r18, r1
    13c8:	31 09       	sbc	r19, r1
    13ca:	4d a1       	ldd	r20, Y+37	; 0x25
    13cc:	5e a1       	ldd	r21, Y+38	; 0x26
    13ce:	6f a1       	ldd	r22, Y+39	; 0x27
    13d0:	78 a5       	ldd	r23, Y+40	; 0x28
    13d2:	04 1b       	sub	r16, r20
    13d4:	15 0b       	sbc	r17, r21
    13d6:	26 0b       	sbc	r18, r22
    13d8:	37 0b       	sbc	r19, r23
    13da:	92 95       	swap	r25
    13dc:	82 95       	swap	r24
    13de:	8f 70       	andi	r24, 0x0F	; 15
    13e0:	89 27       	eor	r24, r25
    13e2:	9f 70       	andi	r25, 0x0F	; 15
    13e4:	89 27       	eor	r24, r25
    13e6:	2c 01       	movw	r4, r24
    13e8:	61 2c       	mov	r6, r1
    13ea:	71 2c       	mov	r7, r1
    13ec:	c9 01       	movw	r24, r18
    13ee:	b8 01       	movw	r22, r16
    13f0:	64 19       	sub	r22, r4
    13f2:	75 09       	sbc	r23, r5
    13f4:	86 09       	sbc	r24, r6
    13f6:	97 09       	sbc	r25, r7
	            / fs->csize
    13f8:	2a 2f       	mov	r18, r26
    13fa:	30 e0       	ldi	r19, 0x00	; 0
    13fc:	40 e0       	ldi	r20, 0x00	; 0
    13fe:	50 e0       	ldi	r21, 0x00	; 0
    1400:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <__udivmodsi4>
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
	if (!tsect)
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
	mclst = (tsect /* Last cluster# + 1 */
    1404:	da 01       	movw	r26, r20
    1406:	c9 01       	movw	r24, r18
    1408:	02 96       	adiw	r24, 0x02	; 2
    140a:	a1 1d       	adc	r26, r1
    140c:	b1 1d       	adc	r27, r1
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
	            / fs->csize
	        + 2;
	fs->n_fatent = (CLUST)mclst;
    140e:	f7 01       	movw	r30, r14
    1410:	86 83       	std	Z+6, r24	; 0x06
    1412:	97 83       	std	Z+7, r25	; 0x07
    1414:	a0 87       	std	Z+8, r26	; 0x08
    1416:	b1 87       	std	Z+9, r27	; 0x09
	fmt = 0; /* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    1418:	87 3f       	cpi	r24, 0xF7	; 247
    141a:	9f 4f       	sbci	r25, 0xFF	; 255
    141c:	a1 05       	cpc	r26, r1
    141e:	b1 05       	cpc	r27, r1
    1420:	20 f0       	brcs	.+8      	; 0x142a <pf_mount+0x284>
		fmt = FS_FAT32;
    1422:	0f 2e       	mov	r0, r31
    1424:	f3 e0       	ldi	r31, 0x03	; 3
    1426:	df 2e       	mov	r13, r31
    1428:	f0 2d       	mov	r31, r0
	if (!fmt)
    142a:	dd 20       	and	r13, r13
    142c:	09 f4       	brne	.+2      	; 0x1430 <pf_mount+0x28a>
    142e:	45 c0       	rjmp	.+138    	; 0x14ba <pf_mount+0x314>
		return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    1430:	d7 01       	movw	r26, r14
    1432:	dc 92       	st	X, r13

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf + (BPB_RootClus - 13)); /* Root directory start cluster */
    1434:	8b a1       	ldd	r24, Y+35	; 0x23
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	a0 e0       	ldi	r26, 0x00	; 0
    143a:	b0 e0       	ldi	r27, 0x00	; 0
    143c:	78 2f       	mov	r23, r24
    143e:	66 27       	eor	r22, r22
    1440:	55 27       	eor	r21, r21
    1442:	44 27       	eor	r20, r20
    1444:	8a a1       	ldd	r24, Y+34	; 0x22
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	a0 e0       	ldi	r26, 0x00	; 0
    144a:	b0 e0       	ldi	r27, 0x00	; 0
    144c:	dc 01       	movw	r26, r24
    144e:	99 27       	eor	r25, r25
    1450:	88 27       	eor	r24, r24
    1452:	84 2b       	or	r24, r20
    1454:	95 2b       	or	r25, r21
    1456:	a6 2b       	or	r26, r22
    1458:	b7 2b       	or	r27, r23
    145a:	49 a1       	ldd	r20, Y+33	; 0x21
    145c:	50 e0       	ldi	r21, 0x00	; 0
    145e:	54 2f       	mov	r21, r20
    1460:	44 27       	eor	r20, r20
    1462:	60 e0       	ldi	r22, 0x00	; 0
    1464:	70 e0       	ldi	r23, 0x00	; 0
    1466:	84 2b       	or	r24, r20
    1468:	95 2b       	or	r25, r21
    146a:	a6 2b       	or	r26, r22
    146c:	b7 2b       	or	r27, r23
    146e:	28 a1       	ldd	r18, Y+32	; 0x20
    1470:	82 2b       	or	r24, r18
    1472:	f7 01       	movw	r30, r14
    1474:	86 87       	std	Z+14, r24	; 0x0e
    1476:	97 87       	std	Z+15, r25	; 0x0f
    1478:	a0 8b       	std	Z+16, r26	; 0x10
    147a:	b1 8b       	std	Z+17, r27	; 0x11
	else
		fs->dirbase = fs->fatbase + fsize;                   /* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16; /* Data start sector (lba) */
    147c:	4d a1       	ldd	r20, Y+37	; 0x25
    147e:	5e a1       	ldd	r21, Y+38	; 0x26
    1480:	6f a1       	ldd	r22, Y+39	; 0x27
    1482:	78 a5       	ldd	r23, Y+40	; 0x28
    1484:	84 0e       	add	r8, r20
    1486:	95 1e       	adc	r9, r21
    1488:	a6 1e       	adc	r10, r22
    148a:	b7 1e       	adc	r11, r23
    148c:	84 0c       	add	r8, r4
    148e:	95 1c       	adc	r9, r5
    1490:	a6 1c       	adc	r10, r6
    1492:	b7 1c       	adc	r11, r7
    1494:	82 8a       	std	Z+18, r8	; 0x12
    1496:	93 8a       	std	Z+19, r9	; 0x13
    1498:	a4 8a       	std	Z+20, r10	; 0x14
    149a:	b5 8a       	std	Z+21, r11	; 0x15

	fs->flag = 0;
    149c:	11 82       	std	Z+1, r1	; 0x01
	FatFs    = fs;
    149e:	f0 92 ce 03 	sts	0x03CE, r15	; 0x8003ce <FatFs+0x1>
    14a2:	e0 92 cd 03 	sts	0x03CD, r14	; 0x8003cd <FatFs>

	return FR_OK;
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	09 c0       	rjmp	.+18     	; 0x14bc <pf_mount+0x316>
	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)
	{
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
    14aa:	82 e0       	ldi	r24, 0x02	; 2
    14ac:	07 c0       	rjmp	.+14     	; 0x14bc <pf_mount+0x316>
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
		return FR_DISK_ERR;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	05 c0       	rjmp	.+10     	; 0x14bc <pf_mount+0x316>
	if (fmt)
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */
    14b2:	86 e0       	ldi	r24, 0x06	; 6
    14b4:	03 c0       	rjmp	.+6      	; 0x14bc <pf_mount+0x316>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
		return FR_DISK_ERR;
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	01 c0       	rjmp	.+2      	; 0x14bc <pf_mount+0x316>
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
		fmt = FS_FAT32;
	if (!fmt)
		return FR_NO_FILESYSTEM;
    14ba:	86 e0       	ldi	r24, 0x06	; 6

	fs->flag = 0;
	FatFs    = fs;

	return FR_OK;
}
    14bc:	a8 96       	adiw	r28, 0x28	; 40
    14be:	0f b6       	in	r0, 0x3f	; 63
    14c0:	f8 94       	cli
    14c2:	de bf       	out	0x3e, r29	; 62
    14c4:	0f be       	out	0x3f, r0	; 63
    14c6:	cd bf       	out	0x3d, r28	; 61
    14c8:	df 91       	pop	r29
    14ca:	cf 91       	pop	r28
    14cc:	1f 91       	pop	r17
    14ce:	0f 91       	pop	r16
    14d0:	ff 90       	pop	r15
    14d2:	ef 90       	pop	r14
    14d4:	df 90       	pop	r13
    14d6:	bf 90       	pop	r11
    14d8:	af 90       	pop	r10
    14da:	9f 90       	pop	r9
    14dc:	8f 90       	pop	r8
    14de:	7f 90       	pop	r7
    14e0:	6f 90       	pop	r6
    14e2:	5f 90       	pop	r5
    14e4:	4f 90       	pop	r4
    14e6:	08 95       	ret

000014e8 <pf_open>:
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT pf_open(const char *path /* Pointer to the file name */
)
 {
    14e8:	0f 93       	push	r16
    14ea:	1f 93       	push	r17
    14ec:	cf 93       	push	r28
    14ee:	df 93       	push	r29
    14f0:	cd b7       	in	r28, 0x3d	; 61
    14f2:	de b7       	in	r29, 0x3e	; 62
    14f4:	ec 97       	sbiw	r28, 0x3c	; 60
    14f6:	0f b6       	in	r0, 0x3f	; 63
    14f8:	f8 94       	cli
    14fa:	de bf       	out	0x3e, r29	; 62
    14fc:	0f be       	out	0x3f, r0	; 63
    14fe:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;
    1500:	00 91 cd 03 	lds	r16, 0x03CD	; 0x8003cd <FatFs>
    1504:	10 91 ce 03 	lds	r17, 0x03CE	; 0x8003ce <FatFs+0x1>

	if (!fs)
    1508:	01 15       	cp	r16, r1
    150a:	11 05       	cpc	r17, r1
    150c:	09 f4       	brne	.+2      	; 0x1510 <pf_open+0x28>
    150e:	4a c0       	rjmp	.+148    	; 0x15a4 <pf_open+0xbc>
    1510:	ac 01       	movw	r20, r24
		return FR_NOT_ENABLED; /* Check file system */

	fs->flag = 0;
    1512:	f8 01       	movw	r30, r16
    1514:	11 82       	std	Z+1, r1	; 0x01
	dj.fn    = sp;
    1516:	ce 01       	movw	r24, r28
    1518:	41 96       	adiw	r24, 0x11	; 17
    151a:	9c 83       	std	Y+4, r25	; 0x04
    151c:	8b 83       	std	Y+3, r24	; 0x03
	res      = follow_path(&dj, dir, path); /* Follow the file path */
    151e:	be 01       	movw	r22, r28
    1520:	63 5e       	subi	r22, 0xE3	; 227
    1522:	7f 4f       	sbci	r23, 0xFF	; 255
    1524:	40 97       	sbiw	r24, 0x10	; 16
    1526:	0e 94 77 08 	call	0x10ee	; 0x10ee <follow_path>
	if (res != FR_OK)
    152a:	81 11       	cpse	r24, r1
    152c:	40 c0       	rjmp	.+128    	; 0x15ae <pf_open+0xc6>
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
    152e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1530:	88 23       	and	r24, r24
    1532:	d1 f1       	breq	.+116    	; 0x15a8 <pf_open+0xc0>
    1534:	88 a5       	ldd	r24, Y+40	; 0x28
    1536:	84 fd       	sbrc	r24, 4
    1538:	39 c0       	rjmp	.+114    	; 0x15ac <pf_open+0xc4>
		return FR_NO_FILE;
	

	fs->org_clust = get_clust(dir);               /* File start cluster */
    153a:	ce 01       	movw	r24, r28
    153c:	4d 96       	adiw	r24, 0x1d	; 29
    153e:	0e 94 32 06 	call	0xc64	; 0xc64 <get_clust>
    1542:	f8 01       	movw	r30, r16
    1544:	66 8f       	std	Z+30, r22	; 0x1e
    1546:	77 8f       	std	Z+31, r23	; 0x1f
    1548:	80 a3       	std	Z+32, r24	; 0x20
    154a:	91 a3       	std	Z+33, r25	; 0x21
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
    154c:	8c ad       	ldd	r24, Y+60	; 0x3c
    154e:	90 e0       	ldi	r25, 0x00	; 0
    1550:	a0 e0       	ldi	r26, 0x00	; 0
    1552:	b0 e0       	ldi	r27, 0x00	; 0
    1554:	78 2f       	mov	r23, r24
    1556:	66 27       	eor	r22, r22
    1558:	55 27       	eor	r21, r21
    155a:	44 27       	eor	r20, r20
    155c:	9b ad       	ldd	r25, Y+59	; 0x3b
    155e:	89 2f       	mov	r24, r25
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	a0 e0       	ldi	r26, 0x00	; 0
    1564:	b0 e0       	ldi	r27, 0x00	; 0
    1566:	dc 01       	movw	r26, r24
    1568:	99 27       	eor	r25, r25
    156a:	88 27       	eor	r24, r24
    156c:	84 2b       	or	r24, r20
    156e:	95 2b       	or	r25, r21
    1570:	a6 2b       	or	r26, r22
    1572:	b7 2b       	or	r27, r23
    1574:	4a ad       	ldd	r20, Y+58	; 0x3a
    1576:	50 e0       	ldi	r21, 0x00	; 0
    1578:	54 2f       	mov	r21, r20
    157a:	44 27       	eor	r20, r20
    157c:	60 e0       	ldi	r22, 0x00	; 0
    157e:	70 e0       	ldi	r23, 0x00	; 0
    1580:	84 2b       	or	r24, r20
    1582:	95 2b       	or	r25, r21
    1584:	a6 2b       	or	r26, r22
    1586:	b7 2b       	or	r27, r23
    1588:	29 ad       	ldd	r18, Y+57	; 0x39
    158a:	82 2b       	or	r24, r18
    158c:	82 8f       	std	Z+26, r24	; 0x1a
    158e:	93 8f       	std	Z+27, r25	; 0x1b
    1590:	a4 8f       	std	Z+28, r26	; 0x1c
    1592:	b5 8f       	std	Z+29, r27	; 0x1d
	fs->fptr      = 0;                            /* File pointer */
    1594:	16 8a       	std	Z+22, r1	; 0x16
    1596:	17 8a       	std	Z+23, r1	; 0x17
    1598:	10 8e       	std	Z+24, r1	; 0x18
    159a:	11 8e       	std	Z+25, r1	; 0x19
	fs->flag      = FA_OPENED;
    159c:	81 e0       	ldi	r24, 0x01	; 1
    159e:	81 83       	std	Z+1, r24	; 0x01

	return FR_OK;
    15a0:	80 e0       	ldi	r24, 0x00	; 0
    15a2:	05 c0       	rjmp	.+10     	; 0x15ae <pf_open+0xc6>
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED; /* Check file system */
    15a4:	85 e0       	ldi	r24, 0x05	; 5
    15a6:	03 c0       	rjmp	.+6      	; 0x15ae <pf_open+0xc6>
	dj.fn    = sp;
	res      = follow_path(&dj, dir, path); /* Follow the file path */
	if (res != FR_OK)
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
		return FR_NO_FILE;
    15a8:	83 e0       	ldi	r24, 0x03	; 3
    15aa:	01 c0       	rjmp	.+2      	; 0x15ae <pf_open+0xc6>
    15ac:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
	fs->fptr      = 0;                            /* File pointer */
	fs->flag      = FA_OPENED;

	return FR_OK;
}
    15ae:	ec 96       	adiw	r28, 0x3c	; 60
    15b0:	0f b6       	in	r0, 0x3f	; 63
    15b2:	f8 94       	cli
    15b4:	de bf       	out	0x3e, r29	; 62
    15b6:	0f be       	out	0x3f, r0	; 63
    15b8:	cd bf       	out	0x3d, r28	; 61
    15ba:	df 91       	pop	r29
    15bc:	cf 91       	pop	r28
    15be:	1f 91       	pop	r17
    15c0:	0f 91       	pop	r16
    15c2:	08 95       	ret

000015c4 <pf_read>:

FRESULT pf_read(void *buff, /* Pointer to the read buffer (NULL:Forward data to the stream)*/
                UINT  btr,  /* Number of bytes to read */
                UINT *br    /* Pointer to number of bytes read */
)
{
    15c4:	6f 92       	push	r6
    15c6:	7f 92       	push	r7
    15c8:	8f 92       	push	r8
    15ca:	9f 92       	push	r9
    15cc:	af 92       	push	r10
    15ce:	bf 92       	push	r11
    15d0:	cf 92       	push	r12
    15d2:	df 92       	push	r13
    15d4:	ef 92       	push	r14
    15d6:	ff 92       	push	r15
    15d8:	0f 93       	push	r16
    15da:	1f 93       	push	r17
    15dc:	cf 93       	push	r28
    15de:	df 93       	push	r29
    15e0:	3c 01       	movw	r6, r24
    15e2:	6b 01       	movw	r12, r22
    15e4:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST   clst;
	DWORD   sect, remain;
	UINT    rcnt;
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;
    15e6:	e0 90 cd 03 	lds	r14, 0x03CD	; 0x8003cd <FatFs>
    15ea:	f0 90 ce 03 	lds	r15, 0x03CE	; 0x8003ce <FatFs+0x1>

	*br = 0;
    15ee:	fa 01       	movw	r30, r20
    15f0:	11 82       	std	Z+1, r1	; 0x01
    15f2:	10 82       	st	Z, r1
	if (!fs)
    15f4:	e1 14       	cp	r14, r1
    15f6:	f1 04       	cpc	r15, r1
    15f8:	09 f4       	brne	.+2      	; 0x15fc <pf_read+0x38>
    15fa:	b5 c0       	rjmp	.+362    	; 0x1766 <pf_read+0x1a2>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    15fc:	f7 01       	movw	r30, r14
    15fe:	81 81       	ldd	r24, Z+1	; 0x01
    1600:	80 ff       	sbrs	r24, 0
    1602:	b3 c0       	rjmp	.+358    	; 0x176a <pf_read+0x1a6>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    1604:	82 8d       	ldd	r24, Z+26	; 0x1a
    1606:	93 8d       	ldd	r25, Z+27	; 0x1b
    1608:	a4 8d       	ldd	r26, Z+28	; 0x1c
    160a:	b5 8d       	ldd	r27, Z+29	; 0x1d
    160c:	46 89       	ldd	r20, Z+22	; 0x16
    160e:	57 89       	ldd	r21, Z+23	; 0x17
    1610:	60 8d       	ldd	r22, Z+24	; 0x18
    1612:	71 8d       	ldd	r23, Z+25	; 0x19
    1614:	84 1b       	sub	r24, r20
    1616:	95 0b       	sbc	r25, r21
    1618:	a6 0b       	sbc	r26, r22
    161a:	b7 0b       	sbc	r27, r23
	if (btr > remain)
    161c:	a6 01       	movw	r20, r12
    161e:	60 e0       	ldi	r22, 0x00	; 0
    1620:	70 e0       	ldi	r23, 0x00	; 0
    1622:	84 17       	cp	r24, r20
    1624:	95 07       	cpc	r25, r21
    1626:	a6 07       	cpc	r26, r22
    1628:	b7 07       	cpc	r27, r23
    162a:	08 f4       	brcc	.+2      	; 0x162e <pf_read+0x6a>
		btr = (UINT)remain; /* Truncate btr by remaining bytes */
    162c:	6c 01       	movw	r12, r24
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
		if (rcnt > btr)
			rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    162e:	53 01       	movw	r10, r6
    1630:	94 c0       	rjmp	.+296    	; 0x175a <pf_read+0x196>
	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {                       /* On the sector boundary? */
    1632:	f7 01       	movw	r30, r14
    1634:	86 89       	ldd	r24, Z+22	; 0x16
    1636:	97 89       	ldd	r25, Z+23	; 0x17
    1638:	a0 8d       	ldd	r26, Z+24	; 0x18
    163a:	b1 8d       	ldd	r27, Z+25	; 0x19
    163c:	ac 01       	movw	r20, r24
    163e:	bd 01       	movw	r22, r26
    1640:	51 70       	andi	r21, 0x01	; 1
    1642:	66 27       	eor	r22, r22
    1644:	77 27       	eor	r23, r23
    1646:	45 2b       	or	r20, r21
    1648:	46 2b       	or	r20, r22
    164a:	47 2b       	or	r20, r23
    164c:	09 f0       	breq	.+2      	; 0x1650 <pf_read+0x8c>
    164e:	48 c0       	rjmp	.+144    	; 0x16e0 <pf_read+0x11c>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1650:	c2 81       	ldd	r28, Z+2	; 0x02
    1652:	c1 50       	subi	r28, 0x01	; 1
    1654:	ac 01       	movw	r20, r24
    1656:	bd 01       	movw	r22, r26
    1658:	03 2e       	mov	r0, r19
    165a:	39 e0       	ldi	r19, 0x09	; 9
    165c:	76 95       	lsr	r23
    165e:	67 95       	ror	r22
    1660:	57 95       	ror	r21
    1662:	47 95       	ror	r20
    1664:	3a 95       	dec	r19
    1666:	d1 f7       	brne	.-12     	; 0x165c <pf_read+0x98>
    1668:	30 2d       	mov	r19, r0
    166a:	c4 23       	and	r28, r20
			if (!cs) {                                     /* On the cluster boundary? */
    166c:	f1 f4       	brne	.+60     	; 0x16aa <pf_read+0xe6>
				if (fs->fptr == 0)                         /* On the top of the file? */
    166e:	89 2b       	or	r24, r25
    1670:	8a 2b       	or	r24, r26
    1672:	8b 2b       	or	r24, r27
    1674:	29 f4       	brne	.+10     	; 0x1680 <pf_read+0xbc>
					clst = fs->org_clust;
    1676:	66 8d       	ldd	r22, Z+30	; 0x1e
    1678:	77 8d       	ldd	r23, Z+31	; 0x1f
    167a:	80 a1       	ldd	r24, Z+32	; 0x20
    167c:	91 a1       	ldd	r25, Z+33	; 0x21
    167e:	07 c0       	rjmp	.+14     	; 0x168e <pf_read+0xca>
				else
					clst = get_fat(fs->curr_clust);
    1680:	f7 01       	movw	r30, r14
    1682:	62 a1       	ldd	r22, Z+34	; 0x22
    1684:	73 a1       	ldd	r23, Z+35	; 0x23
    1686:	84 a1       	ldd	r24, Z+36	; 0x24
    1688:	95 a1       	ldd	r25, Z+37	; 0x25
    168a:	0e 94 1f 07 	call	0xe3e	; 0xe3e <get_fat>
				if (clst <= 1)
    168e:	62 30       	cpi	r22, 0x02	; 2
    1690:	71 05       	cpc	r23, r1
    1692:	81 05       	cpc	r24, r1
    1694:	91 05       	cpc	r25, r1
    1696:	20 f4       	brcc	.+8      	; 0x16a0 <pf_read+0xdc>
					ABORT(FR_DISK_ERR);
    1698:	f7 01       	movw	r30, r14
    169a:	11 82       	std	Z+1, r1	; 0x01
    169c:	81 e0       	ldi	r24, 0x01	; 1
    169e:	66 c0       	rjmp	.+204    	; 0x176c <pf_read+0x1a8>
				fs->curr_clust = clst; /* Update current cluster */
    16a0:	f7 01       	movw	r30, r14
    16a2:	62 a3       	std	Z+34, r22	; 0x22
    16a4:	73 a3       	std	Z+35, r23	; 0x23
    16a6:	84 a3       	std	Z+36, r24	; 0x24
    16a8:	95 a3       	std	Z+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    16aa:	f7 01       	movw	r30, r14
    16ac:	62 a1       	ldd	r22, Z+34	; 0x22
    16ae:	73 a1       	ldd	r23, Z+35	; 0x23
    16b0:	84 a1       	ldd	r24, Z+36	; 0x24
    16b2:	95 a1       	ldd	r25, Z+37	; 0x25
    16b4:	0e 94 07 06 	call	0xc0e	; 0xc0e <clust2sect>
			if (!sect)
    16b8:	61 15       	cp	r22, r1
    16ba:	71 05       	cpc	r23, r1
    16bc:	81 05       	cpc	r24, r1
    16be:	91 05       	cpc	r25, r1
    16c0:	21 f4       	brne	.+8      	; 0x16ca <pf_read+0x106>
				ABORT(FR_DISK_ERR);
    16c2:	f7 01       	movw	r30, r14
    16c4:	11 82       	std	Z+1, r1	; 0x01
    16c6:	81 e0       	ldi	r24, 0x01	; 1
    16c8:	51 c0       	rjmp	.+162    	; 0x176c <pf_read+0x1a8>
			fs->dsect = sect + cs;
    16ca:	dc 01       	movw	r26, r24
    16cc:	cb 01       	movw	r24, r22
    16ce:	8c 0f       	add	r24, r28
    16d0:	91 1d       	adc	r25, r1
    16d2:	a1 1d       	adc	r26, r1
    16d4:	b1 1d       	adc	r27, r1
    16d6:	f7 01       	movw	r30, r14
    16d8:	86 a3       	std	Z+38, r24	; 0x26
    16da:	97 a3       	std	Z+39, r25	; 0x27
    16dc:	a0 a7       	std	Z+40, r26	; 0x28
    16de:	b1 a7       	std	Z+41, r27	; 0x29
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
    16e0:	f7 01       	movw	r30, r14
    16e2:	86 89       	ldd	r24, Z+22	; 0x16
    16e4:	97 89       	ldd	r25, Z+23	; 0x17
    16e6:	a0 8d       	ldd	r26, Z+24	; 0x18
    16e8:	b1 8d       	ldd	r27, Z+25	; 0x19
    16ea:	9c 01       	movw	r18, r24
    16ec:	31 70       	andi	r19, 0x01	; 1
    16ee:	c0 e0       	ldi	r28, 0x00	; 0
    16f0:	d2 e0       	ldi	r29, 0x02	; 2
    16f2:	c2 1b       	sub	r28, r18
    16f4:	d3 0b       	sbc	r29, r19
		if (rcnt > btr)
    16f6:	cc 16       	cp	r12, r28
    16f8:	dd 06       	cpc	r13, r29
    16fa:	08 f4       	brcc	.+2      	; 0x16fe <pf_read+0x13a>
			rcnt = btr;
    16fc:	e6 01       	movw	r28, r12
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    16fe:	f7 01       	movw	r30, r14
    1700:	46 a1       	ldd	r20, Z+38	; 0x26
    1702:	57 a1       	ldd	r21, Z+39	; 0x27
    1704:	60 a5       	ldd	r22, Z+40	; 0x28
    1706:	71 a5       	ldd	r23, Z+41	; 0x29
    1708:	61 14       	cp	r6, r1
    170a:	71 04       	cpc	r7, r1
    170c:	19 f4       	brne	.+6      	; 0x1714 <pf_read+0x150>
    170e:	80 e0       	ldi	r24, 0x00	; 0
    1710:	90 e0       	ldi	r25, 0x00	; 0
    1712:	02 c0       	rjmp	.+4      	; 0x1718 <pf_read+0x154>
    1714:	8a 2d       	mov	r24, r10
    1716:	9b 2d       	mov	r25, r11
    1718:	8e 01       	movw	r16, r28
    171a:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
		if (dr)
    171e:	88 23       	and	r24, r24
    1720:	21 f0       	breq	.+8      	; 0x172a <pf_read+0x166>
			ABORT(FR_DISK_ERR);
    1722:	f7 01       	movw	r30, r14
    1724:	11 82       	std	Z+1, r1	; 0x01
    1726:	81 e0       	ldi	r24, 0x01	; 1
    1728:	21 c0       	rjmp	.+66     	; 0x176c <pf_read+0x1a8>
		fs->fptr += rcnt;
    172a:	f7 01       	movw	r30, r14
    172c:	86 89       	ldd	r24, Z+22	; 0x16
    172e:	97 89       	ldd	r25, Z+23	; 0x17
    1730:	a0 8d       	ldd	r26, Z+24	; 0x18
    1732:	b1 8d       	ldd	r27, Z+25	; 0x19
    1734:	8c 0f       	add	r24, r28
    1736:	9d 1f       	adc	r25, r29
    1738:	a1 1d       	adc	r26, r1
    173a:	b1 1d       	adc	r27, r1
    173c:	86 8b       	std	Z+22, r24	; 0x16
    173e:	97 8b       	std	Z+23, r25	; 0x17
    1740:	a0 8f       	std	Z+24, r26	; 0x18
    1742:	b1 8f       	std	Z+25, r27	; 0x19
		rbuff += rcnt; /* Update pointers and counters */
    1744:	ac 0e       	add	r10, r28
    1746:	bd 1e       	adc	r11, r29
		btr -= rcnt;
    1748:	cc 1a       	sub	r12, r28
    174a:	dd 0a       	sbc	r13, r29
		*br += rcnt;
    174c:	f4 01       	movw	r30, r8
    174e:	80 81       	ld	r24, Z
    1750:	91 81       	ldd	r25, Z+1	; 0x01
    1752:	c8 0f       	add	r28, r24
    1754:	d9 1f       	adc	r29, r25
    1756:	d1 83       	std	Z+1, r29	; 0x01
    1758:	c0 83       	st	Z, r28

	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
    175a:	c1 14       	cp	r12, r1
    175c:	d1 04       	cpc	r13, r1
    175e:	09 f0       	breq	.+2      	; 0x1762 <pf_read+0x19e>
    1760:	68 cf       	rjmp	.-304    	; 0x1632 <pf_read+0x6e>
		rbuff += rcnt; /* Update pointers and counters */
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
    1762:	80 e0       	ldi	r24, 0x00	; 0
    1764:	03 c0       	rjmp	.+6      	; 0x176c <pf_read+0x1a8>
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;

	*br = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1766:	85 e0       	ldi	r24, 0x05	; 5
    1768:	01 c0       	rjmp	.+2      	; 0x176c <pf_read+0x1a8>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    176a:	84 e0       	ldi	r24, 0x04	; 4
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
}
    176c:	df 91       	pop	r29
    176e:	cf 91       	pop	r28
    1770:	1f 91       	pop	r17
    1772:	0f 91       	pop	r16
    1774:	ff 90       	pop	r15
    1776:	ef 90       	pop	r14
    1778:	df 90       	pop	r13
    177a:	cf 90       	pop	r12
    177c:	bf 90       	pop	r11
    177e:	af 90       	pop	r10
    1780:	9f 90       	pop	r9
    1782:	8f 90       	pop	r8
    1784:	7f 90       	pop	r7
    1786:	6f 90       	pop	r6
    1788:	08 95       	ret

0000178a <pf_write>:

FRESULT pf_write(const void *buff, /* Pointer to the data to be written */
                 UINT        btw,  /* Number of bytes to write (0:Finalize the current write operation) */
                 UINT *      bw    /* Pointer to number of bytes written */
)
{
    178a:	4f 92       	push	r4
    178c:	5f 92       	push	r5
    178e:	6f 92       	push	r6
    1790:	7f 92       	push	r7
    1792:	af 92       	push	r10
    1794:	bf 92       	push	r11
    1796:	cf 92       	push	r12
    1798:	df 92       	push	r13
    179a:	ef 92       	push	r14
    179c:	ff 92       	push	r15
    179e:	0f 93       	push	r16
    17a0:	1f 93       	push	r17
    17a2:	cf 93       	push	r28
    17a4:	df 93       	push	r29
    17a6:	7c 01       	movw	r14, r24
    17a8:	5b 01       	movw	r10, r22
    17aa:	6a 01       	movw	r12, r20
	CLUST       clst;
	DWORD       sect, remain;
	const BYTE *p = buff;
	BYTE        cs;
	UINT        wcnt;
	FATFS *     fs = FatFs;
    17ac:	c0 91 cd 03 	lds	r28, 0x03CD	; 0x8003cd <FatFs>
    17b0:	d0 91 ce 03 	lds	r29, 0x03CE	; 0x8003ce <FatFs+0x1>

	*bw = 0;
    17b4:	fa 01       	movw	r30, r20
    17b6:	11 82       	std	Z+1, r1	; 0x01
    17b8:	10 82       	st	Z, r1
	if (!fs)
    17ba:	20 97       	sbiw	r28, 0x00	; 0
    17bc:	09 f4       	brne	.+2      	; 0x17c0 <pf_write+0x36>
    17be:	df c0       	rjmp	.+446    	; 0x197e <pf_write+0x1f4>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    17c0:	89 81       	ldd	r24, Y+1	; 0x01
    17c2:	80 ff       	sbrs	r24, 0
    17c4:	de c0       	rjmp	.+444    	; 0x1982 <pf_write+0x1f8>
		return FR_NOT_OPENED;

	if (!btw) { /* Finalize request */
    17c6:	67 2b       	or	r22, r23
    17c8:	99 f4       	brne	.+38     	; 0x17f0 <pf_write+0x66>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0))
    17ca:	86 ff       	sbrs	r24, 6
    17cc:	0c c0       	rjmp	.+24     	; 0x17e6 <pf_write+0x5c>
    17ce:	40 e0       	ldi	r20, 0x00	; 0
    17d0:	50 e0       	ldi	r21, 0x00	; 0
    17d2:	ba 01       	movw	r22, r20
    17d4:	80 e0       	ldi	r24, 0x00	; 0
    17d6:	90 e0       	ldi	r25, 0x00	; 0
    17d8:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    17dc:	88 23       	and	r24, r24
    17de:	19 f0       	breq	.+6      	; 0x17e6 <pf_write+0x5c>
			ABORT(FR_DISK_ERR);
    17e0:	19 82       	std	Y+1, r1	; 0x01
    17e2:	81 e0       	ldi	r24, 0x01	; 1
    17e4:	cf c0       	rjmp	.+414    	; 0x1984 <pf_write+0x1fa>
		fs->flag &= ~FA__WIP;
    17e6:	89 81       	ldd	r24, Y+1	; 0x01
    17e8:	8f 7b       	andi	r24, 0xBF	; 191
    17ea:	89 83       	std	Y+1, r24	; 0x01
		return FR_OK;
    17ec:	80 e0       	ldi	r24, 0x00	; 0
    17ee:	ca c0       	rjmp	.+404    	; 0x1984 <pf_write+0x1fa>
	} else {                       /* Write data request */
		if (!(fs->flag & FA__WIP)) /* Round-down fptr to the sector boundary */
    17f0:	86 fd       	sbrc	r24, 6
    17f2:	0a c0       	rjmp	.+20     	; 0x1808 <pf_write+0x7e>
			fs->fptr &= 0xFFFFFE00;
    17f4:	8e 89       	ldd	r24, Y+22	; 0x16
    17f6:	9f 89       	ldd	r25, Y+23	; 0x17
    17f8:	a8 8d       	ldd	r26, Y+24	; 0x18
    17fa:	b9 8d       	ldd	r27, Y+25	; 0x19
    17fc:	88 27       	eor	r24, r24
    17fe:	9e 7f       	andi	r25, 0xFE	; 254
    1800:	8e 8b       	std	Y+22, r24	; 0x16
    1802:	9f 8b       	std	Y+23, r25	; 0x17
    1804:	a8 8f       	std	Y+24, r26	; 0x18
    1806:	b9 8f       	std	Y+25, r27	; 0x19
	}
	remain = fs->fsize - fs->fptr;
    1808:	8a 8d       	ldd	r24, Y+26	; 0x1a
    180a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    180c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    180e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1810:	4e 89       	ldd	r20, Y+22	; 0x16
    1812:	5f 89       	ldd	r21, Y+23	; 0x17
    1814:	68 8d       	ldd	r22, Y+24	; 0x18
    1816:	79 8d       	ldd	r23, Y+25	; 0x19
    1818:	84 1b       	sub	r24, r20
    181a:	95 0b       	sbc	r25, r21
    181c:	a6 0b       	sbc	r26, r22
    181e:	b7 0b       	sbc	r27, r23
	if (btw > remain)
    1820:	a5 01       	movw	r20, r10
    1822:	60 e0       	ldi	r22, 0x00	; 0
    1824:	70 e0       	ldi	r23, 0x00	; 0
    1826:	84 17       	cp	r24, r20
    1828:	95 07       	cpc	r25, r21
    182a:	a6 07       	cpc	r26, r22
    182c:	b7 07       	cpc	r27, r23
    182e:	08 f0       	brcs	.+2      	; 0x1832 <pf_write+0xa8>
    1830:	a0 c0       	rjmp	.+320    	; 0x1972 <pf_write+0x1e8>
		btw = (UINT)remain; /* Truncate btw by remaining bytes */
    1832:	5c 01       	movw	r10, r24
    1834:	9e c0       	rjmp	.+316    	; 0x1972 <pf_write+0x1e8>

	while (btw) {                                          /* Repeat until all data transferred */
		if ((UINT)fs->fptr % 512 == 0) {                   /* On the sector boundary? */
    1836:	8e 89       	ldd	r24, Y+22	; 0x16
    1838:	9f 89       	ldd	r25, Y+23	; 0x17
    183a:	a8 8d       	ldd	r26, Y+24	; 0x18
    183c:	b9 8d       	ldd	r27, Y+25	; 0x19
    183e:	9c 01       	movw	r18, r24
    1840:	31 70       	andi	r19, 0x01	; 1
    1842:	23 2b       	or	r18, r19
    1844:	09 f0       	breq	.+2      	; 0x1848 <pf_write+0xbe>
    1846:	4e c0       	rjmp	.+156    	; 0x18e4 <pf_write+0x15a>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1848:	1a 81       	ldd	r17, Y+2	; 0x02
    184a:	11 50       	subi	r17, 0x01	; 1
    184c:	ac 01       	movw	r20, r24
    184e:	bd 01       	movw	r22, r26
    1850:	03 2e       	mov	r0, r19
    1852:	39 e0       	ldi	r19, 0x09	; 9
    1854:	76 95       	lsr	r23
    1856:	67 95       	ror	r22
    1858:	57 95       	ror	r21
    185a:	47 95       	ror	r20
    185c:	3a 95       	dec	r19
    185e:	d1 f7       	brne	.-12     	; 0x1854 <pf_write+0xca>
    1860:	30 2d       	mov	r19, r0
    1862:	14 23       	and	r17, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1864:	d9 f4       	brne	.+54     	; 0x189c <pf_write+0x112>
				if (fs->fptr == 0)                         /* On the top of the file? */
    1866:	89 2b       	or	r24, r25
    1868:	8a 2b       	or	r24, r26
    186a:	8b 2b       	or	r24, r27
    186c:	29 f4       	brne	.+10     	; 0x1878 <pf_write+0xee>
					clst = fs->org_clust;
    186e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1870:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1872:	88 a1       	ldd	r24, Y+32	; 0x20
    1874:	99 a1       	ldd	r25, Y+33	; 0x21
    1876:	06 c0       	rjmp	.+12     	; 0x1884 <pf_write+0xfa>
				else
					clst = get_fat(fs->curr_clust);
    1878:	6a a1       	ldd	r22, Y+34	; 0x22
    187a:	7b a1       	ldd	r23, Y+35	; 0x23
    187c:	8c a1       	ldd	r24, Y+36	; 0x24
    187e:	9d a1       	ldd	r25, Y+37	; 0x25
    1880:	0e 94 1f 07 	call	0xe3e	; 0xe3e <get_fat>
				if (clst <= 1)
    1884:	62 30       	cpi	r22, 0x02	; 2
    1886:	71 05       	cpc	r23, r1
    1888:	81 05       	cpc	r24, r1
    188a:	91 05       	cpc	r25, r1
    188c:	18 f4       	brcc	.+6      	; 0x1894 <pf_write+0x10a>
					ABORT(FR_DISK_ERR);
    188e:	19 82       	std	Y+1, r1	; 0x01
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	78 c0       	rjmp	.+240    	; 0x1984 <pf_write+0x1fa>
				fs->curr_clust = clst; /* Update current cluster */
    1894:	6a a3       	std	Y+34, r22	; 0x22
    1896:	7b a3       	std	Y+35, r23	; 0x23
    1898:	8c a3       	std	Y+36, r24	; 0x24
    189a:	9d a3       	std	Y+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    189c:	6a a1       	ldd	r22, Y+34	; 0x22
    189e:	7b a1       	ldd	r23, Y+35	; 0x23
    18a0:	8c a1       	ldd	r24, Y+36	; 0x24
    18a2:	9d a1       	ldd	r25, Y+37	; 0x25
    18a4:	0e 94 07 06 	call	0xc0e	; 0xc0e <clust2sect>
			if (!sect)
    18a8:	61 15       	cp	r22, r1
    18aa:	71 05       	cpc	r23, r1
    18ac:	81 05       	cpc	r24, r1
    18ae:	91 05       	cpc	r25, r1
    18b0:	19 f4       	brne	.+6      	; 0x18b8 <pf_write+0x12e>
				ABORT(FR_DISK_ERR);
    18b2:	19 82       	std	Y+1, r1	; 0x01
    18b4:	81 e0       	ldi	r24, 0x01	; 1
    18b6:	66 c0       	rjmp	.+204    	; 0x1984 <pf_write+0x1fa>
			fs->dsect = sect + cs;
    18b8:	ab 01       	movw	r20, r22
    18ba:	bc 01       	movw	r22, r24
    18bc:	41 0f       	add	r20, r17
    18be:	51 1d       	adc	r21, r1
    18c0:	61 1d       	adc	r22, r1
    18c2:	71 1d       	adc	r23, r1
    18c4:	4e a3       	std	Y+38, r20	; 0x26
    18c6:	5f a3       	std	Y+39, r21	; 0x27
    18c8:	68 a7       	std	Y+40, r22	; 0x28
    18ca:	79 a7       	std	Y+41, r23	; 0x29
			if (disk_writep(0, fs->dsect))
    18cc:	80 e0       	ldi	r24, 0x00	; 0
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    18d4:	88 23       	and	r24, r24
    18d6:	19 f0       	breq	.+6      	; 0x18de <pf_write+0x154>
				ABORT(FR_DISK_ERR); /* Initiate a sector write operation */
    18d8:	19 82       	std	Y+1, r1	; 0x01
    18da:	81 e0       	ldi	r24, 0x01	; 1
    18dc:	53 c0       	rjmp	.+166    	; 0x1984 <pf_write+0x1fa>
			fs->flag |= FA__WIP;
    18de:	89 81       	ldd	r24, Y+1	; 0x01
    18e0:	80 64       	ori	r24, 0x40	; 64
    18e2:	89 83       	std	Y+1, r24	; 0x01
		}
		wcnt = 512 - (UINT)fs->fptr % 512; /* Number of bytes to write to the sector */
    18e4:	8e 89       	ldd	r24, Y+22	; 0x16
    18e6:	9f 89       	ldd	r25, Y+23	; 0x17
    18e8:	a8 8d       	ldd	r26, Y+24	; 0x18
    18ea:	b9 8d       	ldd	r27, Y+25	; 0x19
    18ec:	91 70       	andi	r25, 0x01	; 1
    18ee:	00 e0       	ldi	r16, 0x00	; 0
    18f0:	12 e0       	ldi	r17, 0x02	; 2
    18f2:	08 1b       	sub	r16, r24
    18f4:	19 0b       	sbc	r17, r25
		if (wcnt > btw)
    18f6:	a0 16       	cp	r10, r16
    18f8:	b1 06       	cpc	r11, r17
    18fa:	08 f4       	brcc	.+2      	; 0x18fe <pf_write+0x174>
			wcnt = btw;
    18fc:	85 01       	movw	r16, r10
		if (disk_writep(p, wcnt))
    18fe:	28 01       	movw	r4, r16
    1900:	61 2c       	mov	r6, r1
    1902:	71 2c       	mov	r7, r1
    1904:	b3 01       	movw	r22, r6
    1906:	a2 01       	movw	r20, r4
    1908:	c7 01       	movw	r24, r14
    190a:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    190e:	88 23       	and	r24, r24
    1910:	19 f0       	breq	.+6      	; 0x1918 <pf_write+0x18e>
			ABORT(FR_DISK_ERR); /* Send data to the sector */
    1912:	19 82       	std	Y+1, r1	; 0x01
    1914:	81 e0       	ldi	r24, 0x01	; 1
    1916:	36 c0       	rjmp	.+108    	; 0x1984 <pf_write+0x1fa>
		fs->fptr += wcnt;
    1918:	8e 89       	ldd	r24, Y+22	; 0x16
    191a:	9f 89       	ldd	r25, Y+23	; 0x17
    191c:	a8 8d       	ldd	r26, Y+24	; 0x18
    191e:	b9 8d       	ldd	r27, Y+25	; 0x19
    1920:	48 0e       	add	r4, r24
    1922:	59 1e       	adc	r5, r25
    1924:	6a 1e       	adc	r6, r26
    1926:	7b 1e       	adc	r7, r27
    1928:	4e 8a       	std	Y+22, r4	; 0x16
    192a:	5f 8a       	std	Y+23, r5	; 0x17
    192c:	68 8e       	std	Y+24, r6	; 0x18
    192e:	79 8e       	std	Y+25, r7	; 0x19
		p += wcnt; /* Update pointers and counters */
    1930:	e0 0e       	add	r14, r16
    1932:	f1 1e       	adc	r15, r17
		btw -= wcnt;
    1934:	a0 1a       	sub	r10, r16
    1936:	b1 0a       	sbc	r11, r17
		*bw += wcnt;
    1938:	f6 01       	movw	r30, r12
    193a:	80 81       	ld	r24, Z
    193c:	91 81       	ldd	r25, Z+1	; 0x01
    193e:	08 0f       	add	r16, r24
    1940:	19 1f       	adc	r17, r25
    1942:	11 83       	std	Z+1, r17	; 0x01
    1944:	00 83       	st	Z, r16
		if ((UINT)fs->fptr % 512 == 0) {
    1946:	8e 89       	ldd	r24, Y+22	; 0x16
    1948:	9f 89       	ldd	r25, Y+23	; 0x17
    194a:	a8 8d       	ldd	r26, Y+24	; 0x18
    194c:	b9 8d       	ldd	r27, Y+25	; 0x19
    194e:	91 70       	andi	r25, 0x01	; 1
    1950:	89 2b       	or	r24, r25
    1952:	79 f4       	brne	.+30     	; 0x1972 <pf_write+0x1e8>
			if (disk_writep(0, 0))
    1954:	40 e0       	ldi	r20, 0x00	; 0
    1956:	50 e0       	ldi	r21, 0x00	; 0
    1958:	ba 01       	movw	r22, r20
    195a:	80 e0       	ldi	r24, 0x00	; 0
    195c:	90 e0       	ldi	r25, 0x00	; 0
    195e:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    1962:	88 23       	and	r24, r24
    1964:	19 f0       	breq	.+6      	; 0x196c <pf_write+0x1e2>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
    1966:	19 82       	std	Y+1, r1	; 0x01
    1968:	81 e0       	ldi	r24, 0x01	; 1
    196a:	0c c0       	rjmp	.+24     	; 0x1984 <pf_write+0x1fa>
			fs->flag &= ~FA__WIP;
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	8f 7b       	andi	r24, 0xBF	; 191
    1970:	89 83       	std	Y+1, r24	; 0x01
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain)
		btw = (UINT)remain; /* Truncate btw by remaining bytes */

	while (btw) {                                          /* Repeat until all data transferred */
    1972:	a1 14       	cp	r10, r1
    1974:	b1 04       	cpc	r11, r1
    1976:	09 f0       	breq	.+2      	; 0x197a <pf_write+0x1f0>
    1978:	5e cf       	rjmp	.-324    	; 0x1836 <pf_write+0xac>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	03 c0       	rjmp	.+6      	; 0x1984 <pf_write+0x1fa>
	UINT        wcnt;
	FATFS *     fs = FatFs;

	*bw = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    197e:	85 e0       	ldi	r24, 0x05	; 5
    1980:	01 c0       	rjmp	.+2      	; 0x1984 <pf_write+0x1fa>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1982:	84 e0       	ldi	r24, 0x04	; 4
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
}
    1984:	df 91       	pop	r29
    1986:	cf 91       	pop	r28
    1988:	1f 91       	pop	r17
    198a:	0f 91       	pop	r16
    198c:	ff 90       	pop	r15
    198e:	ef 90       	pop	r14
    1990:	df 90       	pop	r13
    1992:	cf 90       	pop	r12
    1994:	bf 90       	pop	r11
    1996:	af 90       	pop	r10
    1998:	7f 90       	pop	r7
    199a:	6f 90       	pop	r6
    199c:	5f 90       	pop	r5
    199e:	4f 90       	pop	r4
    19a0:	08 95       	ret

000019a2 <pf_lseek>:
/*-----------------------------------------------------------------------*/
#if _USE_LSEEK

FRESULT pf_lseek(DWORD ofs /* File pointer from top of file */
)
{
    19a2:	4f 92       	push	r4
    19a4:	5f 92       	push	r5
    19a6:	6f 92       	push	r6
    19a8:	7f 92       	push	r7
    19aa:	8f 92       	push	r8
    19ac:	9f 92       	push	r9
    19ae:	af 92       	push	r10
    19b0:	bf 92       	push	r11
    19b2:	cf 92       	push	r12
    19b4:	df 92       	push	r13
    19b6:	ef 92       	push	r14
    19b8:	ff 92       	push	r15
    19ba:	cf 93       	push	r28
    19bc:	df 93       	push	r29
    19be:	00 d0       	rcall	.+0      	; 0x19c0 <pf_lseek+0x1e>
    19c0:	00 d0       	rcall	.+0      	; 0x19c2 <pf_lseek+0x20>
    19c2:	00 d0       	rcall	.+0      	; 0x19c4 <pf_lseek+0x22>
    19c4:	cd b7       	in	r28, 0x3d	; 61
    19c6:	de b7       	in	r29, 0x3e	; 62
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;
    19c8:	20 91 cd 03 	lds	r18, 0x03CD	; 0x8003cd <FatFs>
    19cc:	30 91 ce 03 	lds	r19, 0x03CE	; 0x8003ce <FatFs+0x1>
    19d0:	3e 83       	std	Y+6, r19	; 0x06
    19d2:	2d 83       	std	Y+5, r18	; 0x05

	if (!fs)
    19d4:	21 15       	cp	r18, r1
    19d6:	31 05       	cpc	r19, r1
    19d8:	09 f4       	brne	.+2      	; 0x19dc <pf_lseek+0x3a>
    19da:	f4 c0       	rjmp	.+488    	; 0x1bc4 <pf_lseek+0x222>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    19dc:	d9 01       	movw	r26, r18
    19de:	11 96       	adiw	r26, 0x01	; 1
    19e0:	2c 91       	ld	r18, X
    19e2:	11 97       	sbiw	r26, 0x01	; 1
    19e4:	20 ff       	sbrs	r18, 0
    19e6:	f0 c0       	rjmp	.+480    	; 0x1bc8 <pf_lseek+0x226>
		return FR_NOT_OPENED;

	if (ofs > fs->fsize)
    19e8:	5a 96       	adiw	r26, 0x1a	; 26
    19ea:	cd 90       	ld	r12, X+
    19ec:	dd 90       	ld	r13, X+
    19ee:	ed 90       	ld	r14, X+
    19f0:	fc 90       	ld	r15, X
    19f2:	5d 97       	sbiw	r26, 0x1d	; 29
    19f4:	c6 16       	cp	r12, r22
    19f6:	d7 06       	cpc	r13, r23
    19f8:	e8 06       	cpc	r14, r24
    19fa:	f9 06       	cpc	r15, r25
    19fc:	10 f0       	brcs	.+4      	; 0x1a02 <pf_lseek+0x60>
    19fe:	6b 01       	movw	r12, r22
    1a00:	7c 01       	movw	r14, r24
		ofs = fs->fsize; /* Clip offset with the file size */
	ifptr    = fs->fptr;
    1a02:	ed 81       	ldd	r30, Y+5	; 0x05
    1a04:	fe 81       	ldd	r31, Y+6	; 0x06
    1a06:	46 88       	ldd	r4, Z+22	; 0x16
    1a08:	57 88       	ldd	r5, Z+23	; 0x17
    1a0a:	60 8c       	ldd	r6, Z+24	; 0x18
    1a0c:	71 8c       	ldd	r7, Z+25	; 0x19
	fs->fptr = 0;
    1a0e:	16 8a       	std	Z+22, r1	; 0x16
    1a10:	17 8a       	std	Z+23, r1	; 0x17
    1a12:	10 8e       	std	Z+24, r1	; 0x18
    1a14:	11 8e       	std	Z+25, r1	; 0x19
	if (ofs > 0) {
    1a16:	c1 14       	cp	r12, r1
    1a18:	d1 04       	cpc	r13, r1
    1a1a:	e1 04       	cpc	r14, r1
    1a1c:	f1 04       	cpc	r15, r1
    1a1e:	09 f4       	brne	.+2      	; 0x1a22 <pf_lseek+0x80>
    1a20:	d5 c0       	rjmp	.+426    	; 0x1bcc <pf_lseek+0x22a>
		bcs = (DWORD)fs->csize * 512;                            /* Cluster size (byte) */
    1a22:	82 80       	ldd	r8, Z+2	; 0x02
    1a24:	91 2c       	mov	r9, r1
    1a26:	a1 2c       	mov	r10, r1
    1a28:	b1 2c       	mov	r11, r1
    1a2a:	07 2e       	mov	r0, r23
    1a2c:	79 e0       	ldi	r23, 0x09	; 9
    1a2e:	88 0c       	add	r8, r8
    1a30:	99 1c       	adc	r9, r9
    1a32:	aa 1c       	adc	r10, r10
    1a34:	bb 1c       	adc	r11, r11
    1a36:	7a 95       	dec	r23
    1a38:	d1 f7       	brne	.-12     	; 0x1a2e <pf_lseek+0x8c>
    1a3a:	70 2d       	mov	r23, r0
		if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
    1a3c:	41 14       	cp	r4, r1
    1a3e:	51 04       	cpc	r5, r1
    1a40:	61 04       	cpc	r6, r1
    1a42:	71 04       	cpc	r7, r1
    1a44:	09 f4       	brne	.+2      	; 0x1a48 <pf_lseek+0xa6>
    1a46:	40 c0       	rjmp	.+128    	; 0x1ac8 <pf_lseek+0x126>
    1a48:	c7 01       	movw	r24, r14
    1a4a:	b6 01       	movw	r22, r12
    1a4c:	61 50       	subi	r22, 0x01	; 1
    1a4e:	71 09       	sbc	r23, r1
    1a50:	81 09       	sbc	r24, r1
    1a52:	91 09       	sbc	r25, r1
    1a54:	a5 01       	movw	r20, r10
    1a56:	94 01       	movw	r18, r8
    1a58:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <__udivmodsi4>
    1a5c:	29 83       	std	Y+1, r18	; 0x01
    1a5e:	3a 83       	std	Y+2, r19	; 0x02
    1a60:	4b 83       	std	Y+3, r20	; 0x03
    1a62:	5c 83       	std	Y+4, r21	; 0x04
    1a64:	b1 e0       	ldi	r27, 0x01	; 1
    1a66:	4b 1a       	sub	r4, r27
    1a68:	51 08       	sbc	r5, r1
    1a6a:	61 08       	sbc	r6, r1
    1a6c:	71 08       	sbc	r7, r1
    1a6e:	c3 01       	movw	r24, r6
    1a70:	b2 01       	movw	r22, r4
    1a72:	a5 01       	movw	r20, r10
    1a74:	94 01       	movw	r18, r8
    1a76:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <__udivmodsi4>
    1a7a:	89 81       	ldd	r24, Y+1	; 0x01
    1a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a7e:	ab 81       	ldd	r26, Y+3	; 0x03
    1a80:	bc 81       	ldd	r27, Y+4	; 0x04
    1a82:	82 17       	cp	r24, r18
    1a84:	93 07       	cpc	r25, r19
    1a86:	a4 07       	cpc	r26, r20
    1a88:	b5 07       	cpc	r27, r21
    1a8a:	f0 f0       	brcs	.+60     	; 0x1ac8 <pf_lseek+0x126>
			fs->fptr = (ifptr - 1) & ~(bcs - 1);                 /* start from the current cluster */
    1a8c:	88 27       	eor	r24, r24
    1a8e:	99 27       	eor	r25, r25
    1a90:	dc 01       	movw	r26, r24
    1a92:	88 19       	sub	r24, r8
    1a94:	99 09       	sbc	r25, r9
    1a96:	aa 09       	sbc	r26, r10
    1a98:	bb 09       	sbc	r27, r11
    1a9a:	48 22       	and	r4, r24
    1a9c:	59 22       	and	r5, r25
    1a9e:	6a 22       	and	r6, r26
    1aa0:	7b 22       	and	r7, r27
    1aa2:	ad 81       	ldd	r26, Y+5	; 0x05
    1aa4:	be 81       	ldd	r27, Y+6	; 0x06
    1aa6:	56 96       	adiw	r26, 0x16	; 22
    1aa8:	4d 92       	st	X+, r4
    1aaa:	5d 92       	st	X+, r5
    1aac:	6d 92       	st	X+, r6
    1aae:	7c 92       	st	X, r7
    1ab0:	59 97       	sbiw	r26, 0x19	; 25
			ofs -= fs->fptr;
    1ab2:	c4 18       	sub	r12, r4
    1ab4:	d5 08       	sbc	r13, r5
    1ab6:	e6 08       	sbc	r14, r6
    1ab8:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    1aba:	92 96       	adiw	r26, 0x22	; 34
    1abc:	6d 91       	ld	r22, X+
    1abe:	7d 91       	ld	r23, X+
    1ac0:	8d 91       	ld	r24, X+
    1ac2:	9c 91       	ld	r25, X
    1ac4:	95 97       	sbiw	r26, 0x25	; 37
    1ac6:	39 c0       	rjmp	.+114    	; 0x1b3a <pf_lseek+0x198>
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
    1ac8:	ed 81       	ldd	r30, Y+5	; 0x05
    1aca:	fe 81       	ldd	r31, Y+6	; 0x06
    1acc:	66 8d       	ldd	r22, Z+30	; 0x1e
    1ace:	77 8d       	ldd	r23, Z+31	; 0x1f
    1ad0:	80 a1       	ldd	r24, Z+32	; 0x20
    1ad2:	91 a1       	ldd	r25, Z+33	; 0x21
			fs->curr_clust = clst;
    1ad4:	62 a3       	std	Z+34, r22	; 0x22
    1ad6:	73 a3       	std	Z+35, r23	; 0x23
    1ad8:	84 a3       	std	Z+36, r24	; 0x24
    1ada:	95 a3       	std	Z+37, r25	; 0x25
    1adc:	2e c0       	rjmp	.+92     	; 0x1b3a <pf_lseek+0x198>
		}
		while (ofs > bcs) {       /* Cluster following loop */
			clst = get_fat(clst); /* Follow cluster chain */
    1ade:	0e 94 1f 07 	call	0xe3e	; 0xe3e <get_fat>
			if (clst <= 1 || clst >= fs->n_fatent)
    1ae2:	62 30       	cpi	r22, 0x02	; 2
    1ae4:	71 05       	cpc	r23, r1
    1ae6:	81 05       	cpc	r24, r1
    1ae8:	91 05       	cpc	r25, r1
    1aea:	58 f0       	brcs	.+22     	; 0x1b02 <pf_lseek+0x160>
    1aec:	ed 81       	ldd	r30, Y+5	; 0x05
    1aee:	fe 81       	ldd	r31, Y+6	; 0x06
    1af0:	46 80       	ldd	r4, Z+6	; 0x06
    1af2:	57 80       	ldd	r5, Z+7	; 0x07
    1af4:	60 84       	ldd	r6, Z+8	; 0x08
    1af6:	71 84       	ldd	r7, Z+9	; 0x09
    1af8:	64 15       	cp	r22, r4
    1afa:	75 05       	cpc	r23, r5
    1afc:	86 05       	cpc	r24, r6
    1afe:	97 05       	cpc	r25, r7
    1b00:	30 f0       	brcs	.+12     	; 0x1b0e <pf_lseek+0x16c>
				ABORT(FR_DISK_ERR);
    1b02:	ad 81       	ldd	r26, Y+5	; 0x05
    1b04:	be 81       	ldd	r27, Y+6	; 0x06
    1b06:	11 96       	adiw	r26, 0x01	; 1
    1b08:	1c 92       	st	X, r1
    1b0a:	81 e0       	ldi	r24, 0x01	; 1
    1b0c:	60 c0       	rjmp	.+192    	; 0x1bce <pf_lseek+0x22c>
			fs->curr_clust = clst;
    1b0e:	ed 81       	ldd	r30, Y+5	; 0x05
    1b10:	fe 81       	ldd	r31, Y+6	; 0x06
    1b12:	62 a3       	std	Z+34, r22	; 0x22
    1b14:	73 a3       	std	Z+35, r23	; 0x23
    1b16:	84 a3       	std	Z+36, r24	; 0x24
    1b18:	95 a3       	std	Z+37, r25	; 0x25
			fs->fptr += bcs;
    1b1a:	46 88       	ldd	r4, Z+22	; 0x16
    1b1c:	57 88       	ldd	r5, Z+23	; 0x17
    1b1e:	60 8c       	ldd	r6, Z+24	; 0x18
    1b20:	71 8c       	ldd	r7, Z+25	; 0x19
    1b22:	48 0c       	add	r4, r8
    1b24:	59 1c       	adc	r5, r9
    1b26:	6a 1c       	adc	r6, r10
    1b28:	7b 1c       	adc	r7, r11
    1b2a:	46 8a       	std	Z+22, r4	; 0x16
    1b2c:	57 8a       	std	Z+23, r5	; 0x17
    1b2e:	60 8e       	std	Z+24, r6	; 0x18
    1b30:	71 8e       	std	Z+25, r7	; 0x19
			ofs -= bcs;
    1b32:	c8 18       	sub	r12, r8
    1b34:	d9 08       	sbc	r13, r9
    1b36:	ea 08       	sbc	r14, r10
    1b38:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {       /* Cluster following loop */
    1b3a:	8c 14       	cp	r8, r12
    1b3c:	9d 04       	cpc	r9, r13
    1b3e:	ae 04       	cpc	r10, r14
    1b40:	bf 04       	cpc	r11, r15
    1b42:	68 f2       	brcs	.-102    	; 0x1ade <pf_lseek+0x13c>
				ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    1b44:	ed 81       	ldd	r30, Y+5	; 0x05
    1b46:	fe 81       	ldd	r31, Y+6	; 0x06
    1b48:	86 88       	ldd	r8, Z+22	; 0x16
    1b4a:	97 88       	ldd	r9, Z+23	; 0x17
    1b4c:	a0 8c       	ldd	r10, Z+24	; 0x18
    1b4e:	b1 8c       	ldd	r11, Z+25	; 0x19
    1b50:	c8 0c       	add	r12, r8
    1b52:	d9 1c       	adc	r13, r9
    1b54:	ea 1c       	adc	r14, r10
    1b56:	fb 1c       	adc	r15, r11
    1b58:	c6 8a       	std	Z+22, r12	; 0x16
    1b5a:	d7 8a       	std	Z+23, r13	; 0x17
    1b5c:	e0 8e       	std	Z+24, r14	; 0x18
    1b5e:	f1 8e       	std	Z+25, r15	; 0x19
		sect = clust2sect(clst); /* Current sector */
    1b60:	0e 94 07 06 	call	0xc0e	; 0xc0e <clust2sect>
		if (!sect)
    1b64:	61 15       	cp	r22, r1
    1b66:	71 05       	cpc	r23, r1
    1b68:	81 05       	cpc	r24, r1
    1b6a:	91 05       	cpc	r25, r1
    1b6c:	29 f4       	brne	.+10     	; 0x1b78 <pf_lseek+0x1d6>
			ABORT(FR_DISK_ERR);
    1b6e:	ed 81       	ldd	r30, Y+5	; 0x05
    1b70:	fe 81       	ldd	r31, Y+6	; 0x06
    1b72:	11 82       	std	Z+1, r1	; 0x01
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	2b c0       	rjmp	.+86     	; 0x1bce <pf_lseek+0x22c>
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    1b78:	0b 2e       	mov	r0, r27
    1b7a:	b9 e0       	ldi	r27, 0x09	; 9
    1b7c:	f6 94       	lsr	r15
    1b7e:	e7 94       	ror	r14
    1b80:	d7 94       	ror	r13
    1b82:	c7 94       	ror	r12
    1b84:	ba 95       	dec	r27
    1b86:	d1 f7       	brne	.-12     	; 0x1b7c <pf_lseek+0x1da>
    1b88:	b0 2d       	mov	r27, r0
    1b8a:	ad 81       	ldd	r26, Y+5	; 0x05
    1b8c:	be 81       	ldd	r27, Y+6	; 0x06
    1b8e:	12 96       	adiw	r26, 0x02	; 2
    1b90:	2c 91       	ld	r18, X
    1b92:	30 e0       	ldi	r19, 0x00	; 0
    1b94:	21 50       	subi	r18, 0x01	; 1
    1b96:	31 09       	sbc	r19, r1
    1b98:	49 01       	movw	r8, r18
    1b9a:	33 0f       	add	r19, r19
    1b9c:	aa 08       	sbc	r10, r10
    1b9e:	bb 08       	sbc	r11, r11
    1ba0:	c8 20       	and	r12, r8
    1ba2:	d9 20       	and	r13, r9
    1ba4:	ea 20       	and	r14, r10
    1ba6:	fb 20       	and	r15, r11
    1ba8:	dc 01       	movw	r26, r24
    1baa:	cb 01       	movw	r24, r22
    1bac:	8c 0d       	add	r24, r12
    1bae:	9d 1d       	adc	r25, r13
    1bb0:	ae 1d       	adc	r26, r14
    1bb2:	bf 1d       	adc	r27, r15
    1bb4:	ed 81       	ldd	r30, Y+5	; 0x05
    1bb6:	fe 81       	ldd	r31, Y+6	; 0x06
    1bb8:	86 a3       	std	Z+38, r24	; 0x26
    1bba:	97 a3       	std	Z+39, r25	; 0x27
    1bbc:	a0 a7       	std	Z+40, r26	; 0x28
    1bbe:	b1 a7       	std	Z+41, r27	; 0x29
	}

	return FR_OK;
    1bc0:	80 e0       	ldi	r24, 0x00	; 0
    1bc2:	05 c0       	rjmp	.+10     	; 0x1bce <pf_lseek+0x22c>
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1bc4:	85 e0       	ldi	r24, 0x05	; 5
    1bc6:	03 c0       	rjmp	.+6      	; 0x1bce <pf_lseek+0x22c>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1bc8:	84 e0       	ldi	r24, 0x04	; 4
    1bca:	01 c0       	rjmp	.+2      	; 0x1bce <pf_lseek+0x22c>
		if (!sect)
			ABORT(FR_DISK_ERR);
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
    1bcc:	80 e0       	ldi	r24, 0x00	; 0
}
    1bce:	26 96       	adiw	r28, 0x06	; 6
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	f8 94       	cli
    1bd4:	de bf       	out	0x3e, r29	; 62
    1bd6:	0f be       	out	0x3f, r0	; 63
    1bd8:	cd bf       	out	0x3d, r28	; 61
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	ff 90       	pop	r15
    1be0:	ef 90       	pop	r14
    1be2:	df 90       	pop	r13
    1be4:	cf 90       	pop	r12
    1be6:	bf 90       	pop	r11
    1be8:	af 90       	pop	r10
    1bea:	9f 90       	pop	r9
    1bec:	8f 90       	pop	r8
    1bee:	7f 90       	pop	r7
    1bf0:	6f 90       	pop	r6
    1bf2:	5f 90       	pop	r5
    1bf4:	4f 90       	pop	r4
    1bf6:	08 95       	ret

00001bf8 <__divmodhi4>:
    1bf8:	97 fb       	bst	r25, 7
    1bfa:	07 2e       	mov	r0, r23
    1bfc:	16 f4       	brtc	.+4      	; 0x1c02 <__divmodhi4+0xa>
    1bfe:	00 94       	com	r0
    1c00:	07 d0       	rcall	.+14     	; 0x1c10 <__divmodhi4_neg1>
    1c02:	77 fd       	sbrc	r23, 7
    1c04:	09 d0       	rcall	.+18     	; 0x1c18 <__divmodhi4_neg2>
    1c06:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <__udivmodhi4>
    1c0a:	07 fc       	sbrc	r0, 7
    1c0c:	05 d0       	rcall	.+10     	; 0x1c18 <__divmodhi4_neg2>
    1c0e:	3e f4       	brtc	.+14     	; 0x1c1e <__divmodhi4_exit>

00001c10 <__divmodhi4_neg1>:
    1c10:	90 95       	com	r25
    1c12:	81 95       	neg	r24
    1c14:	9f 4f       	sbci	r25, 0xFF	; 255
    1c16:	08 95       	ret

00001c18 <__divmodhi4_neg2>:
    1c18:	70 95       	com	r23
    1c1a:	61 95       	neg	r22
    1c1c:	7f 4f       	sbci	r23, 0xFF	; 255

00001c1e <__divmodhi4_exit>:
    1c1e:	08 95       	ret

00001c20 <__udivmodsi4>:
    1c20:	a1 e2       	ldi	r26, 0x21	; 33
    1c22:	1a 2e       	mov	r1, r26
    1c24:	aa 1b       	sub	r26, r26
    1c26:	bb 1b       	sub	r27, r27
    1c28:	fd 01       	movw	r30, r26
    1c2a:	0d c0       	rjmp	.+26     	; 0x1c46 <__udivmodsi4_ep>

00001c2c <__udivmodsi4_loop>:
    1c2c:	aa 1f       	adc	r26, r26
    1c2e:	bb 1f       	adc	r27, r27
    1c30:	ee 1f       	adc	r30, r30
    1c32:	ff 1f       	adc	r31, r31
    1c34:	a2 17       	cp	r26, r18
    1c36:	b3 07       	cpc	r27, r19
    1c38:	e4 07       	cpc	r30, r20
    1c3a:	f5 07       	cpc	r31, r21
    1c3c:	20 f0       	brcs	.+8      	; 0x1c46 <__udivmodsi4_ep>
    1c3e:	a2 1b       	sub	r26, r18
    1c40:	b3 0b       	sbc	r27, r19
    1c42:	e4 0b       	sbc	r30, r20
    1c44:	f5 0b       	sbc	r31, r21

00001c46 <__udivmodsi4_ep>:
    1c46:	66 1f       	adc	r22, r22
    1c48:	77 1f       	adc	r23, r23
    1c4a:	88 1f       	adc	r24, r24
    1c4c:	99 1f       	adc	r25, r25
    1c4e:	1a 94       	dec	r1
    1c50:	69 f7       	brne	.-38     	; 0x1c2c <__udivmodsi4_loop>
    1c52:	60 95       	com	r22
    1c54:	70 95       	com	r23
    1c56:	80 95       	com	r24
    1c58:	90 95       	com	r25
    1c5a:	9b 01       	movw	r18, r22
    1c5c:	ac 01       	movw	r20, r24
    1c5e:	bd 01       	movw	r22, r26
    1c60:	cf 01       	movw	r24, r30
    1c62:	08 95       	ret

00001c64 <__muluhisi3>:
    1c64:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <__umulhisi3>
    1c68:	a5 9f       	mul	r26, r21
    1c6a:	90 0d       	add	r25, r0
    1c6c:	b4 9f       	mul	r27, r20
    1c6e:	90 0d       	add	r25, r0
    1c70:	a4 9f       	mul	r26, r20
    1c72:	80 0d       	add	r24, r0
    1c74:	91 1d       	adc	r25, r1
    1c76:	11 24       	eor	r1, r1
    1c78:	08 95       	ret

00001c7a <__udivmodhi4>:
    1c7a:	aa 1b       	sub	r26, r26
    1c7c:	bb 1b       	sub	r27, r27
    1c7e:	51 e1       	ldi	r21, 0x11	; 17
    1c80:	07 c0       	rjmp	.+14     	; 0x1c90 <__udivmodhi4_ep>

00001c82 <__udivmodhi4_loop>:
    1c82:	aa 1f       	adc	r26, r26
    1c84:	bb 1f       	adc	r27, r27
    1c86:	a6 17       	cp	r26, r22
    1c88:	b7 07       	cpc	r27, r23
    1c8a:	10 f0       	brcs	.+4      	; 0x1c90 <__udivmodhi4_ep>
    1c8c:	a6 1b       	sub	r26, r22
    1c8e:	b7 0b       	sbc	r27, r23

00001c90 <__udivmodhi4_ep>:
    1c90:	88 1f       	adc	r24, r24
    1c92:	99 1f       	adc	r25, r25
    1c94:	5a 95       	dec	r21
    1c96:	a9 f7       	brne	.-22     	; 0x1c82 <__udivmodhi4_loop>
    1c98:	80 95       	com	r24
    1c9a:	90 95       	com	r25
    1c9c:	bc 01       	movw	r22, r24
    1c9e:	cd 01       	movw	r24, r26
    1ca0:	08 95       	ret

00001ca2 <__umulhisi3>:
    1ca2:	a2 9f       	mul	r26, r18
    1ca4:	b0 01       	movw	r22, r0
    1ca6:	b3 9f       	mul	r27, r19
    1ca8:	c0 01       	movw	r24, r0
    1caa:	a3 9f       	mul	r26, r19
    1cac:	70 0d       	add	r23, r0
    1cae:	81 1d       	adc	r24, r1
    1cb0:	11 24       	eor	r1, r1
    1cb2:	91 1d       	adc	r25, r1
    1cb4:	b2 9f       	mul	r27, r18
    1cb6:	70 0d       	add	r23, r0
    1cb8:	81 1d       	adc	r24, r1
    1cba:	11 24       	eor	r1, r1
    1cbc:	91 1d       	adc	r25, r1
    1cbe:	08 95       	ret

00001cc0 <sprintf>:
    1cc0:	ae e0       	ldi	r26, 0x0E	; 14
    1cc2:	b0 e0       	ldi	r27, 0x00	; 0
    1cc4:	e6 e6       	ldi	r30, 0x66	; 102
    1cc6:	fe e0       	ldi	r31, 0x0E	; 14
    1cc8:	0c 94 21 11 	jmp	0x2242	; 0x2242 <__prologue_saves__+0x1c>
    1ccc:	0d 89       	ldd	r16, Y+21	; 0x15
    1cce:	1e 89       	ldd	r17, Y+22	; 0x16
    1cd0:	86 e0       	ldi	r24, 0x06	; 6
    1cd2:	8c 83       	std	Y+4, r24	; 0x04
    1cd4:	1a 83       	std	Y+2, r17	; 0x02
    1cd6:	09 83       	std	Y+1, r16	; 0x01
    1cd8:	8f ef       	ldi	r24, 0xFF	; 255
    1cda:	9f e7       	ldi	r25, 0x7F	; 127
    1cdc:	9e 83       	std	Y+6, r25	; 0x06
    1cde:	8d 83       	std	Y+5, r24	; 0x05
    1ce0:	ae 01       	movw	r20, r28
    1ce2:	47 5e       	subi	r20, 0xE7	; 231
    1ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    1ce6:	6f 89       	ldd	r22, Y+23	; 0x17
    1ce8:	78 8d       	ldd	r23, Y+24	; 0x18
    1cea:	ce 01       	movw	r24, r28
    1cec:	01 96       	adiw	r24, 0x01	; 1
    1cee:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <vfprintf>
    1cf2:	ef 81       	ldd	r30, Y+7	; 0x07
    1cf4:	f8 85       	ldd	r31, Y+8	; 0x08
    1cf6:	e0 0f       	add	r30, r16
    1cf8:	f1 1f       	adc	r31, r17
    1cfa:	10 82       	st	Z, r1
    1cfc:	2e 96       	adiw	r28, 0x0e	; 14
    1cfe:	e4 e0       	ldi	r30, 0x04	; 4
    1d00:	0c 94 3d 11 	jmp	0x227a	; 0x227a <__epilogue_restores__+0x1c>

00001d04 <vfprintf>:
    1d04:	ab e0       	ldi	r26, 0x0B	; 11
    1d06:	b0 e0       	ldi	r27, 0x00	; 0
    1d08:	e8 e8       	ldi	r30, 0x88	; 136
    1d0a:	fe e0       	ldi	r31, 0x0E	; 14
    1d0c:	0c 94 13 11 	jmp	0x2226	; 0x2226 <__prologue_saves__>
    1d10:	6c 01       	movw	r12, r24
    1d12:	7b 01       	movw	r14, r22
    1d14:	8a 01       	movw	r16, r20
    1d16:	fc 01       	movw	r30, r24
    1d18:	17 82       	std	Z+7, r1	; 0x07
    1d1a:	16 82       	std	Z+6, r1	; 0x06
    1d1c:	83 81       	ldd	r24, Z+3	; 0x03
    1d1e:	81 ff       	sbrs	r24, 1
    1d20:	cc c1       	rjmp	.+920    	; 0x20ba <vfprintf+0x3b6>
    1d22:	ce 01       	movw	r24, r28
    1d24:	01 96       	adiw	r24, 0x01	; 1
    1d26:	3c 01       	movw	r6, r24
    1d28:	f6 01       	movw	r30, r12
    1d2a:	93 81       	ldd	r25, Z+3	; 0x03
    1d2c:	f7 01       	movw	r30, r14
    1d2e:	93 fd       	sbrc	r25, 3
    1d30:	85 91       	lpm	r24, Z+
    1d32:	93 ff       	sbrs	r25, 3
    1d34:	81 91       	ld	r24, Z+
    1d36:	7f 01       	movw	r14, r30
    1d38:	88 23       	and	r24, r24
    1d3a:	09 f4       	brne	.+2      	; 0x1d3e <vfprintf+0x3a>
    1d3c:	ba c1       	rjmp	.+884    	; 0x20b2 <vfprintf+0x3ae>
    1d3e:	85 32       	cpi	r24, 0x25	; 37
    1d40:	39 f4       	brne	.+14     	; 0x1d50 <vfprintf+0x4c>
    1d42:	93 fd       	sbrc	r25, 3
    1d44:	85 91       	lpm	r24, Z+
    1d46:	93 ff       	sbrs	r25, 3
    1d48:	81 91       	ld	r24, Z+
    1d4a:	7f 01       	movw	r14, r30
    1d4c:	85 32       	cpi	r24, 0x25	; 37
    1d4e:	29 f4       	brne	.+10     	; 0x1d5a <vfprintf+0x56>
    1d50:	b6 01       	movw	r22, r12
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    1d58:	e7 cf       	rjmp	.-50     	; 0x1d28 <vfprintf+0x24>
    1d5a:	91 2c       	mov	r9, r1
    1d5c:	21 2c       	mov	r2, r1
    1d5e:	31 2c       	mov	r3, r1
    1d60:	ff e1       	ldi	r31, 0x1F	; 31
    1d62:	f3 15       	cp	r31, r3
    1d64:	d8 f0       	brcs	.+54     	; 0x1d9c <vfprintf+0x98>
    1d66:	8b 32       	cpi	r24, 0x2B	; 43
    1d68:	79 f0       	breq	.+30     	; 0x1d88 <vfprintf+0x84>
    1d6a:	38 f4       	brcc	.+14     	; 0x1d7a <vfprintf+0x76>
    1d6c:	80 32       	cpi	r24, 0x20	; 32
    1d6e:	79 f0       	breq	.+30     	; 0x1d8e <vfprintf+0x8a>
    1d70:	83 32       	cpi	r24, 0x23	; 35
    1d72:	a1 f4       	brne	.+40     	; 0x1d9c <vfprintf+0x98>
    1d74:	23 2d       	mov	r18, r3
    1d76:	20 61       	ori	r18, 0x10	; 16
    1d78:	1d c0       	rjmp	.+58     	; 0x1db4 <vfprintf+0xb0>
    1d7a:	8d 32       	cpi	r24, 0x2D	; 45
    1d7c:	61 f0       	breq	.+24     	; 0x1d96 <vfprintf+0x92>
    1d7e:	80 33       	cpi	r24, 0x30	; 48
    1d80:	69 f4       	brne	.+26     	; 0x1d9c <vfprintf+0x98>
    1d82:	23 2d       	mov	r18, r3
    1d84:	21 60       	ori	r18, 0x01	; 1
    1d86:	16 c0       	rjmp	.+44     	; 0x1db4 <vfprintf+0xb0>
    1d88:	83 2d       	mov	r24, r3
    1d8a:	82 60       	ori	r24, 0x02	; 2
    1d8c:	38 2e       	mov	r3, r24
    1d8e:	e3 2d       	mov	r30, r3
    1d90:	e4 60       	ori	r30, 0x04	; 4
    1d92:	3e 2e       	mov	r3, r30
    1d94:	2a c0       	rjmp	.+84     	; 0x1dea <vfprintf+0xe6>
    1d96:	f3 2d       	mov	r31, r3
    1d98:	f8 60       	ori	r31, 0x08	; 8
    1d9a:	1d c0       	rjmp	.+58     	; 0x1dd6 <vfprintf+0xd2>
    1d9c:	37 fc       	sbrc	r3, 7
    1d9e:	2d c0       	rjmp	.+90     	; 0x1dfa <vfprintf+0xf6>
    1da0:	20 ed       	ldi	r18, 0xD0	; 208
    1da2:	28 0f       	add	r18, r24
    1da4:	2a 30       	cpi	r18, 0x0A	; 10
    1da6:	40 f0       	brcs	.+16     	; 0x1db8 <vfprintf+0xb4>
    1da8:	8e 32       	cpi	r24, 0x2E	; 46
    1daa:	b9 f4       	brne	.+46     	; 0x1dda <vfprintf+0xd6>
    1dac:	36 fc       	sbrc	r3, 6
    1dae:	81 c1       	rjmp	.+770    	; 0x20b2 <vfprintf+0x3ae>
    1db0:	23 2d       	mov	r18, r3
    1db2:	20 64       	ori	r18, 0x40	; 64
    1db4:	32 2e       	mov	r3, r18
    1db6:	19 c0       	rjmp	.+50     	; 0x1dea <vfprintf+0xe6>
    1db8:	36 fe       	sbrs	r3, 6
    1dba:	06 c0       	rjmp	.+12     	; 0x1dc8 <vfprintf+0xc4>
    1dbc:	8a e0       	ldi	r24, 0x0A	; 10
    1dbe:	98 9e       	mul	r9, r24
    1dc0:	20 0d       	add	r18, r0
    1dc2:	11 24       	eor	r1, r1
    1dc4:	92 2e       	mov	r9, r18
    1dc6:	11 c0       	rjmp	.+34     	; 0x1dea <vfprintf+0xe6>
    1dc8:	ea e0       	ldi	r30, 0x0A	; 10
    1dca:	2e 9e       	mul	r2, r30
    1dcc:	20 0d       	add	r18, r0
    1dce:	11 24       	eor	r1, r1
    1dd0:	22 2e       	mov	r2, r18
    1dd2:	f3 2d       	mov	r31, r3
    1dd4:	f0 62       	ori	r31, 0x20	; 32
    1dd6:	3f 2e       	mov	r3, r31
    1dd8:	08 c0       	rjmp	.+16     	; 0x1dea <vfprintf+0xe6>
    1dda:	8c 36       	cpi	r24, 0x6C	; 108
    1ddc:	21 f4       	brne	.+8      	; 0x1de6 <vfprintf+0xe2>
    1dde:	83 2d       	mov	r24, r3
    1de0:	80 68       	ori	r24, 0x80	; 128
    1de2:	38 2e       	mov	r3, r24
    1de4:	02 c0       	rjmp	.+4      	; 0x1dea <vfprintf+0xe6>
    1de6:	88 36       	cpi	r24, 0x68	; 104
    1de8:	41 f4       	brne	.+16     	; 0x1dfa <vfprintf+0xf6>
    1dea:	f7 01       	movw	r30, r14
    1dec:	93 fd       	sbrc	r25, 3
    1dee:	85 91       	lpm	r24, Z+
    1df0:	93 ff       	sbrs	r25, 3
    1df2:	81 91       	ld	r24, Z+
    1df4:	7f 01       	movw	r14, r30
    1df6:	81 11       	cpse	r24, r1
    1df8:	b3 cf       	rjmp	.-154    	; 0x1d60 <vfprintf+0x5c>
    1dfa:	98 2f       	mov	r25, r24
    1dfc:	9f 7d       	andi	r25, 0xDF	; 223
    1dfe:	95 54       	subi	r25, 0x45	; 69
    1e00:	93 30       	cpi	r25, 0x03	; 3
    1e02:	28 f4       	brcc	.+10     	; 0x1e0e <vfprintf+0x10a>
    1e04:	0c 5f       	subi	r16, 0xFC	; 252
    1e06:	1f 4f       	sbci	r17, 0xFF	; 255
    1e08:	9f e3       	ldi	r25, 0x3F	; 63
    1e0a:	99 83       	std	Y+1, r25	; 0x01
    1e0c:	0d c0       	rjmp	.+26     	; 0x1e28 <vfprintf+0x124>
    1e0e:	83 36       	cpi	r24, 0x63	; 99
    1e10:	31 f0       	breq	.+12     	; 0x1e1e <vfprintf+0x11a>
    1e12:	83 37       	cpi	r24, 0x73	; 115
    1e14:	71 f0       	breq	.+28     	; 0x1e32 <vfprintf+0x12e>
    1e16:	83 35       	cpi	r24, 0x53	; 83
    1e18:	09 f0       	breq	.+2      	; 0x1e1c <vfprintf+0x118>
    1e1a:	59 c0       	rjmp	.+178    	; 0x1ece <vfprintf+0x1ca>
    1e1c:	21 c0       	rjmp	.+66     	; 0x1e60 <vfprintf+0x15c>
    1e1e:	f8 01       	movw	r30, r16
    1e20:	80 81       	ld	r24, Z
    1e22:	89 83       	std	Y+1, r24	; 0x01
    1e24:	0e 5f       	subi	r16, 0xFE	; 254
    1e26:	1f 4f       	sbci	r17, 0xFF	; 255
    1e28:	88 24       	eor	r8, r8
    1e2a:	83 94       	inc	r8
    1e2c:	91 2c       	mov	r9, r1
    1e2e:	53 01       	movw	r10, r6
    1e30:	13 c0       	rjmp	.+38     	; 0x1e58 <vfprintf+0x154>
    1e32:	28 01       	movw	r4, r16
    1e34:	f2 e0       	ldi	r31, 0x02	; 2
    1e36:	4f 0e       	add	r4, r31
    1e38:	51 1c       	adc	r5, r1
    1e3a:	f8 01       	movw	r30, r16
    1e3c:	a0 80       	ld	r10, Z
    1e3e:	b1 80       	ldd	r11, Z+1	; 0x01
    1e40:	36 fe       	sbrs	r3, 6
    1e42:	03 c0       	rjmp	.+6      	; 0x1e4a <vfprintf+0x146>
    1e44:	69 2d       	mov	r22, r9
    1e46:	70 e0       	ldi	r23, 0x00	; 0
    1e48:	02 c0       	rjmp	.+4      	; 0x1e4e <vfprintf+0x14a>
    1e4a:	6f ef       	ldi	r22, 0xFF	; 255
    1e4c:	7f ef       	ldi	r23, 0xFF	; 255
    1e4e:	c5 01       	movw	r24, r10
    1e50:	0e 94 6e 10 	call	0x20dc	; 0x20dc <strnlen>
    1e54:	4c 01       	movw	r8, r24
    1e56:	82 01       	movw	r16, r4
    1e58:	f3 2d       	mov	r31, r3
    1e5a:	ff 77       	andi	r31, 0x7F	; 127
    1e5c:	3f 2e       	mov	r3, r31
    1e5e:	16 c0       	rjmp	.+44     	; 0x1e8c <vfprintf+0x188>
    1e60:	28 01       	movw	r4, r16
    1e62:	22 e0       	ldi	r18, 0x02	; 2
    1e64:	42 0e       	add	r4, r18
    1e66:	51 1c       	adc	r5, r1
    1e68:	f8 01       	movw	r30, r16
    1e6a:	a0 80       	ld	r10, Z
    1e6c:	b1 80       	ldd	r11, Z+1	; 0x01
    1e6e:	36 fe       	sbrs	r3, 6
    1e70:	03 c0       	rjmp	.+6      	; 0x1e78 <vfprintf+0x174>
    1e72:	69 2d       	mov	r22, r9
    1e74:	70 e0       	ldi	r23, 0x00	; 0
    1e76:	02 c0       	rjmp	.+4      	; 0x1e7c <vfprintf+0x178>
    1e78:	6f ef       	ldi	r22, 0xFF	; 255
    1e7a:	7f ef       	ldi	r23, 0xFF	; 255
    1e7c:	c5 01       	movw	r24, r10
    1e7e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <strnlen_P>
    1e82:	4c 01       	movw	r8, r24
    1e84:	f3 2d       	mov	r31, r3
    1e86:	f0 68       	ori	r31, 0x80	; 128
    1e88:	3f 2e       	mov	r3, r31
    1e8a:	82 01       	movw	r16, r4
    1e8c:	33 fc       	sbrc	r3, 3
    1e8e:	1b c0       	rjmp	.+54     	; 0x1ec6 <vfprintf+0x1c2>
    1e90:	82 2d       	mov	r24, r2
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	88 16       	cp	r8, r24
    1e96:	99 06       	cpc	r9, r25
    1e98:	b0 f4       	brcc	.+44     	; 0x1ec6 <vfprintf+0x1c2>
    1e9a:	b6 01       	movw	r22, r12
    1e9c:	80 e2       	ldi	r24, 0x20	; 32
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    1ea4:	2a 94       	dec	r2
    1ea6:	f4 cf       	rjmp	.-24     	; 0x1e90 <vfprintf+0x18c>
    1ea8:	f5 01       	movw	r30, r10
    1eaa:	37 fc       	sbrc	r3, 7
    1eac:	85 91       	lpm	r24, Z+
    1eae:	37 fe       	sbrs	r3, 7
    1eb0:	81 91       	ld	r24, Z+
    1eb2:	5f 01       	movw	r10, r30
    1eb4:	b6 01       	movw	r22, r12
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    1ebc:	21 10       	cpse	r2, r1
    1ebe:	2a 94       	dec	r2
    1ec0:	21 e0       	ldi	r18, 0x01	; 1
    1ec2:	82 1a       	sub	r8, r18
    1ec4:	91 08       	sbc	r9, r1
    1ec6:	81 14       	cp	r8, r1
    1ec8:	91 04       	cpc	r9, r1
    1eca:	71 f7       	brne	.-36     	; 0x1ea8 <vfprintf+0x1a4>
    1ecc:	e8 c0       	rjmp	.+464    	; 0x209e <vfprintf+0x39a>
    1ece:	84 36       	cpi	r24, 0x64	; 100
    1ed0:	11 f0       	breq	.+4      	; 0x1ed6 <vfprintf+0x1d2>
    1ed2:	89 36       	cpi	r24, 0x69	; 105
    1ed4:	41 f5       	brne	.+80     	; 0x1f26 <vfprintf+0x222>
    1ed6:	f8 01       	movw	r30, r16
    1ed8:	37 fe       	sbrs	r3, 7
    1eda:	07 c0       	rjmp	.+14     	; 0x1eea <vfprintf+0x1e6>
    1edc:	60 81       	ld	r22, Z
    1ede:	71 81       	ldd	r23, Z+1	; 0x01
    1ee0:	82 81       	ldd	r24, Z+2	; 0x02
    1ee2:	93 81       	ldd	r25, Z+3	; 0x03
    1ee4:	0c 5f       	subi	r16, 0xFC	; 252
    1ee6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee8:	08 c0       	rjmp	.+16     	; 0x1efa <vfprintf+0x1f6>
    1eea:	60 81       	ld	r22, Z
    1eec:	71 81       	ldd	r23, Z+1	; 0x01
    1eee:	07 2e       	mov	r0, r23
    1ef0:	00 0c       	add	r0, r0
    1ef2:	88 0b       	sbc	r24, r24
    1ef4:	99 0b       	sbc	r25, r25
    1ef6:	0e 5f       	subi	r16, 0xFE	; 254
    1ef8:	1f 4f       	sbci	r17, 0xFF	; 255
    1efa:	f3 2d       	mov	r31, r3
    1efc:	ff 76       	andi	r31, 0x6F	; 111
    1efe:	3f 2e       	mov	r3, r31
    1f00:	97 ff       	sbrs	r25, 7
    1f02:	09 c0       	rjmp	.+18     	; 0x1f16 <vfprintf+0x212>
    1f04:	90 95       	com	r25
    1f06:	80 95       	com	r24
    1f08:	70 95       	com	r23
    1f0a:	61 95       	neg	r22
    1f0c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0e:	8f 4f       	sbci	r24, 0xFF	; 255
    1f10:	9f 4f       	sbci	r25, 0xFF	; 255
    1f12:	f0 68       	ori	r31, 0x80	; 128
    1f14:	3f 2e       	mov	r3, r31
    1f16:	2a e0       	ldi	r18, 0x0A	; 10
    1f18:	30 e0       	ldi	r19, 0x00	; 0
    1f1a:	a3 01       	movw	r20, r6
    1f1c:	0e 94 b5 10 	call	0x216a	; 0x216a <__ultoa_invert>
    1f20:	88 2e       	mov	r8, r24
    1f22:	86 18       	sub	r8, r6
    1f24:	45 c0       	rjmp	.+138    	; 0x1fb0 <vfprintf+0x2ac>
    1f26:	85 37       	cpi	r24, 0x75	; 117
    1f28:	31 f4       	brne	.+12     	; 0x1f36 <vfprintf+0x232>
    1f2a:	23 2d       	mov	r18, r3
    1f2c:	2f 7e       	andi	r18, 0xEF	; 239
    1f2e:	b2 2e       	mov	r11, r18
    1f30:	2a e0       	ldi	r18, 0x0A	; 10
    1f32:	30 e0       	ldi	r19, 0x00	; 0
    1f34:	25 c0       	rjmp	.+74     	; 0x1f80 <vfprintf+0x27c>
    1f36:	93 2d       	mov	r25, r3
    1f38:	99 7f       	andi	r25, 0xF9	; 249
    1f3a:	b9 2e       	mov	r11, r25
    1f3c:	8f 36       	cpi	r24, 0x6F	; 111
    1f3e:	c1 f0       	breq	.+48     	; 0x1f70 <vfprintf+0x26c>
    1f40:	18 f4       	brcc	.+6      	; 0x1f48 <vfprintf+0x244>
    1f42:	88 35       	cpi	r24, 0x58	; 88
    1f44:	79 f0       	breq	.+30     	; 0x1f64 <vfprintf+0x260>
    1f46:	b5 c0       	rjmp	.+362    	; 0x20b2 <vfprintf+0x3ae>
    1f48:	80 37       	cpi	r24, 0x70	; 112
    1f4a:	19 f0       	breq	.+6      	; 0x1f52 <vfprintf+0x24e>
    1f4c:	88 37       	cpi	r24, 0x78	; 120
    1f4e:	21 f0       	breq	.+8      	; 0x1f58 <vfprintf+0x254>
    1f50:	b0 c0       	rjmp	.+352    	; 0x20b2 <vfprintf+0x3ae>
    1f52:	e9 2f       	mov	r30, r25
    1f54:	e0 61       	ori	r30, 0x10	; 16
    1f56:	be 2e       	mov	r11, r30
    1f58:	b4 fe       	sbrs	r11, 4
    1f5a:	0d c0       	rjmp	.+26     	; 0x1f76 <vfprintf+0x272>
    1f5c:	fb 2d       	mov	r31, r11
    1f5e:	f4 60       	ori	r31, 0x04	; 4
    1f60:	bf 2e       	mov	r11, r31
    1f62:	09 c0       	rjmp	.+18     	; 0x1f76 <vfprintf+0x272>
    1f64:	34 fe       	sbrs	r3, 4
    1f66:	0a c0       	rjmp	.+20     	; 0x1f7c <vfprintf+0x278>
    1f68:	29 2f       	mov	r18, r25
    1f6a:	26 60       	ori	r18, 0x06	; 6
    1f6c:	b2 2e       	mov	r11, r18
    1f6e:	06 c0       	rjmp	.+12     	; 0x1f7c <vfprintf+0x278>
    1f70:	28 e0       	ldi	r18, 0x08	; 8
    1f72:	30 e0       	ldi	r19, 0x00	; 0
    1f74:	05 c0       	rjmp	.+10     	; 0x1f80 <vfprintf+0x27c>
    1f76:	20 e1       	ldi	r18, 0x10	; 16
    1f78:	30 e0       	ldi	r19, 0x00	; 0
    1f7a:	02 c0       	rjmp	.+4      	; 0x1f80 <vfprintf+0x27c>
    1f7c:	20 e1       	ldi	r18, 0x10	; 16
    1f7e:	32 e0       	ldi	r19, 0x02	; 2
    1f80:	f8 01       	movw	r30, r16
    1f82:	b7 fe       	sbrs	r11, 7
    1f84:	07 c0       	rjmp	.+14     	; 0x1f94 <vfprintf+0x290>
    1f86:	60 81       	ld	r22, Z
    1f88:	71 81       	ldd	r23, Z+1	; 0x01
    1f8a:	82 81       	ldd	r24, Z+2	; 0x02
    1f8c:	93 81       	ldd	r25, Z+3	; 0x03
    1f8e:	0c 5f       	subi	r16, 0xFC	; 252
    1f90:	1f 4f       	sbci	r17, 0xFF	; 255
    1f92:	06 c0       	rjmp	.+12     	; 0x1fa0 <vfprintf+0x29c>
    1f94:	60 81       	ld	r22, Z
    1f96:	71 81       	ldd	r23, Z+1	; 0x01
    1f98:	80 e0       	ldi	r24, 0x00	; 0
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	0e 5f       	subi	r16, 0xFE	; 254
    1f9e:	1f 4f       	sbci	r17, 0xFF	; 255
    1fa0:	a3 01       	movw	r20, r6
    1fa2:	0e 94 b5 10 	call	0x216a	; 0x216a <__ultoa_invert>
    1fa6:	88 2e       	mov	r8, r24
    1fa8:	86 18       	sub	r8, r6
    1faa:	fb 2d       	mov	r31, r11
    1fac:	ff 77       	andi	r31, 0x7F	; 127
    1fae:	3f 2e       	mov	r3, r31
    1fb0:	36 fe       	sbrs	r3, 6
    1fb2:	0d c0       	rjmp	.+26     	; 0x1fce <vfprintf+0x2ca>
    1fb4:	23 2d       	mov	r18, r3
    1fb6:	2e 7f       	andi	r18, 0xFE	; 254
    1fb8:	a2 2e       	mov	r10, r18
    1fba:	89 14       	cp	r8, r9
    1fbc:	58 f4       	brcc	.+22     	; 0x1fd4 <vfprintf+0x2d0>
    1fbe:	34 fe       	sbrs	r3, 4
    1fc0:	0b c0       	rjmp	.+22     	; 0x1fd8 <vfprintf+0x2d4>
    1fc2:	32 fc       	sbrc	r3, 2
    1fc4:	09 c0       	rjmp	.+18     	; 0x1fd8 <vfprintf+0x2d4>
    1fc6:	83 2d       	mov	r24, r3
    1fc8:	8e 7e       	andi	r24, 0xEE	; 238
    1fca:	a8 2e       	mov	r10, r24
    1fcc:	05 c0       	rjmp	.+10     	; 0x1fd8 <vfprintf+0x2d4>
    1fce:	b8 2c       	mov	r11, r8
    1fd0:	a3 2c       	mov	r10, r3
    1fd2:	03 c0       	rjmp	.+6      	; 0x1fda <vfprintf+0x2d6>
    1fd4:	b8 2c       	mov	r11, r8
    1fd6:	01 c0       	rjmp	.+2      	; 0x1fda <vfprintf+0x2d6>
    1fd8:	b9 2c       	mov	r11, r9
    1fda:	a4 fe       	sbrs	r10, 4
    1fdc:	0f c0       	rjmp	.+30     	; 0x1ffc <vfprintf+0x2f8>
    1fde:	fe 01       	movw	r30, r28
    1fe0:	e8 0d       	add	r30, r8
    1fe2:	f1 1d       	adc	r31, r1
    1fe4:	80 81       	ld	r24, Z
    1fe6:	80 33       	cpi	r24, 0x30	; 48
    1fe8:	21 f4       	brne	.+8      	; 0x1ff2 <vfprintf+0x2ee>
    1fea:	9a 2d       	mov	r25, r10
    1fec:	99 7e       	andi	r25, 0xE9	; 233
    1fee:	a9 2e       	mov	r10, r25
    1ff0:	09 c0       	rjmp	.+18     	; 0x2004 <vfprintf+0x300>
    1ff2:	a2 fe       	sbrs	r10, 2
    1ff4:	06 c0       	rjmp	.+12     	; 0x2002 <vfprintf+0x2fe>
    1ff6:	b3 94       	inc	r11
    1ff8:	b3 94       	inc	r11
    1ffa:	04 c0       	rjmp	.+8      	; 0x2004 <vfprintf+0x300>
    1ffc:	8a 2d       	mov	r24, r10
    1ffe:	86 78       	andi	r24, 0x86	; 134
    2000:	09 f0       	breq	.+2      	; 0x2004 <vfprintf+0x300>
    2002:	b3 94       	inc	r11
    2004:	a3 fc       	sbrc	r10, 3
    2006:	11 c0       	rjmp	.+34     	; 0x202a <vfprintf+0x326>
    2008:	a0 fe       	sbrs	r10, 0
    200a:	06 c0       	rjmp	.+12     	; 0x2018 <vfprintf+0x314>
    200c:	b2 14       	cp	r11, r2
    200e:	88 f4       	brcc	.+34     	; 0x2032 <vfprintf+0x32e>
    2010:	28 0c       	add	r2, r8
    2012:	92 2c       	mov	r9, r2
    2014:	9b 18       	sub	r9, r11
    2016:	0e c0       	rjmp	.+28     	; 0x2034 <vfprintf+0x330>
    2018:	b2 14       	cp	r11, r2
    201a:	60 f4       	brcc	.+24     	; 0x2034 <vfprintf+0x330>
    201c:	b6 01       	movw	r22, r12
    201e:	80 e2       	ldi	r24, 0x20	; 32
    2020:	90 e0       	ldi	r25, 0x00	; 0
    2022:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    2026:	b3 94       	inc	r11
    2028:	f7 cf       	rjmp	.-18     	; 0x2018 <vfprintf+0x314>
    202a:	b2 14       	cp	r11, r2
    202c:	18 f4       	brcc	.+6      	; 0x2034 <vfprintf+0x330>
    202e:	2b 18       	sub	r2, r11
    2030:	02 c0       	rjmp	.+4      	; 0x2036 <vfprintf+0x332>
    2032:	98 2c       	mov	r9, r8
    2034:	21 2c       	mov	r2, r1
    2036:	a4 fe       	sbrs	r10, 4
    2038:	10 c0       	rjmp	.+32     	; 0x205a <vfprintf+0x356>
    203a:	b6 01       	movw	r22, r12
    203c:	80 e3       	ldi	r24, 0x30	; 48
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    2044:	a2 fe       	sbrs	r10, 2
    2046:	17 c0       	rjmp	.+46     	; 0x2076 <vfprintf+0x372>
    2048:	a1 fc       	sbrc	r10, 1
    204a:	03 c0       	rjmp	.+6      	; 0x2052 <vfprintf+0x34e>
    204c:	88 e7       	ldi	r24, 0x78	; 120
    204e:	90 e0       	ldi	r25, 0x00	; 0
    2050:	02 c0       	rjmp	.+4      	; 0x2056 <vfprintf+0x352>
    2052:	88 e5       	ldi	r24, 0x58	; 88
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	b6 01       	movw	r22, r12
    2058:	0c c0       	rjmp	.+24     	; 0x2072 <vfprintf+0x36e>
    205a:	8a 2d       	mov	r24, r10
    205c:	86 78       	andi	r24, 0x86	; 134
    205e:	59 f0       	breq	.+22     	; 0x2076 <vfprintf+0x372>
    2060:	a1 fe       	sbrs	r10, 1
    2062:	02 c0       	rjmp	.+4      	; 0x2068 <vfprintf+0x364>
    2064:	8b e2       	ldi	r24, 0x2B	; 43
    2066:	01 c0       	rjmp	.+2      	; 0x206a <vfprintf+0x366>
    2068:	80 e2       	ldi	r24, 0x20	; 32
    206a:	a7 fc       	sbrc	r10, 7
    206c:	8d e2       	ldi	r24, 0x2D	; 45
    206e:	b6 01       	movw	r22, r12
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    2076:	89 14       	cp	r8, r9
    2078:	38 f4       	brcc	.+14     	; 0x2088 <vfprintf+0x384>
    207a:	b6 01       	movw	r22, r12
    207c:	80 e3       	ldi	r24, 0x30	; 48
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    2084:	9a 94       	dec	r9
    2086:	f7 cf       	rjmp	.-18     	; 0x2076 <vfprintf+0x372>
    2088:	8a 94       	dec	r8
    208a:	f3 01       	movw	r30, r6
    208c:	e8 0d       	add	r30, r8
    208e:	f1 1d       	adc	r31, r1
    2090:	80 81       	ld	r24, Z
    2092:	b6 01       	movw	r22, r12
    2094:	90 e0       	ldi	r25, 0x00	; 0
    2096:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    209a:	81 10       	cpse	r8, r1
    209c:	f5 cf       	rjmp	.-22     	; 0x2088 <vfprintf+0x384>
    209e:	22 20       	and	r2, r2
    20a0:	09 f4       	brne	.+2      	; 0x20a4 <vfprintf+0x3a0>
    20a2:	42 ce       	rjmp	.-892    	; 0x1d28 <vfprintf+0x24>
    20a4:	b6 01       	movw	r22, r12
    20a6:	80 e2       	ldi	r24, 0x20	; 32
    20a8:	90 e0       	ldi	r25, 0x00	; 0
    20aa:	0e 94 79 10 	call	0x20f2	; 0x20f2 <fputc>
    20ae:	2a 94       	dec	r2
    20b0:	f6 cf       	rjmp	.-20     	; 0x209e <vfprintf+0x39a>
    20b2:	f6 01       	movw	r30, r12
    20b4:	86 81       	ldd	r24, Z+6	; 0x06
    20b6:	97 81       	ldd	r25, Z+7	; 0x07
    20b8:	02 c0       	rjmp	.+4      	; 0x20be <vfprintf+0x3ba>
    20ba:	8f ef       	ldi	r24, 0xFF	; 255
    20bc:	9f ef       	ldi	r25, 0xFF	; 255
    20be:	2b 96       	adiw	r28, 0x0b	; 11
    20c0:	e2 e1       	ldi	r30, 0x12	; 18
    20c2:	0c 94 2f 11 	jmp	0x225e	; 0x225e <__epilogue_restores__>

000020c6 <strnlen_P>:
    20c6:	fc 01       	movw	r30, r24
    20c8:	05 90       	lpm	r0, Z+
    20ca:	61 50       	subi	r22, 0x01	; 1
    20cc:	70 40       	sbci	r23, 0x00	; 0
    20ce:	01 10       	cpse	r0, r1
    20d0:	d8 f7       	brcc	.-10     	; 0x20c8 <strnlen_P+0x2>
    20d2:	80 95       	com	r24
    20d4:	90 95       	com	r25
    20d6:	8e 0f       	add	r24, r30
    20d8:	9f 1f       	adc	r25, r31
    20da:	08 95       	ret

000020dc <strnlen>:
    20dc:	fc 01       	movw	r30, r24
    20de:	61 50       	subi	r22, 0x01	; 1
    20e0:	70 40       	sbci	r23, 0x00	; 0
    20e2:	01 90       	ld	r0, Z+
    20e4:	01 10       	cpse	r0, r1
    20e6:	d8 f7       	brcc	.-10     	; 0x20de <strnlen+0x2>
    20e8:	80 95       	com	r24
    20ea:	90 95       	com	r25
    20ec:	8e 0f       	add	r24, r30
    20ee:	9f 1f       	adc	r25, r31
    20f0:	08 95       	ret

000020f2 <fputc>:
    20f2:	0f 93       	push	r16
    20f4:	1f 93       	push	r17
    20f6:	cf 93       	push	r28
    20f8:	df 93       	push	r29
    20fa:	fb 01       	movw	r30, r22
    20fc:	23 81       	ldd	r18, Z+3	; 0x03
    20fe:	21 fd       	sbrc	r18, 1
    2100:	03 c0       	rjmp	.+6      	; 0x2108 <fputc+0x16>
    2102:	8f ef       	ldi	r24, 0xFF	; 255
    2104:	9f ef       	ldi	r25, 0xFF	; 255
    2106:	2c c0       	rjmp	.+88     	; 0x2160 <fputc+0x6e>
    2108:	22 ff       	sbrs	r18, 2
    210a:	16 c0       	rjmp	.+44     	; 0x2138 <fputc+0x46>
    210c:	46 81       	ldd	r20, Z+6	; 0x06
    210e:	57 81       	ldd	r21, Z+7	; 0x07
    2110:	24 81       	ldd	r18, Z+4	; 0x04
    2112:	35 81       	ldd	r19, Z+5	; 0x05
    2114:	42 17       	cp	r20, r18
    2116:	53 07       	cpc	r21, r19
    2118:	44 f4       	brge	.+16     	; 0x212a <fputc+0x38>
    211a:	a0 81       	ld	r26, Z
    211c:	b1 81       	ldd	r27, Z+1	; 0x01
    211e:	9d 01       	movw	r18, r26
    2120:	2f 5f       	subi	r18, 0xFF	; 255
    2122:	3f 4f       	sbci	r19, 0xFF	; 255
    2124:	31 83       	std	Z+1, r19	; 0x01
    2126:	20 83       	st	Z, r18
    2128:	8c 93       	st	X, r24
    212a:	26 81       	ldd	r18, Z+6	; 0x06
    212c:	37 81       	ldd	r19, Z+7	; 0x07
    212e:	2f 5f       	subi	r18, 0xFF	; 255
    2130:	3f 4f       	sbci	r19, 0xFF	; 255
    2132:	37 83       	std	Z+7, r19	; 0x07
    2134:	26 83       	std	Z+6, r18	; 0x06
    2136:	14 c0       	rjmp	.+40     	; 0x2160 <fputc+0x6e>
    2138:	8b 01       	movw	r16, r22
    213a:	ec 01       	movw	r28, r24
    213c:	fb 01       	movw	r30, r22
    213e:	00 84       	ldd	r0, Z+8	; 0x08
    2140:	f1 85       	ldd	r31, Z+9	; 0x09
    2142:	e0 2d       	mov	r30, r0
    2144:	09 95       	icall
    2146:	89 2b       	or	r24, r25
    2148:	e1 f6       	brne	.-72     	; 0x2102 <fputc+0x10>
    214a:	d8 01       	movw	r26, r16
    214c:	16 96       	adiw	r26, 0x06	; 6
    214e:	8d 91       	ld	r24, X+
    2150:	9c 91       	ld	r25, X
    2152:	17 97       	sbiw	r26, 0x07	; 7
    2154:	01 96       	adiw	r24, 0x01	; 1
    2156:	17 96       	adiw	r26, 0x07	; 7
    2158:	9c 93       	st	X, r25
    215a:	8e 93       	st	-X, r24
    215c:	16 97       	sbiw	r26, 0x06	; 6
    215e:	ce 01       	movw	r24, r28
    2160:	df 91       	pop	r29
    2162:	cf 91       	pop	r28
    2164:	1f 91       	pop	r17
    2166:	0f 91       	pop	r16
    2168:	08 95       	ret

0000216a <__ultoa_invert>:
    216a:	fa 01       	movw	r30, r20
    216c:	aa 27       	eor	r26, r26
    216e:	28 30       	cpi	r18, 0x08	; 8
    2170:	51 f1       	breq	.+84     	; 0x21c6 <__ultoa_invert+0x5c>
    2172:	20 31       	cpi	r18, 0x10	; 16
    2174:	81 f1       	breq	.+96     	; 0x21d6 <__ultoa_invert+0x6c>
    2176:	e8 94       	clt
    2178:	6f 93       	push	r22
    217a:	6e 7f       	andi	r22, 0xFE	; 254
    217c:	6e 5f       	subi	r22, 0xFE	; 254
    217e:	7f 4f       	sbci	r23, 0xFF	; 255
    2180:	8f 4f       	sbci	r24, 0xFF	; 255
    2182:	9f 4f       	sbci	r25, 0xFF	; 255
    2184:	af 4f       	sbci	r26, 0xFF	; 255
    2186:	b1 e0       	ldi	r27, 0x01	; 1
    2188:	3e d0       	rcall	.+124    	; 0x2206 <__ultoa_invert+0x9c>
    218a:	b4 e0       	ldi	r27, 0x04	; 4
    218c:	3c d0       	rcall	.+120    	; 0x2206 <__ultoa_invert+0x9c>
    218e:	67 0f       	add	r22, r23
    2190:	78 1f       	adc	r23, r24
    2192:	89 1f       	adc	r24, r25
    2194:	9a 1f       	adc	r25, r26
    2196:	a1 1d       	adc	r26, r1
    2198:	68 0f       	add	r22, r24
    219a:	79 1f       	adc	r23, r25
    219c:	8a 1f       	adc	r24, r26
    219e:	91 1d       	adc	r25, r1
    21a0:	a1 1d       	adc	r26, r1
    21a2:	6a 0f       	add	r22, r26
    21a4:	71 1d       	adc	r23, r1
    21a6:	81 1d       	adc	r24, r1
    21a8:	91 1d       	adc	r25, r1
    21aa:	a1 1d       	adc	r26, r1
    21ac:	20 d0       	rcall	.+64     	; 0x21ee <__ultoa_invert+0x84>
    21ae:	09 f4       	brne	.+2      	; 0x21b2 <__ultoa_invert+0x48>
    21b0:	68 94       	set
    21b2:	3f 91       	pop	r19
    21b4:	2a e0       	ldi	r18, 0x0A	; 10
    21b6:	26 9f       	mul	r18, r22
    21b8:	11 24       	eor	r1, r1
    21ba:	30 19       	sub	r19, r0
    21bc:	30 5d       	subi	r19, 0xD0	; 208
    21be:	31 93       	st	Z+, r19
    21c0:	de f6       	brtc	.-74     	; 0x2178 <__ultoa_invert+0xe>
    21c2:	cf 01       	movw	r24, r30
    21c4:	08 95       	ret
    21c6:	46 2f       	mov	r20, r22
    21c8:	47 70       	andi	r20, 0x07	; 7
    21ca:	40 5d       	subi	r20, 0xD0	; 208
    21cc:	41 93       	st	Z+, r20
    21ce:	b3 e0       	ldi	r27, 0x03	; 3
    21d0:	0f d0       	rcall	.+30     	; 0x21f0 <__ultoa_invert+0x86>
    21d2:	c9 f7       	brne	.-14     	; 0x21c6 <__ultoa_invert+0x5c>
    21d4:	f6 cf       	rjmp	.-20     	; 0x21c2 <__ultoa_invert+0x58>
    21d6:	46 2f       	mov	r20, r22
    21d8:	4f 70       	andi	r20, 0x0F	; 15
    21da:	40 5d       	subi	r20, 0xD0	; 208
    21dc:	4a 33       	cpi	r20, 0x3A	; 58
    21de:	18 f0       	brcs	.+6      	; 0x21e6 <__ultoa_invert+0x7c>
    21e0:	49 5d       	subi	r20, 0xD9	; 217
    21e2:	31 fd       	sbrc	r19, 1
    21e4:	40 52       	subi	r20, 0x20	; 32
    21e6:	41 93       	st	Z+, r20
    21e8:	02 d0       	rcall	.+4      	; 0x21ee <__ultoa_invert+0x84>
    21ea:	a9 f7       	brne	.-22     	; 0x21d6 <__ultoa_invert+0x6c>
    21ec:	ea cf       	rjmp	.-44     	; 0x21c2 <__ultoa_invert+0x58>
    21ee:	b4 e0       	ldi	r27, 0x04	; 4
    21f0:	a6 95       	lsr	r26
    21f2:	97 95       	ror	r25
    21f4:	87 95       	ror	r24
    21f6:	77 95       	ror	r23
    21f8:	67 95       	ror	r22
    21fa:	ba 95       	dec	r27
    21fc:	c9 f7       	brne	.-14     	; 0x21f0 <__ultoa_invert+0x86>
    21fe:	00 97       	sbiw	r24, 0x00	; 0
    2200:	61 05       	cpc	r22, r1
    2202:	71 05       	cpc	r23, r1
    2204:	08 95       	ret
    2206:	9b 01       	movw	r18, r22
    2208:	ac 01       	movw	r20, r24
    220a:	0a 2e       	mov	r0, r26
    220c:	06 94       	lsr	r0
    220e:	57 95       	ror	r21
    2210:	47 95       	ror	r20
    2212:	37 95       	ror	r19
    2214:	27 95       	ror	r18
    2216:	ba 95       	dec	r27
    2218:	c9 f7       	brne	.-14     	; 0x220c <__ultoa_invert+0xa2>
    221a:	62 0f       	add	r22, r18
    221c:	73 1f       	adc	r23, r19
    221e:	84 1f       	adc	r24, r20
    2220:	95 1f       	adc	r25, r21
    2222:	a0 1d       	adc	r26, r0
    2224:	08 95       	ret

00002226 <__prologue_saves__>:
    2226:	2f 92       	push	r2
    2228:	3f 92       	push	r3
    222a:	4f 92       	push	r4
    222c:	5f 92       	push	r5
    222e:	6f 92       	push	r6
    2230:	7f 92       	push	r7
    2232:	8f 92       	push	r8
    2234:	9f 92       	push	r9
    2236:	af 92       	push	r10
    2238:	bf 92       	push	r11
    223a:	cf 92       	push	r12
    223c:	df 92       	push	r13
    223e:	ef 92       	push	r14
    2240:	ff 92       	push	r15
    2242:	0f 93       	push	r16
    2244:	1f 93       	push	r17
    2246:	cf 93       	push	r28
    2248:	df 93       	push	r29
    224a:	cd b7       	in	r28, 0x3d	; 61
    224c:	de b7       	in	r29, 0x3e	; 62
    224e:	ca 1b       	sub	r28, r26
    2250:	db 0b       	sbc	r29, r27
    2252:	0f b6       	in	r0, 0x3f	; 63
    2254:	f8 94       	cli
    2256:	de bf       	out	0x3e, r29	; 62
    2258:	0f be       	out	0x3f, r0	; 63
    225a:	cd bf       	out	0x3d, r28	; 61
    225c:	09 94       	ijmp

0000225e <__epilogue_restores__>:
    225e:	2a 88       	ldd	r2, Y+18	; 0x12
    2260:	39 88       	ldd	r3, Y+17	; 0x11
    2262:	48 88       	ldd	r4, Y+16	; 0x10
    2264:	5f 84       	ldd	r5, Y+15	; 0x0f
    2266:	6e 84       	ldd	r6, Y+14	; 0x0e
    2268:	7d 84       	ldd	r7, Y+13	; 0x0d
    226a:	8c 84       	ldd	r8, Y+12	; 0x0c
    226c:	9b 84       	ldd	r9, Y+11	; 0x0b
    226e:	aa 84       	ldd	r10, Y+10	; 0x0a
    2270:	b9 84       	ldd	r11, Y+9	; 0x09
    2272:	c8 84       	ldd	r12, Y+8	; 0x08
    2274:	df 80       	ldd	r13, Y+7	; 0x07
    2276:	ee 80       	ldd	r14, Y+6	; 0x06
    2278:	fd 80       	ldd	r15, Y+5	; 0x05
    227a:	0c 81       	ldd	r16, Y+4	; 0x04
    227c:	1b 81       	ldd	r17, Y+3	; 0x03
    227e:	aa 81       	ldd	r26, Y+2	; 0x02
    2280:	b9 81       	ldd	r27, Y+1	; 0x01
    2282:	ce 0f       	add	r28, r30
    2284:	d1 1d       	adc	r29, r1
    2286:	0f b6       	in	r0, 0x3f	; 63
    2288:	f8 94       	cli
    228a:	de bf       	out	0x3e, r29	; 62
    228c:	0f be       	out	0x3f, r0	; 63
    228e:	cd bf       	out	0x3d, r28	; 61
    2290:	ed 01       	movw	r28, r26
    2292:	08 95       	ret

00002294 <_exit>:
    2294:	f8 94       	cli

00002296 <__stop_program>:
    2296:	ff cf       	rjmp	.-2      	; 0x2296 <__stop_program>
