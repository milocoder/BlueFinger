
SD_kaart4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000bc  00800100  0000225a  000022ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000225a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000328  008001bc  008001bc  000023aa  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000023aa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002408  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000198  00000000  00000000  00002444  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a55  00000000  00000000  000025dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001157  00000000  00000000  00005031  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000016c9  00000000  00000000  00006188  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000658  00000000  00000000  00007854  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a06  00000000  00000000  00007eac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000257e  00000000  00000000  000088b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000158  00000000  00000000  0000ae30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 28 04 	jmp	0x850	; 0x850 <__vector_10>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_18>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf ef       	ldi	r28, 0xFF	; 255
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e0       	ldi	r26, 0x00	; 0
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	ea e5       	ldi	r30, 0x5A	; 90
      a8:	f2 e2       	ldi	r31, 0x22	; 34
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	ac 3b       	cpi	r26, 0xBC	; 188
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	24 e0       	ldi	r18, 0x04	; 4
      b8:	ac eb       	ldi	r26, 0xBC	; 188
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	a4 3e       	cpi	r26, 0xE4	; 228
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 7d 05 	call	0xafa	; 0xafa <main>
      ca:	0c 94 2b 11 	jmp	0x2256	; 0x2256 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <initCAN>:

	// Set the MOB's mode to transmission, also activating it.
	CANCDMOB |= (0x01 << CONMOB0);

	return 1;
}
      d2:	e8 ed       	ldi	r30, 0xD8	; 216
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	80 81       	ld	r24, Z
      d8:	81 60       	ori	r24, 0x01	; 1
      da:	80 83       	st	Z, r24
      dc:	86 e0       	ldi	r24, 0x06	; 6
      de:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7f80e2>
      e2:	84 e0       	ldi	r24, 0x04	; 4
      e4:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7f80e3>
      e8:	83 e1       	ldi	r24, 0x13	; 19
      ea:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7f80e4>
      ee:	80 e0       	ldi	r24, 0x00	; 0
      f0:	08 c0       	rjmp	.+16     	; 0x102 <initCAN+0x30>
      f2:	98 2f       	mov	r25, r24
      f4:	92 95       	swap	r25
      f6:	90 7f       	andi	r25, 0xF0	; 240
      f8:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
      fc:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     100:	8f 5f       	subi	r24, 0xFF	; 255
     102:	8f 30       	cpi	r24, 0x0F	; 15
     104:	b0 f3       	brcs	.-20     	; 0xf2 <initCAN+0x20>
     106:	78 94       	sei
     108:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     10c:	80 eb       	ldi	r24, 0xB0	; 176
     10e:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7f80db>
     112:	e8 ed       	ldi	r30, 0xD8	; 216
     114:	f0 e0       	ldi	r31, 0x00	; 0
     116:	80 81       	ld	r24, Z
     118:	82 60       	ori	r24, 0x02	; 2
     11a:	80 83       	st	Z, r24
     11c:	08 95       	ret

0000011e <getFreeMob>:
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	0a c0       	rjmp	.+20     	; 0x136 <getFreeMob+0x18>
     122:	98 2f       	mov	r25, r24
     124:	92 95       	swap	r25
     126:	90 7f       	andi	r25, 0xF0	; 240
     128:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     12c:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     130:	90 7c       	andi	r25, 0xC0	; 192
     132:	21 f0       	breq	.+8      	; 0x13c <getFreeMob+0x1e>
     134:	8f 5f       	subi	r24, 0xFF	; 255
     136:	8f 30       	cpi	r24, 0x0F	; 15
     138:	a0 f3       	brcs	.-24     	; 0x122 <getFreeMob+0x4>
     13a:	8f ef       	ldi	r24, 0xFF	; 255
     13c:	08 95       	ret

0000013e <listenForMessage>:
 * @param[in] id - the provided id
 * @return 0 if no free message objects left, 1 otherwise
 *
 */
uint8_t listenForMessage( uint16_t id, uint8_t expectedLength )
{
     13e:	1f 93       	push	r17
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	ec 01       	movw	r28, r24
     146:	16 2f       	mov	r17, r22
	// Try to get a free MOb
	uint8_t mobIndex = getFreeMob();
     148:	0e 94 8f 00 	call	0x11e	; 0x11e <getFreeMob>

	if( mobIndex == 0xFF )
     14c:	8f 3f       	cpi	r24, 0xFF	; 255
     14e:	09 f4       	brne	.+2      	; 0x152 <listenForMessage+0x14>
     150:	4e c0       	rjmp	.+156    	; 0x1ee <listenForMessage+0xb0>
		// No free Message Objects
		return 0;
	}

	// Point to the free message object
	CANPAGE |= (mobIndex << 4);
     152:	ed ee       	ldi	r30, 0xED	; 237
     154:	f0 e0       	ldi	r31, 0x00	; 0
     156:	90 81       	ld	r25, Z
     158:	48 2f       	mov	r20, r24
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	9a 01       	movw	r18, r20
     15e:	22 95       	swap	r18
     160:	32 95       	swap	r19
     162:	30 7f       	andi	r19, 0xF0	; 240
     164:	32 27       	eor	r19, r18
     166:	20 7f       	andi	r18, 0xF0	; 240
     168:	32 27       	eor	r19, r18
     16a:	29 2b       	or	r18, r25
     16c:	20 83       	st	Z, r18

	// Set the MOb's CAN id to the id to be listened for
	CANIDT4 = 0;
     16e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
	CANIDT3 = 0;
     172:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
	CANIDT2 = id << 5;
     176:	9c 2f       	mov	r25, r28
     178:	92 95       	swap	r25
     17a:	99 0f       	add	r25, r25
     17c:	90 7e       	andi	r25, 0xE0	; 224
     17e:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
	CANIDT1 = id >> 3;
     182:	d6 95       	lsr	r29
     184:	c7 95       	ror	r28
     186:	d6 95       	lsr	r29
     188:	c7 95       	ror	r28
     18a:	d6 95       	lsr	r29
     18c:	c7 95       	ror	r28
     18e:	c0 93 f3 00 	sts	0x00F3, r28	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>

	if( expectedLength > 8 )
     192:	19 30       	cpi	r17, 0x09	; 9
     194:	08 f0       	brcs	.+2      	; 0x198 <listenForMessage+0x5a>
	{
		expectedLength = 8;
     196:	18 e0       	ldi	r17, 0x08	; 8
	}

	// Set the MOb's expected length
	CANCDMOB |= expectedLength;
     198:	ef ee       	ldi	r30, 0xEF	; 239
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	60 81       	ld	r22, Z
     19e:	61 2b       	or	r22, r17
     1a0:	60 83       	st	Z, r22

	// Enable interrupts for this MOb
	if( mobIndex < 8 )
     1a2:	88 30       	cpi	r24, 0x08	; 8
     1a4:	78 f4       	brcc	.+30     	; 0x1c4 <listenForMessage+0x86>
	{
		CANIE2 |= (1 << mobIndex);
     1a6:	ee ed       	ldi	r30, 0xDE	; 222
     1a8:	f0 e0       	ldi	r31, 0x00	; 0
     1aa:	40 81       	ld	r20, Z
     1ac:	21 e0       	ldi	r18, 0x01	; 1
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	b9 01       	movw	r22, r18
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <listenForMessage+0x7a>
     1b4:	66 0f       	add	r22, r22
     1b6:	77 1f       	adc	r23, r23
     1b8:	8a 95       	dec	r24
     1ba:	e2 f7       	brpl	.-8      	; 0x1b4 <listenForMessage+0x76>
     1bc:	cb 01       	movw	r24, r22
     1be:	84 2b       	or	r24, r20
     1c0:	80 83       	st	Z, r24
     1c2:	0e c0       	rjmp	.+28     	; 0x1e0 <listenForMessage+0xa2>
	}
	else
	{
		CANIE1 |= (1 << (mobIndex-8));
     1c4:	ef ed       	ldi	r30, 0xDF	; 223
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	20 81       	ld	r18, Z
     1ca:	48 50       	subi	r20, 0x08	; 8
     1cc:	51 09       	sbc	r21, r1
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <listenForMessage+0x9a>
     1d4:	88 0f       	add	r24, r24
     1d6:	99 1f       	adc	r25, r25
     1d8:	4a 95       	dec	r20
     1da:	e2 f7       	brpl	.-8      	; 0x1d4 <listenForMessage+0x96>
     1dc:	82 2b       	or	r24, r18
     1de:	80 83       	st	Z, r24
	}

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);
     1e0:	ef ee       	ldi	r30, 0xEF	; 239
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	80 68       	ori	r24, 0x80	; 128
     1e8:	80 83       	st	Z, r24

	return 1;
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <listenForMessage+0xb2>
	uint8_t mobIndex = getFreeMob();

	if( mobIndex == 0xFF )
	{
		// No free Message Objects
		return 0;
     1ee:	80 e0       	ldi	r24, 0x00	; 0

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);

	return 1;
}
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	1f 91       	pop	r17
     1f6:	08 95       	ret

000001f8 <getMessage>:
 * @param[out] message - message data to fill
 * @return 1 if message was filled, 0 otherwise
 *
 */
uint8_t getMessage( CANMessage * message )
{
     1f8:	dc 01       	movw	r26, r24
	// Default to no message available
	uint8_t messageAvailable = 0;

	if( serviceIndex != bufIndex )
     1fa:	e0 91 be 01 	lds	r30, 0x01BE	; 0x8001be <serviceIndex>
     1fe:	80 91 bd 01 	lds	r24, 0x01BD	; 0x8001bd <bufIndex>
     202:	e8 17       	cp	r30, r24
     204:	09 f4       	brne	.+2      	; 0x208 <getMessage+0x10>
     206:	41 c0       	rjmp	.+130    	; 0x28a <getMessage+0x92>
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
     208:	2b e0       	ldi	r18, 0x0B	; 11
     20a:	2e 9f       	mul	r18, r30
     20c:	f0 01       	movw	r30, r0
     20e:	11 24       	eor	r1, r1
     210:	e1 53       	subi	r30, 0x31	; 49
     212:	fc 4f       	sbci	r31, 0xFC	; 252
     214:	30 81       	ld	r19, Z
     216:	81 81       	ldd	r24, Z+1	; 0x01
     218:	98 2f       	mov	r25, r24
     21a:	97 70       	andi	r25, 0x07	; 7
     21c:	3c 93       	st	X, r19
     21e:	11 96       	adiw	r26, 0x01	; 1
     220:	8c 91       	ld	r24, X
     222:	11 97       	sbiw	r26, 0x01	; 1
     224:	88 7f       	andi	r24, 0xF8	; 248
     226:	89 2b       	or	r24, r25
     228:	11 96       	adiw	r26, 0x01	; 1
     22a:	8c 93       	st	X, r24
     22c:	11 97       	sbiw	r26, 0x01	; 1
		message->length = messageBuffer[ serviceIndex ].length;
     22e:	60 91 be 01 	lds	r22, 0x01BE	; 0x8001be <serviceIndex>
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	26 9f       	mul	r18, r22
     236:	f0 01       	movw	r30, r0
     238:	27 9f       	mul	r18, r23
     23a:	f0 0d       	add	r31, r0
     23c:	11 24       	eor	r1, r1
     23e:	e1 53       	subi	r30, 0x31	; 49
     240:	fc 4f       	sbci	r31, 0xFC	; 252
     242:	82 85       	ldd	r24, Z+10	; 0x0a
     244:	1a 96       	adiw	r26, 0x0a	; 10
     246:	8c 93       	st	X, r24
     248:	1a 97       	sbiw	r26, 0x0a	; 10

		for( uint8_t i = 0; i < message->length; ++i )
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	12 c0       	rjmp	.+36     	; 0x272 <getMessage+0x7a>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
     24e:	29 2f       	mov	r18, r25
     250:	30 e0       	ldi	r19, 0x00	; 0
     252:	4b e0       	ldi	r20, 0x0B	; 11
     254:	46 9f       	mul	r20, r22
     256:	f0 01       	movw	r30, r0
     258:	47 9f       	mul	r20, r23
     25a:	f0 0d       	add	r31, r0
     25c:	11 24       	eor	r1, r1
     25e:	e1 53       	subi	r30, 0x31	; 49
     260:	fc 4f       	sbci	r31, 0xFC	; 252
     262:	e2 0f       	add	r30, r18
     264:	f3 1f       	adc	r31, r19
     266:	42 81       	ldd	r20, Z+2	; 0x02
     268:	fd 01       	movw	r30, r26
     26a:	e2 0f       	add	r30, r18
     26c:	f3 1f       	adc	r31, r19
     26e:	42 83       	std	Z+2, r20	; 0x02
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
		message->length = messageBuffer[ serviceIndex ].length;

		for( uint8_t i = 0; i < message->length; ++i )
     270:	9f 5f       	subi	r25, 0xFF	; 255
     272:	98 17       	cp	r25, r24
     274:	60 f3       	brcs	.-40     	; 0x24e <getMessage+0x56>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
		}

		// Increment the index pointing to the next message to be serviced
		serviceIndex = (serviceIndex + 1) % MESSAGE_BUFFER_LENGTH;
     276:	cb 01       	movw	r24, r22
     278:	01 96       	adiw	r24, 0x01	; 1
     27a:	64 e1       	ldi	r22, 0x14	; 20
     27c:	70 e0       	ldi	r23, 0x00	; 0
     27e:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <__divmodhi4>
     282:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <serviceIndex>

		messageAvailable = 1;
     286:	81 e0       	ldi	r24, 0x01	; 1
     288:	08 95       	ret
 *
 */
uint8_t getMessage( CANMessage * message )
{
	// Default to no message available
	uint8_t messageAvailable = 0;
     28a:	80 e0       	ldi	r24, 0x00	; 0

		messageAvailable = 1;
	}

	return messageAvailable;
}
     28c:	08 95       	ret

0000028e <__vector_18>:
 * Note that the NO_BLOCK attribute is not applied here, so while this is running,
 * all interrupts are blocked.
 *
 */
ISR( CANIT_vect )
{
     28e:	1f 92       	push	r1
     290:	0f 92       	push	r0
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	0f 92       	push	r0
     296:	11 24       	eor	r1, r1
     298:	2f 93       	push	r18
     29a:	3f 93       	push	r19
     29c:	4f 93       	push	r20
     29e:	5f 93       	push	r21
     2a0:	6f 93       	push	r22
     2a2:	7f 93       	push	r23
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	cf 93       	push	r28
     2ae:	ef 93       	push	r30
     2b0:	ff 93       	push	r31
	// **Save off CANPAGE to prevent application code bugs**
	uint8_t canPage = CANPAGE;
     2b2:	c0 91 ed 00 	lds	r28, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     2b6:	87 c0       	rjmp	.+270    	; 0x3c6 <__vector_18+0x138>
	{
		// Point to the Message Object that needs to be serviced
		CANPAGE = CANHPMOB & 0xF0;
     2b8:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     2bc:	80 7f       	andi	r24, 0xF0	; 240
     2be:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

		// Service the correct kind of interrupt
		// Transmit Interrupts
		if( CANSTMOB & (1 << TXOK) )
     2c2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2c6:	86 ff       	sbrs	r24, 6
     2c8:	0c c0       	rjmp	.+24     	; 0x2e2 <__vector_18+0x54>
		{
			// Acknowledge the interrupt
			CANSTMOB = 0;
     2ca:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			// Free up the MOb
			CANCDMOB = 0;
     2ce:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>

			// Determine the MOb index
			uint8_t mob = (CANPAGE & 0xF0) >> 8;
     2d2:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

			// Disable interrupts for this MOb
			if( mob < 8 )
			{
				CANIE2 &= ~(1 << mob);
     2d6:	ee ed       	ldi	r30, 0xDE	; 222
     2d8:	f0 e0       	ldi	r31, 0x00	; 0
     2da:	80 81       	ld	r24, Z
     2dc:	8e 7f       	andi	r24, 0xFE	; 254
     2de:	80 83       	st	Z, r24
     2e0:	72 c0       	rjmp	.+228    	; 0x3c6 <__vector_18+0x138>
			{
				CANIE1 &= ~(1 << (mob-8));
			}
		}
		// Receive Interrupts
		else if ( CANSTMOB & (1 << RXOK) )
     2e2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2e6:	85 ff       	sbrs	r24, 5
     2e8:	62 c0       	rjmp	.+196    	; 0x3ae <__vector_18+0x120>
		{
			// Default to impossible ID
			uint16_t id = 0xFFFF;

			// Load the message data into a free message buffer object
			if( CANCDMOB & (1 << IDE) )
     2ea:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     2ee:	84 ff       	sbrs	r24, 4
     2f0:	0e c0       	rjmp	.+28     	; 0x30e <__vector_18+0x80>
			{
				// Message type is CAN 2.0B
				id = (CANIDT4 >> 3) | ((CANIDT3 & 0x7F) << 5); 
     2f2:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     2f6:	86 95       	lsr	r24
     2f8:	86 95       	lsr	r24
     2fa:	86 95       	lsr	r24
     2fc:	40 91 f1 00 	lds	r20, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     300:	4f 77       	andi	r20, 0x7F	; 127
     302:	90 e2       	ldi	r25, 0x20	; 32
     304:	49 9f       	mul	r20, r25
     306:	a0 01       	movw	r20, r0
     308:	11 24       	eor	r1, r1
     30a:	48 2b       	or	r20, r24
     30c:	0f c0       	rjmp	.+30     	; 0x32c <__vector_18+0x9e>
			}
			else
			{
				// Message type is CAN 2.0A
				id = (CANIDT2 >> 5) | (((uint16_t)CANIDT1 << 3));
     30e:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     312:	82 95       	swap	r24
     314:	86 95       	lsr	r24
     316:	87 70       	andi	r24, 0x07	; 7
     318:	40 91 f3 00 	lds	r20, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     31c:	50 e0       	ldi	r21, 0x00	; 0
     31e:	44 0f       	add	r20, r20
     320:	55 1f       	adc	r21, r21
     322:	44 0f       	add	r20, r20
     324:	55 1f       	adc	r21, r21
     326:	44 0f       	add	r20, r20
     328:	55 1f       	adc	r21, r21
     32a:	48 2b       	or	r20, r24
			}

			messageBuffer[bufIndex].id = id;
     32c:	20 91 bd 01 	lds	r18, 0x01BD	; 0x8001bd <bufIndex>
     330:	30 e0       	ldi	r19, 0x00	; 0
     332:	8b e0       	ldi	r24, 0x0B	; 11
     334:	82 9f       	mul	r24, r18
     336:	f0 01       	movw	r30, r0
     338:	83 9f       	mul	r24, r19
     33a:	f0 0d       	add	r31, r0
     33c:	11 24       	eor	r1, r1
     33e:	e1 53       	subi	r30, 0x31	; 49
     340:	fc 4f       	sbci	r31, 0xFC	; 252
     342:	40 83       	st	Z, r20
     344:	95 2f       	mov	r25, r21
     346:	97 70       	andi	r25, 0x07	; 7
     348:	81 81       	ldd	r24, Z+1	; 0x01
     34a:	88 7f       	andi	r24, 0xF8	; 248
     34c:	89 2b       	or	r24, r25
     34e:	81 83       	std	Z+1, r24	; 0x01

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;
     350:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     354:	8f 70       	andi	r24, 0x0F	; 15
     356:	82 87       	std	Z+10, r24	; 0x0a

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	0e c0       	rjmp	.+28     	; 0x378 <__vector_18+0xea>
			{
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
     35c:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7f80fa>
     360:	4b e0       	ldi	r20, 0x0B	; 11
     362:	42 9f       	mul	r20, r18
     364:	f0 01       	movw	r30, r0
     366:	43 9f       	mul	r20, r19
     368:	f0 0d       	add	r31, r0
     36a:	11 24       	eor	r1, r1
     36c:	e1 53       	subi	r30, 0x31	; 49
     36e:	fc 4f       	sbci	r31, 0xFC	; 252
     370:	e9 0f       	add	r30, r25
     372:	f1 1d       	adc	r31, r1
     374:	82 83       	std	Z+2, r24	; 0x02
			messageBuffer[bufIndex].id = id;

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     376:	9f 5f       	subi	r25, 0xFF	; 255
     378:	8b e0       	ldi	r24, 0x0B	; 11
     37a:	82 9f       	mul	r24, r18
     37c:	f0 01       	movw	r30, r0
     37e:	83 9f       	mul	r24, r19
     380:	f0 0d       	add	r31, r0
     382:	11 24       	eor	r1, r1
     384:	e1 53       	subi	r30, 0x31	; 49
     386:	fc 4f       	sbci	r31, 0xFC	; 252
     388:	82 85       	ldd	r24, Z+10	; 0x0a
     38a:	98 17       	cp	r25, r24
     38c:	38 f3       	brcs	.-50     	; 0x35c <__vector_18+0xce>
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
			}

			bufIndex = (bufIndex + 1) % MESSAGE_BUFFER_LENGTH;
     38e:	c9 01       	movw	r24, r18
     390:	01 96       	adiw	r24, 0x01	; 1
     392:	64 e1       	ldi	r22, 0x14	; 20
     394:	70 e0       	ldi	r23, 0x00	; 0
     396:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <__divmodhi4>
     39a:	80 93 bd 01 	sts	0x01BD, r24	; 0x8001bd <bufIndex>

			// Acknowledge the interrupt
			CANSTMOB = 0;
     39e:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			CANCDMOB |= (2 << CONMOB0);
     3a2:	ef ee       	ldi	r30, 0xEF	; 239
     3a4:	f0 e0       	ldi	r31, 0x00	; 0
     3a6:	80 81       	ld	r24, Z
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 83       	st	Z, r24
     3ac:	0c c0       	rjmp	.+24     	; 0x3c6 <__vector_18+0x138>
			
		}
		else if ( CANGIT & ~(1 << CANIT) )
     3ae:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	89 2b       	or	r24, r25
     3b8:	31 f0       	breq	.+12     	; 0x3c6 <__vector_18+0x138>
		{
			// Preserve the last error received
			lastError = CANGIT;
     3ba:	ea ed       	ldi	r30, 0xDA	; 218
     3bc:	f0 e0       	ldi	r31, 0x00	; 0
     3be:	80 81       	ld	r24, Z
     3c0:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <__data_end>

			// Clear the error
			CANGIT = 0;
     3c4:	10 82       	st	Z, r1
	uint8_t canPage = CANPAGE;

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     3c6:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     3ca:	82 95       	swap	r24
     3cc:	8f 70       	andi	r24, 0x0F	; 15
     3ce:	8f 30       	cpi	r24, 0x0F	; 15
     3d0:	09 f0       	breq	.+2      	; 0x3d4 <__vector_18+0x146>
     3d2:	72 cf       	rjmp	.-284    	; 0x2b8 <__vector_18+0x2a>
			CANGIT = 0;
		}
	}

	// Restore CANPAGE register to where application code had it before interrupt
	CANPAGE = canPage;
     3d4:	c0 93 ed 00 	sts	0x00ED, r28	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     3d8:	ff 91       	pop	r31
     3da:	ef 91       	pop	r30
     3dc:	cf 91       	pop	r28
     3de:	bf 91       	pop	r27
     3e0:	af 91       	pop	r26
     3e2:	9f 91       	pop	r25
     3e4:	8f 91       	pop	r24
     3e6:	7f 91       	pop	r23
     3e8:	6f 91       	pop	r22
     3ea:	5f 91       	pop	r21
     3ec:	4f 91       	pop	r20
     3ee:	3f 91       	pop	r19
     3f0:	2f 91       	pop	r18
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0
     3f8:	1f 90       	pop	r1
     3fa:	18 95       	reti

000003fc <init_spi>:
//

static void init_spi(void)
{
	/* Set MOSI and SCK output, all others input */
	DDR_SPI |= ((1 << MOSI) | (1 << SCK) | (1 << CS));
     3fc:	84 b1       	in	r24, 0x04	; 4
     3fe:	87 60       	ori	r24, 0x07	; 7
     400:	84 b9       	out	0x04, r24	; 4
	
	// enable pull up resistor in MISO
	PORTB |= (1 << MISO);
     402:	85 b1       	in	r24, 0x05	; 5
     404:	88 60       	ori	r24, 0x08	; 8
     406:	85 b9       	out	0x05, r24	; 5
	
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPR0));
     408:	8c b5       	in	r24, 0x2c	; 44
     40a:	81 65       	ori	r24, 0x51	; 81
     40c:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<CS); 				//hoog maken CS	
     40e:	85 b1       	in	r24, 0x05	; 5
     410:	81 60       	ori	r24, 0x01	; 1
     412:	85 b9       	out	0x05, r24	; 5
     414:	08 95       	ret

00000416 <xmit_spi>:
}

static BYTE xmit_spi(BYTE data)
{
	PORTB &= ~(1<<CS); //laag maken
     416:	95 b1       	in	r25, 0x05	; 5
     418:	9e 7f       	andi	r25, 0xFE	; 254
     41a:	95 b9       	out	0x05, r25	; 5
	/* Start transmission */
	SPDR = data;
     41c:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     41e:	0d b4       	in	r0, 0x2d	; 45
     420:	07 fe       	sbrs	r0, 7
     422:	fd cf       	rjmp	.-6      	; 0x41e <xmit_spi+0x8>
	PORTB |= (1<<CS);		//hoog maken CS
     424:	85 b1       	in	r24, 0x05	; 5
     426:	81 60       	ori	r24, 0x01	; 1
     428:	85 b9       	out	0x05, r24	; 5
	
	return SPDR; 
     42a:	8e b5       	in	r24, 0x2e	; 46
}
     42c:	08 95       	ret

0000042e <rcv_spi>:

static BYTE rcv_spi(void)
{
	return xmit_spi(0xFF);
     42e:	8f ef       	ldi	r24, 0xFF	; 255
     430:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
}
     434:	08 95       	ret

00000436 <send_cmd>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static BYTE send_cmd(BYTE  cmd, /* 1st byte (Start + Index) */
                     DWORD arg ) /* Argument (32 bits) */
{
     436:	ff 92       	push	r15
     438:	0f 93       	push	r16
     43a:	1f 93       	push	r17
     43c:	cf 93       	push	r28
     43e:	df 93       	push	r29
     440:	c8 2f       	mov	r28, r24
     442:	d4 2f       	mov	r29, r20
     444:	15 2f       	mov	r17, r21
     446:	06 2f       	mov	r16, r22
     448:	f7 2e       	mov	r15, r23
	BYTE n, res;

	if (cmd & 0x80) { /* ACMD<n> is the command sequence of CMD55-CMD<n> */
     44a:	88 23       	and	r24, r24
     44c:	4c f4       	brge	.+18     	; 0x460 <send_cmd+0x2a>
		cmd &= 0x7F;
     44e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	50 e0       	ldi	r21, 0x00	; 0
     454:	ba 01       	movw	r22, r20
     456:	87 e7       	ldi	r24, 0x77	; 119
     458:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
		if (res > 1)
     45c:	82 30       	cpi	r24, 0x02	; 2
     45e:	50 f5       	brcc	.+84     	; 0x4b4 <send_cmd+0x7e>
			return res;
	}

	/* Select the card */
	DESELECT();
     460:	85 b1       	in	r24, 0x05	; 5
     462:	81 60       	ori	r24, 0x01	; 1
     464:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     466:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	SELECT();
     46a:	85 b1       	in	r24, 0x05	; 5
     46c:	8e 7f       	andi	r24, 0xFE	; 254
     46e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     470:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	/* Send a command packet */
	xmit_spi(cmd);               /* Start + Command index */
     474:	8c 2f       	mov	r24, r28
     476:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
     47a:	8f 2d       	mov	r24, r15
     47c:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
     480:	80 2f       	mov	r24, r16
     482:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
     486:	81 2f       	mov	r24, r17
     488:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
     48c:	8d 2f       	mov	r24, r29
     48e:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	n = 0x01;                    /* Dummy CRC + Stop */
	if (cmd == CMD0)
     492:	c0 34       	cpi	r28, 0x40	; 64
     494:	11 f0       	breq	.+4      	; 0x49a <send_cmd+0x64>
	xmit_spi(cmd);               /* Start + Command index */
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
	n = 0x01;                    /* Dummy CRC + Stop */
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	01 c0       	rjmp	.+2      	; 0x49c <send_cmd+0x66>
	if (cmd == CMD0)
		n = 0x95; /* Valid CRC for CMD0(0) */
     49a:	85 e9       	ldi	r24, 0x95	; 149
	if (cmd == CMD8)
     49c:	c8 34       	cpi	r28, 0x48	; 72
     49e:	09 f4       	brne	.+2      	; 0x4a2 <send_cmd+0x6c>
		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
     4a0:	87 e8       	ldi	r24, 0x87	; 135
	xmit_spi(n);
     4a2:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>

	/* Receive a command response */
	n = 10; /* Wait for a valid response in timeout of 10 attempts */
     4a6:	ca e0       	ldi	r28, 0x0A	; 10
	do {
		res = rcv_spi();
     4a8:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	} while ((res & 0x80) && --n);
     4ac:	88 23       	and	r24, r24
     4ae:	14 f4       	brge	.+4      	; 0x4b4 <send_cmd+0x7e>
     4b0:	c1 50       	subi	r28, 0x01	; 1
     4b2:	d1 f7       	brne	.-12     	; 0x4a8 <send_cmd+0x72>

	return res; /* Return with the response value */
}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	1f 91       	pop	r17
     4ba:	0f 91       	pop	r16
     4bc:	ff 90       	pop	r15
     4be:	08 95       	ret

000004c0 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(void)
{
     4c0:	ef 92       	push	r14
     4c2:	ff 92       	push	r15
     4c4:	0f 93       	push	r16
     4c6:	1f 93       	push	r17
     4c8:	cf 93       	push	r28
     4ca:	df 93       	push	r29
     4cc:	00 d0       	rcall	.+0      	; 0x4ce <disk_initialize+0xe>
     4ce:	00 d0       	rcall	.+0      	; 0x4d0 <disk_initialize+0x10>
     4d0:	cd b7       	in	r28, 0x3d	; 61
     4d2:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING)
     4d4:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     4d8:	81 11       	cpse	r24, r1
     4da:	84 b1       	in	r24, 0x04	; 4
		disk_writep(0, 0); /* Finalize write process if it is in progress */
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
     4dc:	0e 94 fe 01 	call	0x3fc	; 0x3fc <init_spi>
	DESELECT();
     4e0:	85 b1       	in	r24, 0x05	; 5
     4e2:	81 60       	ori	r24, 0x01	; 1
     4e4:	85 b9       	out	0x05, r24	; 5
	for (n = 10; n; n--)
     4e6:	1a e0       	ldi	r17, 0x0A	; 10
     4e8:	03 c0       	rjmp	.+6      	; 0x4f0 <disk_initialize+0x30>
		rcv_spi(); /* 80 dummy clocks with CS=H */
     4ea:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
     4ee:	11 50       	subi	r17, 0x01	; 1
     4f0:	11 11       	cpse	r17, r1
     4f2:	fb cf       	rjmp	.-10     	; 0x4ea <disk_initialize+0x2a>
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
     4f4:	40 e0       	ldi	r20, 0x00	; 0
     4f6:	50 e0       	ldi	r21, 0x00	; 0
     4f8:	ba 01       	movw	r22, r20
     4fa:	80 e4       	ldi	r24, 0x40	; 64
     4fc:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     500:	81 30       	cpi	r24, 0x01	; 1
     502:	09 f0       	breq	.+2      	; 0x506 <disk_initialize+0x46>
     504:	9b c0       	rjmp	.+310    	; 0x63c <disk_initialize+0x17c>
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
     506:	4a ea       	ldi	r20, 0xAA	; 170
     508:	51 e0       	ldi	r21, 0x01	; 1
     50a:	60 e0       	ldi	r22, 0x00	; 0
     50c:	70 e0       	ldi	r23, 0x00	; 0
     50e:	88 e4       	ldi	r24, 0x48	; 72
     510:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     514:	81 30       	cpi	r24, 0x01	; 1
     516:	09 f0       	breq	.+2      	; 0x51a <disk_initialize+0x5a>
     518:	59 c0       	rjmp	.+178    	; 0x5cc <disk_initialize+0x10c>
     51a:	0d c0       	rjmp	.+26     	; 0x536 <disk_initialize+0x76>
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
     51c:	e0 2e       	mov	r14, r16
     51e:	f1 2c       	mov	r15, r1
     520:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     524:	e1 e0       	ldi	r30, 0x01	; 1
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	ec 0f       	add	r30, r28
     52a:	fd 1f       	adc	r31, r29
     52c:	ee 0d       	add	r30, r14
     52e:	ff 1d       	adc	r31, r15
     530:	80 83       	st	Z, r24
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
     532:	0f 5f       	subi	r16, 0xFF	; 255
     534:	01 c0       	rjmp	.+2      	; 0x538 <disk_initialize+0x78>
     536:	01 2f       	mov	r16, r17
     538:	04 30       	cpi	r16, 0x04	; 4
     53a:	80 f3       	brcs	.-32     	; 0x51c <disk_initialize+0x5c>
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
     53c:	8b 81       	ldd	r24, Y+3	; 0x03
     53e:	81 30       	cpi	r24, 0x01	; 1
     540:	09 f0       	breq	.+2      	; 0x544 <disk_initialize+0x84>
     542:	7e c0       	rjmp	.+252    	; 0x640 <disk_initialize+0x180>
     544:	8c 81       	ldd	r24, Y+4	; 0x04
     546:	8a 3a       	cpi	r24, 0xAA	; 170
     548:	61 f0       	breq	.+24     	; 0x562 <disk_initialize+0xa2>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     54a:	f1 2c       	mov	r15, r1
     54c:	84 c0       	rjmp	.+264    	; 0x656 <disk_initialize+0x196>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     54e:	8f e8       	ldi	r24, 0x8F	; 143
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	01 97       	sbiw	r24, 0x01	; 1
     554:	f1 f7       	brne	.-4      	; 0x552 <disk_initialize+0x92>
     556:	00 c0       	rjmp	.+0      	; 0x558 <disk_initialize+0x98>
     558:	00 00       	nop
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
     55a:	91 e0       	ldi	r25, 0x01	; 1
     55c:	e9 1a       	sub	r14, r25
     55e:	f1 08       	sbc	r15, r1
     560:	06 c0       	rjmp	.+12     	; 0x56e <disk_initialize+0xae>
     562:	0f 2e       	mov	r0, r31
     564:	f0 e1       	ldi	r31, 0x10	; 16
     566:	ef 2e       	mov	r14, r31
     568:	f7 e2       	ldi	r31, 0x27	; 39
     56a:	ff 2e       	mov	r15, r31
     56c:	f0 2d       	mov	r31, r0
     56e:	e1 14       	cp	r14, r1
     570:	f1 04       	cpc	r15, r1
     572:	49 f0       	breq	.+18     	; 0x586 <disk_initialize+0xc6>
     574:	40 e0       	ldi	r20, 0x00	; 0
     576:	50 e0       	ldi	r21, 0x00	; 0
     578:	60 e0       	ldi	r22, 0x00	; 0
     57a:	70 e4       	ldi	r23, 0x40	; 64
     57c:	89 ee       	ldi	r24, 0xE9	; 233
     57e:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     582:	81 11       	cpse	r24, r1
     584:	e4 cf       	rjmp	.-56     	; 0x54e <disk_initialize+0x8e>
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
     586:	ef 28       	or	r14, r15
     588:	09 f4       	brne	.+2      	; 0x58c <disk_initialize+0xcc>
     58a:	5c c0       	rjmp	.+184    	; 0x644 <disk_initialize+0x184>
     58c:	40 e0       	ldi	r20, 0x00	; 0
     58e:	50 e0       	ldi	r21, 0x00	; 0
     590:	ba 01       	movw	r22, r20
     592:	8a e7       	ldi	r24, 0x7A	; 122
     594:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	71 f0       	breq	.+28     	; 0x5b8 <disk_initialize+0xf8>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     59c:	f1 2c       	mov	r15, r1
     59e:	5b c0       	rjmp	.+182    	; 0x656 <disk_initialize+0x196>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
     5a0:	e1 2e       	mov	r14, r17
     5a2:	f1 2c       	mov	r15, r1
     5a4:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     5a8:	e1 e0       	ldi	r30, 0x01	; 1
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	ec 0f       	add	r30, r28
     5ae:	fd 1f       	adc	r31, r29
     5b0:	ee 0d       	add	r30, r14
     5b2:	ff 1d       	adc	r31, r15
     5b4:	80 83       	st	Z, r24
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
     5b6:	1f 5f       	subi	r17, 0xFF	; 255
     5b8:	14 30       	cpi	r17, 0x04	; 4
     5ba:	90 f3       	brcs	.-28     	; 0x5a0 <disk_initialize+0xe0>
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     5bc:	89 81       	ldd	r24, Y+1	; 0x01
     5be:	86 ff       	sbrs	r24, 6
     5c0:	43 c0       	rjmp	.+134    	; 0x648 <disk_initialize+0x188>
     5c2:	0f 2e       	mov	r0, r31
     5c4:	fc e0       	ldi	r31, 0x0C	; 12
     5c6:	ff 2e       	mov	r15, r31
     5c8:	f0 2d       	mov	r31, r0
     5ca:	45 c0       	rjmp	.+138    	; 0x656 <disk_initialize+0x196>
				}
			}
		} else { /* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) {
     5cc:	40 e0       	ldi	r20, 0x00	; 0
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	ba 01       	movw	r22, r20
     5d2:	89 ee       	ldi	r24, 0xE9	; 233
     5d4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     5d8:	82 30       	cpi	r24, 0x02	; 2
     5da:	40 f4       	brcc	.+16     	; 0x5ec <disk_initialize+0x12c>
				ty  = CT_SD1;
     5dc:	68 94       	set
     5de:	ff 24       	eor	r15, r15
     5e0:	f1 f8       	bld	r15, 1
				cmd = ACMD41; /* SDv1 */
     5e2:	0f 2e       	mov	r0, r31
     5e4:	f9 ee       	ldi	r31, 0xE9	; 233
     5e6:	ef 2e       	mov	r14, r31
     5e8:	f0 2d       	mov	r31, r0
     5ea:	06 c0       	rjmp	.+12     	; 0x5f8 <disk_initialize+0x138>
			} else {
				ty  = CT_MMC;
     5ec:	ff 24       	eor	r15, r15
     5ee:	f3 94       	inc	r15
				cmd = CMD1; /* MMCv3 */
     5f0:	0f 2e       	mov	r0, r31
     5f2:	f1 e4       	ldi	r31, 0x41	; 65
     5f4:	ef 2e       	mov	r14, r31
     5f6:	f0 2d       	mov	r31, r0
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
     5f8:	00 e1       	ldi	r16, 0x10	; 16
     5fa:	17 e2       	ldi	r17, 0x27	; 39
     5fc:	08 c0       	rjmp	.+16     	; 0x60e <disk_initialize+0x14e>
     5fe:	8f e8       	ldi	r24, 0x8F	; 143
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	01 97       	sbiw	r24, 0x01	; 1
     604:	f1 f7       	brne	.-4      	; 0x602 <disk_initialize+0x142>
     606:	00 c0       	rjmp	.+0      	; 0x608 <disk_initialize+0x148>
     608:	00 00       	nop
     60a:	01 50       	subi	r16, 0x01	; 1
     60c:	11 09       	sbc	r17, r1
     60e:	01 15       	cp	r16, r1
     610:	11 05       	cpc	r17, r1
     612:	41 f0       	breq	.+16     	; 0x624 <disk_initialize+0x164>
     614:	40 e0       	ldi	r20, 0x00	; 0
     616:	50 e0       	ldi	r21, 0x00	; 0
     618:	ba 01       	movw	r22, r20
     61a:	8e 2d       	mov	r24, r14
     61c:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     620:	81 11       	cpse	r24, r1
     622:	ed cf       	rjmp	.-38     	; 0x5fe <disk_initialize+0x13e>
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
     624:	01 2b       	or	r16, r17
     626:	a1 f0       	breq	.+40     	; 0x650 <disk_initialize+0x190>
     628:	40 e0       	ldi	r20, 0x00	; 0
     62a:	52 e0       	ldi	r21, 0x02	; 2
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 e5       	ldi	r24, 0x50	; 80
     632:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     636:	81 11       	cpse	r24, r1
     638:	0d c0       	rjmp	.+26     	; 0x654 <disk_initialize+0x194>
     63a:	0d c0       	rjmp	.+26     	; 0x656 <disk_initialize+0x196>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     63c:	f1 2c       	mov	r15, r1
     63e:	0b c0       	rjmp	.+22     	; 0x656 <disk_initialize+0x196>
     640:	f1 2c       	mov	r15, r1
     642:	09 c0       	rjmp	.+18     	; 0x656 <disk_initialize+0x196>
     644:	f1 2c       	mov	r15, r1
     646:	07 c0       	rjmp	.+14     	; 0x656 <disk_initialize+0x196>
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     648:	68 94       	set
     64a:	ff 24       	eor	r15, r15
     64c:	f2 f8       	bld	r15, 2
     64e:	03 c0       	rjmp	.+6      	; 0x656 <disk_initialize+0x196>
				cmd = CMD1; /* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
				ty = 0;
     650:	f1 2c       	mov	r15, r1
     652:	01 c0       	rjmp	.+2      	; 0x656 <disk_initialize+0x196>
     654:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     656:	f0 92 c1 01 	sts	0x01C1, r15	; 0x8001c1 <CardType>
	DESELECT();
     65a:	85 b1       	in	r24, 0x05	; 5
     65c:	81 60       	ori	r24, 0x01	; 1
     65e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     660:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return ty ? 0 : STA_NOINIT;
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	f1 10       	cpse	r15, r1
     668:	80 e0       	ldi	r24, 0x00	; 0
}
     66a:	0f 90       	pop	r0
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	0f 90       	pop	r0
     672:	df 91       	pop	r29
     674:	cf 91       	pop	r28
     676:	1f 91       	pop	r17
     678:	0f 91       	pop	r16
     67a:	ff 90       	pop	r15
     67c:	ef 90       	pop	r14
     67e:	08 95       	ret

00000680 <disk_readp>:
DRESULT disk_readp(BYTE *buff,   /* Pointer to the read buffer (NULL:Forward to the stream) */
                   DWORD sector, /* Sector number (LBA) */
                   UINT  offset, /* Byte offset to read from (0..511) */
                   UINT  count   /* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
     680:	af 92       	push	r10
     682:	bf 92       	push	r11
     684:	cf 92       	push	r12
     686:	df 92       	push	r13
     688:	ef 92       	push	r14
     68a:	ff 92       	push	r15
     68c:	0f 93       	push	r16
     68e:	1f 93       	push	r17
     690:	cf 93       	push	r28
     692:	df 93       	push	r29
     694:	6c 01       	movw	r12, r24
     696:	79 01       	movw	r14, r18
	DRESULT res;
	BYTE    rc;
	UINT    bc;

	if (!(CardType & CT_BLOCK))
     698:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     69c:	83 fd       	sbrc	r24, 3
     69e:	09 c0       	rjmp	.+18     	; 0x6b2 <disk_readp+0x32>
		sector *= 512; /* Convert to byte address if needed */
     6a0:	03 2e       	mov	r0, r19
     6a2:	39 e0       	ldi	r19, 0x09	; 9
     6a4:	44 0f       	add	r20, r20
     6a6:	55 1f       	adc	r21, r21
     6a8:	66 1f       	adc	r22, r22
     6aa:	77 1f       	adc	r23, r23
     6ac:	3a 95       	dec	r19
     6ae:	d1 f7       	brne	.-12     	; 0x6a4 <disk_readp+0x24>
     6b0:	30 2d       	mov	r19, r0

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
     6b2:	81 e5       	ldi	r24, 0x51	; 81
     6b4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     6b8:	81 11       	cpse	r24, r1
     6ba:	31 c0       	rjmp	.+98     	; 0x71e <disk_readp+0x9e>

		// bc = 40000;	/* Time counter */
		do { /* Wait for response */
			rc = rcv_spi();
     6bc:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		} while (rc == 0xFF);
     6c0:	8f 3f       	cpi	r24, 0xFF	; 255
     6c2:	e1 f3       	breq	.-8      	; 0x6bc <disk_readp+0x3c>

		if (rc == 0xFE) { /* A data packet arrived */
     6c4:	8e 3f       	cpi	r24, 0xFE	; 254
     6c6:	69 f5       	brne	.+90     	; 0x722 <disk_readp+0xa2>

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */
     6c8:	cc 27       	eor	r28, r28
     6ca:	dd 27       	eor	r29, r29
     6cc:	ce 19       	sub	r28, r14
     6ce:	df 09       	sbc	r29, r15
     6d0:	c0 1b       	sub	r28, r16
     6d2:	d1 0b       	sbc	r29, r17
     6d4:	ce 5f       	subi	r28, 0xFE	; 254
     6d6:	dd 4f       	sbci	r29, 0xFD	; 253

			/* Skip leading bytes */
			while (offset--)
     6d8:	03 c0       	rjmp	.+6      	; 0x6e0 <disk_readp+0x60>
				rcv_spi();
     6da:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		if (rc == 0xFE) { /* A data packet arrived */

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */

			/* Skip leading bytes */
			while (offset--)
     6de:	75 01       	movw	r14, r10
     6e0:	57 01       	movw	r10, r14
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	a8 1a       	sub	r10, r24
     6e6:	b1 08       	sbc	r11, r1
     6e8:	ef 28       	or	r14, r15
     6ea:	b9 f7       	brne	.-18     	; 0x6da <disk_readp+0x5a>
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
     6ec:	c1 14       	cp	r12, r1
     6ee:	d1 04       	cpc	r13, r1
     6f0:	69 f0       	breq	.+26     	; 0x70c <disk_readp+0x8c>
				do {
					*buff++ = rcv_spi();
     6f2:	76 01       	movw	r14, r12
     6f4:	ef ef       	ldi	r30, 0xFF	; 255
     6f6:	ee 1a       	sub	r14, r30
     6f8:	fe 0a       	sbc	r15, r30
     6fa:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     6fe:	f6 01       	movw	r30, r12
     700:	80 83       	st	Z, r24
				} while (--count);
     702:	01 50       	subi	r16, 0x01	; 1
     704:	11 09       	sbc	r17, r1
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
				do {
					*buff++ = rcv_spi();
     706:	67 01       	movw	r12, r14
				} while (--count);
     708:	a1 f7       	brne	.-24     	; 0x6f2 <disk_readp+0x72>
     70a:	03 c0       	rjmp	.+6      	; 0x712 <disk_readp+0x92>
			} else { /* Forward data to the outgoing stream */
				do {
					// FORWARD(rcv_spi());
				} while (--count);
     70c:	01 50       	subi	r16, 0x01	; 1
     70e:	11 09       	sbc	r17, r1
     710:	e9 f7       	brne	.-6      	; 0x70c <disk_readp+0x8c>
			}

			/* Skip trailing bytes and CRC */
			do
				rcv_spi();
     712:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
			while (--bc);
     716:	21 97       	sbiw	r28, 0x01	; 1
     718:	e1 f7       	brne	.-8      	; 0x712 <disk_readp+0x92>

			res = RES_OK;
     71a:	c0 e0       	ldi	r28, 0x00	; 0
     71c:	03 c0       	rjmp	.+6      	; 0x724 <disk_readp+0xa4>
	UINT    bc;

	if (!(CardType & CT_BLOCK))
		sector *= 512; /* Convert to byte address if needed */

	res = RES_ERROR;
     71e:	c1 e0       	ldi	r28, 0x01	; 1
     720:	01 c0       	rjmp	.+2      	; 0x724 <disk_readp+0xa4>
     722:	c1 e0       	ldi	r28, 0x01	; 1

			res = RES_OK;
		}
	}

	DESELECT();
     724:	85 b1       	in	r24, 0x05	; 5
     726:	81 60       	ori	r24, 0x01	; 1
     728:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     72a:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return res;
}
     72e:	8c 2f       	mov	r24, r28
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	df 90       	pop	r13
     73e:	cf 90       	pop	r12
     740:	bf 90       	pop	r11
     742:	af 90       	pop	r10
     744:	08 95       	ret

00000746 <disk_writep>:

#if _USE_WRITE
DRESULT disk_writep(const BYTE *buff, /* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
                    DWORD       sc    /* Number of bytes to send, Sector number (LBA) or zero */
)
{
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	fc 01       	movw	r30, r24
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
     750:	89 2b       	or	r24, r25
     752:	f1 f0       	breq	.+60     	; 0x790 <disk_writep+0x4a>
		bc = sc;
     754:	ea 01       	movw	r28, r20
		while (bc && wc) { /* Send data bytes to the card */
     756:	11 c0       	rjmp	.+34     	; 0x77a <disk_writep+0x34>
			xmit_spi(*buff++);
     758:	8f 01       	movw	r16, r30
     75a:	0f 5f       	subi	r16, 0xFF	; 255
     75c:	1f 4f       	sbci	r17, 0xFF	; 255
     75e:	80 81       	ld	r24, Z
     760:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
			wc--;
     764:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     768:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     76c:	01 97       	sbiw	r24, 0x01	; 1
     76e:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <wc.1882+0x1>
     772:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <wc.1882>
			bc--;
     776:	21 97       	sbiw	r28, 0x01	; 1
	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
     778:	f8 01       	movw	r30, r16

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
     77a:	20 97       	sbiw	r28, 0x00	; 0
     77c:	09 f4       	brne	.+2      	; 0x780 <disk_writep+0x3a>
     77e:	5f c0       	rjmp	.+190    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
     780:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     784:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     788:	89 2b       	or	r24, r25
     78a:	31 f7       	brne	.-52     	; 0x758 <disk_writep+0x12>
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     78c:	c0 e0       	ldi	r28, 0x00	; 0
     78e:	5a c0       	rjmp	.+180    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
	} else {
		if (sc) { /* Initiate sector write process */
     790:	41 15       	cp	r20, r1
     792:	51 05       	cpc	r21, r1
     794:	61 05       	cpc	r22, r1
     796:	71 05       	cpc	r23, r1
     798:	01 f1       	breq	.+64     	; 0x7da <disk_writep+0x94>
			if (!(CardType & CT_BLOCK))
     79a:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <CardType>
     79e:	83 fd       	sbrc	r24, 3
     7a0:	09 c0       	rjmp	.+18     	; 0x7b4 <disk_writep+0x6e>
				sc *= 512;                  /* Convert to byte address if needed */
     7a2:	03 2e       	mov	r0, r19
     7a4:	39 e0       	ldi	r19, 0x09	; 9
     7a6:	44 0f       	add	r20, r20
     7a8:	55 1f       	adc	r21, r21
     7aa:	66 1f       	adc	r22, r22
     7ac:	77 1f       	adc	r23, r23
     7ae:	3a 95       	dec	r19
     7b0:	d1 f7       	brne	.-12     	; 0x7a6 <disk_writep+0x60>
     7b2:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sc) == 0) { /* WRITE_SINGLE_BLOCK */
     7b4:	88 e5       	ldi	r24, 0x58	; 88
     7b6:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     7ba:	81 11       	cpse	r24, r1
     7bc:	42 c0       	rjmp	.+132    	; 0x842 <__DATA_REGION_LENGTH__+0x42>
				xmit_spi(0xFF);
     7be:	8f ef       	ldi	r24, 0xFF	; 255
     7c0:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				xmit_spi(0xFE); /* Data block header */
     7c4:	8e ef       	ldi	r24, 0xFE	; 254
     7c6:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	92 e0       	ldi	r25, 0x02	; 2
     7ce:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <wc.1882+0x1>
     7d2:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <wc.1882>
				res = RES_OK;
     7d6:	c0 e0       	ldi	r28, 0x00	; 0
     7d8:	35 c0       	rjmp	.+106    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
     7da:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <wc.1882>
     7de:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <wc.1882+0x1>
     7e2:	02 96       	adiw	r24, 0x02	; 2
			while (bc--) {
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <disk_writep+0xa8>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
     7e6:	80 e0       	ldi	r24, 0x00	; 0
     7e8:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
				res = RES_OK;
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
			while (bc--) {
     7ec:	ce 01       	movw	r24, r28
     7ee:	ec 01       	movw	r28, r24
     7f0:	21 97       	sbiw	r28, 0x01	; 1
     7f2:	89 2b       	or	r24, r25
     7f4:	c1 f7       	brne	.-16     	; 0x7e6 <disk_writep+0xa0>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
			}
			do {
				res = rcv_spi();
     7f6:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     7fa:	c8 2f       	mov	r28, r24
			} while (res == 0xFF);
     7fc:	8f 3f       	cpi	r24, 0xFF	; 255
     7fe:	d9 f3       	breq	.-10     	; 0x7f6 <disk_writep+0xb0>
			if ((res & 0x1F) == 0x05) { /* Receive data resp and wait for end of write process in timeout of 500ms */
     800:	8f 71       	andi	r24, 0x1F	; 31
     802:	85 30       	cpi	r24, 0x05	; 5
     804:	b1 f4       	brne	.+44     	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     806:	09 c0       	rjmp	.+18     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     808:	8f e8       	ldi	r24, 0x8F	; 143
     80a:	91 e0       	ldi	r25, 0x01	; 1
     80c:	01 97       	sbiw	r24, 0x01	; 1
     80e:	f1 f7       	brne	.-4      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     810:	00 c0       	rjmp	.+0      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
     812:	00 00       	nop
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--) /* Wait for ready */
     814:	01 50       	subi	r16, 0x01	; 1
     816:	11 09       	sbc	r17, r1
     818:	02 c0       	rjmp	.+4      	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     81a:	08 e8       	ldi	r16, 0x88	; 136
     81c:	13 e1       	ldi	r17, 0x13	; 19
     81e:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     822:	8f 3f       	cpi	r24, 0xFF	; 255
     824:	19 f0       	breq	.+6      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     826:	01 15       	cp	r16, r1
     828:	11 05       	cpc	r17, r1
     82a:	71 f7       	brne	.-36     	; 0x808 <__DATA_REGION_LENGTH__+0x8>
					_delay_us(100);
				if (bc)
     82c:	01 2b       	or	r16, r17
     82e:	09 f0       	breq	.+2      	; 0x832 <__DATA_REGION_LENGTH__+0x32>
					res = RES_OK;
     830:	c0 e0       	ldi	r28, 0x00	; 0
			}
			DESELECT();
     832:	85 b1       	in	r24, 0x05	; 5
     834:	81 60       	ori	r24, 0x01	; 1
     836:	85 b9       	out	0x05, r24	; 5
			rcv_spi();
     838:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     83c:	03 c0       	rjmp	.+6      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     83e:	c0 e0       	ldi	r28, 0x00	; 0
     840:	01 c0       	rjmp	.+2      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
{
	DRESULT     res;
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;
     842:	c1 e0       	ldi	r28, 0x01	; 1
			rcv_spi();
		}
	}

	return res;
}
     844:	8c 2f       	mov	r24, r28
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	1f 91       	pop	r17
     84c:	0f 91       	pop	r16
     84e:	08 95       	ret

00000850 <__vector_10>:
void start_log_message(void);
unsigned long find_offset(void);
void writeToCard(void);

ISR(TIMER2_OVF_vect)
{
     850:	1f 92       	push	r1
     852:	0f 92       	push	r0
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	0f 92       	push	r0
     858:	11 24       	eor	r1, r1
     85a:	8f 93       	push	r24
     85c:	9f 93       	push	r25
	overflowCounter++;
     85e:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <overflowCounter>
     862:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <overflowCounter+0x1>
     866:	01 96       	adiw	r24, 0x01	; 1
     868:	90 93 c8 01 	sts	0x01C8, r25	; 0x8001c8 <overflowCounter+0x1>
     86c:	80 93 c7 01 	sts	0x01C7, r24	; 0x8001c7 <overflowCounter>
	TCNT2 = 0x00;
     870:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
}
     874:	9f 91       	pop	r25
     876:	8f 91       	pop	r24
     878:	0f 90       	pop	r0
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	0f 90       	pop	r0
     87e:	1f 90       	pop	r1
     880:	18 95       	reti

00000882 <init_timer>:
	while(1) {}
}

void init_timer(void)
{	
	TCNT2 = 0x00; // start counting at 0
     882:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
	TCCR2A = ((1 << CS22) | (1 << CS21) | (1 << CS20)); // prescaler op 1024
     886:	87 e0       	ldi	r24, 0x07	; 7
     888:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
	TIMSK2 = (1 << TOIE2);
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7f8070>
     892:	08 95       	ret

00000894 <write_sentence>:
}

void write_sentence(char* zin, int length)
{
     894:	dc 01       	movw	r26, r24
	for (int i = 0; i < length; i++)
     896:	40 e0       	ldi	r20, 0x00	; 0
     898:	50 e0       	ldi	r21, 0x00	; 0
     89a:	14 c0       	rjmp	.+40     	; 0x8c4 <write_sentence+0x30>
	{
		write_buffer[bufferAmt++] = zin[i];
     89c:	20 91 c9 01 	lds	r18, 0x01C9	; 0x8001c9 <bufferAmt>
     8a0:	30 91 ca 01 	lds	r19, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     8a4:	f9 01       	movw	r30, r18
     8a6:	31 96       	adiw	r30, 0x01	; 1
     8a8:	f0 93 ca 01 	sts	0x01CA, r31	; 0x8001ca <bufferAmt+0x1>
     8ac:	e0 93 c9 01 	sts	0x01C9, r30	; 0x8001c9 <bufferAmt>
     8b0:	fd 01       	movw	r30, r26
     8b2:	e4 0f       	add	r30, r20
     8b4:	f5 1f       	adc	r31, r21
     8b6:	90 81       	ld	r25, Z
     8b8:	f9 01       	movw	r30, r18
     8ba:	e3 53       	subi	r30, 0x33	; 51
     8bc:	fe 4f       	sbci	r31, 0xFE	; 254
     8be:	90 83       	st	Z, r25
	TIMSK2 = (1 << TOIE2);
}

void write_sentence(char* zin, int length)
{
	for (int i = 0; i < length; i++)
     8c0:	4f 5f       	subi	r20, 0xFF	; 255
     8c2:	5f 4f       	sbci	r21, 0xFF	; 255
     8c4:	46 17       	cp	r20, r22
     8c6:	57 07       	cpc	r21, r23
     8c8:	4c f3       	brlt	.-46     	; 0x89c <write_sentence+0x8>
	{
		write_buffer[bufferAmt++] = zin[i];
	}
}
     8ca:	08 95       	ret

000008cc <fill_buffer>:


void fill_buffer(void)
{
     8cc:	cf 93       	push	r28
     8ce:	df 93       	push	r29
     8d0:	cd b7       	in	r28, 0x3d	; 61
     8d2:	de b7       	in	r29, 0x3e	; 62
     8d4:	2b 97       	sbiw	r28, 0x0b	; 11
     8d6:	0f b6       	in	r0, 0x3f	; 63
     8d8:	f8 94       	cli
     8da:	de bf       	out	0x3e, r29	; 62
     8dc:	0f be       	out	0x3f, r0	; 63
     8de:	cd bf       	out	0x3d, r28	; 61
	// predeclaratie van variabelen omdat dat in de switch(case) niet kan
	int val1 = 0;
	int val2 = 0;
	
	write_buffer[bufferAmt++] = '\n';
     8e0:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     8e4:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     8e8:	9c 01       	movw	r18, r24
     8ea:	2f 5f       	subi	r18, 0xFF	; 255
     8ec:	3f 4f       	sbci	r19, 0xFF	; 255
     8ee:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     8f2:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     8f6:	fc 01       	movw	r30, r24
     8f8:	e3 53       	subi	r30, 0x33	; 51
     8fa:	fe 4f       	sbci	r31, 0xFE	; 254
     8fc:	2a e0       	ldi	r18, 0x0A	; 10
     8fe:	20 83       	st	Z, r18
	
	CANMessage bericht;
	int resultaat = getMessage(&bericht); // returnt 0 als het niet lukt om bericht uit te lezen, anders returnt 1
     900:	ce 01       	movw	r24, r28
     902:	01 96       	adiw	r24, 0x01	; 1
     904:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <getMessage>
	if(resultaat == 0)
     908:	81 11       	cpse	r24, r1
     90a:	07 c0       	rjmp	.+14     	; 0x91a <__stack+0x1b>
	{
		// geen bericht ontvangen > can-bus werkt niet
		char* string = "GEEN DATA ONTVANGEN";
		int length = strlen(string);
		write_sentence(string, length);
     90c:	63 e1       	ldi	r22, 0x13	; 19
     90e:	70 e0       	ldi	r23, 0x00	; 0
     910:	80 e0       	ldi	r24, 0x00	; 0
     912:	91 e0       	ldi	r25, 0x01	; 1
     914:	0e 94 4a 04 	call	0x894	; 0x894 <write_sentence>
     918:	21 c0       	rjmp	.+66     	; 0x95c <__stack+0x5d>
	} else 
	{		
		switch(bericht.id)
     91a:	89 81       	ldd	r24, Y+1	; 0x01
     91c:	2a 81       	ldd	r18, Y+2	; 0x02
     91e:	92 2f       	mov	r25, r18
     920:	97 70       	andi	r25, 0x07	; 7
     922:	40 97       	sbiw	r24, 0x10	; 16
     924:	d9 f4       	brne	.+54     	; 0x95c <__stack+0x5d>
		{
			case CAN_ID_SNELHEIDSMETER:
				val1 = bericht.data[0];
     926:	8b 81       	ldd	r24, Y+3	; 0x03
				val2 = bericht.data[1];
     928:	9c 81       	ldd	r25, Y+4	; 0x04
				sprintf(zin_id, "snelheid: %d.%d", val1, val2);
     92a:	1f 92       	push	r1
     92c:	9f 93       	push	r25
     92e:	1f 92       	push	r1
     930:	8f 93       	push	r24
     932:	84 e1       	ldi	r24, 0x14	; 20
     934:	91 e0       	ldi	r25, 0x01	; 1
     936:	9f 93       	push	r25
     938:	8f 93       	push	r24
     93a:	85 ed       	ldi	r24, 0xD5	; 213
     93c:	94 e0       	ldi	r25, 0x04	; 4
     93e:	9f 93       	push	r25
     940:	8f 93       	push	r24
     942:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <sprintf>
				write_sentence(zin_id, 15);
     946:	6f e0       	ldi	r22, 0x0F	; 15
     948:	70 e0       	ldi	r23, 0x00	; 0
     94a:	85 ed       	ldi	r24, 0xD5	; 213
     94c:	94 e0       	ldi	r25, 0x04	; 4
     94e:	0e 94 4a 04 	call	0x894	; 0x894 <write_sentence>
				break;
     952:	0f b6       	in	r0, 0x3f	; 63
     954:	f8 94       	cli
     956:	de bf       	out	0x3e, r29	; 62
     958:	0f be       	out	0x3f, r0	; 63
     95a:	cd bf       	out	0x3d, r28	; 61
				break;
			// etc
		}		
	}
	
	if(bufferAmt>=(512-30)) // sectorgrootte van 512 bytes - ongeveer 30 bytes (iets meer dan 2 lines)
     95c:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     960:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     964:	82 3e       	cpi	r24, 0xE2	; 226
     966:	91 40       	sbci	r25, 0x01	; 1
     968:	3c f0       	brlt	.+14     	; 0x978 <__stack+0x79>
	{
		bufferAmt = 0;
     96a:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <bufferAmt+0x1>
     96e:	10 92 c9 01 	sts	0x01C9, r1	; 0x8001c9 <bufferAmt>
		startWriting = true; // als dit op true staat gaat de microcontroller in de main>while(logging) in de if-statement en vult vanaf daar de sd-kaart 
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <startWriting>
	}
}
     978:	2b 96       	adiw	r28, 0x0b	; 11
     97a:	0f b6       	in	r0, 0x3f	; 63
     97c:	f8 94       	cli
     97e:	de bf       	out	0x3e, r29	; 62
     980:	0f be       	out	0x3f, r0	; 63
     982:	cd bf       	out	0x3d, r28	; 61
     984:	df 91       	pop	r29
     986:	cf 91       	pop	r28
     988:	08 95       	ret

0000098a <writeToCard>:


void writeToCard(void)
{
	// Set file pointer to beginning of sector 
	pf_lseek(curOffset); // offset van 0 is te vinden in sector 8448 van de sd-kaart
     98a:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <curOffset>
     98e:	70 91 c3 01 	lds	r23, 0x01C3	; 0x8001c3 <curOffset+0x1>
     992:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <curOffset+0x2>
     996:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <curOffset+0x3>
     99a:	0e 94 b2 0c 	call	0x1964	; 0x1964 <pf_lseek>
	// Write buffer 
	pf_write(write_buffer, BUFFER_SIZE, &byte_counter);
     99e:	4b ec       	ldi	r20, 0xCB	; 203
     9a0:	51 e0       	ldi	r21, 0x01	; 1
     9a2:	60 e0       	ldi	r22, 0x00	; 0
     9a4:	72 e0       	ldi	r23, 0x02	; 2
     9a6:	8d ec       	ldi	r24, 0xCD	; 205
     9a8:	91 e0       	ldi	r25, 0x01	; 1
     9aa:	0e 94 a6 0b 	call	0x174c	; 0x174c <pf_write>
	if (byte_counter < BUFFER_SIZE) {
		// End of file 
	}
	// Finalize write 
	pf_write(0, 0, &byte_counter);
     9ae:	4b ec       	ldi	r20, 0xCB	; 203
     9b0:	51 e0       	ldi	r21, 0x01	; 1
     9b2:	60 e0       	ldi	r22, 0x00	; 0
     9b4:	70 e0       	ldi	r23, 0x00	; 0
     9b6:	80 e0       	ldi	r24, 0x00	; 0
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	0e 94 a6 0b 	call	0x174c	; 0x174c <pf_write>
	// Reset file pointer to beginning of sector 1 
	pf_lseek(curOffset);
     9be:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <curOffset>
     9c2:	70 91 c3 01 	lds	r23, 0x01C3	; 0x8001c3 <curOffset+0x1>
     9c6:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <curOffset+0x2>
     9ca:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <curOffset+0x3>
     9ce:	0e 94 b2 0c 	call	0x1964	; 0x1964 <pf_lseek>
     9d2:	08 95       	ret

000009d4 <find_offset>:
	}
	*/
}

unsigned long find_offset(void)
{
     9d4:	cf 92       	push	r12
     9d6:	df 92       	push	r13
     9d8:	ef 92       	push	r14
     9da:	ff 92       	push	r15
     9dc:	cf 93       	push	r28
     9de:	df 93       	push	r29
     9e0:	00 d0       	rcall	.+0      	; 0x9e2 <find_offset+0xe>
     9e2:	1f 92       	push	r1
     9e4:	cd b7       	in	r28, 0x3d	; 61
     9e6:	de b7       	in	r29, 0x3e	; 62
	// begin bij sector 0. kijk naar waarde 1e char. als die erop wijst dat de sector al geschreven is, ga naar sector 1. ga zo door. return offset als sector leeg lijkt te zijn
	uint8_t read_first[1]  = {};
     9e8:	19 82       	std	Y+1, r1	; 0x01
	UINT bytecounter = 1;
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	9b 83       	std	Y+3, r25	; 0x03
     9f0:	8a 83       	std	Y+2, r24	; 0x02
	unsigned long tempOffset = 0;
     9f2:	c1 2c       	mov	r12, r1
     9f4:	d1 2c       	mov	r13, r1
     9f6:	76 01       	movw	r14, r12
	unsigned long maxOffset = 51200; // als hij geen lege sector kan vinden na de 1e 100 sectoren
	while(1)
	{
		pf_lseek(tempOffset);
     9f8:	c7 01       	movw	r24, r14
     9fa:	b6 01       	movw	r22, r12
     9fc:	0e 94 b2 0c 	call	0x1964	; 0x1964 <pf_lseek>
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
     a00:	ae 01       	movw	r20, r28
     a02:	4e 5f       	subi	r20, 0xFE	; 254
     a04:	5f 4f       	sbci	r21, 0xFF	; 255
     a06:	61 e0       	ldi	r22, 0x01	; 1
     a08:	70 e0       	ldi	r23, 0x00	; 0
     a0a:	ce 01       	movw	r24, r28
     a0c:	01 96       	adiw	r24, 0x01	; 1
     a0e:	0e 94 c3 0a 	call	0x1586	; 0x1586 <pf_read>
		if(read_first[0] == 32)
     a12:	89 81       	ldd	r24, Y+1	; 0x01
     a14:	80 32       	cpi	r24, 0x20	; 32
     a16:	79 f0       	breq	.+30     	; 0xa36 <find_offset+0x62>
		{
			return tempOffset;
		} else {
			tempOffset += 512;
     a18:	82 e0       	ldi	r24, 0x02	; 2
     a1a:	d8 0e       	add	r13, r24
     a1c:	e1 1c       	adc	r14, r1
     a1e:	f1 1c       	adc	r15, r1
			if(tempOffset >= maxOffset)
     a20:	c1 14       	cp	r12, r1
     a22:	88 ec       	ldi	r24, 0xC8	; 200
     a24:	d8 06       	cpc	r13, r24
     a26:	e1 04       	cpc	r14, r1
     a28:	f1 04       	cpc	r15, r1
     a2a:	30 f3       	brcs	.-52     	; 0x9f8 <find_offset+0x24>
			break;
		}
	}
	return 0;
     a2c:	60 e0       	ldi	r22, 0x00	; 0
     a2e:	70 e0       	ldi	r23, 0x00	; 0
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	04 c0       	rjmp	.+8      	; 0xa3e <find_offset+0x6a>
	{
		pf_lseek(tempOffset);
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
		if(read_first[0] == 32)
		{
			return tempOffset;
     a36:	6c 2d       	mov	r22, r12
     a38:	7d 2d       	mov	r23, r13
     a3a:	8e 2d       	mov	r24, r14
     a3c:	9f 2d       	mov	r25, r15
			if(tempOffset >= maxOffset)
			break;
		}
	}
	return 0;
}
     a3e:	0f 90       	pop	r0
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	df 91       	pop	r29
     a46:	cf 91       	pop	r28
     a48:	ff 90       	pop	r15
     a4a:	ef 90       	pop	r14
     a4c:	df 90       	pop	r13
     a4e:	cf 90       	pop	r12
     a50:	08 95       	ret

00000a52 <start_log_message>:

void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
     a52:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     a56:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     a5a:	9c 01       	movw	r18, r24
     a5c:	2f 5f       	subi	r18, 0xFF	; 255
     a5e:	3f 4f       	sbci	r19, 0xFF	; 255
     a60:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     a64:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     a68:	fc 01       	movw	r30, r24
     a6a:	e3 53       	subi	r30, 0x33	; 51
     a6c:	fe 4f       	sbci	r31, 0xFE	; 254
     a6e:	2a e0       	ldi	r18, 0x0A	; 10
     a70:	20 83       	st	Z, r18
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     a72:	20 e0       	ldi	r18, 0x00	; 0
     a74:	30 e0       	ldi	r19, 0x00	; 0
     a76:	15 c0       	rjmp	.+42     	; 0xaa2 <start_log_message+0x50>
	{
		write_buffer[bufferAmt++] = string[i];
     a78:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     a7c:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     a80:	ac 01       	movw	r20, r24
     a82:	4f 5f       	subi	r20, 0xFF	; 255
     a84:	5f 4f       	sbci	r21, 0xFF	; 255
     a86:	50 93 ca 01 	sts	0x01CA, r21	; 0x8001ca <bufferAmt+0x1>
     a8a:	40 93 c9 01 	sts	0x01C9, r20	; 0x8001c9 <bufferAmt>
     a8e:	f9 01       	movw	r30, r18
     a90:	ec 5d       	subi	r30, 0xDC	; 220
     a92:	fe 4f       	sbci	r31, 0xFE	; 254
     a94:	40 81       	ld	r20, Z
     a96:	fc 01       	movw	r30, r24
     a98:	e3 53       	subi	r30, 0x33	; 51
     a9a:	fe 4f       	sbci	r31, 0xFE	; 254
     a9c:	40 83       	st	Z, r20
void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     a9e:	2f 5f       	subi	r18, 0xFF	; 255
     aa0:	3f 4f       	sbci	r19, 0xFF	; 255
     aa2:	2e 30       	cpi	r18, 0x0E	; 14
     aa4:	31 05       	cpc	r19, r1
     aa6:	44 f3       	brlt	.-48     	; 0xa78 <start_log_message+0x26>
	{
		write_buffer[bufferAmt++] = string[i];
	}
	write_buffer[bufferAmt++] = '\n';
     aa8:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <bufferAmt>
     aac:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <bufferAmt+0x1>
     ab0:	9c 01       	movw	r18, r24
     ab2:	2f 5f       	subi	r18, 0xFF	; 255
     ab4:	3f 4f       	sbci	r19, 0xFF	; 255
     ab6:	30 93 ca 01 	sts	0x01CA, r19	; 0x8001ca <bufferAmt+0x1>
     aba:	20 93 c9 01 	sts	0x01C9, r18	; 0x8001c9 <bufferAmt>
     abe:	fc 01       	movw	r30, r24
     ac0:	e3 53       	subi	r30, 0x33	; 51
     ac2:	fe 4f       	sbci	r31, 0xFE	; 254
     ac4:	2a e0       	ldi	r18, 0x0A	; 10
     ac6:	20 83       	st	Z, r18
     ac8:	08 95       	ret

00000aca <init_sd_card>:
	DSTATUS status;
	FRESULT result;
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
     aca:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
		if (status != 0) {
     ace:	81 11       	cpse	r24, r1
     ad0:	07 c0       	rjmp	.+14     	; 0xae0 <init_sd_card+0x16>
			ERROR = 1; 
		} else {
			ERROR = 0;			
			// Set SPI clock faster after initialization 
			SPCR = (1<<MSTR) | (1<<SPE);
     ad2:	80 e5       	ldi	r24, 0x50	; 80
     ad4:	8c bd       	out	0x2c, r24	; 44
			SPSR = (1<<SPI2X); 		
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	8d bd       	out	0x2d, r24	; 45
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
		} else {
			ERROR = 0;			
     ada:	80 e0       	ldi	r24, 0x00	; 0
     adc:	90 e0       	ldi	r25, 0x00	; 0
     ade:	02 c0       	rjmp	.+4      	; 0xae4 <init_sd_card+0x1a>
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	90 e0       	ldi	r25, 0x00	; 0
			//SPR1 en 0 op 0 SPI clock set to fck/4 (blaz. 174)
			//MSTR, in mastermode zetten
			//SPE, SPI enable maken.
			//SPI2X, het verdubbelen van de snelheid.			
		}
	} while (ERROR == 1);
     ae4:	01 97       	sbiw	r24, 0x01	; 1
     ae6:	89 f3       	breq	.-30     	; 0xaca <init_sd_card>

	// Mount volume 
	result = pf_mount(&file_system);
     ae8:	8b ea       	ldi	r24, 0xAB	; 171
     aea:	94 e0       	ldi	r25, 0x04	; 4
     aec:	0e 94 b4 08 	call	0x1168	; 0x1168 <pf_mount>
	if (result != FR_OK) {} // error

	// Open file 
	result = pf_open("LOG.txt");
     af0:	83 e3       	ldi	r24, 0x33	; 51
     af2:	91 e0       	ldi	r25, 0x01	; 1
     af4:	0e 94 55 0a 	call	0x14aa	; 0x14aa <pf_open>
     af8:	08 95       	ret

00000afa <main>:
}
	
int main(void)
{	
	_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | (1<<CLKPS1)));
	init_sd_card(); // initialize sd-card
     afa:	0e 94 65 05 	call	0xaca	; 0xaca <init_sd_card>
	sei();
     afe:	78 94       	sei
	initCAN(); // init can-bus
     b00:	0e 94 69 00 	call	0xd2	; 0xd2 <initCAN>
	listenForMessage(CAN_ID_SNELHEIDSMETER, 8);
     b04:	68 e0       	ldi	r22, 0x08	; 8
     b06:	80 e1       	ldi	r24, 0x10	; 16
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	0e 94 9f 00 	call	0x13e	; 0x13e <listenForMessage>
	//listenForMessage(CAN_ID_MONITORINGSSYSTEEM, 8);
	// voor elke ID die je uit wilt lezen moet je hier een keer de listenForMessage functie aanroepen
	init_timer();
     b0e:	0e 94 41 04 	call	0x882	; 0x882 <init_timer>
	curOffset = find_offset(); // returnt offset van eerstvolgende lege sector
     b12:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <find_offset>
     b16:	60 93 c2 01 	sts	0x01C2, r22	; 0x8001c2 <curOffset>
     b1a:	70 93 c3 01 	sts	0x01C3, r23	; 0x8001c3 <curOffset+0x1>
     b1e:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <curOffset+0x2>
     b22:	90 93 c5 01 	sts	0x01C5, r25	; 0x8001c5 <curOffset+0x3>
	start_log_message(); // schrijf start log bericht naar de kaart zodat je kan zien wanneer de auto opnieuw aan is gezet
     b26:	0e 94 29 05 	call	0xa52	; 0xa52 <start_log_message>
	while(1)
	{
		if(overflowCounter>=61) // 61 komt van 16.000.000 / 1024 (klokfrequentie / timer2prescaler) =  15625. 15625 / 256 (8 bit timer) = 61
     b2a:	80 91 c7 01 	lds	r24, 0x01C7	; 0x8001c7 <overflowCounter>
     b2e:	90 91 c8 01 	lds	r25, 0x01C8	; 0x8001c8 <overflowCounter+0x1>
     b32:	cd 97       	sbiw	r24, 0x3d	; 61
     b34:	34 f0       	brlt	.+12     	; 0xb42 <main+0x48>
		{
			fill_buffer();
     b36:	0e 94 66 04 	call	0x8cc	; 0x8cc <fill_buffer>
			overflowCounter = 0;
     b3a:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <overflowCounter+0x1>
     b3e:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <overflowCounter>
		}
		
		if(startWriting)
     b42:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <startWriting>
     b46:	88 23       	and	r24, r24
     b48:	81 f3       	breq	.-32     	; 0xb2a <main+0x30>
		{
			PORTC ^= (1 << PC0); // toggle ter indicatie op oscilloscoop
     b4a:	98 b1       	in	r25, 0x08	; 8
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	89 27       	eor	r24, r25
     b50:	88 b9       	out	0x08, r24	; 8
			writeToCard(); // schrijf buffer op kaart
     b52:	0e 94 c5 04 	call	0x98a	; 0x98a <writeToCard>
			curOffset += 512; // zet pointer naar volgende sector
     b56:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <curOffset>
     b5a:	90 91 c3 01 	lds	r25, 0x01C3	; 0x8001c3 <curOffset+0x1>
     b5e:	a0 91 c4 01 	lds	r26, 0x01C4	; 0x8001c4 <curOffset+0x2>
     b62:	b0 91 c5 01 	lds	r27, 0x01C5	; 0x8001c5 <curOffset+0x3>
     b66:	9e 5f       	subi	r25, 0xFE	; 254
     b68:	af 4f       	sbci	r26, 0xFF	; 255
     b6a:	bf 4f       	sbci	r27, 0xFF	; 255
     b6c:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <curOffset>
     b70:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <curOffset+0x1>
     b74:	a0 93 c4 01 	sts	0x01C4, r26	; 0x8001c4 <curOffset+0x2>
     b78:	b0 93 c5 01 	sts	0x01C5, r27	; 0x8001c5 <curOffset+0x3>
			startWriting = false;
     b7c:	10 92 c6 01 	sts	0x01C6, r1	; 0x8001c6 <startWriting>
     b80:	d4 cf       	rjmp	.-88     	; 0xb2a <main+0x30>

00000b82 <mem_set>:

static FATFS *FatFs; /* Pointer to the file system object (logical drive) */

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
     b82:	fc 01       	movw	r30, r24
	char *d = (char *)dst;
	while (cnt--)
     b84:	03 c0       	rjmp	.+6      	; 0xb8c <mem_set+0xa>
		*d++ = (char)val;
     b86:	60 83       	st	Z, r22

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     b88:	ac 01       	movw	r20, r24
		*d++ = (char)val;
     b8a:	31 96       	adiw	r30, 0x01	; 1

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     b8c:	ca 01       	movw	r24, r20
     b8e:	01 97       	sbiw	r24, 0x01	; 1
     b90:	45 2b       	or	r20, r21
     b92:	c9 f7       	brne	.-14     	; 0xb86 <mem_set+0x4>
		*d++ = (char)val;
}
     b94:	08 95       	ret

00000b96 <mem_cmp>:

/* Compare memory to memory */
static int mem_cmp(const void *dst, const void *src, int cnt)
{
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	dc 01       	movw	r26, r24
     b9c:	fb 01       	movw	r30, r22
	const char *d = (const char *)dst, *s = (const char *)src;
	int         r = 0;
     b9e:	80 e0       	ldi	r24, 0x00	; 0
     ba0:	90 e0       	ldi	r25, 0x00	; 0
	while (cnt-- && (r = *d++ - *s++) == 0)
     ba2:	02 c0       	rjmp	.+4      	; 0xba8 <mem_cmp+0x12>
     ba4:	fb 01       	movw	r30, r22
     ba6:	de 01       	movw	r26, r28
     ba8:	9a 01       	movw	r18, r20
     baa:	21 50       	subi	r18, 0x01	; 1
     bac:	31 09       	sbc	r19, r1
     bae:	45 2b       	or	r20, r21
     bb0:	61 f0       	breq	.+24     	; 0xbca <mem_cmp+0x34>
     bb2:	ed 01       	movw	r28, r26
     bb4:	21 96       	adiw	r28, 0x01	; 1
     bb6:	8c 91       	ld	r24, X
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	bf 01       	movw	r22, r30
     bbc:	6f 5f       	subi	r22, 0xFF	; 255
     bbe:	7f 4f       	sbci	r23, 0xFF	; 255
     bc0:	40 81       	ld	r20, Z
     bc2:	84 1b       	sub	r24, r20
     bc4:	91 09       	sbc	r25, r1
     bc6:	a9 01       	movw	r20, r18
     bc8:	69 f3       	breq	.-38     	; 0xba4 <mem_cmp+0xe>
		;
	return r;
}
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	08 95       	ret

00000bd0 <clust2sect>:
/*-----------------------------------------------------------------------*/

static DWORD clust2sect(           /* !=0: Sector number, 0: Failed - invalid cluster# */
                        CLUST clst /* Cluster# to be converted */
)
{
     bd0:	0f 93       	push	r16
     bd2:	1f 93       	push	r17
	FATFS *fs = FatFs;
     bd4:	e0 91 cd 03 	lds	r30, 0x03CD	; 0x8003cd <FatFs>
     bd8:	f0 91 ce 03 	lds	r31, 0x03CE	; 0x8003ce <FatFs+0x1>

	clst -= 2;
     bdc:	9b 01       	movw	r18, r22
     bde:	ac 01       	movw	r20, r24
     be0:	22 50       	subi	r18, 0x02	; 2
     be2:	31 09       	sbc	r19, r1
     be4:	41 09       	sbc	r20, r1
     be6:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2))
     be8:	86 81       	ldd	r24, Z+6	; 0x06
     bea:	97 81       	ldd	r25, Z+7	; 0x07
     bec:	a0 85       	ldd	r26, Z+8	; 0x08
     bee:	b1 85       	ldd	r27, Z+9	; 0x09
     bf0:	02 97       	sbiw	r24, 0x02	; 2
     bf2:	a1 09       	sbc	r26, r1
     bf4:	b1 09       	sbc	r27, r1
     bf6:	28 17       	cp	r18, r24
     bf8:	39 07       	cpc	r19, r25
     bfa:	4a 07       	cpc	r20, r26
     bfc:	5b 07       	cpc	r21, r27
     bfe:	68 f4       	brcc	.+26     	; 0xc1a <clust2sect+0x4a>
		return 0; /* Invalid cluster# */
	return (DWORD)clst * fs->csize + fs->database;
     c00:	a2 81       	ldd	r26, Z+2	; 0x02
     c02:	b0 e0       	ldi	r27, 0x00	; 0
     c04:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <__muluhisi3>
     c08:	02 89       	ldd	r16, Z+18	; 0x12
     c0a:	13 89       	ldd	r17, Z+19	; 0x13
     c0c:	24 89       	ldd	r18, Z+20	; 0x14
     c0e:	35 89       	ldd	r19, Z+21	; 0x15
     c10:	60 0f       	add	r22, r16
     c12:	71 1f       	adc	r23, r17
     c14:	82 1f       	adc	r24, r18
     c16:	93 1f       	adc	r25, r19
     c18:	03 c0       	rjmp	.+6      	; 0xc20 <clust2sect+0x50>
{
	FATFS *fs = FatFs;

	clst -= 2;
	if (clst >= (fs->n_fatent - 2))
		return 0; /* Invalid cluster# */
     c1a:	60 e0       	ldi	r22, 0x00	; 0
     c1c:	70 e0       	ldi	r23, 0x00	; 0
     c1e:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	08 95       	ret

00000c26 <get_clust>:

static CLUST get_clust(BYTE *dir /* Pointer to directory entry */
)
{
     c26:	0f 93       	push	r16
     c28:	1f 93       	push	r17
     c2a:	fc 01       	movw	r30, r24
	FATFS *fs   = FatFs;
	CLUST  clst = 0;

	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
		clst = LD_WORD(dir + DIR_FstClusHI);
     c2c:	65 89       	ldd	r22, Z+21	; 0x15
     c2e:	70 e0       	ldi	r23, 0x00	; 0
     c30:	76 2f       	mov	r23, r22
     c32:	66 27       	eor	r22, r22
     c34:	84 89       	ldd	r24, Z+20	; 0x14
     c36:	68 2b       	or	r22, r24
     c38:	cb 01       	movw	r24, r22
     c3a:	a0 e0       	ldi	r26, 0x00	; 0
     c3c:	b0 e0       	ldi	r27, 0x00	; 0
		clst <<= 16;
     c3e:	bc 01       	movw	r22, r24
     c40:	55 27       	eor	r21, r21
     c42:	44 27       	eor	r20, r20
	}
	clst |= LD_WORD(dir + DIR_FstClusLO);
     c44:	83 8d       	ldd	r24, Z+27	; 0x1b
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	98 2f       	mov	r25, r24
     c4a:	88 27       	eor	r24, r24
     c4c:	22 8d       	ldd	r18, Z+26	; 0x1a
     c4e:	82 2b       	or	r24, r18
     c50:	a0 e0       	ldi	r26, 0x00	; 0
     c52:	b0 e0       	ldi	r27, 0x00	; 0
     c54:	8c 01       	movw	r16, r24
     c56:	9d 01       	movw	r18, r26
     c58:	04 2b       	or	r16, r20
     c5a:	15 2b       	or	r17, r21
     c5c:	26 2b       	or	r18, r22
     c5e:	37 2b       	or	r19, r23
     c60:	c9 01       	movw	r24, r18
     c62:	b8 01       	movw	r22, r16

	return clst;
}
     c64:	1f 91       	pop	r17
     c66:	0f 91       	pop	r16
     c68:	08 95       	ret

00000c6a <dir_rewind>:
/* Directory handling - Rewind directory index                           */
/*-----------------------------------------------------------------------*/

static FRESULT dir_rewind(DIR *dj /* Pointer to directory object */
)
{
     c6a:	0f 93       	push	r16
     c6c:	1f 93       	push	r17
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	fc 01       	movw	r30, r24
	CLUST  clst;
	FATFS *fs = FatFs;
     c74:	a0 91 cd 03 	lds	r26, 0x03CD	; 0x8003cd <FatFs>
     c78:	b0 91 ce 03 	lds	r27, 0x03CE	; 0x8003ce <FatFs+0x1>

	dj->index = 0;
     c7c:	11 82       	std	Z+1, r1	; 0x01
     c7e:	10 82       	st	Z, r1
	clst      = dj->sclust;
     c80:	64 81       	ldd	r22, Z+4	; 0x04
     c82:	75 81       	ldd	r23, Z+5	; 0x05
     c84:	86 81       	ldd	r24, Z+6	; 0x06
     c86:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
     c88:	61 30       	cpi	r22, 0x01	; 1
     c8a:	71 05       	cpc	r23, r1
     c8c:	81 05       	cpc	r24, r1
     c8e:	91 05       	cpc	r25, r1
     c90:	19 f1       	breq	.+70     	; 0xcd8 <dir_rewind+0x6e>
     c92:	16 96       	adiw	r26, 0x06	; 6
     c94:	0d 91       	ld	r16, X+
     c96:	1d 91       	ld	r17, X+
     c98:	2d 91       	ld	r18, X+
     c9a:	3c 91       	ld	r19, X
     c9c:	19 97       	sbiw	r26, 0x09	; 9
     c9e:	60 17       	cp	r22, r16
     ca0:	71 07       	cpc	r23, r17
     ca2:	82 07       	cpc	r24, r18
     ca4:	93 07       	cpc	r25, r19
     ca6:	d0 f4       	brcc	.+52     	; 0xcdc <dir_rewind+0x72>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst
     ca8:	61 15       	cp	r22, r1
     caa:	71 05       	cpc	r23, r1
     cac:	81 05       	cpc	r24, r1
     cae:	91 05       	cpc	r25, r1
     cb0:	31 f4       	brne	.+12     	; 0xcbe <dir_rewind+0x54>
	    && (_FS_32ONLY || fs->fs_type == FS_FAT32)) /* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
     cb2:	1e 96       	adiw	r26, 0x0e	; 14
     cb4:	6d 91       	ld	r22, X+
     cb6:	7d 91       	ld	r23, X+
     cb8:	8d 91       	ld	r24, X+
     cba:	9c 91       	ld	r25, X
     cbc:	51 97       	sbiw	r26, 0x11	; 17
     cbe:	ef 01       	movw	r28, r30
	dj->clust = clst;                                                  /* Current cluster */
     cc0:	60 87       	std	Z+8, r22	; 0x08
     cc2:	71 87       	std	Z+9, r23	; 0x09
     cc4:	82 87       	std	Z+10, r24	; 0x0a
     cc6:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */
     cc8:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <clust2sect>
     ccc:	6c 87       	std	Y+12, r22	; 0x0c
     cce:	7d 87       	std	Y+13, r23	; 0x0d
     cd0:	8e 87       	std	Y+14, r24	; 0x0e
     cd2:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK; /* Seek succeeded */
     cd4:	80 e0       	ldi	r24, 0x00	; 0
     cd6:	03 c0       	rjmp	.+6      	; 0xcde <dir_rewind+0x74>
	FATFS *fs = FatFs;

	dj->index = 0;
	clst      = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
		return FR_DISK_ERR;
     cd8:	81 e0       	ldi	r24, 0x01	; 1
     cda:	01 c0       	rjmp	.+2      	; 0xcde <dir_rewind+0x74>
     cdc:	81 e0       	ldi	r24, 0x01	; 1
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;                                                  /* Current cluster */
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */

	return FR_OK; /* Seek succeeded */
}
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	1f 91       	pop	r17
     ce4:	0f 91       	pop	r16
     ce6:	08 95       	ret

00000ce8 <create_name>:
/*-----------------------------------------------------------------------*/

static FRESULT create_name(DIR *        dj,  /* Pointer to the directory object */
                           const char **path /* Pointer to pointer to the segment in the path string */
)
{
     ce8:	0f 93       	push	r16
     cea:	1f 93       	push	r17
     cec:	cf 93       	push	r28
     cee:	df 93       	push	r29
     cf0:	eb 01       	movw	r28, r22
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
     cf2:	fc 01       	movw	r30, r24
     cf4:	02 81       	ldd	r16, Z+2	; 0x02
     cf6:	13 81       	ldd	r17, Z+3	; 0x03
	mem_set(sfn, ' ', 11);
     cf8:	4b e0       	ldi	r20, 0x0B	; 11
     cfa:	50 e0       	ldi	r21, 0x00	; 0
     cfc:	60 e2       	ldi	r22, 0x20	; 32
     cfe:	70 e0       	ldi	r23, 0x00	; 0
     d00:	c8 01       	movw	r24, r16
     d02:	0e 94 c1 05 	call	0xb82	; 0xb82 <mem_set>
	si = i = 0;
	ni     = 8;
	p      = *path;
     d06:	28 81       	ld	r18, Y
     d08:	39 81       	ldd	r19, Y+1	; 0x01
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0;
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	80 e0       	ldi	r24, 0x00	; 0
	ni     = 8;
     d0e:	58 e0       	ldi	r21, 0x08	; 8
     d10:	01 c0       	rjmp	.+2      	; 0xd14 <create_name+0x2c>
     d12:	84 2f       	mov	r24, r20
	p      = *path;
	for (;;) {
		c = p[si++];
     d14:	41 e0       	ldi	r20, 0x01	; 1
     d16:	48 0f       	add	r20, r24
     d18:	f9 01       	movw	r30, r18
     d1a:	e8 0f       	add	r30, r24
     d1c:	f1 1d       	adc	r31, r1
     d1e:	e0 81       	ld	r30, Z
		if (c <= ' ' || c == '/')
     d20:	e1 32       	cpi	r30, 0x21	; 33
     d22:	f0 f0       	brcs	.+60     	; 0xd60 <create_name+0x78>
     d24:	ef 32       	cpi	r30, 0x2F	; 47
     d26:	e1 f0       	breq	.+56     	; 0xd60 <create_name+0x78>
			break; /* Break on end of segment */
		if (c == '.' || i >= ni) {
     d28:	ee 32       	cpi	r30, 0x2E	; 46
     d2a:	11 f0       	breq	.+4      	; 0xd30 <create_name+0x48>
     d2c:	95 17       	cp	r25, r21
     d2e:	38 f0       	brcs	.+14     	; 0xd3e <create_name+0x56>
			if (ni != 8 || c != '.')
     d30:	58 30       	cpi	r21, 0x08	; 8
     d32:	b1 f4       	brne	.+44     	; 0xd60 <create_name+0x78>
     d34:	ee 32       	cpi	r30, 0x2E	; 46
     d36:	a1 f4       	brne	.+40     	; 0xd60 <create_name+0x78>
				break;
			i  = 8;
     d38:	98 e0       	ldi	r25, 0x08	; 8
			ni = 11;
     d3a:	5b e0       	ldi	r21, 0x0B	; 11
     d3c:	ea cf       	rjmp	.-44     	; 0xd12 <create_name+0x2a>
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80) /* To upper extended char (SBCS) */
     d3e:	ee 23       	and	r30, r30
     d40:	24 f4       	brge	.+8      	; 0xd4a <create_name+0x62>
			c = cvt[c - 0x80];
     d42:	f0 e0       	ldi	r31, 0x00	; 0
     d44:	e5 54       	subi	r30, 0x45	; 69
     d46:	ff 4f       	sbci	r31, 0xFF	; 255
     d48:	e0 81       	ld	r30, Z
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{ /* Single byte code */
			if (_USE_LCC && IsLower(c))
     d4a:	8f e9       	ldi	r24, 0x9F	; 159
     d4c:	8e 0f       	add	r24, r30
     d4e:	8a 31       	cpi	r24, 0x1A	; 26
     d50:	08 f4       	brcc	.+2      	; 0xd54 <create_name+0x6c>
				c -= 0x20; /* toupper */
     d52:	e0 52       	subi	r30, 0x20	; 32
			sfn[i++] = c;
     d54:	d8 01       	movw	r26, r16
     d56:	a9 0f       	add	r26, r25
     d58:	b1 1d       	adc	r27, r1
     d5a:	ec 93       	st	X, r30
     d5c:	9f 5f       	subi	r25, 0xFF	; 255
     d5e:	d9 cf       	rjmp	.-78     	; 0xd12 <create_name+0x2a>
		}
	}
	*path = &p[si]; /* Rerurn pointer to the next segment */
     d60:	24 0f       	add	r18, r20
     d62:	31 1d       	adc	r19, r1
     d64:	39 83       	std	Y+1, r19	; 0x01
     d66:	28 83       	st	Y, r18

	sfn[11] = (c <= ' ') ? 1 : 0; /* Set last segment flag if end of path */
     d68:	81 e0       	ldi	r24, 0x01	; 1
     d6a:	e1 32       	cpi	r30, 0x21	; 33
     d6c:	08 f0       	brcs	.+2      	; 0xd70 <create_name+0x88>
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	f8 01       	movw	r30, r16
     d72:	83 87       	std	Z+11, r24	; 0x0b

	return FR_OK;
}
     d74:	80 e0       	ldi	r24, 0x00	; 0
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	1f 91       	pop	r17
     d7c:	0f 91       	pop	r16
     d7e:	08 95       	ret

00000d80 <check_fs>:

static BYTE check_fs(/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     d80:	cf 92       	push	r12
     d82:	df 92       	push	r13
     d84:	ef 92       	push	r14
     d86:	ff 92       	push	r15
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	ec 01       	movw	r28, r24
     d92:	6a 01       	movw	r12, r20
     d94:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
     d96:	02 e0       	ldi	r16, 0x02	; 2
     d98:	10 e0       	ldi	r17, 0x00	; 0
     d9a:	2e ef       	ldi	r18, 0xFE	; 254
     d9c:	31 e0       	ldi	r19, 0x01	; 1
     d9e:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     da2:	81 11       	cpse	r24, r1
     da4:	1d c0       	rjmp	.+58     	; 0xde0 <check_fs+0x60>
		return 3;
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
     da6:	89 81       	ldd	r24, Y+1	; 0x01
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	98 2f       	mov	r25, r24
     dac:	88 27       	eor	r24, r24
     dae:	28 81       	ld	r18, Y
     db0:	82 2b       	or	r24, r18
     db2:	85 35       	cpi	r24, 0x55	; 85
     db4:	9a 4a       	sbci	r25, 0xAA	; 170
     db6:	b1 f4       	brne	.+44     	; 0xde4 <check_fs+0x64>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
     db8:	22 e5       	ldi	r18, 0x52	; 82
     dba:	30 e0       	ldi	r19, 0x00	; 0
     dbc:	b7 01       	movw	r22, r14
     dbe:	a6 01       	movw	r20, r12
     dc0:	ce 01       	movw	r24, r28
     dc2:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     dc6:	81 11       	cpse	r24, r1
     dc8:	0f c0       	rjmp	.+30     	; 0xde8 <check_fs+0x68>
     dca:	89 81       	ldd	r24, Y+1	; 0x01
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	98 2f       	mov	r25, r24
     dd0:	88 27       	eor	r24, r24
     dd2:	28 81       	ld	r18, Y
     dd4:	82 2b       	or	r24, r18
     dd6:	86 34       	cpi	r24, 0x46	; 70
     dd8:	91 44       	sbci	r25, 0x41	; 65
     dda:	41 f0       	breq	.+16     	; 0xdec <check_fs+0x6c>
		return 0;
	return 1;
     ddc:	81 e0       	ldi	r24, 0x01	; 1
     dde:	07 c0       	rjmp	.+14     	; 0xdee <check_fs+0x6e>
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
		return 3;
     de0:	83 e0       	ldi	r24, 0x03	; 3
     de2:	05 c0       	rjmp	.+10     	; 0xdee <check_fs+0x6e>
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
		return 2;
     de4:	82 e0       	ldi	r24, 0x02	; 2
     de6:	03 c0       	rjmp	.+6      	; 0xdee <check_fs+0x6e>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
	return 1;
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	01 c0       	rjmp	.+2      	; 0xdee <check_fs+0x6e>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
     dec:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	1f 91       	pop	r17
     df4:	0f 91       	pop	r16
     df6:	ff 90       	pop	r15
     df8:	ef 90       	pop	r14
     dfa:	df 90       	pop	r13
     dfc:	cf 90       	pop	r12
     dfe:	08 95       	ret

00000e00 <get_fat>:
/*-----------------------------------------------------------------------*/

static CLUST get_fat(           /* 1:IO error, Else:Cluster status */
                     CLUST clst /* Cluster# to get the link information */
)
{
     e00:	cf 92       	push	r12
     e02:	df 92       	push	r13
     e04:	ef 92       	push	r14
     e06:	ff 92       	push	r15
     e08:	0f 93       	push	r16
     e0a:	1f 93       	push	r17
     e0c:	cf 93       	push	r28
     e0e:	df 93       	push	r29
     e10:	00 d0       	rcall	.+0      	; 0xe12 <get_fat+0x12>
     e12:	00 d0       	rcall	.+0      	; 0xe14 <get_fat+0x14>
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62
	BYTE   buf[4];
	FATFS *fs = FatFs;
     e18:	e0 91 cd 03 	lds	r30, 0x03CD	; 0x8003cd <FatFs>
     e1c:	f0 91 ce 03 	lds	r31, 0x03CE	; 0x8003ce <FatFs+0x1>

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
     e20:	62 30       	cpi	r22, 0x02	; 2
     e22:	71 05       	cpc	r23, r1
     e24:	81 05       	cpc	r24, r1
     e26:	91 05       	cpc	r25, r1
     e28:	08 f4       	brcc	.+2      	; 0xe2c <get_fat+0x2c>
     e2a:	56 c0       	rjmp	.+172    	; 0xed8 <get_fat+0xd8>
     e2c:	06 81       	ldd	r16, Z+6	; 0x06
     e2e:	17 81       	ldd	r17, Z+7	; 0x07
     e30:	20 85       	ldd	r18, Z+8	; 0x08
     e32:	31 85       	ldd	r19, Z+9	; 0x09
     e34:	60 17       	cp	r22, r16
     e36:	71 07       	cpc	r23, r17
     e38:	82 07       	cpc	r24, r18
     e3a:	93 07       	cpc	r25, r19
     e3c:	08 f0       	brcs	.+2      	; 0xe40 <get_fat+0x40>
     e3e:	51 c0       	rjmp	.+162    	; 0xee2 <get_fat+0xe2>
		return 1;

	switch (fs->fs_type) {
     e40:	20 81       	ld	r18, Z
     e42:	23 30       	cpi	r18, 0x03	; 3
     e44:	09 f0       	breq	.+2      	; 0xe48 <get_fat+0x48>
     e46:	52 c0       	rjmp	.+164    	; 0xeec <get_fat+0xec>
     e48:	dc 01       	movw	r26, r24
     e4a:	cb 01       	movw	r24, r22
			break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32:
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4))
     e4c:	9c 01       	movw	r18, r24
     e4e:	2f 77       	andi	r18, 0x7F	; 127
     e50:	33 27       	eor	r19, r19
     e52:	c2 84       	ldd	r12, Z+10	; 0x0a
     e54:	d3 84       	ldd	r13, Z+11	; 0x0b
     e56:	e4 84       	ldd	r14, Z+12	; 0x0c
     e58:	f5 84       	ldd	r15, Z+13	; 0x0d
     e5a:	68 94       	set
     e5c:	16 f8       	bld	r1, 6
     e5e:	b6 95       	lsr	r27
     e60:	a7 95       	ror	r26
     e62:	97 95       	ror	r25
     e64:	87 95       	ror	r24
     e66:	16 94       	lsr	r1
     e68:	d1 f7       	brne	.-12     	; 0xe5e <get_fat+0x5e>
     e6a:	22 0f       	add	r18, r18
     e6c:	33 1f       	adc	r19, r19
     e6e:	22 0f       	add	r18, r18
     e70:	33 1f       	adc	r19, r19
     e72:	b7 01       	movw	r22, r14
     e74:	a6 01       	movw	r20, r12
     e76:	48 0f       	add	r20, r24
     e78:	59 1f       	adc	r21, r25
     e7a:	6a 1f       	adc	r22, r26
     e7c:	7b 1f       	adc	r23, r27
     e7e:	04 e0       	ldi	r16, 0x04	; 4
     e80:	10 e0       	ldi	r17, 0x00	; 0
     e82:	ce 01       	movw	r24, r28
     e84:	01 96       	adiw	r24, 0x01	; 1
     e86:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     e8a:	81 11       	cpse	r24, r1
     e8c:	34 c0       	rjmp	.+104    	; 0xef6 <get_fat+0xf6>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
     e8e:	8c 81       	ldd	r24, Y+4	; 0x04
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	a0 e0       	ldi	r26, 0x00	; 0
     e94:	b0 e0       	ldi	r27, 0x00	; 0
     e96:	78 2f       	mov	r23, r24
     e98:	66 27       	eor	r22, r22
     e9a:	55 27       	eor	r21, r21
     e9c:	44 27       	eor	r20, r20
     e9e:	9b 81       	ldd	r25, Y+3	; 0x03
     ea0:	89 2f       	mov	r24, r25
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	a0 e0       	ldi	r26, 0x00	; 0
     ea6:	b0 e0       	ldi	r27, 0x00	; 0
     ea8:	dc 01       	movw	r26, r24
     eaa:	99 27       	eor	r25, r25
     eac:	88 27       	eor	r24, r24
     eae:	84 2b       	or	r24, r20
     eb0:	95 2b       	or	r25, r21
     eb2:	a6 2b       	or	r26, r22
     eb4:	b7 2b       	or	r27, r23
     eb6:	6a 81       	ldd	r22, Y+2	; 0x02
     eb8:	70 e0       	ldi	r23, 0x00	; 0
     eba:	76 2f       	mov	r23, r22
     ebc:	66 27       	eor	r22, r22
     ebe:	ab 01       	movw	r20, r22
     ec0:	60 e0       	ldi	r22, 0x00	; 0
     ec2:	70 e0       	ldi	r23, 0x00	; 0
     ec4:	84 2b       	or	r24, r20
     ec6:	95 2b       	or	r25, r21
     ec8:	a6 2b       	or	r26, r22
     eca:	b7 2b       	or	r27, r23
     ecc:	29 81       	ldd	r18, Y+1	; 0x01
     ece:	82 2b       	or	r24, r18
     ed0:	bc 01       	movw	r22, r24
     ed2:	cd 01       	movw	r24, r26
     ed4:	9f 70       	andi	r25, 0x0F	; 15
     ed6:	13 c0       	rjmp	.+38     	; 0xefe <get_fat+0xfe>
{
	BYTE   buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
		return 1;
     ed8:	61 e0       	ldi	r22, 0x01	; 1
     eda:	70 e0       	ldi	r23, 0x00	; 0
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	0e c0       	rjmp	.+28     	; 0xefe <get_fat+0xfe>
     ee2:	61 e0       	ldi	r22, 0x01	; 1
     ee4:	70 e0       	ldi	r23, 0x00	; 0
     ee6:	80 e0       	ldi	r24, 0x00	; 0
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	09 c0       	rjmp	.+18     	; 0xefe <get_fat+0xfe>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1; /* An error occured at the disk I/O layer */
     eec:	61 e0       	ldi	r22, 0x01	; 1
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	80 e0       	ldi	r24, 0x00	; 0
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	04 c0       	rjmp	.+8      	; 0xefe <get_fat+0xfe>
     ef6:	61 e0       	ldi	r22, 0x01	; 1
     ef8:	70 e0       	ldi	r23, 0x00	; 0
     efa:	80 e0       	ldi	r24, 0x00	; 0
     efc:	90 e0       	ldi	r25, 0x00	; 0
}
     efe:	0f 90       	pop	r0
     f00:	0f 90       	pop	r0
     f02:	0f 90       	pop	r0
     f04:	0f 90       	pop	r0
     f06:	df 91       	pop	r29
     f08:	cf 91       	pop	r28
     f0a:	1f 91       	pop	r17
     f0c:	0f 91       	pop	r16
     f0e:	ff 90       	pop	r15
     f10:	ef 90       	pop	r14
     f12:	df 90       	pop	r13
     f14:	cf 90       	pop	r12
     f16:	08 95       	ret

00000f18 <dir_next>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_next(        /* FR_OK:Succeeded, FR_NO_FILE:End of table */
                        DIR *dj /* Pointer to directory object */
)
{
     f18:	cf 92       	push	r12
     f1a:	df 92       	push	r13
     f1c:	ef 92       	push	r14
     f1e:	ff 92       	push	r15
     f20:	0f 93       	push	r16
     f22:	1f 93       	push	r17
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
	CLUST  clst;
	WORD   i;
	FATFS *fs = FatFs;
     f28:	e0 90 cd 03 	lds	r14, 0x03CD	; 0x8003cd <FatFs>
     f2c:	f0 90 ce 03 	lds	r15, 0x03CE	; 0x8003ce <FatFs+0x1>

	i = dj->index + 1;
     f30:	fc 01       	movw	r30, r24
     f32:	c0 81       	ld	r28, Z
     f34:	d1 81       	ldd	r29, Z+1	; 0x01
     f36:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
     f38:	09 f4       	brne	.+2      	; 0xf3c <dir_next+0x24>
     f3a:	5c c0       	rjmp	.+184    	; 0xff4 <dir_next+0xdc>
     f3c:	44 85       	ldd	r20, Z+12	; 0x0c
     f3e:	55 85       	ldd	r21, Z+13	; 0x0d
     f40:	66 85       	ldd	r22, Z+14	; 0x0e
     f42:	77 85       	ldd	r23, Z+15	; 0x0f
     f44:	41 15       	cp	r20, r1
     f46:	51 05       	cpc	r21, r1
     f48:	61 05       	cpc	r22, r1
     f4a:	71 05       	cpc	r23, r1
     f4c:	09 f4       	brne	.+2      	; 0xf50 <dir_next+0x38>
     f4e:	54 c0       	rjmp	.+168    	; 0xff8 <dir_next+0xe0>
     f50:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i % 16)) { /* Sector changed? */
     f52:	ce 01       	movw	r24, r28
     f54:	8f 70       	andi	r24, 0x0F	; 15
     f56:	99 27       	eor	r25, r25
     f58:	89 2b       	or	r24, r25
     f5a:	09 f0       	breq	.+2      	; 0xf5e <dir_next+0x46>
     f5c:	46 c0       	rjmp	.+140    	; 0xfea <dir_next+0xd2>
		dj->sect++;  /* Next sector */
     f5e:	4f 5f       	subi	r20, 0xFF	; 255
     f60:	5f 4f       	sbci	r21, 0xFF	; 255
     f62:	6f 4f       	sbci	r22, 0xFF	; 255
     f64:	7f 4f       	sbci	r23, 0xFF	; 255
     f66:	44 87       	std	Z+12, r20	; 0x0c
     f68:	55 87       	std	Z+13, r21	; 0x0d
     f6a:	66 87       	std	Z+14, r22	; 0x0e
     f6c:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {       /* Static table */
     f6e:	40 85       	ldd	r20, Z+8	; 0x08
     f70:	51 85       	ldd	r21, Z+9	; 0x09
     f72:	62 85       	ldd	r22, Z+10	; 0x0a
     f74:	73 85       	ldd	r23, Z+11	; 0x0b
     f76:	41 15       	cp	r20, r1
     f78:	51 05       	cpc	r21, r1
     f7a:	61 05       	cpc	r22, r1
     f7c:	71 05       	cpc	r23, r1
     f7e:	39 f4       	brne	.+14     	; 0xf8e <dir_next+0x76>
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
     f80:	f7 01       	movw	r30, r14
     f82:	84 81       	ldd	r24, Z+4	; 0x04
     f84:	95 81       	ldd	r25, Z+5	; 0x05
     f86:	c8 17       	cp	r28, r24
     f88:	d9 07       	cpc	r29, r25
     f8a:	c0 f5       	brcc	.+112    	; 0xffc <dir_next+0xe4>
     f8c:	2e c0       	rjmp	.+92     	; 0xfea <dir_next+0xd2>
				return FR_NO_FILE;
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
     f8e:	f7 01       	movw	r30, r14
     f90:	82 81       	ldd	r24, Z+2	; 0x02
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	01 97       	sbiw	r24, 0x01	; 1
     f96:	9e 01       	movw	r18, r28
     f98:	32 95       	swap	r19
     f9a:	22 95       	swap	r18
     f9c:	2f 70       	andi	r18, 0x0F	; 15
     f9e:	23 27       	eor	r18, r19
     fa0:	3f 70       	andi	r19, 0x0F	; 15
     fa2:	23 27       	eor	r18, r19
     fa4:	82 23       	and	r24, r18
     fa6:	93 23       	and	r25, r19
     fa8:	89 2b       	or	r24, r25
     faa:	f9 f4       	brne	.+62     	; 0xfea <dir_next+0xd2>
				clst = get_fat(dj->clust);           /* Get next cluster */
     fac:	cb 01       	movw	r24, r22
     fae:	ba 01       	movw	r22, r20
     fb0:	0e 94 00 07 	call	0xe00	; 0xe00 <get_fat>
				if (clst <= 1)
     fb4:	62 30       	cpi	r22, 0x02	; 2
     fb6:	71 05       	cpc	r23, r1
     fb8:	81 05       	cpc	r24, r1
     fba:	91 05       	cpc	r25, r1
     fbc:	08 f1       	brcs	.+66     	; 0x1000 <dir_next+0xe8>
					return FR_DISK_ERR;
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
     fbe:	f7 01       	movw	r30, r14
     fc0:	c6 80       	ldd	r12, Z+6	; 0x06
     fc2:	d7 80       	ldd	r13, Z+7	; 0x07
     fc4:	e0 84       	ldd	r14, Z+8	; 0x08
     fc6:	f1 84       	ldd	r15, Z+9	; 0x09
     fc8:	6c 15       	cp	r22, r12
     fca:	7d 05       	cpc	r23, r13
     fcc:	8e 05       	cpc	r24, r14
     fce:	9f 05       	cpc	r25, r15
     fd0:	c8 f4       	brcc	.+50     	; 0x1004 <dir_next+0xec>
					return FR_NO_FILE;    /* Report EOT */
				dj->clust = clst;         /* Initialize data for new cluster */
     fd2:	f8 01       	movw	r30, r16
     fd4:	60 87       	std	Z+8, r22	; 0x08
     fd6:	71 87       	std	Z+9, r23	; 0x09
     fd8:	82 87       	std	Z+10, r24	; 0x0a
     fda:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect  = clust2sect(clst);
     fdc:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <clust2sect>
     fe0:	f8 01       	movw	r30, r16
     fe2:	64 87       	std	Z+12, r22	; 0x0c
     fe4:	75 87       	std	Z+13, r23	; 0x0d
     fe6:	86 87       	std	Z+14, r24	; 0x0e
     fe8:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
     fea:	f8 01       	movw	r30, r16
     fec:	d1 83       	std	Z+1, r29	; 0x01
     fee:	c0 83       	st	Z, r28

	return FR_OK;
     ff0:	80 e0       	ldi	r24, 0x00	; 0
     ff2:	09 c0       	rjmp	.+18     	; 0x1006 <dir_next+0xee>
	WORD   i;
	FATFS *fs = FatFs;

	i = dj->index + 1;
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
     ff4:	83 e0       	ldi	r24, 0x03	; 3
     ff6:	07 c0       	rjmp	.+14     	; 0x1006 <dir_next+0xee>
     ff8:	83 e0       	ldi	r24, 0x03	; 3
     ffa:	05 c0       	rjmp	.+10     	; 0x1006 <dir_next+0xee>
	if (!(i % 16)) { /* Sector changed? */
		dj->sect++;  /* Next sector */

		if (dj->clust == 0) {       /* Static table */
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
				return FR_NO_FILE;
     ffc:	83 e0       	ldi	r24, 0x03	; 3
     ffe:	03 c0       	rjmp	.+6      	; 0x1006 <dir_next+0xee>
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
				clst = get_fat(dj->clust);           /* Get next cluster */
				if (clst <= 1)
					return FR_DISK_ERR;
    1000:	81 e0       	ldi	r24, 0x01	; 1
    1002:	01 c0       	rjmp	.+2      	; 0x1006 <dir_next+0xee>
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
					return FR_NO_FILE;    /* Report EOT */
    1004:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
    1006:	df 91       	pop	r29
    1008:	cf 91       	pop	r28
    100a:	1f 91       	pop	r17
    100c:	0f 91       	pop	r16
    100e:	ff 90       	pop	r15
    1010:	ef 90       	pop	r14
    1012:	df 90       	pop	r13
    1014:	cf 90       	pop	r12
    1016:	08 95       	ret

00001018 <dir_find>:
/*-----------------------------------------------------------------------*/

	static FRESULT dir_find(DIR * dj, /* Pointer to the directory object linked to the file name */
							BYTE *dir /* 32-byte working buffer */
	)
	{
    1018:	cf 92       	push	r12
    101a:	df 92       	push	r13
    101c:	ff 92       	push	r15
    101e:	0f 93       	push	r16
    1020:	1f 93       	push	r17
    1022:	cf 93       	push	r28
    1024:	df 93       	push	r29
    1026:	ec 01       	movw	r28, r24
    1028:	6b 01       	movw	r12, r22
		FRESULT res;
		BYTE    c;

		res = dir_rewind(dj); /* Rewind directory object */
    102a:	0e 94 35 06 	call	0xc6a	; 0xc6a <dir_rewind>
		if (res != FR_OK)
    102e:	81 11       	cpse	r24, r1
    1030:	37 c0       	rjmp	.+110    	; 0x10a0 <dir_find+0x88>
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    1032:	28 81       	ld	r18, Y
    1034:	39 81       	ldd	r19, Y+1	; 0x01
    1036:	2f 70       	andi	r18, 0x0F	; 15
    1038:	33 27       	eor	r19, r19
    103a:	22 0f       	add	r18, r18
    103c:	33 1f       	adc	r19, r19
    103e:	22 95       	swap	r18
    1040:	32 95       	swap	r19
    1042:	30 7f       	andi	r19, 0xF0	; 240
    1044:	32 27       	eor	r19, r18
    1046:	20 7f       	andi	r18, 0xF0	; 240
    1048:	32 27       	eor	r19, r18
    104a:	4c 85       	ldd	r20, Y+12	; 0x0c
    104c:	5d 85       	ldd	r21, Y+13	; 0x0d
    104e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1050:	7f 85       	ldd	r23, Y+15	; 0x0f
    1052:	00 e2       	ldi	r16, 0x20	; 32
    1054:	10 e0       	ldi	r17, 0x00	; 0
    1056:	c6 01       	movw	r24, r12
    1058:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
					  ? FR_DISK_ERR
					  : FR_OK;
    105c:	91 e0       	ldi	r25, 0x01	; 1
    105e:	81 11       	cpse	r24, r1
    1060:	01 c0       	rjmp	.+2      	; 0x1064 <dir_find+0x4c>
    1062:	90 e0       	ldi	r25, 0x00	; 0
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    1064:	f9 2e       	mov	r15, r25
					  ? FR_DISK_ERR
					  : FR_OK;
			if (res != FR_OK)
    1066:	91 11       	cpse	r25, r1
    1068:	16 c0       	rjmp	.+44     	; 0x1096 <dir_find+0x7e>
				break;
			c = dir[DIR_Name]; /* First character */
    106a:	f6 01       	movw	r30, r12
    106c:	80 81       	ld	r24, Z
			if (c == 0) { ///// hieerrr fout misschien
    106e:	88 23       	and	r24, r24
    1070:	a1 f0       	breq	.+40     	; 0x109a <dir_find+0x82>
				res = FR_NO_FILE;
				break;
			}                                                           /* Reached to end of table */
			if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    1072:	83 85       	ldd	r24, Z+11	; 0x0b
    1074:	83 fd       	sbrc	r24, 3
    1076:	09 c0       	rjmp	.+18     	; 0x108a <dir_find+0x72>
    1078:	6a 81       	ldd	r22, Y+2	; 0x02
    107a:	7b 81       	ldd	r23, Y+3	; 0x03
    107c:	4b e0       	ldi	r20, 0x0B	; 11
    107e:	50 e0       	ldi	r21, 0x00	; 0
    1080:	c6 01       	movw	r24, r12
    1082:	0e 94 cb 05 	call	0xb96	; 0xb96 <mem_cmp>
    1086:	89 2b       	or	r24, r25
    1088:	51 f0       	breq	.+20     	; 0x109e <dir_find+0x86>
				break;
			res = dir_next(dj); /* Next entry */
    108a:	ce 01       	movw	r24, r28
    108c:	0e 94 8c 07 	call	0xf18	; 0xf18 <dir_next>
		} while (res == FR_OK);
    1090:	88 23       	and	r24, r24
    1092:	79 f2       	breq	.-98     	; 0x1032 <dir_find+0x1a>
    1094:	05 c0       	rjmp	.+10     	; 0x10a0 <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    1096:	89 2f       	mov	r24, r25
    1098:	03 c0       	rjmp	.+6      	; 0x10a0 <dir_find+0x88>
					  : FR_OK;
			if (res != FR_OK)
				break;
			c = dir[DIR_Name]; /* First character */
			if (c == 0) { ///// hieerrr fout misschien
				res = FR_NO_FILE;
    109a:	83 e0       	ldi	r24, 0x03	; 3
    109c:	01 c0       	rjmp	.+2      	; 0x10a0 <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    109e:	8f 2d       	mov	r24, r15
				break;
			res = dir_next(dj); /* Next entry */
		} while (res == FR_OK);

		return res;
	}
    10a0:	df 91       	pop	r29
    10a2:	cf 91       	pop	r28
    10a4:	1f 91       	pop	r17
    10a6:	0f 91       	pop	r16
    10a8:	ff 90       	pop	r15
    10aa:	df 90       	pop	r13
    10ac:	cf 90       	pop	r12
    10ae:	08 95       	ret

000010b0 <follow_path>:
static FRESULT follow_path(                 /* FR_OK(0): successful, !=0: error code */
                           DIR *       dj,  /* Directory object to return last directory and found object */
                           BYTE *      dir, /* 32-byte working buffer */
                           const char *path /* Full-path string to find a file or directory */
)
{
    10b0:	ef 92       	push	r14
    10b2:	ff 92       	push	r15
    10b4:	0f 93       	push	r16
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	00 d0       	rcall	.+0      	; 0x10be <follow_path+0xe>
    10be:	cd b7       	in	r28, 0x3d	; 61
    10c0:	de b7       	in	r29, 0x3e	; 62
    10c2:	8c 01       	movw	r16, r24
    10c4:	7b 01       	movw	r14, r22
    10c6:	5a 83       	std	Y+2, r21	; 0x02
    10c8:	49 83       	std	Y+1, r20	; 0x01
	FRESULT res;

	while (*path == ' ')
    10ca:	03 c0       	rjmp	.+6      	; 0x10d2 <follow_path+0x22>
		path++; /* Strip leading spaces */
    10cc:	31 96       	adiw	r30, 0x01	; 1
    10ce:	fa 83       	std	Y+2, r31	; 0x02
    10d0:	e9 83       	std	Y+1, r30	; 0x01
                           const char *path /* Full-path string to find a file or directory */
)
{
	FRESULT res;

	while (*path == ' ')
    10d2:	e9 81       	ldd	r30, Y+1	; 0x01
    10d4:	fa 81       	ldd	r31, Y+2	; 0x02
    10d6:	80 81       	ld	r24, Z
    10d8:	80 32       	cpi	r24, 0x20	; 32
    10da:	c1 f3       	breq	.-16     	; 0x10cc <follow_path+0x1c>
		path++; /* Strip leading spaces */
	if (*path == '/')
    10dc:	8f 32       	cpi	r24, 0x2F	; 47
    10de:	19 f4       	brne	.+6      	; 0x10e6 <follow_path+0x36>
		path++;     /* Strip heading separator if exist */
    10e0:	31 96       	adiw	r30, 0x01	; 1
    10e2:	fa 83       	std	Y+2, r31	; 0x02
    10e4:	e9 83       	std	Y+1, r30	; 0x01
	dj->sclust = 0; /* Set start directory (always root dir) */
    10e6:	d8 01       	movw	r26, r16
    10e8:	14 96       	adiw	r26, 0x04	; 4
    10ea:	1d 92       	st	X+, r1
    10ec:	1d 92       	st	X+, r1
    10ee:	1d 92       	st	X+, r1
    10f0:	1c 92       	st	X, r1
    10f2:	17 97       	sbiw	r26, 0x07	; 7

	if ((BYTE)*path < ' ') { /* Null path means the root directory */
    10f4:	e9 81       	ldd	r30, Y+1	; 0x01
    10f6:	fa 81       	ldd	r31, Y+2	; 0x02
    10f8:	80 81       	ld	r24, Z
    10fa:	80 32       	cpi	r24, 0x20	; 32
    10fc:	30 f4       	brcc	.+12     	; 0x110a <follow_path+0x5a>
		res    = dir_rewind(dj);
    10fe:	c8 01       	movw	r24, r16
    1100:	0e 94 35 06 	call	0xc6a	; 0xc6a <dir_rewind>
		dir[0] = 0;
    1104:	f7 01       	movw	r30, r14
    1106:	10 82       	st	Z, r1
    1108:	26 c0       	rjmp	.+76     	; 0x1156 <follow_path+0xa6>

	} else { /* Follow path */
		for (;;) {
			res = create_name(dj, &path); /* Get a segment */
    110a:	be 01       	movw	r22, r28
    110c:	6f 5f       	subi	r22, 0xFF	; 255
    110e:	7f 4f       	sbci	r23, 0xFF	; 255
    1110:	c8 01       	movw	r24, r16
    1112:	0e 94 74 06 	call	0xce8	; 0xce8 <create_name>
			if (res != FR_OK)
    1116:	81 11       	cpse	r24, r1
    1118:	1e c0       	rjmp	.+60     	; 0x1156 <follow_path+0xa6>
				break;
			res = dir_find(dj, dir); /* Find it */ // het gaat denk ik hier fout
    111a:	b7 01       	movw	r22, r14
    111c:	c8 01       	movw	r24, r16
    111e:	0e 94 0c 08 	call	0x1018	; 0x1018 <dir_find>
			if (res != FR_OK)
    1122:	81 11       	cpse	r24, r1
    1124:	18 c0       	rjmp	.+48     	; 0x1156 <follow_path+0xa6>
				break; /* Could not find the object */
			if (dj->fn[11])
    1126:	d8 01       	movw	r26, r16
    1128:	12 96       	adiw	r26, 0x02	; 2
    112a:	ed 91       	ld	r30, X+
    112c:	fc 91       	ld	r31, X
    112e:	13 97       	sbiw	r26, 0x03	; 3
    1130:	93 85       	ldd	r25, Z+11	; 0x0b
    1132:	91 11       	cpse	r25, r1
    1134:	10 c0       	rjmp	.+32     	; 0x1156 <follow_path+0xa6>
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
    1136:	f7 01       	movw	r30, r14
    1138:	83 85       	ldd	r24, Z+11	; 0x0b
    113a:	84 ff       	sbrs	r24, 4
    113c:	0b c0       	rjmp	.+22     	; 0x1154 <follow_path+0xa4>
				res = FR_NO_FILE;
				break;
			}
			dj->sclust = get_clust(dir); /* Follow next */
    113e:	c7 01       	movw	r24, r14
    1140:	0e 94 13 06 	call	0xc26	; 0xc26 <get_clust>
    1144:	d8 01       	movw	r26, r16
    1146:	14 96       	adiw	r26, 0x04	; 4
    1148:	6d 93       	st	X+, r22
    114a:	7d 93       	st	X+, r23
    114c:	8d 93       	st	X+, r24
    114e:	9c 93       	st	X, r25
    1150:	17 97       	sbiw	r26, 0x07	; 7
		}
    1152:	db cf       	rjmp	.-74     	; 0x110a <follow_path+0x5a>
			if (res != FR_OK)
				break; /* Could not find the object */
			if (dj->fn[11])
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE;
    1154:	83 e0       	ldi	r24, 0x03	; 3
			dj->sclust = get_clust(dir); /* Follow next */
		}
	}

	return res;
}
    1156:	0f 90       	pop	r0
    1158:	0f 90       	pop	r0
    115a:	df 91       	pop	r29
    115c:	cf 91       	pop	r28
    115e:	1f 91       	pop	r17
    1160:	0f 91       	pop	r16
    1162:	ff 90       	pop	r15
    1164:	ef 90       	pop	r14
    1166:	08 95       	ret

00001168 <pf_mount>:
/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount(FATFS *fs /* Pointer to new file system object */)
{
    1168:	4f 92       	push	r4
    116a:	5f 92       	push	r5
    116c:	6f 92       	push	r6
    116e:	7f 92       	push	r7
    1170:	8f 92       	push	r8
    1172:	9f 92       	push	r9
    1174:	af 92       	push	r10
    1176:	bf 92       	push	r11
    1178:	df 92       	push	r13
    117a:	ef 92       	push	r14
    117c:	ff 92       	push	r15
    117e:	0f 93       	push	r16
    1180:	1f 93       	push	r17
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29
    1186:	cd b7       	in	r28, 0x3d	; 61
    1188:	de b7       	in	r29, 0x3e	; 62
    118a:	a8 97       	sbiw	r28, 0x28	; 40
    118c:	0f b6       	in	r0, 0x3f	; 63
    118e:	f8 94       	cli
    1190:	de bf       	out	0x3e, r29	; 62
    1192:	0f be       	out	0x3f, r0	; 63
    1194:	cd bf       	out	0x3d, r28	; 61
    1196:	7c 01       	movw	r14, r24
	BYTE  fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;

	FatFs = 0;
    1198:	10 92 ce 03 	sts	0x03CE, r1	; 0x8003ce <FatFs+0x1>
    119c:	10 92 cd 03 	sts	0x03CD, r1	; 0x8003cd <FatFs>

	if (disk_initialize() & STA_NOINIT)
    11a0:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
    11a4:	80 fd       	sbrc	r24, 0
    11a6:	62 c1       	rjmp	.+708    	; 0x146c <pf_mount+0x304>
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
    11a8:	40 e0       	ldi	r20, 0x00	; 0
    11aa:	50 e0       	ldi	r21, 0x00	; 0
    11ac:	ba 01       	movw	r22, r20
    11ae:	ce 01       	movw	r24, r28
    11b0:	01 96       	adiw	r24, 0x01	; 1
    11b2:	0e 94 c0 06 	call	0xd80	; 0xd80 <check_fs>
    11b6:	d8 2e       	mov	r13, r24
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
    11b8:	21 e0       	ldi	r18, 0x01	; 1
    11ba:	82 13       	cpse	r24, r18
    11bc:	38 c0       	rjmp	.+112    	; 0x122e <pf_mount+0xc6>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
    11be:	00 e1       	ldi	r16, 0x10	; 16
    11c0:	10 e0       	ldi	r17, 0x00	; 0
    11c2:	2e eb       	ldi	r18, 0xBE	; 190
    11c4:	31 e0       	ldi	r19, 0x01	; 1
    11c6:	40 e0       	ldi	r20, 0x00	; 0
    11c8:	50 e0       	ldi	r21, 0x00	; 0
    11ca:	ba 01       	movw	r22, r20
    11cc:	ce 01       	movw	r24, r28
    11ce:	01 96       	adiw	r24, 0x01	; 1
    11d0:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    11d4:	81 11       	cpse	r24, r1
    11d6:	2f c0       	rjmp	.+94     	; 0x1236 <pf_mount+0xce>
			fmt = 3;
		} else {
			if (buf[4]) {                     /* Is the partition existing? */
    11d8:	8d 81       	ldd	r24, Y+5	; 0x05
    11da:	88 23       	and	r24, r24
    11dc:	a1 f1       	breq	.+104    	; 0x1246 <pf_mount+0xde>
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
    11de:	8c 84       	ldd	r8, Y+12	; 0x0c
    11e0:	91 2c       	mov	r9, r1
    11e2:	a1 2c       	mov	r10, r1
    11e4:	b1 2c       	mov	r11, r1
    11e6:	b8 2c       	mov	r11, r8
    11e8:	aa 24       	eor	r10, r10
    11ea:	99 24       	eor	r9, r9
    11ec:	88 24       	eor	r8, r8
    11ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    11f0:	89 2f       	mov	r24, r25
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	a0 e0       	ldi	r26, 0x00	; 0
    11f6:	b0 e0       	ldi	r27, 0x00	; 0
    11f8:	dc 01       	movw	r26, r24
    11fa:	99 27       	eor	r25, r25
    11fc:	88 27       	eor	r24, r24
    11fe:	88 29       	or	r24, r8
    1200:	99 29       	or	r25, r9
    1202:	aa 29       	or	r26, r10
    1204:	bb 29       	or	r27, r11
    1206:	8a 84       	ldd	r8, Y+10	; 0x0a
    1208:	91 2c       	mov	r9, r1
    120a:	98 2c       	mov	r9, r8
    120c:	88 24       	eor	r8, r8
    120e:	a1 2c       	mov	r10, r1
    1210:	b1 2c       	mov	r11, r1
    1212:	88 2a       	or	r8, r24
    1214:	99 2a       	or	r9, r25
    1216:	aa 2a       	or	r10, r26
    1218:	bb 2a       	or	r11, r27
    121a:	89 85       	ldd	r24, Y+9	; 0x09
    121c:	88 2a       	or	r8, r24
				fmt   = check_fs(buf, bsect); /* Check the partition */
    121e:	b5 01       	movw	r22, r10
    1220:	a4 01       	movw	r20, r8
    1222:	ce 01       	movw	r24, r28
    1224:	01 96       	adiw	r24, 0x01	; 1
    1226:	0e 94 c0 06 	call	0xd80	; 0xd80 <check_fs>
    122a:	d8 2e       	mov	r13, r24
    122c:	0f c0       	rjmp	.+30     	; 0x124c <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    122e:	81 2c       	mov	r8, r1
    1230:	91 2c       	mov	r9, r1
    1232:	54 01       	movw	r10, r8
    1234:	0b c0       	rjmp	.+22     	; 0x124c <pf_mount+0xe4>
    1236:	81 2c       	mov	r8, r1
    1238:	91 2c       	mov	r9, r1
    123a:	54 01       	movw	r10, r8
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
			fmt = 3;
    123c:	0f 2e       	mov	r0, r31
    123e:	f3 e0       	ldi	r31, 0x03	; 3
    1240:	df 2e       	mov	r13, r31
    1242:	f0 2d       	mov	r31, r0
    1244:	03 c0       	rjmp	.+6      	; 0x124c <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1246:	81 2c       	mov	r8, r1
    1248:	91 2c       	mov	r9, r1
    124a:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
    124c:	43 e0       	ldi	r20, 0x03	; 3
    124e:	d4 16       	cp	r13, r20
    1250:	09 f4       	brne	.+2      	; 0x1254 <pf_mount+0xec>
    1252:	0e c1       	rjmp	.+540    	; 0x1470 <pf_mount+0x308>
		return FR_DISK_ERR;
	if (fmt)
    1254:	d1 10       	cpse	r13, r1
    1256:	0e c1       	rjmp	.+540    	; 0x1474 <pf_mount+0x30c>
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
    1258:	04 e2       	ldi	r16, 0x24	; 36
    125a:	10 e0       	ldi	r17, 0x00	; 0
    125c:	2d e0       	ldi	r18, 0x0D	; 13
    125e:	30 e0       	ldi	r19, 0x00	; 0
    1260:	b5 01       	movw	r22, r10
    1262:	a4 01       	movw	r20, r8
    1264:	ce 01       	movw	r24, r28
    1266:	01 96       	adiw	r24, 0x01	; 1
    1268:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    126c:	81 11       	cpse	r24, r1
    126e:	04 c1       	rjmp	.+520    	; 0x1478 <pf_mount+0x310>
		return FR_DISK_ERR;

	fsize = LD_WORD(buf + BPB_FATSz16 - 13); /* Number of sectors per FAT */
    1270:	2b 85       	ldd	r18, Y+11	; 0x0b
    1272:	30 e0       	ldi	r19, 0x00	; 0
    1274:	32 2f       	mov	r19, r18
    1276:	22 27       	eor	r18, r18
    1278:	8a 85       	ldd	r24, Y+10	; 0x0a
    127a:	28 2b       	or	r18, r24
    127c:	40 e0       	ldi	r20, 0x00	; 0
    127e:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize)
    1280:	21 15       	cp	r18, r1
    1282:	31 05       	cpc	r19, r1
    1284:	41 05       	cpc	r20, r1
    1286:	51 05       	cpc	r21, r1
    1288:	21 f5       	brne	.+72     	; 0x12d2 <pf_mount+0x16a>
		fsize = LD_DWORD(buf + BPB_FATSz32 - 13);
    128a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    128c:	82 2f       	mov	r24, r18
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	a0 e0       	ldi	r26, 0x00	; 0
    1292:	b0 e0       	ldi	r27, 0x00	; 0
    1294:	78 2f       	mov	r23, r24
    1296:	66 27       	eor	r22, r22
    1298:	55 27       	eor	r21, r21
    129a:	44 27       	eor	r20, r20
    129c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    129e:	89 2f       	mov	r24, r25
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	a0 e0       	ldi	r26, 0x00	; 0
    12a4:	b0 e0       	ldi	r27, 0x00	; 0
    12a6:	dc 01       	movw	r26, r24
    12a8:	99 27       	eor	r25, r25
    12aa:	88 27       	eor	r24, r24
    12ac:	84 2b       	or	r24, r20
    12ae:	95 2b       	or	r25, r21
    12b0:	a6 2b       	or	r26, r22
    12b2:	b7 2b       	or	r27, r23
    12b4:	29 8d       	ldd	r18, Y+25	; 0x19
    12b6:	30 e0       	ldi	r19, 0x00	; 0
    12b8:	32 2f       	mov	r19, r18
    12ba:	22 27       	eor	r18, r18
    12bc:	a9 01       	movw	r20, r18
    12be:	60 e0       	ldi	r22, 0x00	; 0
    12c0:	70 e0       	ldi	r23, 0x00	; 0
    12c2:	48 2b       	or	r20, r24
    12c4:	59 2b       	or	r21, r25
    12c6:	6a 2b       	or	r22, r26
    12c8:	7b 2b       	or	r23, r27
    12ca:	88 8d       	ldd	r24, Y+24	; 0x18
    12cc:	9a 01       	movw	r18, r20
    12ce:	ab 01       	movw	r20, r22
    12d0:	28 2b       	or	r18, r24

	fsize *= buf[BPB_NumFATs - 13];                             /* Number of sectors in FAT area */
    12d2:	ac 81       	ldd	r26, Y+4	; 0x04
    12d4:	b0 e0       	ldi	r27, 0x00	; 0
    12d6:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <__muluhisi3>
    12da:	6d a3       	std	Y+37, r22	; 0x25
    12dc:	7e a3       	std	Y+38, r23	; 0x26
    12de:	8f a3       	std	Y+39, r24	; 0x27
    12e0:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase   = bsect + LD_WORD(buf + BPB_RsvdSecCnt - 13); /* FAT start sector (lba) */
    12e2:	8b 81       	ldd	r24, Y+3	; 0x03
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	98 2f       	mov	r25, r24
    12e8:	88 27       	eor	r24, r24
    12ea:	4a 81       	ldd	r20, Y+2	; 0x02
    12ec:	50 e0       	ldi	r21, 0x00	; 0
    12ee:	84 2b       	or	r24, r20
    12f0:	95 2b       	or	r25, r21
    12f2:	88 0e       	add	r8, r24
    12f4:	99 1e       	adc	r9, r25
    12f6:	a1 1c       	adc	r10, r1
    12f8:	b1 1c       	adc	r11, r1
    12fa:	d7 01       	movw	r26, r14
    12fc:	1a 96       	adiw	r26, 0x0a	; 10
    12fe:	8d 92       	st	X+, r8
    1300:	9d 92       	st	X+, r9
    1302:	ad 92       	st	X+, r10
    1304:	bc 92       	st	X, r11
    1306:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
    1308:	a9 81       	ldd	r26, Y+1	; 0x01
    130a:	f7 01       	movw	r30, r14
    130c:	a2 83       	std	Z+2, r26	; 0x02
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
    130e:	8e 81       	ldd	r24, Y+6	; 0x06
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	98 2f       	mov	r25, r24
    1314:	88 27       	eor	r24, r24
    1316:	2d 81       	ldd	r18, Y+5	; 0x05
    1318:	82 2b       	or	r24, r18
    131a:	95 83       	std	Z+5, r25	; 0x05
    131c:	84 83       	std	Z+4, r24	; 0x04
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
    131e:	08 85       	ldd	r16, Y+8	; 0x08
    1320:	10 e0       	ldi	r17, 0x00	; 0
    1322:	10 2f       	mov	r17, r16
    1324:	00 27       	eor	r16, r16
    1326:	2f 81       	ldd	r18, Y+7	; 0x07
    1328:	02 2b       	or	r16, r18
    132a:	20 e0       	ldi	r18, 0x00	; 0
    132c:	30 e0       	ldi	r19, 0x00	; 0
	if (!tsect)
    132e:	01 15       	cp	r16, r1
    1330:	11 05       	cpc	r17, r1
    1332:	21 05       	cpc	r18, r1
    1334:	31 05       	cpc	r19, r1
    1336:	01 f5       	brne	.+64     	; 0x1378 <pf_mount+0x210>
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
    1338:	0f 89       	ldd	r16, Y+23	; 0x17
    133a:	10 e0       	ldi	r17, 0x00	; 0
    133c:	20 e0       	ldi	r18, 0x00	; 0
    133e:	30 e0       	ldi	r19, 0x00	; 0
    1340:	70 2e       	mov	r7, r16
    1342:	66 24       	eor	r6, r6
    1344:	55 24       	eor	r5, r5
    1346:	44 24       	eor	r4, r4
    1348:	0e 89       	ldd	r16, Y+22	; 0x16
    134a:	10 e0       	ldi	r17, 0x00	; 0
    134c:	20 e0       	ldi	r18, 0x00	; 0
    134e:	30 e0       	ldi	r19, 0x00	; 0
    1350:	98 01       	movw	r18, r16
    1352:	11 27       	eor	r17, r17
    1354:	00 27       	eor	r16, r16
    1356:	40 2a       	or	r4, r16
    1358:	51 2a       	or	r5, r17
    135a:	62 2a       	or	r6, r18
    135c:	73 2a       	or	r7, r19
    135e:	2d 89       	ldd	r18, Y+21	; 0x15
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	32 2f       	mov	r19, r18
    1364:	22 27       	eor	r18, r18
    1366:	89 01       	movw	r16, r18
    1368:	20 e0       	ldi	r18, 0x00	; 0
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	04 29       	or	r16, r4
    136e:	15 29       	or	r17, r5
    1370:	26 29       	or	r18, r6
    1372:	37 29       	or	r19, r7
    1374:	6c 89       	ldd	r22, Y+20	; 0x14
    1376:	06 2b       	or	r16, r22
	mclst = (tsect /* Last cluster# + 1 */
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
    1378:	eb 81       	ldd	r30, Y+3	; 0x03
    137a:	f0 e0       	ldi	r31, 0x00	; 0
    137c:	fe 2f       	mov	r31, r30
    137e:	ee 27       	eor	r30, r30
    1380:	4e 2b       	or	r20, r30
    1382:	5f 2b       	or	r21, r31
    1384:	04 1b       	sub	r16, r20
    1386:	15 0b       	sbc	r17, r21
    1388:	21 09       	sbc	r18, r1
    138a:	31 09       	sbc	r19, r1
    138c:	4d a1       	ldd	r20, Y+37	; 0x25
    138e:	5e a1       	ldd	r21, Y+38	; 0x26
    1390:	6f a1       	ldd	r22, Y+39	; 0x27
    1392:	78 a5       	ldd	r23, Y+40	; 0x28
    1394:	04 1b       	sub	r16, r20
    1396:	15 0b       	sbc	r17, r21
    1398:	26 0b       	sbc	r18, r22
    139a:	37 0b       	sbc	r19, r23
    139c:	92 95       	swap	r25
    139e:	82 95       	swap	r24
    13a0:	8f 70       	andi	r24, 0x0F	; 15
    13a2:	89 27       	eor	r24, r25
    13a4:	9f 70       	andi	r25, 0x0F	; 15
    13a6:	89 27       	eor	r24, r25
    13a8:	2c 01       	movw	r4, r24
    13aa:	61 2c       	mov	r6, r1
    13ac:	71 2c       	mov	r7, r1
    13ae:	c9 01       	movw	r24, r18
    13b0:	b8 01       	movw	r22, r16
    13b2:	64 19       	sub	r22, r4
    13b4:	75 09       	sbc	r23, r5
    13b6:	86 09       	sbc	r24, r6
    13b8:	97 09       	sbc	r25, r7
	            / fs->csize
    13ba:	2a 2f       	mov	r18, r26
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	40 e0       	ldi	r20, 0x00	; 0
    13c0:	50 e0       	ldi	r21, 0x00	; 0
    13c2:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <__udivmodsi4>
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
	if (!tsect)
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
	mclst = (tsect /* Last cluster# + 1 */
    13c6:	da 01       	movw	r26, r20
    13c8:	c9 01       	movw	r24, r18
    13ca:	02 96       	adiw	r24, 0x02	; 2
    13cc:	a1 1d       	adc	r26, r1
    13ce:	b1 1d       	adc	r27, r1
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
	            / fs->csize
	        + 2;
	fs->n_fatent = (CLUST)mclst;
    13d0:	f7 01       	movw	r30, r14
    13d2:	86 83       	std	Z+6, r24	; 0x06
    13d4:	97 83       	std	Z+7, r25	; 0x07
    13d6:	a0 87       	std	Z+8, r26	; 0x08
    13d8:	b1 87       	std	Z+9, r27	; 0x09
	fmt = 0; /* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    13da:	87 3f       	cpi	r24, 0xF7	; 247
    13dc:	9f 4f       	sbci	r25, 0xFF	; 255
    13de:	a1 05       	cpc	r26, r1
    13e0:	b1 05       	cpc	r27, r1
    13e2:	20 f0       	brcs	.+8      	; 0x13ec <pf_mount+0x284>
		fmt = FS_FAT32;
    13e4:	0f 2e       	mov	r0, r31
    13e6:	f3 e0       	ldi	r31, 0x03	; 3
    13e8:	df 2e       	mov	r13, r31
    13ea:	f0 2d       	mov	r31, r0
	if (!fmt)
    13ec:	dd 20       	and	r13, r13
    13ee:	09 f4       	brne	.+2      	; 0x13f2 <pf_mount+0x28a>
    13f0:	45 c0       	rjmp	.+138    	; 0x147c <pf_mount+0x314>
		return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    13f2:	d7 01       	movw	r26, r14
    13f4:	dc 92       	st	X, r13

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf + (BPB_RootClus - 13)); /* Root directory start cluster */
    13f6:	8b a1       	ldd	r24, Y+35	; 0x23
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	a0 e0       	ldi	r26, 0x00	; 0
    13fc:	b0 e0       	ldi	r27, 0x00	; 0
    13fe:	78 2f       	mov	r23, r24
    1400:	66 27       	eor	r22, r22
    1402:	55 27       	eor	r21, r21
    1404:	44 27       	eor	r20, r20
    1406:	8a a1       	ldd	r24, Y+34	; 0x22
    1408:	90 e0       	ldi	r25, 0x00	; 0
    140a:	a0 e0       	ldi	r26, 0x00	; 0
    140c:	b0 e0       	ldi	r27, 0x00	; 0
    140e:	dc 01       	movw	r26, r24
    1410:	99 27       	eor	r25, r25
    1412:	88 27       	eor	r24, r24
    1414:	84 2b       	or	r24, r20
    1416:	95 2b       	or	r25, r21
    1418:	a6 2b       	or	r26, r22
    141a:	b7 2b       	or	r27, r23
    141c:	49 a1       	ldd	r20, Y+33	; 0x21
    141e:	50 e0       	ldi	r21, 0x00	; 0
    1420:	54 2f       	mov	r21, r20
    1422:	44 27       	eor	r20, r20
    1424:	60 e0       	ldi	r22, 0x00	; 0
    1426:	70 e0       	ldi	r23, 0x00	; 0
    1428:	84 2b       	or	r24, r20
    142a:	95 2b       	or	r25, r21
    142c:	a6 2b       	or	r26, r22
    142e:	b7 2b       	or	r27, r23
    1430:	28 a1       	ldd	r18, Y+32	; 0x20
    1432:	82 2b       	or	r24, r18
    1434:	f7 01       	movw	r30, r14
    1436:	86 87       	std	Z+14, r24	; 0x0e
    1438:	97 87       	std	Z+15, r25	; 0x0f
    143a:	a0 8b       	std	Z+16, r26	; 0x10
    143c:	b1 8b       	std	Z+17, r27	; 0x11
	else
		fs->dirbase = fs->fatbase + fsize;                   /* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16; /* Data start sector (lba) */
    143e:	4d a1       	ldd	r20, Y+37	; 0x25
    1440:	5e a1       	ldd	r21, Y+38	; 0x26
    1442:	6f a1       	ldd	r22, Y+39	; 0x27
    1444:	78 a5       	ldd	r23, Y+40	; 0x28
    1446:	84 0e       	add	r8, r20
    1448:	95 1e       	adc	r9, r21
    144a:	a6 1e       	adc	r10, r22
    144c:	b7 1e       	adc	r11, r23
    144e:	84 0c       	add	r8, r4
    1450:	95 1c       	adc	r9, r5
    1452:	a6 1c       	adc	r10, r6
    1454:	b7 1c       	adc	r11, r7
    1456:	82 8a       	std	Z+18, r8	; 0x12
    1458:	93 8a       	std	Z+19, r9	; 0x13
    145a:	a4 8a       	std	Z+20, r10	; 0x14
    145c:	b5 8a       	std	Z+21, r11	; 0x15

	fs->flag = 0;
    145e:	11 82       	std	Z+1, r1	; 0x01
	FatFs    = fs;
    1460:	f0 92 ce 03 	sts	0x03CE, r15	; 0x8003ce <FatFs+0x1>
    1464:	e0 92 cd 03 	sts	0x03CD, r14	; 0x8003cd <FatFs>

	return FR_OK;
    1468:	80 e0       	ldi	r24, 0x00	; 0
    146a:	09 c0       	rjmp	.+18     	; 0x147e <pf_mount+0x316>
	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)
	{
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
    146c:	82 e0       	ldi	r24, 0x02	; 2
    146e:	07 c0       	rjmp	.+14     	; 0x147e <pf_mount+0x316>
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
		return FR_DISK_ERR;
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	05 c0       	rjmp	.+10     	; 0x147e <pf_mount+0x316>
	if (fmt)
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */
    1474:	86 e0       	ldi	r24, 0x06	; 6
    1476:	03 c0       	rjmp	.+6      	; 0x147e <pf_mount+0x316>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
		return FR_DISK_ERR;
    1478:	81 e0       	ldi	r24, 0x01	; 1
    147a:	01 c0       	rjmp	.+2      	; 0x147e <pf_mount+0x316>
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
		fmt = FS_FAT32;
	if (!fmt)
		return FR_NO_FILESYSTEM;
    147c:	86 e0       	ldi	r24, 0x06	; 6

	fs->flag = 0;
	FatFs    = fs;

	return FR_OK;
}
    147e:	a8 96       	adiw	r28, 0x28	; 40
    1480:	0f b6       	in	r0, 0x3f	; 63
    1482:	f8 94       	cli
    1484:	de bf       	out	0x3e, r29	; 62
    1486:	0f be       	out	0x3f, r0	; 63
    1488:	cd bf       	out	0x3d, r28	; 61
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	1f 91       	pop	r17
    1490:	0f 91       	pop	r16
    1492:	ff 90       	pop	r15
    1494:	ef 90       	pop	r14
    1496:	df 90       	pop	r13
    1498:	bf 90       	pop	r11
    149a:	af 90       	pop	r10
    149c:	9f 90       	pop	r9
    149e:	8f 90       	pop	r8
    14a0:	7f 90       	pop	r7
    14a2:	6f 90       	pop	r6
    14a4:	5f 90       	pop	r5
    14a6:	4f 90       	pop	r4
    14a8:	08 95       	ret

000014aa <pf_open>:
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT pf_open(const char *path /* Pointer to the file name */
)
 {
    14aa:	0f 93       	push	r16
    14ac:	1f 93       	push	r17
    14ae:	cf 93       	push	r28
    14b0:	df 93       	push	r29
    14b2:	cd b7       	in	r28, 0x3d	; 61
    14b4:	de b7       	in	r29, 0x3e	; 62
    14b6:	ec 97       	sbiw	r28, 0x3c	; 60
    14b8:	0f b6       	in	r0, 0x3f	; 63
    14ba:	f8 94       	cli
    14bc:	de bf       	out	0x3e, r29	; 62
    14be:	0f be       	out	0x3f, r0	; 63
    14c0:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;
    14c2:	00 91 cd 03 	lds	r16, 0x03CD	; 0x8003cd <FatFs>
    14c6:	10 91 ce 03 	lds	r17, 0x03CE	; 0x8003ce <FatFs+0x1>

	if (!fs)
    14ca:	01 15       	cp	r16, r1
    14cc:	11 05       	cpc	r17, r1
    14ce:	09 f4       	brne	.+2      	; 0x14d2 <pf_open+0x28>
    14d0:	4a c0       	rjmp	.+148    	; 0x1566 <pf_open+0xbc>
    14d2:	ac 01       	movw	r20, r24
		return FR_NOT_ENABLED; /* Check file system */

	fs->flag = 0;
    14d4:	f8 01       	movw	r30, r16
    14d6:	11 82       	std	Z+1, r1	; 0x01
	dj.fn    = sp;
    14d8:	ce 01       	movw	r24, r28
    14da:	41 96       	adiw	r24, 0x11	; 17
    14dc:	9c 83       	std	Y+4, r25	; 0x04
    14de:	8b 83       	std	Y+3, r24	; 0x03
	res      = follow_path(&dj, dir, path); /* Follow the file path */
    14e0:	be 01       	movw	r22, r28
    14e2:	63 5e       	subi	r22, 0xE3	; 227
    14e4:	7f 4f       	sbci	r23, 0xFF	; 255
    14e6:	40 97       	sbiw	r24, 0x10	; 16
    14e8:	0e 94 58 08 	call	0x10b0	; 0x10b0 <follow_path>
	if (res != FR_OK)
    14ec:	81 11       	cpse	r24, r1
    14ee:	40 c0       	rjmp	.+128    	; 0x1570 <pf_open+0xc6>
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
    14f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14f2:	88 23       	and	r24, r24
    14f4:	d1 f1       	breq	.+116    	; 0x156a <pf_open+0xc0>
    14f6:	88 a5       	ldd	r24, Y+40	; 0x28
    14f8:	84 fd       	sbrc	r24, 4
    14fa:	39 c0       	rjmp	.+114    	; 0x156e <pf_open+0xc4>
		return FR_NO_FILE;
	

	fs->org_clust = get_clust(dir);               /* File start cluster */
    14fc:	ce 01       	movw	r24, r28
    14fe:	4d 96       	adiw	r24, 0x1d	; 29
    1500:	0e 94 13 06 	call	0xc26	; 0xc26 <get_clust>
    1504:	f8 01       	movw	r30, r16
    1506:	66 8f       	std	Z+30, r22	; 0x1e
    1508:	77 8f       	std	Z+31, r23	; 0x1f
    150a:	80 a3       	std	Z+32, r24	; 0x20
    150c:	91 a3       	std	Z+33, r25	; 0x21
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
    150e:	8c ad       	ldd	r24, Y+60	; 0x3c
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	a0 e0       	ldi	r26, 0x00	; 0
    1514:	b0 e0       	ldi	r27, 0x00	; 0
    1516:	78 2f       	mov	r23, r24
    1518:	66 27       	eor	r22, r22
    151a:	55 27       	eor	r21, r21
    151c:	44 27       	eor	r20, r20
    151e:	9b ad       	ldd	r25, Y+59	; 0x3b
    1520:	89 2f       	mov	r24, r25
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	a0 e0       	ldi	r26, 0x00	; 0
    1526:	b0 e0       	ldi	r27, 0x00	; 0
    1528:	dc 01       	movw	r26, r24
    152a:	99 27       	eor	r25, r25
    152c:	88 27       	eor	r24, r24
    152e:	84 2b       	or	r24, r20
    1530:	95 2b       	or	r25, r21
    1532:	a6 2b       	or	r26, r22
    1534:	b7 2b       	or	r27, r23
    1536:	4a ad       	ldd	r20, Y+58	; 0x3a
    1538:	50 e0       	ldi	r21, 0x00	; 0
    153a:	54 2f       	mov	r21, r20
    153c:	44 27       	eor	r20, r20
    153e:	60 e0       	ldi	r22, 0x00	; 0
    1540:	70 e0       	ldi	r23, 0x00	; 0
    1542:	84 2b       	or	r24, r20
    1544:	95 2b       	or	r25, r21
    1546:	a6 2b       	or	r26, r22
    1548:	b7 2b       	or	r27, r23
    154a:	29 ad       	ldd	r18, Y+57	; 0x39
    154c:	82 2b       	or	r24, r18
    154e:	82 8f       	std	Z+26, r24	; 0x1a
    1550:	93 8f       	std	Z+27, r25	; 0x1b
    1552:	a4 8f       	std	Z+28, r26	; 0x1c
    1554:	b5 8f       	std	Z+29, r27	; 0x1d
	fs->fptr      = 0;                            /* File pointer */
    1556:	16 8a       	std	Z+22, r1	; 0x16
    1558:	17 8a       	std	Z+23, r1	; 0x17
    155a:	10 8e       	std	Z+24, r1	; 0x18
    155c:	11 8e       	std	Z+25, r1	; 0x19
	fs->flag      = FA_OPENED;
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	81 83       	std	Z+1, r24	; 0x01

	return FR_OK;
    1562:	80 e0       	ldi	r24, 0x00	; 0
    1564:	05 c0       	rjmp	.+10     	; 0x1570 <pf_open+0xc6>
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED; /* Check file system */
    1566:	85 e0       	ldi	r24, 0x05	; 5
    1568:	03 c0       	rjmp	.+6      	; 0x1570 <pf_open+0xc6>
	dj.fn    = sp;
	res      = follow_path(&dj, dir, path); /* Follow the file path */
	if (res != FR_OK)
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
		return FR_NO_FILE;
    156a:	83 e0       	ldi	r24, 0x03	; 3
    156c:	01 c0       	rjmp	.+2      	; 0x1570 <pf_open+0xc6>
    156e:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
	fs->fptr      = 0;                            /* File pointer */
	fs->flag      = FA_OPENED;

	return FR_OK;
}
    1570:	ec 96       	adiw	r28, 0x3c	; 60
    1572:	0f b6       	in	r0, 0x3f	; 63
    1574:	f8 94       	cli
    1576:	de bf       	out	0x3e, r29	; 62
    1578:	0f be       	out	0x3f, r0	; 63
    157a:	cd bf       	out	0x3d, r28	; 61
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	08 95       	ret

00001586 <pf_read>:

FRESULT pf_read(void *buff, /* Pointer to the read buffer (NULL:Forward data to the stream)*/
                UINT  btr,  /* Number of bytes to read */
                UINT *br    /* Pointer to number of bytes read */
)
{
    1586:	6f 92       	push	r6
    1588:	7f 92       	push	r7
    158a:	8f 92       	push	r8
    158c:	9f 92       	push	r9
    158e:	af 92       	push	r10
    1590:	bf 92       	push	r11
    1592:	cf 92       	push	r12
    1594:	df 92       	push	r13
    1596:	ef 92       	push	r14
    1598:	ff 92       	push	r15
    159a:	0f 93       	push	r16
    159c:	1f 93       	push	r17
    159e:	cf 93       	push	r28
    15a0:	df 93       	push	r29
    15a2:	3c 01       	movw	r6, r24
    15a4:	6b 01       	movw	r12, r22
    15a6:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST   clst;
	DWORD   sect, remain;
	UINT    rcnt;
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;
    15a8:	e0 90 cd 03 	lds	r14, 0x03CD	; 0x8003cd <FatFs>
    15ac:	f0 90 ce 03 	lds	r15, 0x03CE	; 0x8003ce <FatFs+0x1>

	*br = 0;
    15b0:	fa 01       	movw	r30, r20
    15b2:	11 82       	std	Z+1, r1	; 0x01
    15b4:	10 82       	st	Z, r1
	if (!fs)
    15b6:	e1 14       	cp	r14, r1
    15b8:	f1 04       	cpc	r15, r1
    15ba:	09 f4       	brne	.+2      	; 0x15be <pf_read+0x38>
    15bc:	b5 c0       	rjmp	.+362    	; 0x1728 <pf_read+0x1a2>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    15be:	f7 01       	movw	r30, r14
    15c0:	81 81       	ldd	r24, Z+1	; 0x01
    15c2:	80 ff       	sbrs	r24, 0
    15c4:	b3 c0       	rjmp	.+358    	; 0x172c <pf_read+0x1a6>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    15c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    15c8:	93 8d       	ldd	r25, Z+27	; 0x1b
    15ca:	a4 8d       	ldd	r26, Z+28	; 0x1c
    15cc:	b5 8d       	ldd	r27, Z+29	; 0x1d
    15ce:	46 89       	ldd	r20, Z+22	; 0x16
    15d0:	57 89       	ldd	r21, Z+23	; 0x17
    15d2:	60 8d       	ldd	r22, Z+24	; 0x18
    15d4:	71 8d       	ldd	r23, Z+25	; 0x19
    15d6:	84 1b       	sub	r24, r20
    15d8:	95 0b       	sbc	r25, r21
    15da:	a6 0b       	sbc	r26, r22
    15dc:	b7 0b       	sbc	r27, r23
	if (btr > remain)
    15de:	a6 01       	movw	r20, r12
    15e0:	60 e0       	ldi	r22, 0x00	; 0
    15e2:	70 e0       	ldi	r23, 0x00	; 0
    15e4:	84 17       	cp	r24, r20
    15e6:	95 07       	cpc	r25, r21
    15e8:	a6 07       	cpc	r26, r22
    15ea:	b7 07       	cpc	r27, r23
    15ec:	08 f4       	brcc	.+2      	; 0x15f0 <pf_read+0x6a>
		btr = (UINT)remain; /* Truncate btr by remaining bytes */
    15ee:	6c 01       	movw	r12, r24
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
		if (rcnt > btr)
			rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    15f0:	53 01       	movw	r10, r6
    15f2:	94 c0       	rjmp	.+296    	; 0x171c <pf_read+0x196>
	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {                       /* On the sector boundary? */
    15f4:	f7 01       	movw	r30, r14
    15f6:	86 89       	ldd	r24, Z+22	; 0x16
    15f8:	97 89       	ldd	r25, Z+23	; 0x17
    15fa:	a0 8d       	ldd	r26, Z+24	; 0x18
    15fc:	b1 8d       	ldd	r27, Z+25	; 0x19
    15fe:	ac 01       	movw	r20, r24
    1600:	bd 01       	movw	r22, r26
    1602:	51 70       	andi	r21, 0x01	; 1
    1604:	66 27       	eor	r22, r22
    1606:	77 27       	eor	r23, r23
    1608:	45 2b       	or	r20, r21
    160a:	46 2b       	or	r20, r22
    160c:	47 2b       	or	r20, r23
    160e:	09 f0       	breq	.+2      	; 0x1612 <pf_read+0x8c>
    1610:	48 c0       	rjmp	.+144    	; 0x16a2 <pf_read+0x11c>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1612:	c2 81       	ldd	r28, Z+2	; 0x02
    1614:	c1 50       	subi	r28, 0x01	; 1
    1616:	ac 01       	movw	r20, r24
    1618:	bd 01       	movw	r22, r26
    161a:	03 2e       	mov	r0, r19
    161c:	39 e0       	ldi	r19, 0x09	; 9
    161e:	76 95       	lsr	r23
    1620:	67 95       	ror	r22
    1622:	57 95       	ror	r21
    1624:	47 95       	ror	r20
    1626:	3a 95       	dec	r19
    1628:	d1 f7       	brne	.-12     	; 0x161e <pf_read+0x98>
    162a:	30 2d       	mov	r19, r0
    162c:	c4 23       	and	r28, r20
			if (!cs) {                                     /* On the cluster boundary? */
    162e:	f1 f4       	brne	.+60     	; 0x166c <pf_read+0xe6>
				if (fs->fptr == 0)                         /* On the top of the file? */
    1630:	89 2b       	or	r24, r25
    1632:	8a 2b       	or	r24, r26
    1634:	8b 2b       	or	r24, r27
    1636:	29 f4       	brne	.+10     	; 0x1642 <pf_read+0xbc>
					clst = fs->org_clust;
    1638:	66 8d       	ldd	r22, Z+30	; 0x1e
    163a:	77 8d       	ldd	r23, Z+31	; 0x1f
    163c:	80 a1       	ldd	r24, Z+32	; 0x20
    163e:	91 a1       	ldd	r25, Z+33	; 0x21
    1640:	07 c0       	rjmp	.+14     	; 0x1650 <pf_read+0xca>
				else
					clst = get_fat(fs->curr_clust);
    1642:	f7 01       	movw	r30, r14
    1644:	62 a1       	ldd	r22, Z+34	; 0x22
    1646:	73 a1       	ldd	r23, Z+35	; 0x23
    1648:	84 a1       	ldd	r24, Z+36	; 0x24
    164a:	95 a1       	ldd	r25, Z+37	; 0x25
    164c:	0e 94 00 07 	call	0xe00	; 0xe00 <get_fat>
				if (clst <= 1)
    1650:	62 30       	cpi	r22, 0x02	; 2
    1652:	71 05       	cpc	r23, r1
    1654:	81 05       	cpc	r24, r1
    1656:	91 05       	cpc	r25, r1
    1658:	20 f4       	brcc	.+8      	; 0x1662 <pf_read+0xdc>
					ABORT(FR_DISK_ERR);
    165a:	f7 01       	movw	r30, r14
    165c:	11 82       	std	Z+1, r1	; 0x01
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	66 c0       	rjmp	.+204    	; 0x172e <pf_read+0x1a8>
				fs->curr_clust = clst; /* Update current cluster */
    1662:	f7 01       	movw	r30, r14
    1664:	62 a3       	std	Z+34, r22	; 0x22
    1666:	73 a3       	std	Z+35, r23	; 0x23
    1668:	84 a3       	std	Z+36, r24	; 0x24
    166a:	95 a3       	std	Z+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    166c:	f7 01       	movw	r30, r14
    166e:	62 a1       	ldd	r22, Z+34	; 0x22
    1670:	73 a1       	ldd	r23, Z+35	; 0x23
    1672:	84 a1       	ldd	r24, Z+36	; 0x24
    1674:	95 a1       	ldd	r25, Z+37	; 0x25
    1676:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <clust2sect>
			if (!sect)
    167a:	61 15       	cp	r22, r1
    167c:	71 05       	cpc	r23, r1
    167e:	81 05       	cpc	r24, r1
    1680:	91 05       	cpc	r25, r1
    1682:	21 f4       	brne	.+8      	; 0x168c <pf_read+0x106>
				ABORT(FR_DISK_ERR);
    1684:	f7 01       	movw	r30, r14
    1686:	11 82       	std	Z+1, r1	; 0x01
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	51 c0       	rjmp	.+162    	; 0x172e <pf_read+0x1a8>
			fs->dsect = sect + cs;
    168c:	dc 01       	movw	r26, r24
    168e:	cb 01       	movw	r24, r22
    1690:	8c 0f       	add	r24, r28
    1692:	91 1d       	adc	r25, r1
    1694:	a1 1d       	adc	r26, r1
    1696:	b1 1d       	adc	r27, r1
    1698:	f7 01       	movw	r30, r14
    169a:	86 a3       	std	Z+38, r24	; 0x26
    169c:	97 a3       	std	Z+39, r25	; 0x27
    169e:	a0 a7       	std	Z+40, r26	; 0x28
    16a0:	b1 a7       	std	Z+41, r27	; 0x29
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
    16a2:	f7 01       	movw	r30, r14
    16a4:	86 89       	ldd	r24, Z+22	; 0x16
    16a6:	97 89       	ldd	r25, Z+23	; 0x17
    16a8:	a0 8d       	ldd	r26, Z+24	; 0x18
    16aa:	b1 8d       	ldd	r27, Z+25	; 0x19
    16ac:	9c 01       	movw	r18, r24
    16ae:	31 70       	andi	r19, 0x01	; 1
    16b0:	c0 e0       	ldi	r28, 0x00	; 0
    16b2:	d2 e0       	ldi	r29, 0x02	; 2
    16b4:	c2 1b       	sub	r28, r18
    16b6:	d3 0b       	sbc	r29, r19
		if (rcnt > btr)
    16b8:	cc 16       	cp	r12, r28
    16ba:	dd 06       	cpc	r13, r29
    16bc:	08 f4       	brcc	.+2      	; 0x16c0 <pf_read+0x13a>
			rcnt = btr;
    16be:	e6 01       	movw	r28, r12
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    16c0:	f7 01       	movw	r30, r14
    16c2:	46 a1       	ldd	r20, Z+38	; 0x26
    16c4:	57 a1       	ldd	r21, Z+39	; 0x27
    16c6:	60 a5       	ldd	r22, Z+40	; 0x28
    16c8:	71 a5       	ldd	r23, Z+41	; 0x29
    16ca:	61 14       	cp	r6, r1
    16cc:	71 04       	cpc	r7, r1
    16ce:	19 f4       	brne	.+6      	; 0x16d6 <pf_read+0x150>
    16d0:	80 e0       	ldi	r24, 0x00	; 0
    16d2:	90 e0       	ldi	r25, 0x00	; 0
    16d4:	02 c0       	rjmp	.+4      	; 0x16da <pf_read+0x154>
    16d6:	8a 2d       	mov	r24, r10
    16d8:	9b 2d       	mov	r25, r11
    16da:	8e 01       	movw	r16, r28
    16dc:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
		if (dr)
    16e0:	88 23       	and	r24, r24
    16e2:	21 f0       	breq	.+8      	; 0x16ec <pf_read+0x166>
			ABORT(FR_DISK_ERR);
    16e4:	f7 01       	movw	r30, r14
    16e6:	11 82       	std	Z+1, r1	; 0x01
    16e8:	81 e0       	ldi	r24, 0x01	; 1
    16ea:	21 c0       	rjmp	.+66     	; 0x172e <pf_read+0x1a8>
		fs->fptr += rcnt;
    16ec:	f7 01       	movw	r30, r14
    16ee:	86 89       	ldd	r24, Z+22	; 0x16
    16f0:	97 89       	ldd	r25, Z+23	; 0x17
    16f2:	a0 8d       	ldd	r26, Z+24	; 0x18
    16f4:	b1 8d       	ldd	r27, Z+25	; 0x19
    16f6:	8c 0f       	add	r24, r28
    16f8:	9d 1f       	adc	r25, r29
    16fa:	a1 1d       	adc	r26, r1
    16fc:	b1 1d       	adc	r27, r1
    16fe:	86 8b       	std	Z+22, r24	; 0x16
    1700:	97 8b       	std	Z+23, r25	; 0x17
    1702:	a0 8f       	std	Z+24, r26	; 0x18
    1704:	b1 8f       	std	Z+25, r27	; 0x19
		rbuff += rcnt; /* Update pointers and counters */
    1706:	ac 0e       	add	r10, r28
    1708:	bd 1e       	adc	r11, r29
		btr -= rcnt;
    170a:	cc 1a       	sub	r12, r28
    170c:	dd 0a       	sbc	r13, r29
		*br += rcnt;
    170e:	f4 01       	movw	r30, r8
    1710:	80 81       	ld	r24, Z
    1712:	91 81       	ldd	r25, Z+1	; 0x01
    1714:	c8 0f       	add	r28, r24
    1716:	d9 1f       	adc	r29, r25
    1718:	d1 83       	std	Z+1, r29	; 0x01
    171a:	c0 83       	st	Z, r28

	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
    171c:	c1 14       	cp	r12, r1
    171e:	d1 04       	cpc	r13, r1
    1720:	09 f0       	breq	.+2      	; 0x1724 <pf_read+0x19e>
    1722:	68 cf       	rjmp	.-304    	; 0x15f4 <pf_read+0x6e>
		rbuff += rcnt; /* Update pointers and counters */
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
    1724:	80 e0       	ldi	r24, 0x00	; 0
    1726:	03 c0       	rjmp	.+6      	; 0x172e <pf_read+0x1a8>
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;

	*br = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1728:	85 e0       	ldi	r24, 0x05	; 5
    172a:	01 c0       	rjmp	.+2      	; 0x172e <pf_read+0x1a8>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    172c:	84 e0       	ldi	r24, 0x04	; 4
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
}
    172e:	df 91       	pop	r29
    1730:	cf 91       	pop	r28
    1732:	1f 91       	pop	r17
    1734:	0f 91       	pop	r16
    1736:	ff 90       	pop	r15
    1738:	ef 90       	pop	r14
    173a:	df 90       	pop	r13
    173c:	cf 90       	pop	r12
    173e:	bf 90       	pop	r11
    1740:	af 90       	pop	r10
    1742:	9f 90       	pop	r9
    1744:	8f 90       	pop	r8
    1746:	7f 90       	pop	r7
    1748:	6f 90       	pop	r6
    174a:	08 95       	ret

0000174c <pf_write>:

FRESULT pf_write(const void *buff, /* Pointer to the data to be written */
                 UINT        btw,  /* Number of bytes to write (0:Finalize the current write operation) */
                 UINT *      bw    /* Pointer to number of bytes written */
)
{
    174c:	4f 92       	push	r4
    174e:	5f 92       	push	r5
    1750:	6f 92       	push	r6
    1752:	7f 92       	push	r7
    1754:	af 92       	push	r10
    1756:	bf 92       	push	r11
    1758:	cf 92       	push	r12
    175a:	df 92       	push	r13
    175c:	ef 92       	push	r14
    175e:	ff 92       	push	r15
    1760:	0f 93       	push	r16
    1762:	1f 93       	push	r17
    1764:	cf 93       	push	r28
    1766:	df 93       	push	r29
    1768:	7c 01       	movw	r14, r24
    176a:	5b 01       	movw	r10, r22
    176c:	6a 01       	movw	r12, r20
	CLUST       clst;
	DWORD       sect, remain;
	const BYTE *p = buff;
	BYTE        cs;
	UINT        wcnt;
	FATFS *     fs = FatFs;
    176e:	c0 91 cd 03 	lds	r28, 0x03CD	; 0x8003cd <FatFs>
    1772:	d0 91 ce 03 	lds	r29, 0x03CE	; 0x8003ce <FatFs+0x1>

	*bw = 0;
    1776:	fa 01       	movw	r30, r20
    1778:	11 82       	std	Z+1, r1	; 0x01
    177a:	10 82       	st	Z, r1
	if (!fs)
    177c:	20 97       	sbiw	r28, 0x00	; 0
    177e:	09 f4       	brne	.+2      	; 0x1782 <pf_write+0x36>
    1780:	df c0       	rjmp	.+446    	; 0x1940 <pf_write+0x1f4>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    1782:	89 81       	ldd	r24, Y+1	; 0x01
    1784:	80 ff       	sbrs	r24, 0
    1786:	de c0       	rjmp	.+444    	; 0x1944 <pf_write+0x1f8>
		return FR_NOT_OPENED;

	if (!btw) { /* Finalize request */
    1788:	67 2b       	or	r22, r23
    178a:	99 f4       	brne	.+38     	; 0x17b2 <pf_write+0x66>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0))
    178c:	86 ff       	sbrs	r24, 6
    178e:	0c c0       	rjmp	.+24     	; 0x17a8 <pf_write+0x5c>
    1790:	40 e0       	ldi	r20, 0x00	; 0
    1792:	50 e0       	ldi	r21, 0x00	; 0
    1794:	ba 01       	movw	r22, r20
    1796:	80 e0       	ldi	r24, 0x00	; 0
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    179e:	88 23       	and	r24, r24
    17a0:	19 f0       	breq	.+6      	; 0x17a8 <pf_write+0x5c>
			ABORT(FR_DISK_ERR);
    17a2:	19 82       	std	Y+1, r1	; 0x01
    17a4:	81 e0       	ldi	r24, 0x01	; 1
    17a6:	cf c0       	rjmp	.+414    	; 0x1946 <pf_write+0x1fa>
		fs->flag &= ~FA__WIP;
    17a8:	89 81       	ldd	r24, Y+1	; 0x01
    17aa:	8f 7b       	andi	r24, 0xBF	; 191
    17ac:	89 83       	std	Y+1, r24	; 0x01
		return FR_OK;
    17ae:	80 e0       	ldi	r24, 0x00	; 0
    17b0:	ca c0       	rjmp	.+404    	; 0x1946 <pf_write+0x1fa>
	} else {                       /* Write data request */
		if (!(fs->flag & FA__WIP)) /* Round-down fptr to the sector boundary */
    17b2:	86 fd       	sbrc	r24, 6
    17b4:	0a c0       	rjmp	.+20     	; 0x17ca <pf_write+0x7e>
			fs->fptr &= 0xFFFFFE00;
    17b6:	8e 89       	ldd	r24, Y+22	; 0x16
    17b8:	9f 89       	ldd	r25, Y+23	; 0x17
    17ba:	a8 8d       	ldd	r26, Y+24	; 0x18
    17bc:	b9 8d       	ldd	r27, Y+25	; 0x19
    17be:	88 27       	eor	r24, r24
    17c0:	9e 7f       	andi	r25, 0xFE	; 254
    17c2:	8e 8b       	std	Y+22, r24	; 0x16
    17c4:	9f 8b       	std	Y+23, r25	; 0x17
    17c6:	a8 8f       	std	Y+24, r26	; 0x18
    17c8:	b9 8f       	std	Y+25, r27	; 0x19
	}
	remain = fs->fsize - fs->fptr;
    17ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17cc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    17ce:	ac 8d       	ldd	r26, Y+28	; 0x1c
    17d0:	bd 8d       	ldd	r27, Y+29	; 0x1d
    17d2:	4e 89       	ldd	r20, Y+22	; 0x16
    17d4:	5f 89       	ldd	r21, Y+23	; 0x17
    17d6:	68 8d       	ldd	r22, Y+24	; 0x18
    17d8:	79 8d       	ldd	r23, Y+25	; 0x19
    17da:	84 1b       	sub	r24, r20
    17dc:	95 0b       	sbc	r25, r21
    17de:	a6 0b       	sbc	r26, r22
    17e0:	b7 0b       	sbc	r27, r23
	if (btw > remain)
    17e2:	a5 01       	movw	r20, r10
    17e4:	60 e0       	ldi	r22, 0x00	; 0
    17e6:	70 e0       	ldi	r23, 0x00	; 0
    17e8:	84 17       	cp	r24, r20
    17ea:	95 07       	cpc	r25, r21
    17ec:	a6 07       	cpc	r26, r22
    17ee:	b7 07       	cpc	r27, r23
    17f0:	08 f0       	brcs	.+2      	; 0x17f4 <pf_write+0xa8>
    17f2:	a0 c0       	rjmp	.+320    	; 0x1934 <pf_write+0x1e8>
		btw = (UINT)remain; /* Truncate btw by remaining bytes */
    17f4:	5c 01       	movw	r10, r24
    17f6:	9e c0       	rjmp	.+316    	; 0x1934 <pf_write+0x1e8>

	while (btw) {                                          /* Repeat until all data transferred */
		if ((UINT)fs->fptr % 512 == 0) {                   /* On the sector boundary? */
    17f8:	8e 89       	ldd	r24, Y+22	; 0x16
    17fa:	9f 89       	ldd	r25, Y+23	; 0x17
    17fc:	a8 8d       	ldd	r26, Y+24	; 0x18
    17fe:	b9 8d       	ldd	r27, Y+25	; 0x19
    1800:	9c 01       	movw	r18, r24
    1802:	31 70       	andi	r19, 0x01	; 1
    1804:	23 2b       	or	r18, r19
    1806:	09 f0       	breq	.+2      	; 0x180a <pf_write+0xbe>
    1808:	4e c0       	rjmp	.+156    	; 0x18a6 <pf_write+0x15a>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    180a:	1a 81       	ldd	r17, Y+2	; 0x02
    180c:	11 50       	subi	r17, 0x01	; 1
    180e:	ac 01       	movw	r20, r24
    1810:	bd 01       	movw	r22, r26
    1812:	03 2e       	mov	r0, r19
    1814:	39 e0       	ldi	r19, 0x09	; 9
    1816:	76 95       	lsr	r23
    1818:	67 95       	ror	r22
    181a:	57 95       	ror	r21
    181c:	47 95       	ror	r20
    181e:	3a 95       	dec	r19
    1820:	d1 f7       	brne	.-12     	; 0x1816 <pf_write+0xca>
    1822:	30 2d       	mov	r19, r0
    1824:	14 23       	and	r17, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1826:	d9 f4       	brne	.+54     	; 0x185e <pf_write+0x112>
				if (fs->fptr == 0)                         /* On the top of the file? */
    1828:	89 2b       	or	r24, r25
    182a:	8a 2b       	or	r24, r26
    182c:	8b 2b       	or	r24, r27
    182e:	29 f4       	brne	.+10     	; 0x183a <pf_write+0xee>
					clst = fs->org_clust;
    1830:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1832:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1834:	88 a1       	ldd	r24, Y+32	; 0x20
    1836:	99 a1       	ldd	r25, Y+33	; 0x21
    1838:	06 c0       	rjmp	.+12     	; 0x1846 <pf_write+0xfa>
				else
					clst = get_fat(fs->curr_clust);
    183a:	6a a1       	ldd	r22, Y+34	; 0x22
    183c:	7b a1       	ldd	r23, Y+35	; 0x23
    183e:	8c a1       	ldd	r24, Y+36	; 0x24
    1840:	9d a1       	ldd	r25, Y+37	; 0x25
    1842:	0e 94 00 07 	call	0xe00	; 0xe00 <get_fat>
				if (clst <= 1)
    1846:	62 30       	cpi	r22, 0x02	; 2
    1848:	71 05       	cpc	r23, r1
    184a:	81 05       	cpc	r24, r1
    184c:	91 05       	cpc	r25, r1
    184e:	18 f4       	brcc	.+6      	; 0x1856 <pf_write+0x10a>
					ABORT(FR_DISK_ERR);
    1850:	19 82       	std	Y+1, r1	; 0x01
    1852:	81 e0       	ldi	r24, 0x01	; 1
    1854:	78 c0       	rjmp	.+240    	; 0x1946 <pf_write+0x1fa>
				fs->curr_clust = clst; /* Update current cluster */
    1856:	6a a3       	std	Y+34, r22	; 0x22
    1858:	7b a3       	std	Y+35, r23	; 0x23
    185a:	8c a3       	std	Y+36, r24	; 0x24
    185c:	9d a3       	std	Y+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    185e:	6a a1       	ldd	r22, Y+34	; 0x22
    1860:	7b a1       	ldd	r23, Y+35	; 0x23
    1862:	8c a1       	ldd	r24, Y+36	; 0x24
    1864:	9d a1       	ldd	r25, Y+37	; 0x25
    1866:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <clust2sect>
			if (!sect)
    186a:	61 15       	cp	r22, r1
    186c:	71 05       	cpc	r23, r1
    186e:	81 05       	cpc	r24, r1
    1870:	91 05       	cpc	r25, r1
    1872:	19 f4       	brne	.+6      	; 0x187a <pf_write+0x12e>
				ABORT(FR_DISK_ERR);
    1874:	19 82       	std	Y+1, r1	; 0x01
    1876:	81 e0       	ldi	r24, 0x01	; 1
    1878:	66 c0       	rjmp	.+204    	; 0x1946 <pf_write+0x1fa>
			fs->dsect = sect + cs;
    187a:	ab 01       	movw	r20, r22
    187c:	bc 01       	movw	r22, r24
    187e:	41 0f       	add	r20, r17
    1880:	51 1d       	adc	r21, r1
    1882:	61 1d       	adc	r22, r1
    1884:	71 1d       	adc	r23, r1
    1886:	4e a3       	std	Y+38, r20	; 0x26
    1888:	5f a3       	std	Y+39, r21	; 0x27
    188a:	68 a7       	std	Y+40, r22	; 0x28
    188c:	79 a7       	std	Y+41, r23	; 0x29
			if (disk_writep(0, fs->dsect))
    188e:	80 e0       	ldi	r24, 0x00	; 0
    1890:	90 e0       	ldi	r25, 0x00	; 0
    1892:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    1896:	88 23       	and	r24, r24
    1898:	19 f0       	breq	.+6      	; 0x18a0 <pf_write+0x154>
				ABORT(FR_DISK_ERR); /* Initiate a sector write operation */
    189a:	19 82       	std	Y+1, r1	; 0x01
    189c:	81 e0       	ldi	r24, 0x01	; 1
    189e:	53 c0       	rjmp	.+166    	; 0x1946 <pf_write+0x1fa>
			fs->flag |= FA__WIP;
    18a0:	89 81       	ldd	r24, Y+1	; 0x01
    18a2:	80 64       	ori	r24, 0x40	; 64
    18a4:	89 83       	std	Y+1, r24	; 0x01
		}
		wcnt = 512 - (UINT)fs->fptr % 512; /* Number of bytes to write to the sector */
    18a6:	8e 89       	ldd	r24, Y+22	; 0x16
    18a8:	9f 89       	ldd	r25, Y+23	; 0x17
    18aa:	a8 8d       	ldd	r26, Y+24	; 0x18
    18ac:	b9 8d       	ldd	r27, Y+25	; 0x19
    18ae:	91 70       	andi	r25, 0x01	; 1
    18b0:	00 e0       	ldi	r16, 0x00	; 0
    18b2:	12 e0       	ldi	r17, 0x02	; 2
    18b4:	08 1b       	sub	r16, r24
    18b6:	19 0b       	sbc	r17, r25
		if (wcnt > btw)
    18b8:	a0 16       	cp	r10, r16
    18ba:	b1 06       	cpc	r11, r17
    18bc:	08 f4       	brcc	.+2      	; 0x18c0 <pf_write+0x174>
			wcnt = btw;
    18be:	85 01       	movw	r16, r10
		if (disk_writep(p, wcnt))
    18c0:	28 01       	movw	r4, r16
    18c2:	61 2c       	mov	r6, r1
    18c4:	71 2c       	mov	r7, r1
    18c6:	b3 01       	movw	r22, r6
    18c8:	a2 01       	movw	r20, r4
    18ca:	c7 01       	movw	r24, r14
    18cc:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    18d0:	88 23       	and	r24, r24
    18d2:	19 f0       	breq	.+6      	; 0x18da <pf_write+0x18e>
			ABORT(FR_DISK_ERR); /* Send data to the sector */
    18d4:	19 82       	std	Y+1, r1	; 0x01
    18d6:	81 e0       	ldi	r24, 0x01	; 1
    18d8:	36 c0       	rjmp	.+108    	; 0x1946 <pf_write+0x1fa>
		fs->fptr += wcnt;
    18da:	8e 89       	ldd	r24, Y+22	; 0x16
    18dc:	9f 89       	ldd	r25, Y+23	; 0x17
    18de:	a8 8d       	ldd	r26, Y+24	; 0x18
    18e0:	b9 8d       	ldd	r27, Y+25	; 0x19
    18e2:	48 0e       	add	r4, r24
    18e4:	59 1e       	adc	r5, r25
    18e6:	6a 1e       	adc	r6, r26
    18e8:	7b 1e       	adc	r7, r27
    18ea:	4e 8a       	std	Y+22, r4	; 0x16
    18ec:	5f 8a       	std	Y+23, r5	; 0x17
    18ee:	68 8e       	std	Y+24, r6	; 0x18
    18f0:	79 8e       	std	Y+25, r7	; 0x19
		p += wcnt; /* Update pointers and counters */
    18f2:	e0 0e       	add	r14, r16
    18f4:	f1 1e       	adc	r15, r17
		btw -= wcnt;
    18f6:	a0 1a       	sub	r10, r16
    18f8:	b1 0a       	sbc	r11, r17
		*bw += wcnt;
    18fa:	f6 01       	movw	r30, r12
    18fc:	80 81       	ld	r24, Z
    18fe:	91 81       	ldd	r25, Z+1	; 0x01
    1900:	08 0f       	add	r16, r24
    1902:	19 1f       	adc	r17, r25
    1904:	11 83       	std	Z+1, r17	; 0x01
    1906:	00 83       	st	Z, r16
		if ((UINT)fs->fptr % 512 == 0) {
    1908:	8e 89       	ldd	r24, Y+22	; 0x16
    190a:	9f 89       	ldd	r25, Y+23	; 0x17
    190c:	a8 8d       	ldd	r26, Y+24	; 0x18
    190e:	b9 8d       	ldd	r27, Y+25	; 0x19
    1910:	91 70       	andi	r25, 0x01	; 1
    1912:	89 2b       	or	r24, r25
    1914:	79 f4       	brne	.+30     	; 0x1934 <pf_write+0x1e8>
			if (disk_writep(0, 0))
    1916:	40 e0       	ldi	r20, 0x00	; 0
    1918:	50 e0       	ldi	r21, 0x00	; 0
    191a:	ba 01       	movw	r22, r20
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    1924:	88 23       	and	r24, r24
    1926:	19 f0       	breq	.+6      	; 0x192e <pf_write+0x1e2>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
    1928:	19 82       	std	Y+1, r1	; 0x01
    192a:	81 e0       	ldi	r24, 0x01	; 1
    192c:	0c c0       	rjmp	.+24     	; 0x1946 <pf_write+0x1fa>
			fs->flag &= ~FA__WIP;
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	8f 7b       	andi	r24, 0xBF	; 191
    1932:	89 83       	std	Y+1, r24	; 0x01
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain)
		btw = (UINT)remain; /* Truncate btw by remaining bytes */

	while (btw) {                                          /* Repeat until all data transferred */
    1934:	a1 14       	cp	r10, r1
    1936:	b1 04       	cpc	r11, r1
    1938:	09 f0       	breq	.+2      	; 0x193c <pf_write+0x1f0>
    193a:	5e cf       	rjmp	.-324    	; 0x17f8 <pf_write+0xac>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    193c:	80 e0       	ldi	r24, 0x00	; 0
    193e:	03 c0       	rjmp	.+6      	; 0x1946 <pf_write+0x1fa>
	UINT        wcnt;
	FATFS *     fs = FatFs;

	*bw = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1940:	85 e0       	ldi	r24, 0x05	; 5
    1942:	01 c0       	rjmp	.+2      	; 0x1946 <pf_write+0x1fa>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1944:	84 e0       	ldi	r24, 0x04	; 4
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
}
    1946:	df 91       	pop	r29
    1948:	cf 91       	pop	r28
    194a:	1f 91       	pop	r17
    194c:	0f 91       	pop	r16
    194e:	ff 90       	pop	r15
    1950:	ef 90       	pop	r14
    1952:	df 90       	pop	r13
    1954:	cf 90       	pop	r12
    1956:	bf 90       	pop	r11
    1958:	af 90       	pop	r10
    195a:	7f 90       	pop	r7
    195c:	6f 90       	pop	r6
    195e:	5f 90       	pop	r5
    1960:	4f 90       	pop	r4
    1962:	08 95       	ret

00001964 <pf_lseek>:
/*-----------------------------------------------------------------------*/
#if _USE_LSEEK

FRESULT pf_lseek(DWORD ofs /* File pointer from top of file */
)
{
    1964:	4f 92       	push	r4
    1966:	5f 92       	push	r5
    1968:	6f 92       	push	r6
    196a:	7f 92       	push	r7
    196c:	8f 92       	push	r8
    196e:	9f 92       	push	r9
    1970:	af 92       	push	r10
    1972:	bf 92       	push	r11
    1974:	cf 92       	push	r12
    1976:	df 92       	push	r13
    1978:	ef 92       	push	r14
    197a:	ff 92       	push	r15
    197c:	cf 93       	push	r28
    197e:	df 93       	push	r29
    1980:	00 d0       	rcall	.+0      	; 0x1982 <pf_lseek+0x1e>
    1982:	00 d0       	rcall	.+0      	; 0x1984 <pf_lseek+0x20>
    1984:	00 d0       	rcall	.+0      	; 0x1986 <pf_lseek+0x22>
    1986:	cd b7       	in	r28, 0x3d	; 61
    1988:	de b7       	in	r29, 0x3e	; 62
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;
    198a:	20 91 cd 03 	lds	r18, 0x03CD	; 0x8003cd <FatFs>
    198e:	30 91 ce 03 	lds	r19, 0x03CE	; 0x8003ce <FatFs+0x1>
    1992:	3e 83       	std	Y+6, r19	; 0x06
    1994:	2d 83       	std	Y+5, r18	; 0x05

	if (!fs)
    1996:	21 15       	cp	r18, r1
    1998:	31 05       	cpc	r19, r1
    199a:	09 f4       	brne	.+2      	; 0x199e <pf_lseek+0x3a>
    199c:	f4 c0       	rjmp	.+488    	; 0x1b86 <pf_lseek+0x222>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    199e:	d9 01       	movw	r26, r18
    19a0:	11 96       	adiw	r26, 0x01	; 1
    19a2:	2c 91       	ld	r18, X
    19a4:	11 97       	sbiw	r26, 0x01	; 1
    19a6:	20 ff       	sbrs	r18, 0
    19a8:	f0 c0       	rjmp	.+480    	; 0x1b8a <pf_lseek+0x226>
		return FR_NOT_OPENED;

	if (ofs > fs->fsize)
    19aa:	5a 96       	adiw	r26, 0x1a	; 26
    19ac:	cd 90       	ld	r12, X+
    19ae:	dd 90       	ld	r13, X+
    19b0:	ed 90       	ld	r14, X+
    19b2:	fc 90       	ld	r15, X
    19b4:	5d 97       	sbiw	r26, 0x1d	; 29
    19b6:	c6 16       	cp	r12, r22
    19b8:	d7 06       	cpc	r13, r23
    19ba:	e8 06       	cpc	r14, r24
    19bc:	f9 06       	cpc	r15, r25
    19be:	10 f0       	brcs	.+4      	; 0x19c4 <pf_lseek+0x60>
    19c0:	6b 01       	movw	r12, r22
    19c2:	7c 01       	movw	r14, r24
		ofs = fs->fsize; /* Clip offset with the file size */
	ifptr    = fs->fptr;
    19c4:	ed 81       	ldd	r30, Y+5	; 0x05
    19c6:	fe 81       	ldd	r31, Y+6	; 0x06
    19c8:	46 88       	ldd	r4, Z+22	; 0x16
    19ca:	57 88       	ldd	r5, Z+23	; 0x17
    19cc:	60 8c       	ldd	r6, Z+24	; 0x18
    19ce:	71 8c       	ldd	r7, Z+25	; 0x19
	fs->fptr = 0;
    19d0:	16 8a       	std	Z+22, r1	; 0x16
    19d2:	17 8a       	std	Z+23, r1	; 0x17
    19d4:	10 8e       	std	Z+24, r1	; 0x18
    19d6:	11 8e       	std	Z+25, r1	; 0x19
	if (ofs > 0) {
    19d8:	c1 14       	cp	r12, r1
    19da:	d1 04       	cpc	r13, r1
    19dc:	e1 04       	cpc	r14, r1
    19de:	f1 04       	cpc	r15, r1
    19e0:	09 f4       	brne	.+2      	; 0x19e4 <pf_lseek+0x80>
    19e2:	d5 c0       	rjmp	.+426    	; 0x1b8e <pf_lseek+0x22a>
		bcs = (DWORD)fs->csize * 512;                            /* Cluster size (byte) */
    19e4:	82 80       	ldd	r8, Z+2	; 0x02
    19e6:	91 2c       	mov	r9, r1
    19e8:	a1 2c       	mov	r10, r1
    19ea:	b1 2c       	mov	r11, r1
    19ec:	07 2e       	mov	r0, r23
    19ee:	79 e0       	ldi	r23, 0x09	; 9
    19f0:	88 0c       	add	r8, r8
    19f2:	99 1c       	adc	r9, r9
    19f4:	aa 1c       	adc	r10, r10
    19f6:	bb 1c       	adc	r11, r11
    19f8:	7a 95       	dec	r23
    19fa:	d1 f7       	brne	.-12     	; 0x19f0 <pf_lseek+0x8c>
    19fc:	70 2d       	mov	r23, r0
		if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
    19fe:	41 14       	cp	r4, r1
    1a00:	51 04       	cpc	r5, r1
    1a02:	61 04       	cpc	r6, r1
    1a04:	71 04       	cpc	r7, r1
    1a06:	09 f4       	brne	.+2      	; 0x1a0a <pf_lseek+0xa6>
    1a08:	40 c0       	rjmp	.+128    	; 0x1a8a <pf_lseek+0x126>
    1a0a:	c7 01       	movw	r24, r14
    1a0c:	b6 01       	movw	r22, r12
    1a0e:	61 50       	subi	r22, 0x01	; 1
    1a10:	71 09       	sbc	r23, r1
    1a12:	81 09       	sbc	r24, r1
    1a14:	91 09       	sbc	r25, r1
    1a16:	a5 01       	movw	r20, r10
    1a18:	94 01       	movw	r18, r8
    1a1a:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <__udivmodsi4>
    1a1e:	29 83       	std	Y+1, r18	; 0x01
    1a20:	3a 83       	std	Y+2, r19	; 0x02
    1a22:	4b 83       	std	Y+3, r20	; 0x03
    1a24:	5c 83       	std	Y+4, r21	; 0x04
    1a26:	b1 e0       	ldi	r27, 0x01	; 1
    1a28:	4b 1a       	sub	r4, r27
    1a2a:	51 08       	sbc	r5, r1
    1a2c:	61 08       	sbc	r6, r1
    1a2e:	71 08       	sbc	r7, r1
    1a30:	c3 01       	movw	r24, r6
    1a32:	b2 01       	movw	r22, r4
    1a34:	a5 01       	movw	r20, r10
    1a36:	94 01       	movw	r18, r8
    1a38:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <__udivmodsi4>
    1a3c:	89 81       	ldd	r24, Y+1	; 0x01
    1a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a40:	ab 81       	ldd	r26, Y+3	; 0x03
    1a42:	bc 81       	ldd	r27, Y+4	; 0x04
    1a44:	82 17       	cp	r24, r18
    1a46:	93 07       	cpc	r25, r19
    1a48:	a4 07       	cpc	r26, r20
    1a4a:	b5 07       	cpc	r27, r21
    1a4c:	f0 f0       	brcs	.+60     	; 0x1a8a <pf_lseek+0x126>
			fs->fptr = (ifptr - 1) & ~(bcs - 1);                 /* start from the current cluster */
    1a4e:	88 27       	eor	r24, r24
    1a50:	99 27       	eor	r25, r25
    1a52:	dc 01       	movw	r26, r24
    1a54:	88 19       	sub	r24, r8
    1a56:	99 09       	sbc	r25, r9
    1a58:	aa 09       	sbc	r26, r10
    1a5a:	bb 09       	sbc	r27, r11
    1a5c:	48 22       	and	r4, r24
    1a5e:	59 22       	and	r5, r25
    1a60:	6a 22       	and	r6, r26
    1a62:	7b 22       	and	r7, r27
    1a64:	ad 81       	ldd	r26, Y+5	; 0x05
    1a66:	be 81       	ldd	r27, Y+6	; 0x06
    1a68:	56 96       	adiw	r26, 0x16	; 22
    1a6a:	4d 92       	st	X+, r4
    1a6c:	5d 92       	st	X+, r5
    1a6e:	6d 92       	st	X+, r6
    1a70:	7c 92       	st	X, r7
    1a72:	59 97       	sbiw	r26, 0x19	; 25
			ofs -= fs->fptr;
    1a74:	c4 18       	sub	r12, r4
    1a76:	d5 08       	sbc	r13, r5
    1a78:	e6 08       	sbc	r14, r6
    1a7a:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    1a7c:	92 96       	adiw	r26, 0x22	; 34
    1a7e:	6d 91       	ld	r22, X+
    1a80:	7d 91       	ld	r23, X+
    1a82:	8d 91       	ld	r24, X+
    1a84:	9c 91       	ld	r25, X
    1a86:	95 97       	sbiw	r26, 0x25	; 37
    1a88:	39 c0       	rjmp	.+114    	; 0x1afc <pf_lseek+0x198>
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
    1a8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a8e:	66 8d       	ldd	r22, Z+30	; 0x1e
    1a90:	77 8d       	ldd	r23, Z+31	; 0x1f
    1a92:	80 a1       	ldd	r24, Z+32	; 0x20
    1a94:	91 a1       	ldd	r25, Z+33	; 0x21
			fs->curr_clust = clst;
    1a96:	62 a3       	std	Z+34, r22	; 0x22
    1a98:	73 a3       	std	Z+35, r23	; 0x23
    1a9a:	84 a3       	std	Z+36, r24	; 0x24
    1a9c:	95 a3       	std	Z+37, r25	; 0x25
    1a9e:	2e c0       	rjmp	.+92     	; 0x1afc <pf_lseek+0x198>
		}
		while (ofs > bcs) {       /* Cluster following loop */
			clst = get_fat(clst); /* Follow cluster chain */
    1aa0:	0e 94 00 07 	call	0xe00	; 0xe00 <get_fat>
			if (clst <= 1 || clst >= fs->n_fatent)
    1aa4:	62 30       	cpi	r22, 0x02	; 2
    1aa6:	71 05       	cpc	r23, r1
    1aa8:	81 05       	cpc	r24, r1
    1aaa:	91 05       	cpc	r25, r1
    1aac:	58 f0       	brcs	.+22     	; 0x1ac4 <pf_lseek+0x160>
    1aae:	ed 81       	ldd	r30, Y+5	; 0x05
    1ab0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ab2:	46 80       	ldd	r4, Z+6	; 0x06
    1ab4:	57 80       	ldd	r5, Z+7	; 0x07
    1ab6:	60 84       	ldd	r6, Z+8	; 0x08
    1ab8:	71 84       	ldd	r7, Z+9	; 0x09
    1aba:	64 15       	cp	r22, r4
    1abc:	75 05       	cpc	r23, r5
    1abe:	86 05       	cpc	r24, r6
    1ac0:	97 05       	cpc	r25, r7
    1ac2:	30 f0       	brcs	.+12     	; 0x1ad0 <pf_lseek+0x16c>
				ABORT(FR_DISK_ERR);
    1ac4:	ad 81       	ldd	r26, Y+5	; 0x05
    1ac6:	be 81       	ldd	r27, Y+6	; 0x06
    1ac8:	11 96       	adiw	r26, 0x01	; 1
    1aca:	1c 92       	st	X, r1
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	60 c0       	rjmp	.+192    	; 0x1b90 <pf_lseek+0x22c>
			fs->curr_clust = clst;
    1ad0:	ed 81       	ldd	r30, Y+5	; 0x05
    1ad2:	fe 81       	ldd	r31, Y+6	; 0x06
    1ad4:	62 a3       	std	Z+34, r22	; 0x22
    1ad6:	73 a3       	std	Z+35, r23	; 0x23
    1ad8:	84 a3       	std	Z+36, r24	; 0x24
    1ada:	95 a3       	std	Z+37, r25	; 0x25
			fs->fptr += bcs;
    1adc:	46 88       	ldd	r4, Z+22	; 0x16
    1ade:	57 88       	ldd	r5, Z+23	; 0x17
    1ae0:	60 8c       	ldd	r6, Z+24	; 0x18
    1ae2:	71 8c       	ldd	r7, Z+25	; 0x19
    1ae4:	48 0c       	add	r4, r8
    1ae6:	59 1c       	adc	r5, r9
    1ae8:	6a 1c       	adc	r6, r10
    1aea:	7b 1c       	adc	r7, r11
    1aec:	46 8a       	std	Z+22, r4	; 0x16
    1aee:	57 8a       	std	Z+23, r5	; 0x17
    1af0:	60 8e       	std	Z+24, r6	; 0x18
    1af2:	71 8e       	std	Z+25, r7	; 0x19
			ofs -= bcs;
    1af4:	c8 18       	sub	r12, r8
    1af6:	d9 08       	sbc	r13, r9
    1af8:	ea 08       	sbc	r14, r10
    1afa:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {       /* Cluster following loop */
    1afc:	8c 14       	cp	r8, r12
    1afe:	9d 04       	cpc	r9, r13
    1b00:	ae 04       	cpc	r10, r14
    1b02:	bf 04       	cpc	r11, r15
    1b04:	68 f2       	brcs	.-102    	; 0x1aa0 <pf_lseek+0x13c>
				ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    1b06:	ed 81       	ldd	r30, Y+5	; 0x05
    1b08:	fe 81       	ldd	r31, Y+6	; 0x06
    1b0a:	86 88       	ldd	r8, Z+22	; 0x16
    1b0c:	97 88       	ldd	r9, Z+23	; 0x17
    1b0e:	a0 8c       	ldd	r10, Z+24	; 0x18
    1b10:	b1 8c       	ldd	r11, Z+25	; 0x19
    1b12:	c8 0c       	add	r12, r8
    1b14:	d9 1c       	adc	r13, r9
    1b16:	ea 1c       	adc	r14, r10
    1b18:	fb 1c       	adc	r15, r11
    1b1a:	c6 8a       	std	Z+22, r12	; 0x16
    1b1c:	d7 8a       	std	Z+23, r13	; 0x17
    1b1e:	e0 8e       	std	Z+24, r14	; 0x18
    1b20:	f1 8e       	std	Z+25, r15	; 0x19
		sect = clust2sect(clst); /* Current sector */
    1b22:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <clust2sect>
		if (!sect)
    1b26:	61 15       	cp	r22, r1
    1b28:	71 05       	cpc	r23, r1
    1b2a:	81 05       	cpc	r24, r1
    1b2c:	91 05       	cpc	r25, r1
    1b2e:	29 f4       	brne	.+10     	; 0x1b3a <pf_lseek+0x1d6>
			ABORT(FR_DISK_ERR);
    1b30:	ed 81       	ldd	r30, Y+5	; 0x05
    1b32:	fe 81       	ldd	r31, Y+6	; 0x06
    1b34:	11 82       	std	Z+1, r1	; 0x01
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	2b c0       	rjmp	.+86     	; 0x1b90 <pf_lseek+0x22c>
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    1b3a:	0b 2e       	mov	r0, r27
    1b3c:	b9 e0       	ldi	r27, 0x09	; 9
    1b3e:	f6 94       	lsr	r15
    1b40:	e7 94       	ror	r14
    1b42:	d7 94       	ror	r13
    1b44:	c7 94       	ror	r12
    1b46:	ba 95       	dec	r27
    1b48:	d1 f7       	brne	.-12     	; 0x1b3e <pf_lseek+0x1da>
    1b4a:	b0 2d       	mov	r27, r0
    1b4c:	ad 81       	ldd	r26, Y+5	; 0x05
    1b4e:	be 81       	ldd	r27, Y+6	; 0x06
    1b50:	12 96       	adiw	r26, 0x02	; 2
    1b52:	2c 91       	ld	r18, X
    1b54:	30 e0       	ldi	r19, 0x00	; 0
    1b56:	21 50       	subi	r18, 0x01	; 1
    1b58:	31 09       	sbc	r19, r1
    1b5a:	49 01       	movw	r8, r18
    1b5c:	33 0f       	add	r19, r19
    1b5e:	aa 08       	sbc	r10, r10
    1b60:	bb 08       	sbc	r11, r11
    1b62:	c8 20       	and	r12, r8
    1b64:	d9 20       	and	r13, r9
    1b66:	ea 20       	and	r14, r10
    1b68:	fb 20       	and	r15, r11
    1b6a:	dc 01       	movw	r26, r24
    1b6c:	cb 01       	movw	r24, r22
    1b6e:	8c 0d       	add	r24, r12
    1b70:	9d 1d       	adc	r25, r13
    1b72:	ae 1d       	adc	r26, r14
    1b74:	bf 1d       	adc	r27, r15
    1b76:	ed 81       	ldd	r30, Y+5	; 0x05
    1b78:	fe 81       	ldd	r31, Y+6	; 0x06
    1b7a:	86 a3       	std	Z+38, r24	; 0x26
    1b7c:	97 a3       	std	Z+39, r25	; 0x27
    1b7e:	a0 a7       	std	Z+40, r26	; 0x28
    1b80:	b1 a7       	std	Z+41, r27	; 0x29
	}

	return FR_OK;
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	05 c0       	rjmp	.+10     	; 0x1b90 <pf_lseek+0x22c>
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1b86:	85 e0       	ldi	r24, 0x05	; 5
    1b88:	03 c0       	rjmp	.+6      	; 0x1b90 <pf_lseek+0x22c>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1b8a:	84 e0       	ldi	r24, 0x04	; 4
    1b8c:	01 c0       	rjmp	.+2      	; 0x1b90 <pf_lseek+0x22c>
		if (!sect)
			ABORT(FR_DISK_ERR);
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
    1b8e:	80 e0       	ldi	r24, 0x00	; 0
}
    1b90:	26 96       	adiw	r28, 0x06	; 6
    1b92:	0f b6       	in	r0, 0x3f	; 63
    1b94:	f8 94       	cli
    1b96:	de bf       	out	0x3e, r29	; 62
    1b98:	0f be       	out	0x3f, r0	; 63
    1b9a:	cd bf       	out	0x3d, r28	; 61
    1b9c:	df 91       	pop	r29
    1b9e:	cf 91       	pop	r28
    1ba0:	ff 90       	pop	r15
    1ba2:	ef 90       	pop	r14
    1ba4:	df 90       	pop	r13
    1ba6:	cf 90       	pop	r12
    1ba8:	bf 90       	pop	r11
    1baa:	af 90       	pop	r10
    1bac:	9f 90       	pop	r9
    1bae:	8f 90       	pop	r8
    1bb0:	7f 90       	pop	r7
    1bb2:	6f 90       	pop	r6
    1bb4:	5f 90       	pop	r5
    1bb6:	4f 90       	pop	r4
    1bb8:	08 95       	ret

00001bba <__divmodhi4>:
    1bba:	97 fb       	bst	r25, 7
    1bbc:	07 2e       	mov	r0, r23
    1bbe:	16 f4       	brtc	.+4      	; 0x1bc4 <__divmodhi4+0xa>
    1bc0:	00 94       	com	r0
    1bc2:	07 d0       	rcall	.+14     	; 0x1bd2 <__divmodhi4_neg1>
    1bc4:	77 fd       	sbrc	r23, 7
    1bc6:	09 d0       	rcall	.+18     	; 0x1bda <__divmodhi4_neg2>
    1bc8:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <__udivmodhi4>
    1bcc:	07 fc       	sbrc	r0, 7
    1bce:	05 d0       	rcall	.+10     	; 0x1bda <__divmodhi4_neg2>
    1bd0:	3e f4       	brtc	.+14     	; 0x1be0 <__divmodhi4_exit>

00001bd2 <__divmodhi4_neg1>:
    1bd2:	90 95       	com	r25
    1bd4:	81 95       	neg	r24
    1bd6:	9f 4f       	sbci	r25, 0xFF	; 255
    1bd8:	08 95       	ret

00001bda <__divmodhi4_neg2>:
    1bda:	70 95       	com	r23
    1bdc:	61 95       	neg	r22
    1bde:	7f 4f       	sbci	r23, 0xFF	; 255

00001be0 <__divmodhi4_exit>:
    1be0:	08 95       	ret

00001be2 <__udivmodsi4>:
    1be2:	a1 e2       	ldi	r26, 0x21	; 33
    1be4:	1a 2e       	mov	r1, r26
    1be6:	aa 1b       	sub	r26, r26
    1be8:	bb 1b       	sub	r27, r27
    1bea:	fd 01       	movw	r30, r26
    1bec:	0d c0       	rjmp	.+26     	; 0x1c08 <__udivmodsi4_ep>

00001bee <__udivmodsi4_loop>:
    1bee:	aa 1f       	adc	r26, r26
    1bf0:	bb 1f       	adc	r27, r27
    1bf2:	ee 1f       	adc	r30, r30
    1bf4:	ff 1f       	adc	r31, r31
    1bf6:	a2 17       	cp	r26, r18
    1bf8:	b3 07       	cpc	r27, r19
    1bfa:	e4 07       	cpc	r30, r20
    1bfc:	f5 07       	cpc	r31, r21
    1bfe:	20 f0       	brcs	.+8      	; 0x1c08 <__udivmodsi4_ep>
    1c00:	a2 1b       	sub	r26, r18
    1c02:	b3 0b       	sbc	r27, r19
    1c04:	e4 0b       	sbc	r30, r20
    1c06:	f5 0b       	sbc	r31, r21

00001c08 <__udivmodsi4_ep>:
    1c08:	66 1f       	adc	r22, r22
    1c0a:	77 1f       	adc	r23, r23
    1c0c:	88 1f       	adc	r24, r24
    1c0e:	99 1f       	adc	r25, r25
    1c10:	1a 94       	dec	r1
    1c12:	69 f7       	brne	.-38     	; 0x1bee <__udivmodsi4_loop>
    1c14:	60 95       	com	r22
    1c16:	70 95       	com	r23
    1c18:	80 95       	com	r24
    1c1a:	90 95       	com	r25
    1c1c:	9b 01       	movw	r18, r22
    1c1e:	ac 01       	movw	r20, r24
    1c20:	bd 01       	movw	r22, r26
    1c22:	cf 01       	movw	r24, r30
    1c24:	08 95       	ret

00001c26 <__muluhisi3>:
    1c26:	0e 94 32 0e 	call	0x1c64	; 0x1c64 <__umulhisi3>
    1c2a:	a5 9f       	mul	r26, r21
    1c2c:	90 0d       	add	r25, r0
    1c2e:	b4 9f       	mul	r27, r20
    1c30:	90 0d       	add	r25, r0
    1c32:	a4 9f       	mul	r26, r20
    1c34:	80 0d       	add	r24, r0
    1c36:	91 1d       	adc	r25, r1
    1c38:	11 24       	eor	r1, r1
    1c3a:	08 95       	ret

00001c3c <__udivmodhi4>:
    1c3c:	aa 1b       	sub	r26, r26
    1c3e:	bb 1b       	sub	r27, r27
    1c40:	51 e1       	ldi	r21, 0x11	; 17
    1c42:	07 c0       	rjmp	.+14     	; 0x1c52 <__udivmodhi4_ep>

00001c44 <__udivmodhi4_loop>:
    1c44:	aa 1f       	adc	r26, r26
    1c46:	bb 1f       	adc	r27, r27
    1c48:	a6 17       	cp	r26, r22
    1c4a:	b7 07       	cpc	r27, r23
    1c4c:	10 f0       	brcs	.+4      	; 0x1c52 <__udivmodhi4_ep>
    1c4e:	a6 1b       	sub	r26, r22
    1c50:	b7 0b       	sbc	r27, r23

00001c52 <__udivmodhi4_ep>:
    1c52:	88 1f       	adc	r24, r24
    1c54:	99 1f       	adc	r25, r25
    1c56:	5a 95       	dec	r21
    1c58:	a9 f7       	brne	.-22     	; 0x1c44 <__udivmodhi4_loop>
    1c5a:	80 95       	com	r24
    1c5c:	90 95       	com	r25
    1c5e:	bc 01       	movw	r22, r24
    1c60:	cd 01       	movw	r24, r26
    1c62:	08 95       	ret

00001c64 <__umulhisi3>:
    1c64:	a2 9f       	mul	r26, r18
    1c66:	b0 01       	movw	r22, r0
    1c68:	b3 9f       	mul	r27, r19
    1c6a:	c0 01       	movw	r24, r0
    1c6c:	a3 9f       	mul	r26, r19
    1c6e:	70 0d       	add	r23, r0
    1c70:	81 1d       	adc	r24, r1
    1c72:	11 24       	eor	r1, r1
    1c74:	91 1d       	adc	r25, r1
    1c76:	b2 9f       	mul	r27, r18
    1c78:	70 0d       	add	r23, r0
    1c7a:	81 1d       	adc	r24, r1
    1c7c:	11 24       	eor	r1, r1
    1c7e:	91 1d       	adc	r25, r1
    1c80:	08 95       	ret

00001c82 <sprintf>:
    1c82:	ae e0       	ldi	r26, 0x0E	; 14
    1c84:	b0 e0       	ldi	r27, 0x00	; 0
    1c86:	e7 e4       	ldi	r30, 0x47	; 71
    1c88:	fe e0       	ldi	r31, 0x0E	; 14
    1c8a:	0c 94 02 11 	jmp	0x2204	; 0x2204 <__prologue_saves__+0x1c>
    1c8e:	0d 89       	ldd	r16, Y+21	; 0x15
    1c90:	1e 89       	ldd	r17, Y+22	; 0x16
    1c92:	86 e0       	ldi	r24, 0x06	; 6
    1c94:	8c 83       	std	Y+4, r24	; 0x04
    1c96:	1a 83       	std	Y+2, r17	; 0x02
    1c98:	09 83       	std	Y+1, r16	; 0x01
    1c9a:	8f ef       	ldi	r24, 0xFF	; 255
    1c9c:	9f e7       	ldi	r25, 0x7F	; 127
    1c9e:	9e 83       	std	Y+6, r25	; 0x06
    1ca0:	8d 83       	std	Y+5, r24	; 0x05
    1ca2:	ae 01       	movw	r20, r28
    1ca4:	47 5e       	subi	r20, 0xE7	; 231
    1ca6:	5f 4f       	sbci	r21, 0xFF	; 255
    1ca8:	6f 89       	ldd	r22, Y+23	; 0x17
    1caa:	78 8d       	ldd	r23, Y+24	; 0x18
    1cac:	ce 01       	movw	r24, r28
    1cae:	01 96       	adiw	r24, 0x01	; 1
    1cb0:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <vfprintf>
    1cb4:	ef 81       	ldd	r30, Y+7	; 0x07
    1cb6:	f8 85       	ldd	r31, Y+8	; 0x08
    1cb8:	e0 0f       	add	r30, r16
    1cba:	f1 1f       	adc	r31, r17
    1cbc:	10 82       	st	Z, r1
    1cbe:	2e 96       	adiw	r28, 0x0e	; 14
    1cc0:	e4 e0       	ldi	r30, 0x04	; 4
    1cc2:	0c 94 1e 11 	jmp	0x223c	; 0x223c <__epilogue_restores__+0x1c>

00001cc6 <vfprintf>:
    1cc6:	ab e0       	ldi	r26, 0x0B	; 11
    1cc8:	b0 e0       	ldi	r27, 0x00	; 0
    1cca:	e9 e6       	ldi	r30, 0x69	; 105
    1ccc:	fe e0       	ldi	r31, 0x0E	; 14
    1cce:	0c 94 f4 10 	jmp	0x21e8	; 0x21e8 <__prologue_saves__>
    1cd2:	6c 01       	movw	r12, r24
    1cd4:	7b 01       	movw	r14, r22
    1cd6:	8a 01       	movw	r16, r20
    1cd8:	fc 01       	movw	r30, r24
    1cda:	17 82       	std	Z+7, r1	; 0x07
    1cdc:	16 82       	std	Z+6, r1	; 0x06
    1cde:	83 81       	ldd	r24, Z+3	; 0x03
    1ce0:	81 ff       	sbrs	r24, 1
    1ce2:	cc c1       	rjmp	.+920    	; 0x207c <vfprintf+0x3b6>
    1ce4:	ce 01       	movw	r24, r28
    1ce6:	01 96       	adiw	r24, 0x01	; 1
    1ce8:	3c 01       	movw	r6, r24
    1cea:	f6 01       	movw	r30, r12
    1cec:	93 81       	ldd	r25, Z+3	; 0x03
    1cee:	f7 01       	movw	r30, r14
    1cf0:	93 fd       	sbrc	r25, 3
    1cf2:	85 91       	lpm	r24, Z+
    1cf4:	93 ff       	sbrs	r25, 3
    1cf6:	81 91       	ld	r24, Z+
    1cf8:	7f 01       	movw	r14, r30
    1cfa:	88 23       	and	r24, r24
    1cfc:	09 f4       	brne	.+2      	; 0x1d00 <vfprintf+0x3a>
    1cfe:	ba c1       	rjmp	.+884    	; 0x2074 <vfprintf+0x3ae>
    1d00:	85 32       	cpi	r24, 0x25	; 37
    1d02:	39 f4       	brne	.+14     	; 0x1d12 <vfprintf+0x4c>
    1d04:	93 fd       	sbrc	r25, 3
    1d06:	85 91       	lpm	r24, Z+
    1d08:	93 ff       	sbrs	r25, 3
    1d0a:	81 91       	ld	r24, Z+
    1d0c:	7f 01       	movw	r14, r30
    1d0e:	85 32       	cpi	r24, 0x25	; 37
    1d10:	29 f4       	brne	.+10     	; 0x1d1c <vfprintf+0x56>
    1d12:	b6 01       	movw	r22, r12
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    1d1a:	e7 cf       	rjmp	.-50     	; 0x1cea <vfprintf+0x24>
    1d1c:	91 2c       	mov	r9, r1
    1d1e:	21 2c       	mov	r2, r1
    1d20:	31 2c       	mov	r3, r1
    1d22:	ff e1       	ldi	r31, 0x1F	; 31
    1d24:	f3 15       	cp	r31, r3
    1d26:	d8 f0       	brcs	.+54     	; 0x1d5e <vfprintf+0x98>
    1d28:	8b 32       	cpi	r24, 0x2B	; 43
    1d2a:	79 f0       	breq	.+30     	; 0x1d4a <vfprintf+0x84>
    1d2c:	38 f4       	brcc	.+14     	; 0x1d3c <vfprintf+0x76>
    1d2e:	80 32       	cpi	r24, 0x20	; 32
    1d30:	79 f0       	breq	.+30     	; 0x1d50 <vfprintf+0x8a>
    1d32:	83 32       	cpi	r24, 0x23	; 35
    1d34:	a1 f4       	brne	.+40     	; 0x1d5e <vfprintf+0x98>
    1d36:	23 2d       	mov	r18, r3
    1d38:	20 61       	ori	r18, 0x10	; 16
    1d3a:	1d c0       	rjmp	.+58     	; 0x1d76 <vfprintf+0xb0>
    1d3c:	8d 32       	cpi	r24, 0x2D	; 45
    1d3e:	61 f0       	breq	.+24     	; 0x1d58 <vfprintf+0x92>
    1d40:	80 33       	cpi	r24, 0x30	; 48
    1d42:	69 f4       	brne	.+26     	; 0x1d5e <vfprintf+0x98>
    1d44:	23 2d       	mov	r18, r3
    1d46:	21 60       	ori	r18, 0x01	; 1
    1d48:	16 c0       	rjmp	.+44     	; 0x1d76 <vfprintf+0xb0>
    1d4a:	83 2d       	mov	r24, r3
    1d4c:	82 60       	ori	r24, 0x02	; 2
    1d4e:	38 2e       	mov	r3, r24
    1d50:	e3 2d       	mov	r30, r3
    1d52:	e4 60       	ori	r30, 0x04	; 4
    1d54:	3e 2e       	mov	r3, r30
    1d56:	2a c0       	rjmp	.+84     	; 0x1dac <vfprintf+0xe6>
    1d58:	f3 2d       	mov	r31, r3
    1d5a:	f8 60       	ori	r31, 0x08	; 8
    1d5c:	1d c0       	rjmp	.+58     	; 0x1d98 <vfprintf+0xd2>
    1d5e:	37 fc       	sbrc	r3, 7
    1d60:	2d c0       	rjmp	.+90     	; 0x1dbc <vfprintf+0xf6>
    1d62:	20 ed       	ldi	r18, 0xD0	; 208
    1d64:	28 0f       	add	r18, r24
    1d66:	2a 30       	cpi	r18, 0x0A	; 10
    1d68:	40 f0       	brcs	.+16     	; 0x1d7a <vfprintf+0xb4>
    1d6a:	8e 32       	cpi	r24, 0x2E	; 46
    1d6c:	b9 f4       	brne	.+46     	; 0x1d9c <vfprintf+0xd6>
    1d6e:	36 fc       	sbrc	r3, 6
    1d70:	81 c1       	rjmp	.+770    	; 0x2074 <vfprintf+0x3ae>
    1d72:	23 2d       	mov	r18, r3
    1d74:	20 64       	ori	r18, 0x40	; 64
    1d76:	32 2e       	mov	r3, r18
    1d78:	19 c0       	rjmp	.+50     	; 0x1dac <vfprintf+0xe6>
    1d7a:	36 fe       	sbrs	r3, 6
    1d7c:	06 c0       	rjmp	.+12     	; 0x1d8a <vfprintf+0xc4>
    1d7e:	8a e0       	ldi	r24, 0x0A	; 10
    1d80:	98 9e       	mul	r9, r24
    1d82:	20 0d       	add	r18, r0
    1d84:	11 24       	eor	r1, r1
    1d86:	92 2e       	mov	r9, r18
    1d88:	11 c0       	rjmp	.+34     	; 0x1dac <vfprintf+0xe6>
    1d8a:	ea e0       	ldi	r30, 0x0A	; 10
    1d8c:	2e 9e       	mul	r2, r30
    1d8e:	20 0d       	add	r18, r0
    1d90:	11 24       	eor	r1, r1
    1d92:	22 2e       	mov	r2, r18
    1d94:	f3 2d       	mov	r31, r3
    1d96:	f0 62       	ori	r31, 0x20	; 32
    1d98:	3f 2e       	mov	r3, r31
    1d9a:	08 c0       	rjmp	.+16     	; 0x1dac <vfprintf+0xe6>
    1d9c:	8c 36       	cpi	r24, 0x6C	; 108
    1d9e:	21 f4       	brne	.+8      	; 0x1da8 <vfprintf+0xe2>
    1da0:	83 2d       	mov	r24, r3
    1da2:	80 68       	ori	r24, 0x80	; 128
    1da4:	38 2e       	mov	r3, r24
    1da6:	02 c0       	rjmp	.+4      	; 0x1dac <vfprintf+0xe6>
    1da8:	88 36       	cpi	r24, 0x68	; 104
    1daa:	41 f4       	brne	.+16     	; 0x1dbc <vfprintf+0xf6>
    1dac:	f7 01       	movw	r30, r14
    1dae:	93 fd       	sbrc	r25, 3
    1db0:	85 91       	lpm	r24, Z+
    1db2:	93 ff       	sbrs	r25, 3
    1db4:	81 91       	ld	r24, Z+
    1db6:	7f 01       	movw	r14, r30
    1db8:	81 11       	cpse	r24, r1
    1dba:	b3 cf       	rjmp	.-154    	; 0x1d22 <vfprintf+0x5c>
    1dbc:	98 2f       	mov	r25, r24
    1dbe:	9f 7d       	andi	r25, 0xDF	; 223
    1dc0:	95 54       	subi	r25, 0x45	; 69
    1dc2:	93 30       	cpi	r25, 0x03	; 3
    1dc4:	28 f4       	brcc	.+10     	; 0x1dd0 <vfprintf+0x10a>
    1dc6:	0c 5f       	subi	r16, 0xFC	; 252
    1dc8:	1f 4f       	sbci	r17, 0xFF	; 255
    1dca:	9f e3       	ldi	r25, 0x3F	; 63
    1dcc:	99 83       	std	Y+1, r25	; 0x01
    1dce:	0d c0       	rjmp	.+26     	; 0x1dea <vfprintf+0x124>
    1dd0:	83 36       	cpi	r24, 0x63	; 99
    1dd2:	31 f0       	breq	.+12     	; 0x1de0 <vfprintf+0x11a>
    1dd4:	83 37       	cpi	r24, 0x73	; 115
    1dd6:	71 f0       	breq	.+28     	; 0x1df4 <vfprintf+0x12e>
    1dd8:	83 35       	cpi	r24, 0x53	; 83
    1dda:	09 f0       	breq	.+2      	; 0x1dde <vfprintf+0x118>
    1ddc:	59 c0       	rjmp	.+178    	; 0x1e90 <vfprintf+0x1ca>
    1dde:	21 c0       	rjmp	.+66     	; 0x1e22 <vfprintf+0x15c>
    1de0:	f8 01       	movw	r30, r16
    1de2:	80 81       	ld	r24, Z
    1de4:	89 83       	std	Y+1, r24	; 0x01
    1de6:	0e 5f       	subi	r16, 0xFE	; 254
    1de8:	1f 4f       	sbci	r17, 0xFF	; 255
    1dea:	88 24       	eor	r8, r8
    1dec:	83 94       	inc	r8
    1dee:	91 2c       	mov	r9, r1
    1df0:	53 01       	movw	r10, r6
    1df2:	13 c0       	rjmp	.+38     	; 0x1e1a <vfprintf+0x154>
    1df4:	28 01       	movw	r4, r16
    1df6:	f2 e0       	ldi	r31, 0x02	; 2
    1df8:	4f 0e       	add	r4, r31
    1dfa:	51 1c       	adc	r5, r1
    1dfc:	f8 01       	movw	r30, r16
    1dfe:	a0 80       	ld	r10, Z
    1e00:	b1 80       	ldd	r11, Z+1	; 0x01
    1e02:	36 fe       	sbrs	r3, 6
    1e04:	03 c0       	rjmp	.+6      	; 0x1e0c <vfprintf+0x146>
    1e06:	69 2d       	mov	r22, r9
    1e08:	70 e0       	ldi	r23, 0x00	; 0
    1e0a:	02 c0       	rjmp	.+4      	; 0x1e10 <vfprintf+0x14a>
    1e0c:	6f ef       	ldi	r22, 0xFF	; 255
    1e0e:	7f ef       	ldi	r23, 0xFF	; 255
    1e10:	c5 01       	movw	r24, r10
    1e12:	0e 94 4f 10 	call	0x209e	; 0x209e <strnlen>
    1e16:	4c 01       	movw	r8, r24
    1e18:	82 01       	movw	r16, r4
    1e1a:	f3 2d       	mov	r31, r3
    1e1c:	ff 77       	andi	r31, 0x7F	; 127
    1e1e:	3f 2e       	mov	r3, r31
    1e20:	16 c0       	rjmp	.+44     	; 0x1e4e <vfprintf+0x188>
    1e22:	28 01       	movw	r4, r16
    1e24:	22 e0       	ldi	r18, 0x02	; 2
    1e26:	42 0e       	add	r4, r18
    1e28:	51 1c       	adc	r5, r1
    1e2a:	f8 01       	movw	r30, r16
    1e2c:	a0 80       	ld	r10, Z
    1e2e:	b1 80       	ldd	r11, Z+1	; 0x01
    1e30:	36 fe       	sbrs	r3, 6
    1e32:	03 c0       	rjmp	.+6      	; 0x1e3a <vfprintf+0x174>
    1e34:	69 2d       	mov	r22, r9
    1e36:	70 e0       	ldi	r23, 0x00	; 0
    1e38:	02 c0       	rjmp	.+4      	; 0x1e3e <vfprintf+0x178>
    1e3a:	6f ef       	ldi	r22, 0xFF	; 255
    1e3c:	7f ef       	ldi	r23, 0xFF	; 255
    1e3e:	c5 01       	movw	r24, r10
    1e40:	0e 94 44 10 	call	0x2088	; 0x2088 <strnlen_P>
    1e44:	4c 01       	movw	r8, r24
    1e46:	f3 2d       	mov	r31, r3
    1e48:	f0 68       	ori	r31, 0x80	; 128
    1e4a:	3f 2e       	mov	r3, r31
    1e4c:	82 01       	movw	r16, r4
    1e4e:	33 fc       	sbrc	r3, 3
    1e50:	1b c0       	rjmp	.+54     	; 0x1e88 <vfprintf+0x1c2>
    1e52:	82 2d       	mov	r24, r2
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	88 16       	cp	r8, r24
    1e58:	99 06       	cpc	r9, r25
    1e5a:	b0 f4       	brcc	.+44     	; 0x1e88 <vfprintf+0x1c2>
    1e5c:	b6 01       	movw	r22, r12
    1e5e:	80 e2       	ldi	r24, 0x20	; 32
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    1e66:	2a 94       	dec	r2
    1e68:	f4 cf       	rjmp	.-24     	; 0x1e52 <vfprintf+0x18c>
    1e6a:	f5 01       	movw	r30, r10
    1e6c:	37 fc       	sbrc	r3, 7
    1e6e:	85 91       	lpm	r24, Z+
    1e70:	37 fe       	sbrs	r3, 7
    1e72:	81 91       	ld	r24, Z+
    1e74:	5f 01       	movw	r10, r30
    1e76:	b6 01       	movw	r22, r12
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    1e7e:	21 10       	cpse	r2, r1
    1e80:	2a 94       	dec	r2
    1e82:	21 e0       	ldi	r18, 0x01	; 1
    1e84:	82 1a       	sub	r8, r18
    1e86:	91 08       	sbc	r9, r1
    1e88:	81 14       	cp	r8, r1
    1e8a:	91 04       	cpc	r9, r1
    1e8c:	71 f7       	brne	.-36     	; 0x1e6a <vfprintf+0x1a4>
    1e8e:	e8 c0       	rjmp	.+464    	; 0x2060 <vfprintf+0x39a>
    1e90:	84 36       	cpi	r24, 0x64	; 100
    1e92:	11 f0       	breq	.+4      	; 0x1e98 <vfprintf+0x1d2>
    1e94:	89 36       	cpi	r24, 0x69	; 105
    1e96:	41 f5       	brne	.+80     	; 0x1ee8 <vfprintf+0x222>
    1e98:	f8 01       	movw	r30, r16
    1e9a:	37 fe       	sbrs	r3, 7
    1e9c:	07 c0       	rjmp	.+14     	; 0x1eac <vfprintf+0x1e6>
    1e9e:	60 81       	ld	r22, Z
    1ea0:	71 81       	ldd	r23, Z+1	; 0x01
    1ea2:	82 81       	ldd	r24, Z+2	; 0x02
    1ea4:	93 81       	ldd	r25, Z+3	; 0x03
    1ea6:	0c 5f       	subi	r16, 0xFC	; 252
    1ea8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eaa:	08 c0       	rjmp	.+16     	; 0x1ebc <vfprintf+0x1f6>
    1eac:	60 81       	ld	r22, Z
    1eae:	71 81       	ldd	r23, Z+1	; 0x01
    1eb0:	07 2e       	mov	r0, r23
    1eb2:	00 0c       	add	r0, r0
    1eb4:	88 0b       	sbc	r24, r24
    1eb6:	99 0b       	sbc	r25, r25
    1eb8:	0e 5f       	subi	r16, 0xFE	; 254
    1eba:	1f 4f       	sbci	r17, 0xFF	; 255
    1ebc:	f3 2d       	mov	r31, r3
    1ebe:	ff 76       	andi	r31, 0x6F	; 111
    1ec0:	3f 2e       	mov	r3, r31
    1ec2:	97 ff       	sbrs	r25, 7
    1ec4:	09 c0       	rjmp	.+18     	; 0x1ed8 <vfprintf+0x212>
    1ec6:	90 95       	com	r25
    1ec8:	80 95       	com	r24
    1eca:	70 95       	com	r23
    1ecc:	61 95       	neg	r22
    1ece:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed0:	8f 4f       	sbci	r24, 0xFF	; 255
    1ed2:	9f 4f       	sbci	r25, 0xFF	; 255
    1ed4:	f0 68       	ori	r31, 0x80	; 128
    1ed6:	3f 2e       	mov	r3, r31
    1ed8:	2a e0       	ldi	r18, 0x0A	; 10
    1eda:	30 e0       	ldi	r19, 0x00	; 0
    1edc:	a3 01       	movw	r20, r6
    1ede:	0e 94 96 10 	call	0x212c	; 0x212c <__ultoa_invert>
    1ee2:	88 2e       	mov	r8, r24
    1ee4:	86 18       	sub	r8, r6
    1ee6:	45 c0       	rjmp	.+138    	; 0x1f72 <vfprintf+0x2ac>
    1ee8:	85 37       	cpi	r24, 0x75	; 117
    1eea:	31 f4       	brne	.+12     	; 0x1ef8 <vfprintf+0x232>
    1eec:	23 2d       	mov	r18, r3
    1eee:	2f 7e       	andi	r18, 0xEF	; 239
    1ef0:	b2 2e       	mov	r11, r18
    1ef2:	2a e0       	ldi	r18, 0x0A	; 10
    1ef4:	30 e0       	ldi	r19, 0x00	; 0
    1ef6:	25 c0       	rjmp	.+74     	; 0x1f42 <vfprintf+0x27c>
    1ef8:	93 2d       	mov	r25, r3
    1efa:	99 7f       	andi	r25, 0xF9	; 249
    1efc:	b9 2e       	mov	r11, r25
    1efe:	8f 36       	cpi	r24, 0x6F	; 111
    1f00:	c1 f0       	breq	.+48     	; 0x1f32 <vfprintf+0x26c>
    1f02:	18 f4       	brcc	.+6      	; 0x1f0a <vfprintf+0x244>
    1f04:	88 35       	cpi	r24, 0x58	; 88
    1f06:	79 f0       	breq	.+30     	; 0x1f26 <vfprintf+0x260>
    1f08:	b5 c0       	rjmp	.+362    	; 0x2074 <vfprintf+0x3ae>
    1f0a:	80 37       	cpi	r24, 0x70	; 112
    1f0c:	19 f0       	breq	.+6      	; 0x1f14 <vfprintf+0x24e>
    1f0e:	88 37       	cpi	r24, 0x78	; 120
    1f10:	21 f0       	breq	.+8      	; 0x1f1a <vfprintf+0x254>
    1f12:	b0 c0       	rjmp	.+352    	; 0x2074 <vfprintf+0x3ae>
    1f14:	e9 2f       	mov	r30, r25
    1f16:	e0 61       	ori	r30, 0x10	; 16
    1f18:	be 2e       	mov	r11, r30
    1f1a:	b4 fe       	sbrs	r11, 4
    1f1c:	0d c0       	rjmp	.+26     	; 0x1f38 <vfprintf+0x272>
    1f1e:	fb 2d       	mov	r31, r11
    1f20:	f4 60       	ori	r31, 0x04	; 4
    1f22:	bf 2e       	mov	r11, r31
    1f24:	09 c0       	rjmp	.+18     	; 0x1f38 <vfprintf+0x272>
    1f26:	34 fe       	sbrs	r3, 4
    1f28:	0a c0       	rjmp	.+20     	; 0x1f3e <vfprintf+0x278>
    1f2a:	29 2f       	mov	r18, r25
    1f2c:	26 60       	ori	r18, 0x06	; 6
    1f2e:	b2 2e       	mov	r11, r18
    1f30:	06 c0       	rjmp	.+12     	; 0x1f3e <vfprintf+0x278>
    1f32:	28 e0       	ldi	r18, 0x08	; 8
    1f34:	30 e0       	ldi	r19, 0x00	; 0
    1f36:	05 c0       	rjmp	.+10     	; 0x1f42 <vfprintf+0x27c>
    1f38:	20 e1       	ldi	r18, 0x10	; 16
    1f3a:	30 e0       	ldi	r19, 0x00	; 0
    1f3c:	02 c0       	rjmp	.+4      	; 0x1f42 <vfprintf+0x27c>
    1f3e:	20 e1       	ldi	r18, 0x10	; 16
    1f40:	32 e0       	ldi	r19, 0x02	; 2
    1f42:	f8 01       	movw	r30, r16
    1f44:	b7 fe       	sbrs	r11, 7
    1f46:	07 c0       	rjmp	.+14     	; 0x1f56 <vfprintf+0x290>
    1f48:	60 81       	ld	r22, Z
    1f4a:	71 81       	ldd	r23, Z+1	; 0x01
    1f4c:	82 81       	ldd	r24, Z+2	; 0x02
    1f4e:	93 81       	ldd	r25, Z+3	; 0x03
    1f50:	0c 5f       	subi	r16, 0xFC	; 252
    1f52:	1f 4f       	sbci	r17, 0xFF	; 255
    1f54:	06 c0       	rjmp	.+12     	; 0x1f62 <vfprintf+0x29c>
    1f56:	60 81       	ld	r22, Z
    1f58:	71 81       	ldd	r23, Z+1	; 0x01
    1f5a:	80 e0       	ldi	r24, 0x00	; 0
    1f5c:	90 e0       	ldi	r25, 0x00	; 0
    1f5e:	0e 5f       	subi	r16, 0xFE	; 254
    1f60:	1f 4f       	sbci	r17, 0xFF	; 255
    1f62:	a3 01       	movw	r20, r6
    1f64:	0e 94 96 10 	call	0x212c	; 0x212c <__ultoa_invert>
    1f68:	88 2e       	mov	r8, r24
    1f6a:	86 18       	sub	r8, r6
    1f6c:	fb 2d       	mov	r31, r11
    1f6e:	ff 77       	andi	r31, 0x7F	; 127
    1f70:	3f 2e       	mov	r3, r31
    1f72:	36 fe       	sbrs	r3, 6
    1f74:	0d c0       	rjmp	.+26     	; 0x1f90 <vfprintf+0x2ca>
    1f76:	23 2d       	mov	r18, r3
    1f78:	2e 7f       	andi	r18, 0xFE	; 254
    1f7a:	a2 2e       	mov	r10, r18
    1f7c:	89 14       	cp	r8, r9
    1f7e:	58 f4       	brcc	.+22     	; 0x1f96 <vfprintf+0x2d0>
    1f80:	34 fe       	sbrs	r3, 4
    1f82:	0b c0       	rjmp	.+22     	; 0x1f9a <vfprintf+0x2d4>
    1f84:	32 fc       	sbrc	r3, 2
    1f86:	09 c0       	rjmp	.+18     	; 0x1f9a <vfprintf+0x2d4>
    1f88:	83 2d       	mov	r24, r3
    1f8a:	8e 7e       	andi	r24, 0xEE	; 238
    1f8c:	a8 2e       	mov	r10, r24
    1f8e:	05 c0       	rjmp	.+10     	; 0x1f9a <vfprintf+0x2d4>
    1f90:	b8 2c       	mov	r11, r8
    1f92:	a3 2c       	mov	r10, r3
    1f94:	03 c0       	rjmp	.+6      	; 0x1f9c <vfprintf+0x2d6>
    1f96:	b8 2c       	mov	r11, r8
    1f98:	01 c0       	rjmp	.+2      	; 0x1f9c <vfprintf+0x2d6>
    1f9a:	b9 2c       	mov	r11, r9
    1f9c:	a4 fe       	sbrs	r10, 4
    1f9e:	0f c0       	rjmp	.+30     	; 0x1fbe <vfprintf+0x2f8>
    1fa0:	fe 01       	movw	r30, r28
    1fa2:	e8 0d       	add	r30, r8
    1fa4:	f1 1d       	adc	r31, r1
    1fa6:	80 81       	ld	r24, Z
    1fa8:	80 33       	cpi	r24, 0x30	; 48
    1faa:	21 f4       	brne	.+8      	; 0x1fb4 <vfprintf+0x2ee>
    1fac:	9a 2d       	mov	r25, r10
    1fae:	99 7e       	andi	r25, 0xE9	; 233
    1fb0:	a9 2e       	mov	r10, r25
    1fb2:	09 c0       	rjmp	.+18     	; 0x1fc6 <vfprintf+0x300>
    1fb4:	a2 fe       	sbrs	r10, 2
    1fb6:	06 c0       	rjmp	.+12     	; 0x1fc4 <vfprintf+0x2fe>
    1fb8:	b3 94       	inc	r11
    1fba:	b3 94       	inc	r11
    1fbc:	04 c0       	rjmp	.+8      	; 0x1fc6 <vfprintf+0x300>
    1fbe:	8a 2d       	mov	r24, r10
    1fc0:	86 78       	andi	r24, 0x86	; 134
    1fc2:	09 f0       	breq	.+2      	; 0x1fc6 <vfprintf+0x300>
    1fc4:	b3 94       	inc	r11
    1fc6:	a3 fc       	sbrc	r10, 3
    1fc8:	11 c0       	rjmp	.+34     	; 0x1fec <vfprintf+0x326>
    1fca:	a0 fe       	sbrs	r10, 0
    1fcc:	06 c0       	rjmp	.+12     	; 0x1fda <vfprintf+0x314>
    1fce:	b2 14       	cp	r11, r2
    1fd0:	88 f4       	brcc	.+34     	; 0x1ff4 <vfprintf+0x32e>
    1fd2:	28 0c       	add	r2, r8
    1fd4:	92 2c       	mov	r9, r2
    1fd6:	9b 18       	sub	r9, r11
    1fd8:	0e c0       	rjmp	.+28     	; 0x1ff6 <vfprintf+0x330>
    1fda:	b2 14       	cp	r11, r2
    1fdc:	60 f4       	brcc	.+24     	; 0x1ff6 <vfprintf+0x330>
    1fde:	b6 01       	movw	r22, r12
    1fe0:	80 e2       	ldi	r24, 0x20	; 32
    1fe2:	90 e0       	ldi	r25, 0x00	; 0
    1fe4:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    1fe8:	b3 94       	inc	r11
    1fea:	f7 cf       	rjmp	.-18     	; 0x1fda <vfprintf+0x314>
    1fec:	b2 14       	cp	r11, r2
    1fee:	18 f4       	brcc	.+6      	; 0x1ff6 <vfprintf+0x330>
    1ff0:	2b 18       	sub	r2, r11
    1ff2:	02 c0       	rjmp	.+4      	; 0x1ff8 <vfprintf+0x332>
    1ff4:	98 2c       	mov	r9, r8
    1ff6:	21 2c       	mov	r2, r1
    1ff8:	a4 fe       	sbrs	r10, 4
    1ffa:	10 c0       	rjmp	.+32     	; 0x201c <vfprintf+0x356>
    1ffc:	b6 01       	movw	r22, r12
    1ffe:	80 e3       	ldi	r24, 0x30	; 48
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    2006:	a2 fe       	sbrs	r10, 2
    2008:	17 c0       	rjmp	.+46     	; 0x2038 <vfprintf+0x372>
    200a:	a1 fc       	sbrc	r10, 1
    200c:	03 c0       	rjmp	.+6      	; 0x2014 <vfprintf+0x34e>
    200e:	88 e7       	ldi	r24, 0x78	; 120
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	02 c0       	rjmp	.+4      	; 0x2018 <vfprintf+0x352>
    2014:	88 e5       	ldi	r24, 0x58	; 88
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	b6 01       	movw	r22, r12
    201a:	0c c0       	rjmp	.+24     	; 0x2034 <vfprintf+0x36e>
    201c:	8a 2d       	mov	r24, r10
    201e:	86 78       	andi	r24, 0x86	; 134
    2020:	59 f0       	breq	.+22     	; 0x2038 <vfprintf+0x372>
    2022:	a1 fe       	sbrs	r10, 1
    2024:	02 c0       	rjmp	.+4      	; 0x202a <vfprintf+0x364>
    2026:	8b e2       	ldi	r24, 0x2B	; 43
    2028:	01 c0       	rjmp	.+2      	; 0x202c <vfprintf+0x366>
    202a:	80 e2       	ldi	r24, 0x20	; 32
    202c:	a7 fc       	sbrc	r10, 7
    202e:	8d e2       	ldi	r24, 0x2D	; 45
    2030:	b6 01       	movw	r22, r12
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    2038:	89 14       	cp	r8, r9
    203a:	38 f4       	brcc	.+14     	; 0x204a <vfprintf+0x384>
    203c:	b6 01       	movw	r22, r12
    203e:	80 e3       	ldi	r24, 0x30	; 48
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    2046:	9a 94       	dec	r9
    2048:	f7 cf       	rjmp	.-18     	; 0x2038 <vfprintf+0x372>
    204a:	8a 94       	dec	r8
    204c:	f3 01       	movw	r30, r6
    204e:	e8 0d       	add	r30, r8
    2050:	f1 1d       	adc	r31, r1
    2052:	80 81       	ld	r24, Z
    2054:	b6 01       	movw	r22, r12
    2056:	90 e0       	ldi	r25, 0x00	; 0
    2058:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    205c:	81 10       	cpse	r8, r1
    205e:	f5 cf       	rjmp	.-22     	; 0x204a <vfprintf+0x384>
    2060:	22 20       	and	r2, r2
    2062:	09 f4       	brne	.+2      	; 0x2066 <vfprintf+0x3a0>
    2064:	42 ce       	rjmp	.-892    	; 0x1cea <vfprintf+0x24>
    2066:	b6 01       	movw	r22, r12
    2068:	80 e2       	ldi	r24, 0x20	; 32
    206a:	90 e0       	ldi	r25, 0x00	; 0
    206c:	0e 94 5a 10 	call	0x20b4	; 0x20b4 <fputc>
    2070:	2a 94       	dec	r2
    2072:	f6 cf       	rjmp	.-20     	; 0x2060 <vfprintf+0x39a>
    2074:	f6 01       	movw	r30, r12
    2076:	86 81       	ldd	r24, Z+6	; 0x06
    2078:	97 81       	ldd	r25, Z+7	; 0x07
    207a:	02 c0       	rjmp	.+4      	; 0x2080 <vfprintf+0x3ba>
    207c:	8f ef       	ldi	r24, 0xFF	; 255
    207e:	9f ef       	ldi	r25, 0xFF	; 255
    2080:	2b 96       	adiw	r28, 0x0b	; 11
    2082:	e2 e1       	ldi	r30, 0x12	; 18
    2084:	0c 94 10 11 	jmp	0x2220	; 0x2220 <__epilogue_restores__>

00002088 <strnlen_P>:
    2088:	fc 01       	movw	r30, r24
    208a:	05 90       	lpm	r0, Z+
    208c:	61 50       	subi	r22, 0x01	; 1
    208e:	70 40       	sbci	r23, 0x00	; 0
    2090:	01 10       	cpse	r0, r1
    2092:	d8 f7       	brcc	.-10     	; 0x208a <strnlen_P+0x2>
    2094:	80 95       	com	r24
    2096:	90 95       	com	r25
    2098:	8e 0f       	add	r24, r30
    209a:	9f 1f       	adc	r25, r31
    209c:	08 95       	ret

0000209e <strnlen>:
    209e:	fc 01       	movw	r30, r24
    20a0:	61 50       	subi	r22, 0x01	; 1
    20a2:	70 40       	sbci	r23, 0x00	; 0
    20a4:	01 90       	ld	r0, Z+
    20a6:	01 10       	cpse	r0, r1
    20a8:	d8 f7       	brcc	.-10     	; 0x20a0 <strnlen+0x2>
    20aa:	80 95       	com	r24
    20ac:	90 95       	com	r25
    20ae:	8e 0f       	add	r24, r30
    20b0:	9f 1f       	adc	r25, r31
    20b2:	08 95       	ret

000020b4 <fputc>:
    20b4:	0f 93       	push	r16
    20b6:	1f 93       	push	r17
    20b8:	cf 93       	push	r28
    20ba:	df 93       	push	r29
    20bc:	fb 01       	movw	r30, r22
    20be:	23 81       	ldd	r18, Z+3	; 0x03
    20c0:	21 fd       	sbrc	r18, 1
    20c2:	03 c0       	rjmp	.+6      	; 0x20ca <fputc+0x16>
    20c4:	8f ef       	ldi	r24, 0xFF	; 255
    20c6:	9f ef       	ldi	r25, 0xFF	; 255
    20c8:	2c c0       	rjmp	.+88     	; 0x2122 <fputc+0x6e>
    20ca:	22 ff       	sbrs	r18, 2
    20cc:	16 c0       	rjmp	.+44     	; 0x20fa <fputc+0x46>
    20ce:	46 81       	ldd	r20, Z+6	; 0x06
    20d0:	57 81       	ldd	r21, Z+7	; 0x07
    20d2:	24 81       	ldd	r18, Z+4	; 0x04
    20d4:	35 81       	ldd	r19, Z+5	; 0x05
    20d6:	42 17       	cp	r20, r18
    20d8:	53 07       	cpc	r21, r19
    20da:	44 f4       	brge	.+16     	; 0x20ec <fputc+0x38>
    20dc:	a0 81       	ld	r26, Z
    20de:	b1 81       	ldd	r27, Z+1	; 0x01
    20e0:	9d 01       	movw	r18, r26
    20e2:	2f 5f       	subi	r18, 0xFF	; 255
    20e4:	3f 4f       	sbci	r19, 0xFF	; 255
    20e6:	31 83       	std	Z+1, r19	; 0x01
    20e8:	20 83       	st	Z, r18
    20ea:	8c 93       	st	X, r24
    20ec:	26 81       	ldd	r18, Z+6	; 0x06
    20ee:	37 81       	ldd	r19, Z+7	; 0x07
    20f0:	2f 5f       	subi	r18, 0xFF	; 255
    20f2:	3f 4f       	sbci	r19, 0xFF	; 255
    20f4:	37 83       	std	Z+7, r19	; 0x07
    20f6:	26 83       	std	Z+6, r18	; 0x06
    20f8:	14 c0       	rjmp	.+40     	; 0x2122 <fputc+0x6e>
    20fa:	8b 01       	movw	r16, r22
    20fc:	ec 01       	movw	r28, r24
    20fe:	fb 01       	movw	r30, r22
    2100:	00 84       	ldd	r0, Z+8	; 0x08
    2102:	f1 85       	ldd	r31, Z+9	; 0x09
    2104:	e0 2d       	mov	r30, r0
    2106:	09 95       	icall
    2108:	89 2b       	or	r24, r25
    210a:	e1 f6       	brne	.-72     	; 0x20c4 <fputc+0x10>
    210c:	d8 01       	movw	r26, r16
    210e:	16 96       	adiw	r26, 0x06	; 6
    2110:	8d 91       	ld	r24, X+
    2112:	9c 91       	ld	r25, X
    2114:	17 97       	sbiw	r26, 0x07	; 7
    2116:	01 96       	adiw	r24, 0x01	; 1
    2118:	17 96       	adiw	r26, 0x07	; 7
    211a:	9c 93       	st	X, r25
    211c:	8e 93       	st	-X, r24
    211e:	16 97       	sbiw	r26, 0x06	; 6
    2120:	ce 01       	movw	r24, r28
    2122:	df 91       	pop	r29
    2124:	cf 91       	pop	r28
    2126:	1f 91       	pop	r17
    2128:	0f 91       	pop	r16
    212a:	08 95       	ret

0000212c <__ultoa_invert>:
    212c:	fa 01       	movw	r30, r20
    212e:	aa 27       	eor	r26, r26
    2130:	28 30       	cpi	r18, 0x08	; 8
    2132:	51 f1       	breq	.+84     	; 0x2188 <__ultoa_invert+0x5c>
    2134:	20 31       	cpi	r18, 0x10	; 16
    2136:	81 f1       	breq	.+96     	; 0x2198 <__ultoa_invert+0x6c>
    2138:	e8 94       	clt
    213a:	6f 93       	push	r22
    213c:	6e 7f       	andi	r22, 0xFE	; 254
    213e:	6e 5f       	subi	r22, 0xFE	; 254
    2140:	7f 4f       	sbci	r23, 0xFF	; 255
    2142:	8f 4f       	sbci	r24, 0xFF	; 255
    2144:	9f 4f       	sbci	r25, 0xFF	; 255
    2146:	af 4f       	sbci	r26, 0xFF	; 255
    2148:	b1 e0       	ldi	r27, 0x01	; 1
    214a:	3e d0       	rcall	.+124    	; 0x21c8 <__ultoa_invert+0x9c>
    214c:	b4 e0       	ldi	r27, 0x04	; 4
    214e:	3c d0       	rcall	.+120    	; 0x21c8 <__ultoa_invert+0x9c>
    2150:	67 0f       	add	r22, r23
    2152:	78 1f       	adc	r23, r24
    2154:	89 1f       	adc	r24, r25
    2156:	9a 1f       	adc	r25, r26
    2158:	a1 1d       	adc	r26, r1
    215a:	68 0f       	add	r22, r24
    215c:	79 1f       	adc	r23, r25
    215e:	8a 1f       	adc	r24, r26
    2160:	91 1d       	adc	r25, r1
    2162:	a1 1d       	adc	r26, r1
    2164:	6a 0f       	add	r22, r26
    2166:	71 1d       	adc	r23, r1
    2168:	81 1d       	adc	r24, r1
    216a:	91 1d       	adc	r25, r1
    216c:	a1 1d       	adc	r26, r1
    216e:	20 d0       	rcall	.+64     	; 0x21b0 <__ultoa_invert+0x84>
    2170:	09 f4       	brne	.+2      	; 0x2174 <__ultoa_invert+0x48>
    2172:	68 94       	set
    2174:	3f 91       	pop	r19
    2176:	2a e0       	ldi	r18, 0x0A	; 10
    2178:	26 9f       	mul	r18, r22
    217a:	11 24       	eor	r1, r1
    217c:	30 19       	sub	r19, r0
    217e:	30 5d       	subi	r19, 0xD0	; 208
    2180:	31 93       	st	Z+, r19
    2182:	de f6       	brtc	.-74     	; 0x213a <__ultoa_invert+0xe>
    2184:	cf 01       	movw	r24, r30
    2186:	08 95       	ret
    2188:	46 2f       	mov	r20, r22
    218a:	47 70       	andi	r20, 0x07	; 7
    218c:	40 5d       	subi	r20, 0xD0	; 208
    218e:	41 93       	st	Z+, r20
    2190:	b3 e0       	ldi	r27, 0x03	; 3
    2192:	0f d0       	rcall	.+30     	; 0x21b2 <__ultoa_invert+0x86>
    2194:	c9 f7       	brne	.-14     	; 0x2188 <__ultoa_invert+0x5c>
    2196:	f6 cf       	rjmp	.-20     	; 0x2184 <__ultoa_invert+0x58>
    2198:	46 2f       	mov	r20, r22
    219a:	4f 70       	andi	r20, 0x0F	; 15
    219c:	40 5d       	subi	r20, 0xD0	; 208
    219e:	4a 33       	cpi	r20, 0x3A	; 58
    21a0:	18 f0       	brcs	.+6      	; 0x21a8 <__ultoa_invert+0x7c>
    21a2:	49 5d       	subi	r20, 0xD9	; 217
    21a4:	31 fd       	sbrc	r19, 1
    21a6:	40 52       	subi	r20, 0x20	; 32
    21a8:	41 93       	st	Z+, r20
    21aa:	02 d0       	rcall	.+4      	; 0x21b0 <__ultoa_invert+0x84>
    21ac:	a9 f7       	brne	.-22     	; 0x2198 <__ultoa_invert+0x6c>
    21ae:	ea cf       	rjmp	.-44     	; 0x2184 <__ultoa_invert+0x58>
    21b0:	b4 e0       	ldi	r27, 0x04	; 4
    21b2:	a6 95       	lsr	r26
    21b4:	97 95       	ror	r25
    21b6:	87 95       	ror	r24
    21b8:	77 95       	ror	r23
    21ba:	67 95       	ror	r22
    21bc:	ba 95       	dec	r27
    21be:	c9 f7       	brne	.-14     	; 0x21b2 <__ultoa_invert+0x86>
    21c0:	00 97       	sbiw	r24, 0x00	; 0
    21c2:	61 05       	cpc	r22, r1
    21c4:	71 05       	cpc	r23, r1
    21c6:	08 95       	ret
    21c8:	9b 01       	movw	r18, r22
    21ca:	ac 01       	movw	r20, r24
    21cc:	0a 2e       	mov	r0, r26
    21ce:	06 94       	lsr	r0
    21d0:	57 95       	ror	r21
    21d2:	47 95       	ror	r20
    21d4:	37 95       	ror	r19
    21d6:	27 95       	ror	r18
    21d8:	ba 95       	dec	r27
    21da:	c9 f7       	brne	.-14     	; 0x21ce <__ultoa_invert+0xa2>
    21dc:	62 0f       	add	r22, r18
    21de:	73 1f       	adc	r23, r19
    21e0:	84 1f       	adc	r24, r20
    21e2:	95 1f       	adc	r25, r21
    21e4:	a0 1d       	adc	r26, r0
    21e6:	08 95       	ret

000021e8 <__prologue_saves__>:
    21e8:	2f 92       	push	r2
    21ea:	3f 92       	push	r3
    21ec:	4f 92       	push	r4
    21ee:	5f 92       	push	r5
    21f0:	6f 92       	push	r6
    21f2:	7f 92       	push	r7
    21f4:	8f 92       	push	r8
    21f6:	9f 92       	push	r9
    21f8:	af 92       	push	r10
    21fa:	bf 92       	push	r11
    21fc:	cf 92       	push	r12
    21fe:	df 92       	push	r13
    2200:	ef 92       	push	r14
    2202:	ff 92       	push	r15
    2204:	0f 93       	push	r16
    2206:	1f 93       	push	r17
    2208:	cf 93       	push	r28
    220a:	df 93       	push	r29
    220c:	cd b7       	in	r28, 0x3d	; 61
    220e:	de b7       	in	r29, 0x3e	; 62
    2210:	ca 1b       	sub	r28, r26
    2212:	db 0b       	sbc	r29, r27
    2214:	0f b6       	in	r0, 0x3f	; 63
    2216:	f8 94       	cli
    2218:	de bf       	out	0x3e, r29	; 62
    221a:	0f be       	out	0x3f, r0	; 63
    221c:	cd bf       	out	0x3d, r28	; 61
    221e:	09 94       	ijmp

00002220 <__epilogue_restores__>:
    2220:	2a 88       	ldd	r2, Y+18	; 0x12
    2222:	39 88       	ldd	r3, Y+17	; 0x11
    2224:	48 88       	ldd	r4, Y+16	; 0x10
    2226:	5f 84       	ldd	r5, Y+15	; 0x0f
    2228:	6e 84       	ldd	r6, Y+14	; 0x0e
    222a:	7d 84       	ldd	r7, Y+13	; 0x0d
    222c:	8c 84       	ldd	r8, Y+12	; 0x0c
    222e:	9b 84       	ldd	r9, Y+11	; 0x0b
    2230:	aa 84       	ldd	r10, Y+10	; 0x0a
    2232:	b9 84       	ldd	r11, Y+9	; 0x09
    2234:	c8 84       	ldd	r12, Y+8	; 0x08
    2236:	df 80       	ldd	r13, Y+7	; 0x07
    2238:	ee 80       	ldd	r14, Y+6	; 0x06
    223a:	fd 80       	ldd	r15, Y+5	; 0x05
    223c:	0c 81       	ldd	r16, Y+4	; 0x04
    223e:	1b 81       	ldd	r17, Y+3	; 0x03
    2240:	aa 81       	ldd	r26, Y+2	; 0x02
    2242:	b9 81       	ldd	r27, Y+1	; 0x01
    2244:	ce 0f       	add	r28, r30
    2246:	d1 1d       	adc	r29, r1
    2248:	0f b6       	in	r0, 0x3f	; 63
    224a:	f8 94       	cli
    224c:	de bf       	out	0x3e, r29	; 62
    224e:	0f be       	out	0x3f, r0	; 63
    2250:	cd bf       	out	0x3d, r28	; 61
    2252:	ed 01       	movw	r28, r26
    2254:	08 95       	ret

00002256 <_exit>:
    2256:	f8 94       	cli

00002258 <__stop_program>:
    2258:	ff cf       	rjmp	.-2      	; 0x2258 <__stop_program>
