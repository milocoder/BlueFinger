
SD_kaart4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000c0  00800100  0000226c  00002300  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000226c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000034b  008001c0  008001c0  000023c0  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000023c0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000241c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000198  00000000  00000000  00002458  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a9d  00000000  00000000  000025f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001157  00000000  00000000  0000508d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000016cf  00000000  00000000  000061e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000664  00000000  00000000  000078b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a29  00000000  00000000  00007f18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002588  00000000  00000000  00008941  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000158  00000000  00000000  0000aec9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 28 04 	jmp	0x850	; 0x850 <__vector_10>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 47 01 	jmp	0x28e	; 0x28e <__vector_18>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf ef       	ldi	r28, 0xFF	; 255
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e0       	ldi	r26, 0x00	; 0
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	ec e6       	ldi	r30, 0x6C	; 108
      a8:	f2 e2       	ldi	r31, 0x22	; 34
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a0 3c       	cpi	r26, 0xC0	; 192
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	25 e0       	ldi	r18, 0x05	; 5
      b8:	a0 ec       	ldi	r26, 0xC0	; 192
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	ab 30       	cpi	r26, 0x0B	; 11
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 86 05 	call	0xb0c	; 0xb0c <main>
      ca:	0c 94 34 11 	jmp	0x2268	; 0x2268 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <initCAN>:

	// Set the MOB's mode to transmission, also activating it.
	CANCDMOB |= (0x01 << CONMOB0);

	return 1;
}
      d2:	e8 ed       	ldi	r30, 0xD8	; 216
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	80 81       	ld	r24, Z
      d8:	81 60       	ori	r24, 0x01	; 1
      da:	80 83       	st	Z, r24
      dc:	86 e0       	ldi	r24, 0x06	; 6
      de:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7f80e2>
      e2:	84 e0       	ldi	r24, 0x04	; 4
      e4:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7f80e3>
      e8:	83 e1       	ldi	r24, 0x13	; 19
      ea:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7f80e4>
      ee:	80 e0       	ldi	r24, 0x00	; 0
      f0:	08 c0       	rjmp	.+16     	; 0x102 <initCAN+0x30>
      f2:	98 2f       	mov	r25, r24
      f4:	92 95       	swap	r25
      f6:	90 7f       	andi	r25, 0xF0	; 240
      f8:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
      fc:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     100:	8f 5f       	subi	r24, 0xFF	; 255
     102:	8f 30       	cpi	r24, 0x0F	; 15
     104:	b0 f3       	brcs	.-20     	; 0xf2 <initCAN+0x20>
     106:	78 94       	sei
     108:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     10c:	80 eb       	ldi	r24, 0xB0	; 176
     10e:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7f80db>
     112:	e8 ed       	ldi	r30, 0xD8	; 216
     114:	f0 e0       	ldi	r31, 0x00	; 0
     116:	80 81       	ld	r24, Z
     118:	82 60       	ori	r24, 0x02	; 2
     11a:	80 83       	st	Z, r24
     11c:	08 95       	ret

0000011e <getFreeMob>:
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	0a c0       	rjmp	.+20     	; 0x136 <getFreeMob+0x18>
     122:	98 2f       	mov	r25, r24
     124:	92 95       	swap	r25
     126:	90 7f       	andi	r25, 0xF0	; 240
     128:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     12c:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     130:	90 7c       	andi	r25, 0xC0	; 192
     132:	21 f0       	breq	.+8      	; 0x13c <getFreeMob+0x1e>
     134:	8f 5f       	subi	r24, 0xFF	; 255
     136:	8f 30       	cpi	r24, 0x0F	; 15
     138:	a0 f3       	brcs	.-24     	; 0x122 <getFreeMob+0x4>
     13a:	8f ef       	ldi	r24, 0xFF	; 255
     13c:	08 95       	ret

0000013e <listenForMessage>:
 * @param[in] id - the provided id
 * @return 0 if no free message objects left, 1 otherwise
 *
 */
uint8_t listenForMessage( uint16_t id, uint8_t expectedLength )
{
     13e:	1f 93       	push	r17
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	ec 01       	movw	r28, r24
     146:	16 2f       	mov	r17, r22
	// Try to get a free MOb
	uint8_t mobIndex = getFreeMob();
     148:	0e 94 8f 00 	call	0x11e	; 0x11e <getFreeMob>

	if( mobIndex == 0xFF )
     14c:	8f 3f       	cpi	r24, 0xFF	; 255
     14e:	09 f4       	brne	.+2      	; 0x152 <listenForMessage+0x14>
     150:	4e c0       	rjmp	.+156    	; 0x1ee <listenForMessage+0xb0>
		// No free Message Objects
		return 0;
	}

	// Point to the free message object
	CANPAGE |= (mobIndex << 4);
     152:	ed ee       	ldi	r30, 0xED	; 237
     154:	f0 e0       	ldi	r31, 0x00	; 0
     156:	90 81       	ld	r25, Z
     158:	48 2f       	mov	r20, r24
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	9a 01       	movw	r18, r20
     15e:	22 95       	swap	r18
     160:	32 95       	swap	r19
     162:	30 7f       	andi	r19, 0xF0	; 240
     164:	32 27       	eor	r19, r18
     166:	20 7f       	andi	r18, 0xF0	; 240
     168:	32 27       	eor	r19, r18
     16a:	29 2b       	or	r18, r25
     16c:	20 83       	st	Z, r18

	// Set the MOb's CAN id to the id to be listened for
	CANIDT4 = 0;
     16e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
	CANIDT3 = 0;
     172:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
	CANIDT2 = id << 5;
     176:	9c 2f       	mov	r25, r28
     178:	92 95       	swap	r25
     17a:	99 0f       	add	r25, r25
     17c:	90 7e       	andi	r25, 0xE0	; 224
     17e:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
	CANIDT1 = id >> 3;
     182:	d6 95       	lsr	r29
     184:	c7 95       	ror	r28
     186:	d6 95       	lsr	r29
     188:	c7 95       	ror	r28
     18a:	d6 95       	lsr	r29
     18c:	c7 95       	ror	r28
     18e:	c0 93 f3 00 	sts	0x00F3, r28	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>

	if( expectedLength > 8 )
     192:	19 30       	cpi	r17, 0x09	; 9
     194:	08 f0       	brcs	.+2      	; 0x198 <listenForMessage+0x5a>
	{
		expectedLength = 8;
     196:	18 e0       	ldi	r17, 0x08	; 8
	}

	// Set the MOb's expected length
	CANCDMOB |= expectedLength;
     198:	ef ee       	ldi	r30, 0xEF	; 239
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	60 81       	ld	r22, Z
     19e:	61 2b       	or	r22, r17
     1a0:	60 83       	st	Z, r22

	// Enable interrupts for this MOb
	if( mobIndex < 8 )
     1a2:	88 30       	cpi	r24, 0x08	; 8
     1a4:	78 f4       	brcc	.+30     	; 0x1c4 <listenForMessage+0x86>
	{
		CANIE2 |= (1 << mobIndex);
     1a6:	ee ed       	ldi	r30, 0xDE	; 222
     1a8:	f0 e0       	ldi	r31, 0x00	; 0
     1aa:	40 81       	ld	r20, Z
     1ac:	21 e0       	ldi	r18, 0x01	; 1
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	b9 01       	movw	r22, r18
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <listenForMessage+0x7a>
     1b4:	66 0f       	add	r22, r22
     1b6:	77 1f       	adc	r23, r23
     1b8:	8a 95       	dec	r24
     1ba:	e2 f7       	brpl	.-8      	; 0x1b4 <listenForMessage+0x76>
     1bc:	cb 01       	movw	r24, r22
     1be:	84 2b       	or	r24, r20
     1c0:	80 83       	st	Z, r24
     1c2:	0e c0       	rjmp	.+28     	; 0x1e0 <listenForMessage+0xa2>
	}
	else
	{
		CANIE1 |= (1 << (mobIndex-8));
     1c4:	ef ed       	ldi	r30, 0xDF	; 223
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	20 81       	ld	r18, Z
     1ca:	48 50       	subi	r20, 0x08	; 8
     1cc:	51 09       	sbc	r21, r1
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <listenForMessage+0x9a>
     1d4:	88 0f       	add	r24, r24
     1d6:	99 1f       	adc	r25, r25
     1d8:	4a 95       	dec	r20
     1da:	e2 f7       	brpl	.-8      	; 0x1d4 <listenForMessage+0x96>
     1dc:	82 2b       	or	r24, r18
     1de:	80 83       	st	Z, r24
	}

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);
     1e0:	ef ee       	ldi	r30, 0xEF	; 239
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	80 68       	ori	r24, 0x80	; 128
     1e8:	80 83       	st	Z, r24

	return 1;
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <listenForMessage+0xb2>
	uint8_t mobIndex = getFreeMob();

	if( mobIndex == 0xFF )
	{
		// No free Message Objects
		return 0;
     1ee:	80 e0       	ldi	r24, 0x00	; 0

	// Set the MOb's mode to receive, also activating it.
	CANCDMOB |= (0x02 << CONMOB0);

	return 1;
}
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	1f 91       	pop	r17
     1f6:	08 95       	ret

000001f8 <getMessage>:
 * @param[out] message - message data to fill
 * @return 1 if message was filled, 0 otherwise
 *
 */
uint8_t getMessage( CANMessage * message )
{
     1f8:	dc 01       	movw	r26, r24
	// Default to no message available
	uint8_t messageAvailable = 0;

	if( serviceIndex != bufIndex )
     1fa:	e0 91 c2 01 	lds	r30, 0x01C2	; 0x8001c2 <serviceIndex>
     1fe:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <bufIndex>
     202:	e8 17       	cp	r30, r24
     204:	09 f4       	brne	.+2      	; 0x208 <getMessage+0x10>
     206:	41 c0       	rjmp	.+130    	; 0x28a <getMessage+0x92>
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
     208:	2b e0       	ldi	r18, 0x0B	; 11
     20a:	2e 9f       	mul	r18, r30
     20c:	f0 01       	movw	r30, r0
     20e:	11 24       	eor	r1, r1
     210:	ed 52       	subi	r30, 0x2D	; 45
     212:	fc 4f       	sbci	r31, 0xFC	; 252
     214:	30 81       	ld	r19, Z
     216:	81 81       	ldd	r24, Z+1	; 0x01
     218:	98 2f       	mov	r25, r24
     21a:	97 70       	andi	r25, 0x07	; 7
     21c:	3c 93       	st	X, r19
     21e:	11 96       	adiw	r26, 0x01	; 1
     220:	8c 91       	ld	r24, X
     222:	11 97       	sbiw	r26, 0x01	; 1
     224:	88 7f       	andi	r24, 0xF8	; 248
     226:	89 2b       	or	r24, r25
     228:	11 96       	adiw	r26, 0x01	; 1
     22a:	8c 93       	st	X, r24
     22c:	11 97       	sbiw	r26, 0x01	; 1
		message->length = messageBuffer[ serviceIndex ].length;
     22e:	60 91 c2 01 	lds	r22, 0x01C2	; 0x8001c2 <serviceIndex>
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	26 9f       	mul	r18, r22
     236:	f0 01       	movw	r30, r0
     238:	27 9f       	mul	r18, r23
     23a:	f0 0d       	add	r31, r0
     23c:	11 24       	eor	r1, r1
     23e:	ed 52       	subi	r30, 0x2D	; 45
     240:	fc 4f       	sbci	r31, 0xFC	; 252
     242:	82 85       	ldd	r24, Z+10	; 0x0a
     244:	1a 96       	adiw	r26, 0x0a	; 10
     246:	8c 93       	st	X, r24
     248:	1a 97       	sbiw	r26, 0x0a	; 10

		for( uint8_t i = 0; i < message->length; ++i )
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	12 c0       	rjmp	.+36     	; 0x272 <getMessage+0x7a>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
     24e:	29 2f       	mov	r18, r25
     250:	30 e0       	ldi	r19, 0x00	; 0
     252:	4b e0       	ldi	r20, 0x0B	; 11
     254:	46 9f       	mul	r20, r22
     256:	f0 01       	movw	r30, r0
     258:	47 9f       	mul	r20, r23
     25a:	f0 0d       	add	r31, r0
     25c:	11 24       	eor	r1, r1
     25e:	ed 52       	subi	r30, 0x2D	; 45
     260:	fc 4f       	sbci	r31, 0xFC	; 252
     262:	e2 0f       	add	r30, r18
     264:	f3 1f       	adc	r31, r19
     266:	42 81       	ldd	r20, Z+2	; 0x02
     268:	fd 01       	movw	r30, r26
     26a:	e2 0f       	add	r30, r18
     26c:	f3 1f       	adc	r31, r19
     26e:	42 83       	std	Z+2, r20	; 0x02
	{
		// Load the data from the next message received in FIFO order into the out message
		message->id = messageBuffer[ serviceIndex ].id;
		message->length = messageBuffer[ serviceIndex ].length;

		for( uint8_t i = 0; i < message->length; ++i )
     270:	9f 5f       	subi	r25, 0xFF	; 255
     272:	98 17       	cp	r25, r24
     274:	60 f3       	brcs	.-40     	; 0x24e <getMessage+0x56>
		{
			message->data[ i ] = messageBuffer[ serviceIndex ].data[ i ];
		}

		// Increment the index pointing to the next message to be serviced
		serviceIndex = (serviceIndex + 1) % MESSAGE_BUFFER_LENGTH;
     276:	cb 01       	movw	r24, r22
     278:	01 96       	adiw	r24, 0x01	; 1
     27a:	64 e1       	ldi	r22, 0x14	; 20
     27c:	70 e0       	ldi	r23, 0x00	; 0
     27e:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <__divmodhi4>
     282:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <serviceIndex>

		messageAvailable = 1;
     286:	81 e0       	ldi	r24, 0x01	; 1
     288:	08 95       	ret
 *
 */
uint8_t getMessage( CANMessage * message )
{
	// Default to no message available
	uint8_t messageAvailable = 0;
     28a:	80 e0       	ldi	r24, 0x00	; 0

		messageAvailable = 1;
	}

	return messageAvailable;
}
     28c:	08 95       	ret

0000028e <__vector_18>:
 * Note that the NO_BLOCK attribute is not applied here, so while this is running,
 * all interrupts are blocked.
 *
 */
ISR( CANIT_vect )
{
     28e:	1f 92       	push	r1
     290:	0f 92       	push	r0
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	0f 92       	push	r0
     296:	11 24       	eor	r1, r1
     298:	2f 93       	push	r18
     29a:	3f 93       	push	r19
     29c:	4f 93       	push	r20
     29e:	5f 93       	push	r21
     2a0:	6f 93       	push	r22
     2a2:	7f 93       	push	r23
     2a4:	8f 93       	push	r24
     2a6:	9f 93       	push	r25
     2a8:	af 93       	push	r26
     2aa:	bf 93       	push	r27
     2ac:	cf 93       	push	r28
     2ae:	ef 93       	push	r30
     2b0:	ff 93       	push	r31
	// **Save off CANPAGE to prevent application code bugs**
	uint8_t canPage = CANPAGE;
     2b2:	c0 91 ed 00 	lds	r28, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     2b6:	87 c0       	rjmp	.+270    	; 0x3c6 <__vector_18+0x138>
	{
		// Point to the Message Object that needs to be serviced
		CANPAGE = CANHPMOB & 0xF0;
     2b8:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     2bc:	80 7f       	andi	r24, 0xF0	; 240
     2be:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

		// Service the correct kind of interrupt
		// Transmit Interrupts
		if( CANSTMOB & (1 << TXOK) )
     2c2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2c6:	86 ff       	sbrs	r24, 6
     2c8:	0c c0       	rjmp	.+24     	; 0x2e2 <__vector_18+0x54>
		{
			// Acknowledge the interrupt
			CANSTMOB = 0;
     2ca:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			// Free up the MOb
			CANCDMOB = 0;
     2ce:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>

			// Determine the MOb index
			uint8_t mob = (CANPAGE & 0xF0) >> 8;
     2d2:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

			// Disable interrupts for this MOb
			if( mob < 8 )
			{
				CANIE2 &= ~(1 << mob);
     2d6:	ee ed       	ldi	r30, 0xDE	; 222
     2d8:	f0 e0       	ldi	r31, 0x00	; 0
     2da:	80 81       	ld	r24, Z
     2dc:	8e 7f       	andi	r24, 0xFE	; 254
     2de:	80 83       	st	Z, r24
     2e0:	72 c0       	rjmp	.+228    	; 0x3c6 <__vector_18+0x138>
			{
				CANIE1 &= ~(1 << (mob-8));
			}
		}
		// Receive Interrupts
		else if ( CANSTMOB & (1 << RXOK) )
     2e2:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     2e6:	85 ff       	sbrs	r24, 5
     2e8:	62 c0       	rjmp	.+196    	; 0x3ae <__vector_18+0x120>
		{
			// Default to impossible ID
			uint16_t id = 0xFFFF;

			// Load the message data into a free message buffer object
			if( CANCDMOB & (1 << IDE) )
     2ea:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     2ee:	84 ff       	sbrs	r24, 4
     2f0:	0e c0       	rjmp	.+28     	; 0x30e <__vector_18+0x80>
			{
				// Message type is CAN 2.0B
				id = (CANIDT4 >> 3) | ((CANIDT3 & 0x7F) << 5); 
     2f2:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     2f6:	86 95       	lsr	r24
     2f8:	86 95       	lsr	r24
     2fa:	86 95       	lsr	r24
     2fc:	40 91 f1 00 	lds	r20, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     300:	4f 77       	andi	r20, 0x7F	; 127
     302:	90 e2       	ldi	r25, 0x20	; 32
     304:	49 9f       	mul	r20, r25
     306:	a0 01       	movw	r20, r0
     308:	11 24       	eor	r1, r1
     30a:	48 2b       	or	r20, r24
     30c:	0f c0       	rjmp	.+30     	; 0x32c <__vector_18+0x9e>
			}
			else
			{
				// Message type is CAN 2.0A
				id = (CANIDT2 >> 5) | (((uint16_t)CANIDT1 << 3));
     30e:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     312:	82 95       	swap	r24
     314:	86 95       	lsr	r24
     316:	87 70       	andi	r24, 0x07	; 7
     318:	40 91 f3 00 	lds	r20, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     31c:	50 e0       	ldi	r21, 0x00	; 0
     31e:	44 0f       	add	r20, r20
     320:	55 1f       	adc	r21, r21
     322:	44 0f       	add	r20, r20
     324:	55 1f       	adc	r21, r21
     326:	44 0f       	add	r20, r20
     328:	55 1f       	adc	r21, r21
     32a:	48 2b       	or	r20, r24
			}

			messageBuffer[bufIndex].id = id;
     32c:	20 91 c1 01 	lds	r18, 0x01C1	; 0x8001c1 <bufIndex>
     330:	30 e0       	ldi	r19, 0x00	; 0
     332:	8b e0       	ldi	r24, 0x0B	; 11
     334:	82 9f       	mul	r24, r18
     336:	f0 01       	movw	r30, r0
     338:	83 9f       	mul	r24, r19
     33a:	f0 0d       	add	r31, r0
     33c:	11 24       	eor	r1, r1
     33e:	ed 52       	subi	r30, 0x2D	; 45
     340:	fc 4f       	sbci	r31, 0xFC	; 252
     342:	40 83       	st	Z, r20
     344:	95 2f       	mov	r25, r21
     346:	97 70       	andi	r25, 0x07	; 7
     348:	81 81       	ldd	r24, Z+1	; 0x01
     34a:	88 7f       	andi	r24, 0xF8	; 248
     34c:	89 2b       	or	r24, r25
     34e:	81 83       	std	Z+1, r24	; 0x01

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;
     350:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     354:	8f 70       	andi	r24, 0x0F	; 15
     356:	82 87       	std	Z+10, r24	; 0x0a

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	0e c0       	rjmp	.+28     	; 0x378 <__vector_18+0xea>
			{
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
     35c:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7f80fa>
     360:	4b e0       	ldi	r20, 0x0B	; 11
     362:	42 9f       	mul	r20, r18
     364:	f0 01       	movw	r30, r0
     366:	43 9f       	mul	r20, r19
     368:	f0 0d       	add	r31, r0
     36a:	11 24       	eor	r1, r1
     36c:	ed 52       	subi	r30, 0x2D	; 45
     36e:	fc 4f       	sbci	r31, 0xFC	; 252
     370:	e9 0f       	add	r30, r25
     372:	f1 1d       	adc	r31, r1
     374:	82 83       	std	Z+2, r24	; 0x02
			messageBuffer[bufIndex].id = id;

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     376:	9f 5f       	subi	r25, 0xFF	; 255
     378:	8b e0       	ldi	r24, 0x0B	; 11
     37a:	82 9f       	mul	r24, r18
     37c:	f0 01       	movw	r30, r0
     37e:	83 9f       	mul	r24, r19
     380:	f0 0d       	add	r31, r0
     382:	11 24       	eor	r1, r1
     384:	ed 52       	subi	r30, 0x2D	; 45
     386:	fc 4f       	sbci	r31, 0xFC	; 252
     388:	82 85       	ldd	r24, Z+10	; 0x0a
     38a:	98 17       	cp	r25, r24
     38c:	38 f3       	brcs	.-50     	; 0x35c <__vector_18+0xce>
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
			}

			bufIndex = (bufIndex + 1) % MESSAGE_BUFFER_LENGTH;
     38e:	c9 01       	movw	r24, r18
     390:	01 96       	adiw	r24, 0x01	; 1
     392:	64 e1       	ldi	r22, 0x14	; 20
     394:	70 e0       	ldi	r23, 0x00	; 0
     396:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <__divmodhi4>
     39a:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <bufIndex>

			// Acknowledge the interrupt
			CANSTMOB = 0;
     39e:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			CANCDMOB |= (2 << CONMOB0);
     3a2:	ef ee       	ldi	r30, 0xEF	; 239
     3a4:	f0 e0       	ldi	r31, 0x00	; 0
     3a6:	80 81       	ld	r24, Z
     3a8:	80 68       	ori	r24, 0x80	; 128
     3aa:	80 83       	st	Z, r24
     3ac:	0c c0       	rjmp	.+24     	; 0x3c6 <__vector_18+0x138>
			
		}
		else if ( CANGIT & ~(1 << CANIT) )
     3ae:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	89 2b       	or	r24, r25
     3b8:	31 f0       	breq	.+12     	; 0x3c6 <__vector_18+0x138>
		{
			// Preserve the last error received
			lastError = CANGIT;
     3ba:	ea ed       	ldi	r30, 0xDA	; 218
     3bc:	f0 e0       	ldi	r31, 0x00	; 0
     3be:	80 81       	ld	r24, Z
     3c0:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <__data_end>

			// Clear the error
			CANGIT = 0;
     3c4:	10 82       	st	Z, r1
	uint8_t canPage = CANPAGE;

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     3c6:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     3ca:	82 95       	swap	r24
     3cc:	8f 70       	andi	r24, 0x0F	; 15
     3ce:	8f 30       	cpi	r24, 0x0F	; 15
     3d0:	09 f0       	breq	.+2      	; 0x3d4 <__vector_18+0x146>
     3d2:	72 cf       	rjmp	.-284    	; 0x2b8 <__vector_18+0x2a>
			CANGIT = 0;
		}
	}

	// Restore CANPAGE register to where application code had it before interrupt
	CANPAGE = canPage;
     3d4:	c0 93 ed 00 	sts	0x00ED, r28	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     3d8:	ff 91       	pop	r31
     3da:	ef 91       	pop	r30
     3dc:	cf 91       	pop	r28
     3de:	bf 91       	pop	r27
     3e0:	af 91       	pop	r26
     3e2:	9f 91       	pop	r25
     3e4:	8f 91       	pop	r24
     3e6:	7f 91       	pop	r23
     3e8:	6f 91       	pop	r22
     3ea:	5f 91       	pop	r21
     3ec:	4f 91       	pop	r20
     3ee:	3f 91       	pop	r19
     3f0:	2f 91       	pop	r18
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0
     3f8:	1f 90       	pop	r1
     3fa:	18 95       	reti

000003fc <init_spi>:
//

static void init_spi(void)
{
	/* Set MOSI and SCK output, all others input */
	DDR_SPI |= ((1 << MOSI) | (1 << SCK) | (1 << CS));
     3fc:	84 b1       	in	r24, 0x04	; 4
     3fe:	87 60       	ori	r24, 0x07	; 7
     400:	84 b9       	out	0x04, r24	; 4
	
	// enable pull up resistor in MISO
	PORTB |= (1 << MISO);
     402:	85 b1       	in	r24, 0x05	; 5
     404:	88 60       	ori	r24, 0x08	; 8
     406:	85 b9       	out	0x05, r24	; 5
	
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPR0));
     408:	8c b5       	in	r24, 0x2c	; 44
     40a:	81 65       	ori	r24, 0x51	; 81
     40c:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<CS); 				//hoog maken CS	
     40e:	85 b1       	in	r24, 0x05	; 5
     410:	81 60       	ori	r24, 0x01	; 1
     412:	85 b9       	out	0x05, r24	; 5
     414:	08 95       	ret

00000416 <xmit_spi>:
}

static BYTE xmit_spi(BYTE data)
{
	PORTB &= ~(1<<CS); //laag maken
     416:	95 b1       	in	r25, 0x05	; 5
     418:	9e 7f       	andi	r25, 0xFE	; 254
     41a:	95 b9       	out	0x05, r25	; 5
	/* Start transmission */
	SPDR = data;
     41c:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     41e:	0d b4       	in	r0, 0x2d	; 45
     420:	07 fe       	sbrs	r0, 7
     422:	fd cf       	rjmp	.-6      	; 0x41e <xmit_spi+0x8>
	PORTB |= (1<<CS);		//hoog maken CS
     424:	85 b1       	in	r24, 0x05	; 5
     426:	81 60       	ori	r24, 0x01	; 1
     428:	85 b9       	out	0x05, r24	; 5
	
	return SPDR; 
     42a:	8e b5       	in	r24, 0x2e	; 46
}
     42c:	08 95       	ret

0000042e <rcv_spi>:

static BYTE rcv_spi(void)
{
	return xmit_spi(0xFF);
     42e:	8f ef       	ldi	r24, 0xFF	; 255
     430:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
}
     434:	08 95       	ret

00000436 <send_cmd>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static BYTE send_cmd(BYTE  cmd, /* 1st byte (Start + Index) */
                     DWORD arg ) /* Argument (32 bits) */
{
     436:	ff 92       	push	r15
     438:	0f 93       	push	r16
     43a:	1f 93       	push	r17
     43c:	cf 93       	push	r28
     43e:	df 93       	push	r29
     440:	c8 2f       	mov	r28, r24
     442:	d4 2f       	mov	r29, r20
     444:	15 2f       	mov	r17, r21
     446:	06 2f       	mov	r16, r22
     448:	f7 2e       	mov	r15, r23
	BYTE n, res;

	if (cmd & 0x80) { /* ACMD<n> is the command sequence of CMD55-CMD<n> */
     44a:	88 23       	and	r24, r24
     44c:	4c f4       	brge	.+18     	; 0x460 <send_cmd+0x2a>
		cmd &= 0x7F;
     44e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	50 e0       	ldi	r21, 0x00	; 0
     454:	ba 01       	movw	r22, r20
     456:	87 e7       	ldi	r24, 0x77	; 119
     458:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
		if (res > 1)
     45c:	82 30       	cpi	r24, 0x02	; 2
     45e:	50 f5       	brcc	.+84     	; 0x4b4 <send_cmd+0x7e>
			return res;
	}

	/* Select the card */
	DESELECT();
     460:	85 b1       	in	r24, 0x05	; 5
     462:	81 60       	ori	r24, 0x01	; 1
     464:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     466:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	SELECT();
     46a:	85 b1       	in	r24, 0x05	; 5
     46c:	8e 7f       	andi	r24, 0xFE	; 254
     46e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     470:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	/* Send a command packet */
	xmit_spi(cmd);               /* Start + Command index */
     474:	8c 2f       	mov	r24, r28
     476:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
     47a:	8f 2d       	mov	r24, r15
     47c:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
     480:	80 2f       	mov	r24, r16
     482:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
     486:	81 2f       	mov	r24, r17
     488:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
     48c:	8d 2f       	mov	r24, r29
     48e:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
	n = 0x01;                    /* Dummy CRC + Stop */
	if (cmd == CMD0)
     492:	c0 34       	cpi	r28, 0x40	; 64
     494:	11 f0       	breq	.+4      	; 0x49a <send_cmd+0x64>
	xmit_spi(cmd);               /* Start + Command index */
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
	n = 0x01;                    /* Dummy CRC + Stop */
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	01 c0       	rjmp	.+2      	; 0x49c <send_cmd+0x66>
	if (cmd == CMD0)
		n = 0x95; /* Valid CRC for CMD0(0) */
     49a:	85 e9       	ldi	r24, 0x95	; 149
	if (cmd == CMD8)
     49c:	c8 34       	cpi	r28, 0x48	; 72
     49e:	09 f4       	brne	.+2      	; 0x4a2 <send_cmd+0x6c>
		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
     4a0:	87 e8       	ldi	r24, 0x87	; 135
	xmit_spi(n);
     4a2:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>

	/* Receive a command response */
	n = 10; /* Wait for a valid response in timeout of 10 attempts */
     4a6:	ca e0       	ldi	r28, 0x0A	; 10
	do {
		res = rcv_spi();
     4a8:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	} while ((res & 0x80) && --n);
     4ac:	88 23       	and	r24, r24
     4ae:	14 f4       	brge	.+4      	; 0x4b4 <send_cmd+0x7e>
     4b0:	c1 50       	subi	r28, 0x01	; 1
     4b2:	d1 f7       	brne	.-12     	; 0x4a8 <send_cmd+0x72>

	return res; /* Return with the response value */
}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	1f 91       	pop	r17
     4ba:	0f 91       	pop	r16
     4bc:	ff 90       	pop	r15
     4be:	08 95       	ret

000004c0 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(void)
{
     4c0:	ef 92       	push	r14
     4c2:	ff 92       	push	r15
     4c4:	0f 93       	push	r16
     4c6:	1f 93       	push	r17
     4c8:	cf 93       	push	r28
     4ca:	df 93       	push	r29
     4cc:	00 d0       	rcall	.+0      	; 0x4ce <disk_initialize+0xe>
     4ce:	00 d0       	rcall	.+0      	; 0x4d0 <disk_initialize+0x10>
     4d0:	cd b7       	in	r28, 0x3d	; 61
     4d2:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING)
     4d4:	80 91 c5 01 	lds	r24, 0x01C5	; 0x8001c5 <CardType>
     4d8:	81 11       	cpse	r24, r1
     4da:	84 b1       	in	r24, 0x04	; 4
		disk_writep(0, 0); /* Finalize write process if it is in progress */
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
     4dc:	0e 94 fe 01 	call	0x3fc	; 0x3fc <init_spi>
	DESELECT();
     4e0:	85 b1       	in	r24, 0x05	; 5
     4e2:	81 60       	ori	r24, 0x01	; 1
     4e4:	85 b9       	out	0x05, r24	; 5
	for (n = 10; n; n--)
     4e6:	1a e0       	ldi	r17, 0x0A	; 10
     4e8:	03 c0       	rjmp	.+6      	; 0x4f0 <disk_initialize+0x30>
		rcv_spi(); /* 80 dummy clocks with CS=H */
     4ea:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
     4ee:	11 50       	subi	r17, 0x01	; 1
     4f0:	11 11       	cpse	r17, r1
     4f2:	fb cf       	rjmp	.-10     	; 0x4ea <disk_initialize+0x2a>
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
     4f4:	40 e0       	ldi	r20, 0x00	; 0
     4f6:	50 e0       	ldi	r21, 0x00	; 0
     4f8:	ba 01       	movw	r22, r20
     4fa:	80 e4       	ldi	r24, 0x40	; 64
     4fc:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     500:	81 30       	cpi	r24, 0x01	; 1
     502:	09 f0       	breq	.+2      	; 0x506 <disk_initialize+0x46>
     504:	9b c0       	rjmp	.+310    	; 0x63c <disk_initialize+0x17c>
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
     506:	4a ea       	ldi	r20, 0xAA	; 170
     508:	51 e0       	ldi	r21, 0x01	; 1
     50a:	60 e0       	ldi	r22, 0x00	; 0
     50c:	70 e0       	ldi	r23, 0x00	; 0
     50e:	88 e4       	ldi	r24, 0x48	; 72
     510:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     514:	81 30       	cpi	r24, 0x01	; 1
     516:	09 f0       	breq	.+2      	; 0x51a <disk_initialize+0x5a>
     518:	59 c0       	rjmp	.+178    	; 0x5cc <disk_initialize+0x10c>
     51a:	0d c0       	rjmp	.+26     	; 0x536 <disk_initialize+0x76>
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
     51c:	e0 2e       	mov	r14, r16
     51e:	f1 2c       	mov	r15, r1
     520:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     524:	e1 e0       	ldi	r30, 0x01	; 1
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	ec 0f       	add	r30, r28
     52a:	fd 1f       	adc	r31, r29
     52c:	ee 0d       	add	r30, r14
     52e:	ff 1d       	adc	r31, r15
     530:	80 83       	st	Z, r24
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
     532:	0f 5f       	subi	r16, 0xFF	; 255
     534:	01 c0       	rjmp	.+2      	; 0x538 <disk_initialize+0x78>
     536:	01 2f       	mov	r16, r17
     538:	04 30       	cpi	r16, 0x04	; 4
     53a:	80 f3       	brcs	.-32     	; 0x51c <disk_initialize+0x5c>
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
     53c:	8b 81       	ldd	r24, Y+3	; 0x03
     53e:	81 30       	cpi	r24, 0x01	; 1
     540:	09 f0       	breq	.+2      	; 0x544 <disk_initialize+0x84>
     542:	7e c0       	rjmp	.+252    	; 0x640 <disk_initialize+0x180>
     544:	8c 81       	ldd	r24, Y+4	; 0x04
     546:	8a 3a       	cpi	r24, 0xAA	; 170
     548:	61 f0       	breq	.+24     	; 0x562 <disk_initialize+0xa2>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     54a:	f1 2c       	mov	r15, r1
     54c:	84 c0       	rjmp	.+264    	; 0x656 <disk_initialize+0x196>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     54e:	8f e8       	ldi	r24, 0x8F	; 143
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	01 97       	sbiw	r24, 0x01	; 1
     554:	f1 f7       	brne	.-4      	; 0x552 <disk_initialize+0x92>
     556:	00 c0       	rjmp	.+0      	; 0x558 <disk_initialize+0x98>
     558:	00 00       	nop
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
     55a:	91 e0       	ldi	r25, 0x01	; 1
     55c:	e9 1a       	sub	r14, r25
     55e:	f1 08       	sbc	r15, r1
     560:	06 c0       	rjmp	.+12     	; 0x56e <disk_initialize+0xae>
     562:	0f 2e       	mov	r0, r31
     564:	f0 e1       	ldi	r31, 0x10	; 16
     566:	ef 2e       	mov	r14, r31
     568:	f7 e2       	ldi	r31, 0x27	; 39
     56a:	ff 2e       	mov	r15, r31
     56c:	f0 2d       	mov	r31, r0
     56e:	e1 14       	cp	r14, r1
     570:	f1 04       	cpc	r15, r1
     572:	49 f0       	breq	.+18     	; 0x586 <disk_initialize+0xc6>
     574:	40 e0       	ldi	r20, 0x00	; 0
     576:	50 e0       	ldi	r21, 0x00	; 0
     578:	60 e0       	ldi	r22, 0x00	; 0
     57a:	70 e4       	ldi	r23, 0x40	; 64
     57c:	89 ee       	ldi	r24, 0xE9	; 233
     57e:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     582:	81 11       	cpse	r24, r1
     584:	e4 cf       	rjmp	.-56     	; 0x54e <disk_initialize+0x8e>
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
     586:	ef 28       	or	r14, r15
     588:	09 f4       	brne	.+2      	; 0x58c <disk_initialize+0xcc>
     58a:	5c c0       	rjmp	.+184    	; 0x644 <disk_initialize+0x184>
     58c:	40 e0       	ldi	r20, 0x00	; 0
     58e:	50 e0       	ldi	r21, 0x00	; 0
     590:	ba 01       	movw	r22, r20
     592:	8a e7       	ldi	r24, 0x7A	; 122
     594:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	71 f0       	breq	.+28     	; 0x5b8 <disk_initialize+0xf8>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     59c:	f1 2c       	mov	r15, r1
     59e:	5b c0       	rjmp	.+182    	; 0x656 <disk_initialize+0x196>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
     5a0:	e1 2e       	mov	r14, r17
     5a2:	f1 2c       	mov	r15, r1
     5a4:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     5a8:	e1 e0       	ldi	r30, 0x01	; 1
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	ec 0f       	add	r30, r28
     5ae:	fd 1f       	adc	r31, r29
     5b0:	ee 0d       	add	r30, r14
     5b2:	ff 1d       	adc	r31, r15
     5b4:	80 83       	st	Z, r24
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
     5b6:	1f 5f       	subi	r17, 0xFF	; 255
     5b8:	14 30       	cpi	r17, 0x04	; 4
     5ba:	90 f3       	brcs	.-28     	; 0x5a0 <disk_initialize+0xe0>
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     5bc:	89 81       	ldd	r24, Y+1	; 0x01
     5be:	86 ff       	sbrs	r24, 6
     5c0:	43 c0       	rjmp	.+134    	; 0x648 <disk_initialize+0x188>
     5c2:	0f 2e       	mov	r0, r31
     5c4:	fc e0       	ldi	r31, 0x0C	; 12
     5c6:	ff 2e       	mov	r15, r31
     5c8:	f0 2d       	mov	r31, r0
     5ca:	45 c0       	rjmp	.+138    	; 0x656 <disk_initialize+0x196>
				}
			}
		} else { /* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) {
     5cc:	40 e0       	ldi	r20, 0x00	; 0
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	ba 01       	movw	r22, r20
     5d2:	89 ee       	ldi	r24, 0xE9	; 233
     5d4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     5d8:	82 30       	cpi	r24, 0x02	; 2
     5da:	40 f4       	brcc	.+16     	; 0x5ec <disk_initialize+0x12c>
				ty  = CT_SD1;
     5dc:	68 94       	set
     5de:	ff 24       	eor	r15, r15
     5e0:	f1 f8       	bld	r15, 1
				cmd = ACMD41; /* SDv1 */
     5e2:	0f 2e       	mov	r0, r31
     5e4:	f9 ee       	ldi	r31, 0xE9	; 233
     5e6:	ef 2e       	mov	r14, r31
     5e8:	f0 2d       	mov	r31, r0
     5ea:	06 c0       	rjmp	.+12     	; 0x5f8 <disk_initialize+0x138>
			} else {
				ty  = CT_MMC;
     5ec:	ff 24       	eor	r15, r15
     5ee:	f3 94       	inc	r15
				cmd = CMD1; /* MMCv3 */
     5f0:	0f 2e       	mov	r0, r31
     5f2:	f1 e4       	ldi	r31, 0x41	; 65
     5f4:	ef 2e       	mov	r14, r31
     5f6:	f0 2d       	mov	r31, r0
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
     5f8:	00 e1       	ldi	r16, 0x10	; 16
     5fa:	17 e2       	ldi	r17, 0x27	; 39
     5fc:	08 c0       	rjmp	.+16     	; 0x60e <disk_initialize+0x14e>
     5fe:	8f e8       	ldi	r24, 0x8F	; 143
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	01 97       	sbiw	r24, 0x01	; 1
     604:	f1 f7       	brne	.-4      	; 0x602 <disk_initialize+0x142>
     606:	00 c0       	rjmp	.+0      	; 0x608 <disk_initialize+0x148>
     608:	00 00       	nop
     60a:	01 50       	subi	r16, 0x01	; 1
     60c:	11 09       	sbc	r17, r1
     60e:	01 15       	cp	r16, r1
     610:	11 05       	cpc	r17, r1
     612:	41 f0       	breq	.+16     	; 0x624 <disk_initialize+0x164>
     614:	40 e0       	ldi	r20, 0x00	; 0
     616:	50 e0       	ldi	r21, 0x00	; 0
     618:	ba 01       	movw	r22, r20
     61a:	8e 2d       	mov	r24, r14
     61c:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     620:	81 11       	cpse	r24, r1
     622:	ed cf       	rjmp	.-38     	; 0x5fe <disk_initialize+0x13e>
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
     624:	01 2b       	or	r16, r17
     626:	a1 f0       	breq	.+40     	; 0x650 <disk_initialize+0x190>
     628:	40 e0       	ldi	r20, 0x00	; 0
     62a:	52 e0       	ldi	r21, 0x02	; 2
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 e5       	ldi	r24, 0x50	; 80
     632:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     636:	81 11       	cpse	r24, r1
     638:	0d c0       	rjmp	.+26     	; 0x654 <disk_initialize+0x194>
     63a:	0d c0       	rjmp	.+26     	; 0x656 <disk_initialize+0x196>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     63c:	f1 2c       	mov	r15, r1
     63e:	0b c0       	rjmp	.+22     	; 0x656 <disk_initialize+0x196>
     640:	f1 2c       	mov	r15, r1
     642:	09 c0       	rjmp	.+18     	; 0x656 <disk_initialize+0x196>
     644:	f1 2c       	mov	r15, r1
     646:	07 c0       	rjmp	.+14     	; 0x656 <disk_initialize+0x196>
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     648:	68 94       	set
     64a:	ff 24       	eor	r15, r15
     64c:	f2 f8       	bld	r15, 2
     64e:	03 c0       	rjmp	.+6      	; 0x656 <disk_initialize+0x196>
				cmd = CMD1; /* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
				ty = 0;
     650:	f1 2c       	mov	r15, r1
     652:	01 c0       	rjmp	.+2      	; 0x656 <disk_initialize+0x196>
     654:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     656:	f0 92 c5 01 	sts	0x01C5, r15	; 0x8001c5 <CardType>
	DESELECT();
     65a:	85 b1       	in	r24, 0x05	; 5
     65c:	81 60       	ori	r24, 0x01	; 1
     65e:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     660:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return ty ? 0 : STA_NOINIT;
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	f1 10       	cpse	r15, r1
     668:	80 e0       	ldi	r24, 0x00	; 0
}
     66a:	0f 90       	pop	r0
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	0f 90       	pop	r0
     672:	df 91       	pop	r29
     674:	cf 91       	pop	r28
     676:	1f 91       	pop	r17
     678:	0f 91       	pop	r16
     67a:	ff 90       	pop	r15
     67c:	ef 90       	pop	r14
     67e:	08 95       	ret

00000680 <disk_readp>:
DRESULT disk_readp(BYTE *buff,   /* Pointer to the read buffer (NULL:Forward to the stream) */
                   DWORD sector, /* Sector number (LBA) */
                   UINT  offset, /* Byte offset to read from (0..511) */
                   UINT  count   /* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
     680:	af 92       	push	r10
     682:	bf 92       	push	r11
     684:	cf 92       	push	r12
     686:	df 92       	push	r13
     688:	ef 92       	push	r14
     68a:	ff 92       	push	r15
     68c:	0f 93       	push	r16
     68e:	1f 93       	push	r17
     690:	cf 93       	push	r28
     692:	df 93       	push	r29
     694:	6c 01       	movw	r12, r24
     696:	79 01       	movw	r14, r18
	DRESULT res;
	BYTE    rc;
	UINT    bc;

	if (!(CardType & CT_BLOCK))
     698:	80 91 c5 01 	lds	r24, 0x01C5	; 0x8001c5 <CardType>
     69c:	83 fd       	sbrc	r24, 3
     69e:	09 c0       	rjmp	.+18     	; 0x6b2 <disk_readp+0x32>
		sector *= 512; /* Convert to byte address if needed */
     6a0:	03 2e       	mov	r0, r19
     6a2:	39 e0       	ldi	r19, 0x09	; 9
     6a4:	44 0f       	add	r20, r20
     6a6:	55 1f       	adc	r21, r21
     6a8:	66 1f       	adc	r22, r22
     6aa:	77 1f       	adc	r23, r23
     6ac:	3a 95       	dec	r19
     6ae:	d1 f7       	brne	.-12     	; 0x6a4 <disk_readp+0x24>
     6b0:	30 2d       	mov	r19, r0

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
     6b2:	81 e5       	ldi	r24, 0x51	; 81
     6b4:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     6b8:	81 11       	cpse	r24, r1
     6ba:	31 c0       	rjmp	.+98     	; 0x71e <disk_readp+0x9e>

		// bc = 40000;	/* Time counter */
		do { /* Wait for response */
			rc = rcv_spi();
     6bc:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		} while (rc == 0xFF);
     6c0:	8f 3f       	cpi	r24, 0xFF	; 255
     6c2:	e1 f3       	breq	.-8      	; 0x6bc <disk_readp+0x3c>

		if (rc == 0xFE) { /* A data packet arrived */
     6c4:	8e 3f       	cpi	r24, 0xFE	; 254
     6c6:	69 f5       	brne	.+90     	; 0x722 <disk_readp+0xa2>

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */
     6c8:	cc 27       	eor	r28, r28
     6ca:	dd 27       	eor	r29, r29
     6cc:	ce 19       	sub	r28, r14
     6ce:	df 09       	sbc	r29, r15
     6d0:	c0 1b       	sub	r28, r16
     6d2:	d1 0b       	sbc	r29, r17
     6d4:	ce 5f       	subi	r28, 0xFE	; 254
     6d6:	dd 4f       	sbci	r29, 0xFD	; 253

			/* Skip leading bytes */
			while (offset--)
     6d8:	03 c0       	rjmp	.+6      	; 0x6e0 <disk_readp+0x60>
				rcv_spi();
     6da:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
		if (rc == 0xFE) { /* A data packet arrived */

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */

			/* Skip leading bytes */
			while (offset--)
     6de:	75 01       	movw	r14, r10
     6e0:	57 01       	movw	r10, r14
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	a8 1a       	sub	r10, r24
     6e6:	b1 08       	sbc	r11, r1
     6e8:	ef 28       	or	r14, r15
     6ea:	b9 f7       	brne	.-18     	; 0x6da <disk_readp+0x5a>
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
     6ec:	c1 14       	cp	r12, r1
     6ee:	d1 04       	cpc	r13, r1
     6f0:	69 f0       	breq	.+26     	; 0x70c <disk_readp+0x8c>
				do {
					*buff++ = rcv_spi();
     6f2:	76 01       	movw	r14, r12
     6f4:	ef ef       	ldi	r30, 0xFF	; 255
     6f6:	ee 1a       	sub	r14, r30
     6f8:	fe 0a       	sbc	r15, r30
     6fa:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     6fe:	f6 01       	movw	r30, r12
     700:	80 83       	st	Z, r24
				} while (--count);
     702:	01 50       	subi	r16, 0x01	; 1
     704:	11 09       	sbc	r17, r1
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
				do {
					*buff++ = rcv_spi();
     706:	67 01       	movw	r12, r14
				} while (--count);
     708:	a1 f7       	brne	.-24     	; 0x6f2 <disk_readp+0x72>
     70a:	03 c0       	rjmp	.+6      	; 0x712 <disk_readp+0x92>
			} else { /* Forward data to the outgoing stream */
				do {
					// FORWARD(rcv_spi());
				} while (--count);
     70c:	01 50       	subi	r16, 0x01	; 1
     70e:	11 09       	sbc	r17, r1
     710:	e9 f7       	brne	.-6      	; 0x70c <disk_readp+0x8c>
			}

			/* Skip trailing bytes and CRC */
			do
				rcv_spi();
     712:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
			while (--bc);
     716:	21 97       	sbiw	r28, 0x01	; 1
     718:	e1 f7       	brne	.-8      	; 0x712 <disk_readp+0x92>

			res = RES_OK;
     71a:	c0 e0       	ldi	r28, 0x00	; 0
     71c:	03 c0       	rjmp	.+6      	; 0x724 <disk_readp+0xa4>
	UINT    bc;

	if (!(CardType & CT_BLOCK))
		sector *= 512; /* Convert to byte address if needed */

	res = RES_ERROR;
     71e:	c1 e0       	ldi	r28, 0x01	; 1
     720:	01 c0       	rjmp	.+2      	; 0x724 <disk_readp+0xa4>
     722:	c1 e0       	ldi	r28, 0x01	; 1

			res = RES_OK;
		}
	}

	DESELECT();
     724:	85 b1       	in	r24, 0x05	; 5
     726:	81 60       	ori	r24, 0x01	; 1
     728:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     72a:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>

	return res;
}
     72e:	8c 2f       	mov	r24, r28
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	df 90       	pop	r13
     73e:	cf 90       	pop	r12
     740:	bf 90       	pop	r11
     742:	af 90       	pop	r10
     744:	08 95       	ret

00000746 <disk_writep>:

#if _USE_WRITE
DRESULT disk_writep(const BYTE *buff, /* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
                    DWORD       sc    /* Number of bytes to send, Sector number (LBA) or zero */
)
{
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	fc 01       	movw	r30, r24
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
     750:	89 2b       	or	r24, r25
     752:	f1 f0       	breq	.+60     	; 0x790 <disk_writep+0x4a>
		bc = sc;
     754:	ea 01       	movw	r28, r20
		while (bc && wc) { /* Send data bytes to the card */
     756:	11 c0       	rjmp	.+34     	; 0x77a <disk_writep+0x34>
			xmit_spi(*buff++);
     758:	8f 01       	movw	r16, r30
     75a:	0f 5f       	subi	r16, 0xFF	; 255
     75c:	1f 4f       	sbci	r17, 0xFF	; 255
     75e:	80 81       	ld	r24, Z
     760:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
			wc--;
     764:	80 91 c3 01 	lds	r24, 0x01C3	; 0x8001c3 <wc.1882>
     768:	90 91 c4 01 	lds	r25, 0x01C4	; 0x8001c4 <wc.1882+0x1>
     76c:	01 97       	sbiw	r24, 0x01	; 1
     76e:	90 93 c4 01 	sts	0x01C4, r25	; 0x8001c4 <wc.1882+0x1>
     772:	80 93 c3 01 	sts	0x01C3, r24	; 0x8001c3 <wc.1882>
			bc--;
     776:	21 97       	sbiw	r28, 0x01	; 1
	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
     778:	f8 01       	movw	r30, r16

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
     77a:	20 97       	sbiw	r28, 0x00	; 0
     77c:	09 f4       	brne	.+2      	; 0x780 <disk_writep+0x3a>
     77e:	5f c0       	rjmp	.+190    	; 0x83e <__DATA_REGION_LENGTH__+0x3e>
     780:	80 91 c3 01 	lds	r24, 0x01C3	; 0x8001c3 <wc.1882>
     784:	90 91 c4 01 	lds	r25, 0x01C4	; 0x8001c4 <wc.1882+0x1>
     788:	89 2b       	or	r24, r25
     78a:	31 f7       	brne	.-52     	; 0x758 <disk_writep+0x12>
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     78c:	c0 e0       	ldi	r28, 0x00	; 0
     78e:	5a c0       	rjmp	.+180    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
	} else {
		if (sc) { /* Initiate sector write process */
     790:	41 15       	cp	r20, r1
     792:	51 05       	cpc	r21, r1
     794:	61 05       	cpc	r22, r1
     796:	71 05       	cpc	r23, r1
     798:	01 f1       	breq	.+64     	; 0x7da <disk_writep+0x94>
			if (!(CardType & CT_BLOCK))
     79a:	80 91 c5 01 	lds	r24, 0x01C5	; 0x8001c5 <CardType>
     79e:	83 fd       	sbrc	r24, 3
     7a0:	09 c0       	rjmp	.+18     	; 0x7b4 <disk_writep+0x6e>
				sc *= 512;                  /* Convert to byte address if needed */
     7a2:	03 2e       	mov	r0, r19
     7a4:	39 e0       	ldi	r19, 0x09	; 9
     7a6:	44 0f       	add	r20, r20
     7a8:	55 1f       	adc	r21, r21
     7aa:	66 1f       	adc	r22, r22
     7ac:	77 1f       	adc	r23, r23
     7ae:	3a 95       	dec	r19
     7b0:	d1 f7       	brne	.-12     	; 0x7a6 <disk_writep+0x60>
     7b2:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sc) == 0) { /* WRITE_SINGLE_BLOCK */
     7b4:	88 e5       	ldi	r24, 0x58	; 88
     7b6:	0e 94 1b 02 	call	0x436	; 0x436 <send_cmd>
     7ba:	81 11       	cpse	r24, r1
     7bc:	42 c0       	rjmp	.+132    	; 0x842 <__DATA_REGION_LENGTH__+0x42>
				xmit_spi(0xFF);
     7be:	8f ef       	ldi	r24, 0xFF	; 255
     7c0:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				xmit_spi(0xFE); /* Data block header */
     7c4:	8e ef       	ldi	r24, 0xFE	; 254
     7c6:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	92 e0       	ldi	r25, 0x02	; 2
     7ce:	90 93 c4 01 	sts	0x01C4, r25	; 0x8001c4 <wc.1882+0x1>
     7d2:	80 93 c3 01 	sts	0x01C3, r24	; 0x8001c3 <wc.1882>
				res = RES_OK;
     7d6:	c0 e0       	ldi	r28, 0x00	; 0
     7d8:	35 c0       	rjmp	.+106    	; 0x844 <__DATA_REGION_LENGTH__+0x44>
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
     7da:	80 91 c3 01 	lds	r24, 0x01C3	; 0x8001c3 <wc.1882>
     7de:	90 91 c4 01 	lds	r25, 0x01C4	; 0x8001c4 <wc.1882+0x1>
     7e2:	02 96       	adiw	r24, 0x02	; 2
			while (bc--) {
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <disk_writep+0xa8>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
     7e6:	80 e0       	ldi	r24, 0x00	; 0
     7e8:	0e 94 0b 02 	call	0x416	; 0x416 <xmit_spi>
				wc  = 512;      /* Set byte counter */
				res = RES_OK;
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
			while (bc--) {
     7ec:	ce 01       	movw	r24, r28
     7ee:	ec 01       	movw	r28, r24
     7f0:	21 97       	sbiw	r28, 0x01	; 1
     7f2:	89 2b       	or	r24, r25
     7f4:	c1 f7       	brne	.-16     	; 0x7e6 <disk_writep+0xa0>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
			}
			do {
				res = rcv_spi();
     7f6:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     7fa:	c8 2f       	mov	r28, r24
			} while (res == 0xFF);
     7fc:	8f 3f       	cpi	r24, 0xFF	; 255
     7fe:	d9 f3       	breq	.-10     	; 0x7f6 <disk_writep+0xb0>
			if ((res & 0x1F) == 0x05) { /* Receive data resp and wait for end of write process in timeout of 500ms */
     800:	8f 71       	andi	r24, 0x1F	; 31
     802:	85 30       	cpi	r24, 0x05	; 5
     804:	b1 f4       	brne	.+44     	; 0x832 <__DATA_REGION_LENGTH__+0x32>
     806:	09 c0       	rjmp	.+18     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     808:	8f e8       	ldi	r24, 0x8F	; 143
     80a:	91 e0       	ldi	r25, 0x01	; 1
     80c:	01 97       	sbiw	r24, 0x01	; 1
     80e:	f1 f7       	brne	.-4      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     810:	00 c0       	rjmp	.+0      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
     812:	00 00       	nop
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--) /* Wait for ready */
     814:	01 50       	subi	r16, 0x01	; 1
     816:	11 09       	sbc	r17, r1
     818:	02 c0       	rjmp	.+4      	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     81a:	08 e8       	ldi	r16, 0x88	; 136
     81c:	13 e1       	ldi	r17, 0x13	; 19
     81e:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     822:	8f 3f       	cpi	r24, 0xFF	; 255
     824:	19 f0       	breq	.+6      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     826:	01 15       	cp	r16, r1
     828:	11 05       	cpc	r17, r1
     82a:	71 f7       	brne	.-36     	; 0x808 <__DATA_REGION_LENGTH__+0x8>
					_delay_us(100);
				if (bc)
     82c:	01 2b       	or	r16, r17
     82e:	09 f0       	breq	.+2      	; 0x832 <__DATA_REGION_LENGTH__+0x32>
					res = RES_OK;
     830:	c0 e0       	ldi	r28, 0x00	; 0
			}
			DESELECT();
     832:	85 b1       	in	r24, 0x05	; 5
     834:	81 60       	ori	r24, 0x01	; 1
     836:	85 b9       	out	0x05, r24	; 5
			rcv_spi();
     838:	0e 94 17 02 	call	0x42e	; 0x42e <rcv_spi>
     83c:	03 c0       	rjmp	.+6      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     83e:	c0 e0       	ldi	r28, 0x00	; 0
     840:	01 c0       	rjmp	.+2      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
{
	DRESULT     res;
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;
     842:	c1 e0       	ldi	r28, 0x01	; 1
			rcv_spi();
		}
	}

	return res;
}
     844:	8c 2f       	mov	r24, r28
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	1f 91       	pop	r17
     84c:	0f 91       	pop	r16
     84e:	08 95       	ret

00000850 <__vector_10>:
unsigned long find_offset(void);
void writeToCard(void);
void write_to_buffer(char* zin, int length);

ISR(TIMER2_OVF_vect)
{
     850:	1f 92       	push	r1
     852:	0f 92       	push	r0
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	0f 92       	push	r0
     858:	11 24       	eor	r1, r1
     85a:	8f 93       	push	r24
     85c:	9f 93       	push	r25
	overflowCounter++;
     85e:	80 91 cb 01 	lds	r24, 0x01CB	; 0x8001cb <overflowCounter>
     862:	90 91 cc 01 	lds	r25, 0x01CC	; 0x8001cc <overflowCounter+0x1>
     866:	01 96       	adiw	r24, 0x01	; 1
     868:	90 93 cc 01 	sts	0x01CC, r25	; 0x8001cc <overflowCounter+0x1>
     86c:	80 93 cb 01 	sts	0x01CB, r24	; 0x8001cb <overflowCounter>
	TCNT2 = 0x00;
     870:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
}
     874:	9f 91       	pop	r25
     876:	8f 91       	pop	r24
     878:	0f 90       	pop	r0
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	0f 90       	pop	r0
     87e:	1f 90       	pop	r1
     880:	18 95       	reti

00000882 <init_timer>:
	while(1) {}
}

void init_timer(void)
{	
	TCNT2 = 0x00; // start counting at 0
     882:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f80b2>
	TCCR2A = ((1 << CS22) | (1 << CS21) | (1 << CS20)); // prescaler op 1024
     886:	87 e0       	ldi	r24, 0x07	; 7
     888:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
	TIMSK2 = (1 << TOIE2);
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7f8070>
     892:	08 95       	ret

00000894 <write_to_buffer>:
}

void write_to_buffer(char* zin, int length)
{
     894:	dc 01       	movw	r26, r24
	for (int i = 0; i < length; i++)
     896:	40 e0       	ldi	r20, 0x00	; 0
     898:	50 e0       	ldi	r21, 0x00	; 0
     89a:	14 c0       	rjmp	.+40     	; 0x8c4 <write_to_buffer+0x30>
	{
		write_buffer[bufferAmt++] = zin[i];
     89c:	20 91 cd 01 	lds	r18, 0x01CD	; 0x8001cd <bufferAmt>
     8a0:	30 91 ce 01 	lds	r19, 0x01CE	; 0x8001ce <bufferAmt+0x1>
     8a4:	f9 01       	movw	r30, r18
     8a6:	31 96       	adiw	r30, 0x01	; 1
     8a8:	f0 93 ce 01 	sts	0x01CE, r31	; 0x8001ce <bufferAmt+0x1>
     8ac:	e0 93 cd 01 	sts	0x01CD, r30	; 0x8001cd <bufferAmt>
     8b0:	fd 01       	movw	r30, r26
     8b2:	e4 0f       	add	r30, r20
     8b4:	f5 1f       	adc	r31, r21
     8b6:	90 81       	ld	r25, Z
     8b8:	f9 01       	movw	r30, r18
     8ba:	ef 52       	subi	r30, 0x2F	; 47
     8bc:	fe 4f       	sbci	r31, 0xFE	; 254
     8be:	90 83       	st	Z, r25
	TIMSK2 = (1 << TOIE2);
}

void write_to_buffer(char* zin, int length)
{
	for (int i = 0; i < length; i++)
     8c0:	4f 5f       	subi	r20, 0xFF	; 255
     8c2:	5f 4f       	sbci	r21, 0xFF	; 255
     8c4:	46 17       	cp	r20, r22
     8c6:	57 07       	cpc	r21, r23
     8c8:	4c f3       	brlt	.-46     	; 0x89c <write_to_buffer+0x8>
	{
		write_buffer[bufferAmt++] = zin[i];
	}
}
     8ca:	08 95       	ret

000008cc <fill_buffer>:


void fill_buffer(void)
{
     8cc:	0f 93       	push	r16
     8ce:	1f 93       	push	r17
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	cd b7       	in	r28, 0x3d	; 61
     8d6:	de b7       	in	r29, 0x3e	; 62
     8d8:	2b 97       	sbiw	r28, 0x0b	; 11
     8da:	0f b6       	in	r0, 0x3f	; 63
     8dc:	f8 94       	cli
     8de:	de bf       	out	0x3e, r29	; 62
     8e0:	0f be       	out	0x3f, r0	; 63
     8e2:	cd bf       	out	0x3d, r28	; 61
	int val5 = 0;
	int val6 = 0;
	int val7 = 0;
	int val8 = 0;
	
	write_buffer[bufferAmt++] = '\n';
     8e4:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <bufferAmt>
     8e8:	90 91 ce 01 	lds	r25, 0x01CE	; 0x8001ce <bufferAmt+0x1>
     8ec:	9c 01       	movw	r18, r24
     8ee:	2f 5f       	subi	r18, 0xFF	; 255
     8f0:	3f 4f       	sbci	r19, 0xFF	; 255
     8f2:	30 93 ce 01 	sts	0x01CE, r19	; 0x8001ce <bufferAmt+0x1>
     8f6:	20 93 cd 01 	sts	0x01CD, r18	; 0x8001cd <bufferAmt>
     8fa:	fc 01       	movw	r30, r24
     8fc:	ef 52       	subi	r30, 0x2F	; 47
     8fe:	fe 4f       	sbci	r31, 0xFE	; 254
     900:	2a e0       	ldi	r18, 0x0A	; 10
     902:	20 83       	st	Z, r18
	
	CANMessage bericht;
	int resultaat;
	do 
	{
		resultaat = getMessage(&bericht); // 0 als er geen bericht is, anders 1
     904:	ce 01       	movw	r24, r28
     906:	01 96       	adiw	r24, 0x01	; 1
     908:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <getMessage>
     90c:	08 2f       	mov	r16, r24
     90e:	10 e0       	ldi	r17, 0x00	; 0
		if(resultaat == 0)
     910:	01 15       	cp	r16, r1
     912:	11 05       	cpc	r17, r1
     914:	39 f4       	brne	.+14     	; 0x924 <__stack+0x25>
		{
			char* string = "GEEN DATA ONTVANGEN";
			int length = strlen(string);
			write_to_buffer(string, length);
     916:	63 e1       	ldi	r22, 0x13	; 19
     918:	70 e0       	ldi	r23, 0x00	; 0
     91a:	80 e0       	ldi	r24, 0x00	; 0
     91c:	91 e0       	ldi	r25, 0x01	; 1
     91e:	0e 94 4a 04 	call	0x894	; 0x894 <write_to_buffer>
     922:	21 c0       	rjmp	.+66     	; 0x966 <__stack+0x67>
		} else
		{
			switch(bericht.id)
     924:	89 81       	ldd	r24, Y+1	; 0x01
     926:	2a 81       	ldd	r18, Y+2	; 0x02
     928:	92 2f       	mov	r25, r18
     92a:	97 70       	andi	r25, 0x07	; 7
     92c:	40 97       	sbiw	r24, 0x10	; 16
     92e:	d9 f4       	brne	.+54     	; 0x966 <__stack+0x67>
			{
				case CAN_ID_SNELHEIDSMETER:
					val1 = bericht.data[0];
     930:	8b 81       	ldd	r24, Y+3	; 0x03
					val2 = bericht.data[1];
     932:	9c 81       	ldd	r25, Y+4	; 0x04
					sprintf(zin_buffer, "snelheid: %03d.%02d", val1, val2);
     934:	1f 92       	push	r1
     936:	9f 93       	push	r25
     938:	1f 92       	push	r1
     93a:	8f 93       	push	r24
     93c:	84 e1       	ldi	r24, 0x14	; 20
     93e:	91 e0       	ldi	r25, 0x01	; 1
     940:	9f 93       	push	r25
     942:	8f 93       	push	r24
     944:	8f ea       	ldi	r24, 0xAF	; 175
     946:	94 e0       	ldi	r25, 0x04	; 4
     948:	9f 93       	push	r25
     94a:	8f 93       	push	r24
     94c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <sprintf>
					write_to_buffer(zin_buffer, 16);
     950:	60 e1       	ldi	r22, 0x10	; 16
     952:	70 e0       	ldi	r23, 0x00	; 0
     954:	8f ea       	ldi	r24, 0xAF	; 175
     956:	94 e0       	ldi	r25, 0x04	; 4
     958:	0e 94 4a 04 	call	0x894	; 0x894 <write_to_buffer>
					break;
     95c:	0f b6       	in	r0, 0x3f	; 63
     95e:	f8 94       	cli
     960:	de bf       	out	0x3e, r29	; 62
     962:	0f be       	out	0x3f, r0	; 63
     964:	cd bf       	out	0x3d, r28	; 61
					write_to_buffer(zin_buffer, 19);
					break;
				// schrijf een case voor alle can_id's
			}
		}
	} while (resultaat != 0);
     966:	01 2b       	or	r16, r17
     968:	69 f6       	brne	.-102    	; 0x904 <__stack+0x5>
	
	
	if(bufferAmt>=(512-30)) // sectorgrootte van 512 bytes - ongeveer 30 bytes (iets meer dan 2 lines)
     96a:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <bufferAmt>
     96e:	90 91 ce 01 	lds	r25, 0x01CE	; 0x8001ce <bufferAmt+0x1>
     972:	82 3e       	cpi	r24, 0xE2	; 226
     974:	91 40       	sbci	r25, 0x01	; 1
     976:	3c f0       	brlt	.+14     	; 0x986 <__stack+0x87>
	{
		bufferAmt = 0;
     978:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <bufferAmt+0x1>
     97c:	10 92 cd 01 	sts	0x01CD, r1	; 0x8001cd <bufferAmt>
		startWriting = true; // als dit op true staat gaat de microcontroller in de main>while(logging) in de if-statement en vult vanaf daar de sd-kaart 
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <startWriting>
	}
}
     986:	2b 96       	adiw	r28, 0x0b	; 11
     988:	0f b6       	in	r0, 0x3f	; 63
     98a:	f8 94       	cli
     98c:	de bf       	out	0x3e, r29	; 62
     98e:	0f be       	out	0x3f, r0	; 63
     990:	cd bf       	out	0x3d, r28	; 61
     992:	df 91       	pop	r29
     994:	cf 91       	pop	r28
     996:	1f 91       	pop	r17
     998:	0f 91       	pop	r16
     99a:	08 95       	ret

0000099c <writeToCard>:


void writeToCard(void)
{
	// Set file pointer to beginning of sector 
	pf_lseek(curOffset); // offset van 0 is te vinden in sector 8448 van de sd-kaart
     99c:	60 91 c6 01 	lds	r22, 0x01C6	; 0x8001c6 <curOffset>
     9a0:	70 91 c7 01 	lds	r23, 0x01C7	; 0x8001c7 <curOffset+0x1>
     9a4:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <curOffset+0x2>
     9a8:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <curOffset+0x3>
     9ac:	0e 94 bb 0c 	call	0x1976	; 0x1976 <pf_lseek>
	// Write buffer 
	pf_write(write_buffer, BUFFER_SIZE, &byte_counter);
     9b0:	4f ec       	ldi	r20, 0xCF	; 207
     9b2:	51 e0       	ldi	r21, 0x01	; 1
     9b4:	60 e0       	ldi	r22, 0x00	; 0
     9b6:	72 e0       	ldi	r23, 0x02	; 2
     9b8:	81 ed       	ldi	r24, 0xD1	; 209
     9ba:	91 e0       	ldi	r25, 0x01	; 1
     9bc:	0e 94 af 0b 	call	0x175e	; 0x175e <pf_write>
	if (byte_counter < BUFFER_SIZE) {
		// End of file 
	}
	// Finalize write 
	pf_write(0, 0, &byte_counter);
     9c0:	4f ec       	ldi	r20, 0xCF	; 207
     9c2:	51 e0       	ldi	r21, 0x01	; 1
     9c4:	60 e0       	ldi	r22, 0x00	; 0
     9c6:	70 e0       	ldi	r23, 0x00	; 0
     9c8:	80 e0       	ldi	r24, 0x00	; 0
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	0e 94 af 0b 	call	0x175e	; 0x175e <pf_write>
	// Reset file pointer to beginning of sector 1 
	pf_lseek(curOffset);
     9d0:	60 91 c6 01 	lds	r22, 0x01C6	; 0x8001c6 <curOffset>
     9d4:	70 91 c7 01 	lds	r23, 0x01C7	; 0x8001c7 <curOffset+0x1>
     9d8:	80 91 c8 01 	lds	r24, 0x01C8	; 0x8001c8 <curOffset+0x2>
     9dc:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <curOffset+0x3>
     9e0:	0e 94 bb 0c 	call	0x1976	; 0x1976 <pf_lseek>
     9e4:	08 95       	ret

000009e6 <find_offset>:
	}
	*/
}

unsigned long find_offset(void)
{
     9e6:	cf 92       	push	r12
     9e8:	df 92       	push	r13
     9ea:	ef 92       	push	r14
     9ec:	ff 92       	push	r15
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
     9f2:	00 d0       	rcall	.+0      	; 0x9f4 <find_offset+0xe>
     9f4:	1f 92       	push	r1
     9f6:	cd b7       	in	r28, 0x3d	; 61
     9f8:	de b7       	in	r29, 0x3e	; 62
	// begin bij sector 0. kijk naar waarde 1e char. als die erop wijst dat de sector al geschreven is, ga naar sector 1. ga zo door. return offset als sector leeg lijkt te zijn
	uint8_t read_first[1]  = {};
     9fa:	19 82       	std	Y+1, r1	; 0x01
	UINT bytecounter = 1;
     9fc:	81 e0       	ldi	r24, 0x01	; 1
     9fe:	90 e0       	ldi	r25, 0x00	; 0
     a00:	9b 83       	std	Y+3, r25	; 0x03
     a02:	8a 83       	std	Y+2, r24	; 0x02
	unsigned long tempOffset = 0;
     a04:	c1 2c       	mov	r12, r1
     a06:	d1 2c       	mov	r13, r1
     a08:	76 01       	movw	r14, r12
	unsigned long maxOffset = 51200; // als hij geen lege sector kan vinden na de 1e 100 sectoren
	while(1)
	{
		pf_lseek(tempOffset);
     a0a:	c7 01       	movw	r24, r14
     a0c:	b6 01       	movw	r22, r12
     a0e:	0e 94 bb 0c 	call	0x1976	; 0x1976 <pf_lseek>
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
     a12:	ae 01       	movw	r20, r28
     a14:	4e 5f       	subi	r20, 0xFE	; 254
     a16:	5f 4f       	sbci	r21, 0xFF	; 255
     a18:	61 e0       	ldi	r22, 0x01	; 1
     a1a:	70 e0       	ldi	r23, 0x00	; 0
     a1c:	ce 01       	movw	r24, r28
     a1e:	01 96       	adiw	r24, 0x01	; 1
     a20:	0e 94 cc 0a 	call	0x1598	; 0x1598 <pf_read>
		if(read_first[0] == 32)
     a24:	89 81       	ldd	r24, Y+1	; 0x01
     a26:	80 32       	cpi	r24, 0x20	; 32
     a28:	79 f0       	breq	.+30     	; 0xa48 <find_offset+0x62>
		{
			return tempOffset;
		} else {
			tempOffset += 512;
     a2a:	82 e0       	ldi	r24, 0x02	; 2
     a2c:	d8 0e       	add	r13, r24
     a2e:	e1 1c       	adc	r14, r1
     a30:	f1 1c       	adc	r15, r1
			if(tempOffset >= maxOffset)
     a32:	c1 14       	cp	r12, r1
     a34:	88 ec       	ldi	r24, 0xC8	; 200
     a36:	d8 06       	cpc	r13, r24
     a38:	e1 04       	cpc	r14, r1
     a3a:	f1 04       	cpc	r15, r1
     a3c:	30 f3       	brcs	.-52     	; 0xa0a <find_offset+0x24>
			break;
		}
	}
	return 0;
     a3e:	60 e0       	ldi	r22, 0x00	; 0
     a40:	70 e0       	ldi	r23, 0x00	; 0
     a42:	80 e0       	ldi	r24, 0x00	; 0
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	04 c0       	rjmp	.+8      	; 0xa50 <find_offset+0x6a>
	{
		pf_lseek(tempOffset);
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
		if(read_first[0] == 32)
		{
			return tempOffset;
     a48:	6c 2d       	mov	r22, r12
     a4a:	7d 2d       	mov	r23, r13
     a4c:	8e 2d       	mov	r24, r14
     a4e:	9f 2d       	mov	r25, r15
			if(tempOffset >= maxOffset)
			break;
		}
	}
	return 0;
}
     a50:	0f 90       	pop	r0
     a52:	0f 90       	pop	r0
     a54:	0f 90       	pop	r0
     a56:	df 91       	pop	r29
     a58:	cf 91       	pop	r28
     a5a:	ff 90       	pop	r15
     a5c:	ef 90       	pop	r14
     a5e:	df 90       	pop	r13
     a60:	cf 90       	pop	r12
     a62:	08 95       	ret

00000a64 <start_log_message>:

void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
     a64:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <bufferAmt>
     a68:	90 91 ce 01 	lds	r25, 0x01CE	; 0x8001ce <bufferAmt+0x1>
     a6c:	9c 01       	movw	r18, r24
     a6e:	2f 5f       	subi	r18, 0xFF	; 255
     a70:	3f 4f       	sbci	r19, 0xFF	; 255
     a72:	30 93 ce 01 	sts	0x01CE, r19	; 0x8001ce <bufferAmt+0x1>
     a76:	20 93 cd 01 	sts	0x01CD, r18	; 0x8001cd <bufferAmt>
     a7a:	fc 01       	movw	r30, r24
     a7c:	ef 52       	subi	r30, 0x2F	; 47
     a7e:	fe 4f       	sbci	r31, 0xFE	; 254
     a80:	2a e0       	ldi	r18, 0x0A	; 10
     a82:	20 83       	st	Z, r18
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     a84:	20 e0       	ldi	r18, 0x00	; 0
     a86:	30 e0       	ldi	r19, 0x00	; 0
     a88:	15 c0       	rjmp	.+42     	; 0xab4 <start_log_message+0x50>
	{
		write_buffer[bufferAmt++] = string[i];
     a8a:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <bufferAmt>
     a8e:	90 91 ce 01 	lds	r25, 0x01CE	; 0x8001ce <bufferAmt+0x1>
     a92:	ac 01       	movw	r20, r24
     a94:	4f 5f       	subi	r20, 0xFF	; 255
     a96:	5f 4f       	sbci	r21, 0xFF	; 255
     a98:	50 93 ce 01 	sts	0x01CE, r21	; 0x8001ce <bufferAmt+0x1>
     a9c:	40 93 cd 01 	sts	0x01CD, r20	; 0x8001cd <bufferAmt>
     aa0:	f9 01       	movw	r30, r18
     aa2:	e8 5d       	subi	r30, 0xD8	; 216
     aa4:	fe 4f       	sbci	r31, 0xFE	; 254
     aa6:	40 81       	ld	r20, Z
     aa8:	fc 01       	movw	r30, r24
     aaa:	ef 52       	subi	r30, 0x2F	; 47
     aac:	fe 4f       	sbci	r31, 0xFE	; 254
     aae:	40 83       	st	Z, r20
void start_log_message(void)
{
	const char* string = "START LOG HIER";
	write_buffer[bufferAmt++] = '\n';
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     ab0:	2f 5f       	subi	r18, 0xFF	; 255
     ab2:	3f 4f       	sbci	r19, 0xFF	; 255
     ab4:	2e 30       	cpi	r18, 0x0E	; 14
     ab6:	31 05       	cpc	r19, r1
     ab8:	44 f3       	brlt	.-48     	; 0xa8a <start_log_message+0x26>
	{
		write_buffer[bufferAmt++] = string[i];
	}
	write_buffer[bufferAmt++] = '\n';
     aba:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <bufferAmt>
     abe:	90 91 ce 01 	lds	r25, 0x01CE	; 0x8001ce <bufferAmt+0x1>
     ac2:	9c 01       	movw	r18, r24
     ac4:	2f 5f       	subi	r18, 0xFF	; 255
     ac6:	3f 4f       	sbci	r19, 0xFF	; 255
     ac8:	30 93 ce 01 	sts	0x01CE, r19	; 0x8001ce <bufferAmt+0x1>
     acc:	20 93 cd 01 	sts	0x01CD, r18	; 0x8001cd <bufferAmt>
     ad0:	fc 01       	movw	r30, r24
     ad2:	ef 52       	subi	r30, 0x2F	; 47
     ad4:	fe 4f       	sbci	r31, 0xFE	; 254
     ad6:	2a e0       	ldi	r18, 0x0A	; 10
     ad8:	20 83       	st	Z, r18
     ada:	08 95       	ret

00000adc <init_sd_card>:
	DSTATUS status;
	FRESULT result;
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
     adc:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
		if (status != 0) {
     ae0:	81 11       	cpse	r24, r1
     ae2:	07 c0       	rjmp	.+14     	; 0xaf2 <init_sd_card+0x16>
			ERROR = 1; 
		} else {
			ERROR = 0;			
			// Set SPI clock faster after initialization 
			SPCR = (1<<MSTR) | (1<<SPE);
     ae4:	80 e5       	ldi	r24, 0x50	; 80
     ae6:	8c bd       	out	0x2c, r24	; 44
			SPSR = (1<<SPI2X); 		
     ae8:	81 e0       	ldi	r24, 0x01	; 1
     aea:	8d bd       	out	0x2d, r24	; 45
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
		} else {
			ERROR = 0;			
     aec:	80 e0       	ldi	r24, 0x00	; 0
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	02 c0       	rjmp	.+4      	; 0xaf6 <init_sd_card+0x1a>
	int ERROR = 0;
	// Initialize physical drive 
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
     af2:	81 e0       	ldi	r24, 0x01	; 1
     af4:	90 e0       	ldi	r25, 0x00	; 0
			//SPR1 en 0 op 0 SPI clock set to fck/4 (blaz. 174)
			//MSTR, in mastermode zetten
			//SPE, SPI enable maken.
			//SPI2X, het verdubbelen van de snelheid.			
		}
	} while (ERROR == 1);
     af6:	01 97       	sbiw	r24, 0x01	; 1
     af8:	89 f3       	breq	.-30     	; 0xadc <init_sd_card>

	// Mount volume 
	result = pf_mount(&file_system);
     afa:	81 ee       	ldi	r24, 0xE1	; 225
     afc:	94 e0       	ldi	r25, 0x04	; 4
     afe:	0e 94 bd 08 	call	0x117a	; 0x117a <pf_mount>
	if (result != FR_OK) {} // error

	// Open file 
	result = pf_open("LOG.txt");
     b02:	87 e3       	ldi	r24, 0x37	; 55
     b04:	91 e0       	ldi	r25, 0x01	; 1
     b06:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <pf_open>
     b0a:	08 95       	ret

00000b0c <main>:
}
	
int main(void)
{	
	_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | (1<<CLKPS1)));
	init_sd_card(); // initialize sd-card
     b0c:	0e 94 6e 05 	call	0xadc	; 0xadc <init_sd_card>
	sei();
     b10:	78 94       	sei
	initCAN(); // init can-bus
     b12:	0e 94 69 00 	call	0xd2	; 0xd2 <initCAN>
	listenForMessage(CAN_ID_SNELHEIDSMETER, 8);
     b16:	68 e0       	ldi	r22, 0x08	; 8
     b18:	80 e1       	ldi	r24, 0x10	; 16
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	0e 94 9f 00 	call	0x13e	; 0x13e <listenForMessage>
	//listenForMessage(CAN_ID_MONITORINGSSYSTEEM, 8);
	// voor elke ID die je uit wilt lezen moet je hier een keer de listenForMessage functie aanroepen
	init_timer();
     b20:	0e 94 41 04 	call	0x882	; 0x882 <init_timer>
	curOffset = find_offset(); // returnt offset van eerstvolgende lege sector
     b24:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <find_offset>
     b28:	60 93 c6 01 	sts	0x01C6, r22	; 0x8001c6 <curOffset>
     b2c:	70 93 c7 01 	sts	0x01C7, r23	; 0x8001c7 <curOffset+0x1>
     b30:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <curOffset+0x2>
     b34:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <curOffset+0x3>
	start_log_message(); // schrijf start log bericht naar de kaart zodat je kan zien wanneer de auto opnieuw aan is gezet
     b38:	0e 94 32 05 	call	0xa64	; 0xa64 <start_log_message>
	while(1)
	{
		if(overflowCounter>=61) // 61 komt van 16.000.000 / 1024 (klokfrequentie / timer2prescaler) =  15625. 15625 / 256 (8 bit timer) = 61
     b3c:	80 91 cb 01 	lds	r24, 0x01CB	; 0x8001cb <overflowCounter>
     b40:	90 91 cc 01 	lds	r25, 0x01CC	; 0x8001cc <overflowCounter+0x1>
     b44:	cd 97       	sbiw	r24, 0x3d	; 61
     b46:	34 f0       	brlt	.+12     	; 0xb54 <main+0x48>
		{
			fill_buffer();
     b48:	0e 94 66 04 	call	0x8cc	; 0x8cc <fill_buffer>
			overflowCounter = 0;
     b4c:	10 92 cc 01 	sts	0x01CC, r1	; 0x8001cc <overflowCounter+0x1>
     b50:	10 92 cb 01 	sts	0x01CB, r1	; 0x8001cb <overflowCounter>
		}
		
		if(startWriting)
     b54:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <startWriting>
     b58:	88 23       	and	r24, r24
     b5a:	81 f3       	breq	.-32     	; 0xb3c <main+0x30>
		{
			PORTC ^= (1 << PC0); // toggle ter indicatie op oscilloscoop
     b5c:	98 b1       	in	r25, 0x08	; 8
     b5e:	81 e0       	ldi	r24, 0x01	; 1
     b60:	89 27       	eor	r24, r25
     b62:	88 b9       	out	0x08, r24	; 8
			writeToCard(); // schrijf buffer op kaart
     b64:	0e 94 ce 04 	call	0x99c	; 0x99c <writeToCard>
			curOffset += 512; // zet pointer naar volgende sector
     b68:	80 91 c6 01 	lds	r24, 0x01C6	; 0x8001c6 <curOffset>
     b6c:	90 91 c7 01 	lds	r25, 0x01C7	; 0x8001c7 <curOffset+0x1>
     b70:	a0 91 c8 01 	lds	r26, 0x01C8	; 0x8001c8 <curOffset+0x2>
     b74:	b0 91 c9 01 	lds	r27, 0x01C9	; 0x8001c9 <curOffset+0x3>
     b78:	9e 5f       	subi	r25, 0xFE	; 254
     b7a:	af 4f       	sbci	r26, 0xFF	; 255
     b7c:	bf 4f       	sbci	r27, 0xFF	; 255
     b7e:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <curOffset>
     b82:	90 93 c7 01 	sts	0x01C7, r25	; 0x8001c7 <curOffset+0x1>
     b86:	a0 93 c8 01 	sts	0x01C8, r26	; 0x8001c8 <curOffset+0x2>
     b8a:	b0 93 c9 01 	sts	0x01C9, r27	; 0x8001c9 <curOffset+0x3>
			startWriting = false;
     b8e:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <startWriting>
     b92:	d4 cf       	rjmp	.-88     	; 0xb3c <main+0x30>

00000b94 <mem_set>:

static FATFS *FatFs; /* Pointer to the file system object (logical drive) */

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
     b94:	fc 01       	movw	r30, r24
	char *d = (char *)dst;
	while (cnt--)
     b96:	03 c0       	rjmp	.+6      	; 0xb9e <mem_set+0xa>
		*d++ = (char)val;
     b98:	60 83       	st	Z, r22

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     b9a:	ac 01       	movw	r20, r24
		*d++ = (char)val;
     b9c:	31 96       	adiw	r30, 0x01	; 1

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     b9e:	ca 01       	movw	r24, r20
     ba0:	01 97       	sbiw	r24, 0x01	; 1
     ba2:	45 2b       	or	r20, r21
     ba4:	c9 f7       	brne	.-14     	; 0xb98 <mem_set+0x4>
		*d++ = (char)val;
}
     ba6:	08 95       	ret

00000ba8 <mem_cmp>:

/* Compare memory to memory */
static int mem_cmp(const void *dst, const void *src, int cnt)
{
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
     bac:	dc 01       	movw	r26, r24
     bae:	fb 01       	movw	r30, r22
	const char *d = (const char *)dst, *s = (const char *)src;
	int         r = 0;
     bb0:	80 e0       	ldi	r24, 0x00	; 0
     bb2:	90 e0       	ldi	r25, 0x00	; 0
	while (cnt-- && (r = *d++ - *s++) == 0)
     bb4:	02 c0       	rjmp	.+4      	; 0xbba <mem_cmp+0x12>
     bb6:	fb 01       	movw	r30, r22
     bb8:	de 01       	movw	r26, r28
     bba:	9a 01       	movw	r18, r20
     bbc:	21 50       	subi	r18, 0x01	; 1
     bbe:	31 09       	sbc	r19, r1
     bc0:	45 2b       	or	r20, r21
     bc2:	61 f0       	breq	.+24     	; 0xbdc <mem_cmp+0x34>
     bc4:	ed 01       	movw	r28, r26
     bc6:	21 96       	adiw	r28, 0x01	; 1
     bc8:	8c 91       	ld	r24, X
     bca:	90 e0       	ldi	r25, 0x00	; 0
     bcc:	bf 01       	movw	r22, r30
     bce:	6f 5f       	subi	r22, 0xFF	; 255
     bd0:	7f 4f       	sbci	r23, 0xFF	; 255
     bd2:	40 81       	ld	r20, Z
     bd4:	84 1b       	sub	r24, r20
     bd6:	91 09       	sbc	r25, r1
     bd8:	a9 01       	movw	r20, r18
     bda:	69 f3       	breq	.-38     	; 0xbb6 <mem_cmp+0xe>
		;
	return r;
}
     bdc:	df 91       	pop	r29
     bde:	cf 91       	pop	r28
     be0:	08 95       	ret

00000be2 <clust2sect>:
/*-----------------------------------------------------------------------*/

static DWORD clust2sect(           /* !=0: Sector number, 0: Failed - invalid cluster# */
                        CLUST clst /* Cluster# to be converted */
)
{
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
	FATFS *fs = FatFs;
     be6:	e0 91 d1 03 	lds	r30, 0x03D1	; 0x8003d1 <FatFs>
     bea:	f0 91 d2 03 	lds	r31, 0x03D2	; 0x8003d2 <FatFs+0x1>

	clst -= 2;
     bee:	9b 01       	movw	r18, r22
     bf0:	ac 01       	movw	r20, r24
     bf2:	22 50       	subi	r18, 0x02	; 2
     bf4:	31 09       	sbc	r19, r1
     bf6:	41 09       	sbc	r20, r1
     bf8:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2))
     bfa:	86 81       	ldd	r24, Z+6	; 0x06
     bfc:	97 81       	ldd	r25, Z+7	; 0x07
     bfe:	a0 85       	ldd	r26, Z+8	; 0x08
     c00:	b1 85       	ldd	r27, Z+9	; 0x09
     c02:	02 97       	sbiw	r24, 0x02	; 2
     c04:	a1 09       	sbc	r26, r1
     c06:	b1 09       	sbc	r27, r1
     c08:	28 17       	cp	r18, r24
     c0a:	39 07       	cpc	r19, r25
     c0c:	4a 07       	cpc	r20, r26
     c0e:	5b 07       	cpc	r21, r27
     c10:	68 f4       	brcc	.+26     	; 0xc2c <clust2sect+0x4a>
		return 0; /* Invalid cluster# */
	return (DWORD)clst * fs->csize + fs->database;
     c12:	a2 81       	ldd	r26, Z+2	; 0x02
     c14:	b0 e0       	ldi	r27, 0x00	; 0
     c16:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <__muluhisi3>
     c1a:	02 89       	ldd	r16, Z+18	; 0x12
     c1c:	13 89       	ldd	r17, Z+19	; 0x13
     c1e:	24 89       	ldd	r18, Z+20	; 0x14
     c20:	35 89       	ldd	r19, Z+21	; 0x15
     c22:	60 0f       	add	r22, r16
     c24:	71 1f       	adc	r23, r17
     c26:	82 1f       	adc	r24, r18
     c28:	93 1f       	adc	r25, r19
     c2a:	03 c0       	rjmp	.+6      	; 0xc32 <clust2sect+0x50>
{
	FATFS *fs = FatFs;

	clst -= 2;
	if (clst >= (fs->n_fatent - 2))
		return 0; /* Invalid cluster# */
     c2c:	60 e0       	ldi	r22, 0x00	; 0
     c2e:	70 e0       	ldi	r23, 0x00	; 0
     c30:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     c32:	1f 91       	pop	r17
     c34:	0f 91       	pop	r16
     c36:	08 95       	ret

00000c38 <get_clust>:

static CLUST get_clust(BYTE *dir /* Pointer to directory entry */
)
{
     c38:	0f 93       	push	r16
     c3a:	1f 93       	push	r17
     c3c:	fc 01       	movw	r30, r24
	FATFS *fs   = FatFs;
	CLUST  clst = 0;

	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
		clst = LD_WORD(dir + DIR_FstClusHI);
     c3e:	65 89       	ldd	r22, Z+21	; 0x15
     c40:	70 e0       	ldi	r23, 0x00	; 0
     c42:	76 2f       	mov	r23, r22
     c44:	66 27       	eor	r22, r22
     c46:	84 89       	ldd	r24, Z+20	; 0x14
     c48:	68 2b       	or	r22, r24
     c4a:	cb 01       	movw	r24, r22
     c4c:	a0 e0       	ldi	r26, 0x00	; 0
     c4e:	b0 e0       	ldi	r27, 0x00	; 0
		clst <<= 16;
     c50:	bc 01       	movw	r22, r24
     c52:	55 27       	eor	r21, r21
     c54:	44 27       	eor	r20, r20
	}
	clst |= LD_WORD(dir + DIR_FstClusLO);
     c56:	83 8d       	ldd	r24, Z+27	; 0x1b
     c58:	90 e0       	ldi	r25, 0x00	; 0
     c5a:	98 2f       	mov	r25, r24
     c5c:	88 27       	eor	r24, r24
     c5e:	22 8d       	ldd	r18, Z+26	; 0x1a
     c60:	82 2b       	or	r24, r18
     c62:	a0 e0       	ldi	r26, 0x00	; 0
     c64:	b0 e0       	ldi	r27, 0x00	; 0
     c66:	8c 01       	movw	r16, r24
     c68:	9d 01       	movw	r18, r26
     c6a:	04 2b       	or	r16, r20
     c6c:	15 2b       	or	r17, r21
     c6e:	26 2b       	or	r18, r22
     c70:	37 2b       	or	r19, r23
     c72:	c9 01       	movw	r24, r18
     c74:	b8 01       	movw	r22, r16

	return clst;
}
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	08 95       	ret

00000c7c <dir_rewind>:
/* Directory handling - Rewind directory index                           */
/*-----------------------------------------------------------------------*/

static FRESULT dir_rewind(DIR *dj /* Pointer to directory object */
)
{
     c7c:	0f 93       	push	r16
     c7e:	1f 93       	push	r17
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
     c84:	fc 01       	movw	r30, r24
	CLUST  clst;
	FATFS *fs = FatFs;
     c86:	a0 91 d1 03 	lds	r26, 0x03D1	; 0x8003d1 <FatFs>
     c8a:	b0 91 d2 03 	lds	r27, 0x03D2	; 0x8003d2 <FatFs+0x1>

	dj->index = 0;
     c8e:	11 82       	std	Z+1, r1	; 0x01
     c90:	10 82       	st	Z, r1
	clst      = dj->sclust;
     c92:	64 81       	ldd	r22, Z+4	; 0x04
     c94:	75 81       	ldd	r23, Z+5	; 0x05
     c96:	86 81       	ldd	r24, Z+6	; 0x06
     c98:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
     c9a:	61 30       	cpi	r22, 0x01	; 1
     c9c:	71 05       	cpc	r23, r1
     c9e:	81 05       	cpc	r24, r1
     ca0:	91 05       	cpc	r25, r1
     ca2:	19 f1       	breq	.+70     	; 0xcea <dir_rewind+0x6e>
     ca4:	16 96       	adiw	r26, 0x06	; 6
     ca6:	0d 91       	ld	r16, X+
     ca8:	1d 91       	ld	r17, X+
     caa:	2d 91       	ld	r18, X+
     cac:	3c 91       	ld	r19, X
     cae:	19 97       	sbiw	r26, 0x09	; 9
     cb0:	60 17       	cp	r22, r16
     cb2:	71 07       	cpc	r23, r17
     cb4:	82 07       	cpc	r24, r18
     cb6:	93 07       	cpc	r25, r19
     cb8:	d0 f4       	brcc	.+52     	; 0xcee <dir_rewind+0x72>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst
     cba:	61 15       	cp	r22, r1
     cbc:	71 05       	cpc	r23, r1
     cbe:	81 05       	cpc	r24, r1
     cc0:	91 05       	cpc	r25, r1
     cc2:	31 f4       	brne	.+12     	; 0xcd0 <dir_rewind+0x54>
	    && (_FS_32ONLY || fs->fs_type == FS_FAT32)) /* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
     cc4:	1e 96       	adiw	r26, 0x0e	; 14
     cc6:	6d 91       	ld	r22, X+
     cc8:	7d 91       	ld	r23, X+
     cca:	8d 91       	ld	r24, X+
     ccc:	9c 91       	ld	r25, X
     cce:	51 97       	sbiw	r26, 0x11	; 17
     cd0:	ef 01       	movw	r28, r30
	dj->clust = clst;                                                  /* Current cluster */
     cd2:	60 87       	std	Z+8, r22	; 0x08
     cd4:	71 87       	std	Z+9, r23	; 0x09
     cd6:	82 87       	std	Z+10, r24	; 0x0a
     cd8:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */
     cda:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clust2sect>
     cde:	6c 87       	std	Y+12, r22	; 0x0c
     ce0:	7d 87       	std	Y+13, r23	; 0x0d
     ce2:	8e 87       	std	Y+14, r24	; 0x0e
     ce4:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK; /* Seek succeeded */
     ce6:	80 e0       	ldi	r24, 0x00	; 0
     ce8:	03 c0       	rjmp	.+6      	; 0xcf0 <dir_rewind+0x74>
	FATFS *fs = FatFs;

	dj->index = 0;
	clst      = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
		return FR_DISK_ERR;
     cea:	81 e0       	ldi	r24, 0x01	; 1
     cec:	01 c0       	rjmp	.+2      	; 0xcf0 <dir_rewind+0x74>
     cee:	81 e0       	ldi	r24, 0x01	; 1
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;                                                  /* Current cluster */
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */

	return FR_OK; /* Seek succeeded */
}
     cf0:	df 91       	pop	r29
     cf2:	cf 91       	pop	r28
     cf4:	1f 91       	pop	r17
     cf6:	0f 91       	pop	r16
     cf8:	08 95       	ret

00000cfa <create_name>:
/*-----------------------------------------------------------------------*/

static FRESULT create_name(DIR *        dj,  /* Pointer to the directory object */
                           const char **path /* Pointer to pointer to the segment in the path string */
)
{
     cfa:	0f 93       	push	r16
     cfc:	1f 93       	push	r17
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
     d02:	eb 01       	movw	r28, r22
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
     d04:	fc 01       	movw	r30, r24
     d06:	02 81       	ldd	r16, Z+2	; 0x02
     d08:	13 81       	ldd	r17, Z+3	; 0x03
	mem_set(sfn, ' ', 11);
     d0a:	4b e0       	ldi	r20, 0x0B	; 11
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	60 e2       	ldi	r22, 0x20	; 32
     d10:	70 e0       	ldi	r23, 0x00	; 0
     d12:	c8 01       	movw	r24, r16
     d14:	0e 94 ca 05 	call	0xb94	; 0xb94 <mem_set>
	si = i = 0;
	ni     = 8;
	p      = *path;
     d18:	28 81       	ld	r18, Y
     d1a:	39 81       	ldd	r19, Y+1	; 0x01
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0;
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	80 e0       	ldi	r24, 0x00	; 0
	ni     = 8;
     d20:	58 e0       	ldi	r21, 0x08	; 8
     d22:	01 c0       	rjmp	.+2      	; 0xd26 <create_name+0x2c>
     d24:	84 2f       	mov	r24, r20
	p      = *path;
	for (;;) {
		c = p[si++];
     d26:	41 e0       	ldi	r20, 0x01	; 1
     d28:	48 0f       	add	r20, r24
     d2a:	f9 01       	movw	r30, r18
     d2c:	e8 0f       	add	r30, r24
     d2e:	f1 1d       	adc	r31, r1
     d30:	e0 81       	ld	r30, Z
		if (c <= ' ' || c == '/')
     d32:	e1 32       	cpi	r30, 0x21	; 33
     d34:	f0 f0       	brcs	.+60     	; 0xd72 <create_name+0x78>
     d36:	ef 32       	cpi	r30, 0x2F	; 47
     d38:	e1 f0       	breq	.+56     	; 0xd72 <create_name+0x78>
			break; /* Break on end of segment */
		if (c == '.' || i >= ni) {
     d3a:	ee 32       	cpi	r30, 0x2E	; 46
     d3c:	11 f0       	breq	.+4      	; 0xd42 <create_name+0x48>
     d3e:	95 17       	cp	r25, r21
     d40:	38 f0       	brcs	.+14     	; 0xd50 <create_name+0x56>
			if (ni != 8 || c != '.')
     d42:	58 30       	cpi	r21, 0x08	; 8
     d44:	b1 f4       	brne	.+44     	; 0xd72 <create_name+0x78>
     d46:	ee 32       	cpi	r30, 0x2E	; 46
     d48:	a1 f4       	brne	.+40     	; 0xd72 <create_name+0x78>
				break;
			i  = 8;
     d4a:	98 e0       	ldi	r25, 0x08	; 8
			ni = 11;
     d4c:	5b e0       	ldi	r21, 0x0B	; 11
     d4e:	ea cf       	rjmp	.-44     	; 0xd24 <create_name+0x2a>
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80) /* To upper extended char (SBCS) */
     d50:	ee 23       	and	r30, r30
     d52:	24 f4       	brge	.+8      	; 0xd5c <create_name+0x62>
			c = cvt[c - 0x80];
     d54:	f0 e0       	ldi	r31, 0x00	; 0
     d56:	e1 54       	subi	r30, 0x41	; 65
     d58:	ff 4f       	sbci	r31, 0xFF	; 255
     d5a:	e0 81       	ld	r30, Z
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{ /* Single byte code */
			if (_USE_LCC && IsLower(c))
     d5c:	8f e9       	ldi	r24, 0x9F	; 159
     d5e:	8e 0f       	add	r24, r30
     d60:	8a 31       	cpi	r24, 0x1A	; 26
     d62:	08 f4       	brcc	.+2      	; 0xd66 <create_name+0x6c>
				c -= 0x20; /* toupper */
     d64:	e0 52       	subi	r30, 0x20	; 32
			sfn[i++] = c;
     d66:	d8 01       	movw	r26, r16
     d68:	a9 0f       	add	r26, r25
     d6a:	b1 1d       	adc	r27, r1
     d6c:	ec 93       	st	X, r30
     d6e:	9f 5f       	subi	r25, 0xFF	; 255
     d70:	d9 cf       	rjmp	.-78     	; 0xd24 <create_name+0x2a>
		}
	}
	*path = &p[si]; /* Rerurn pointer to the next segment */
     d72:	24 0f       	add	r18, r20
     d74:	31 1d       	adc	r19, r1
     d76:	39 83       	std	Y+1, r19	; 0x01
     d78:	28 83       	st	Y, r18

	sfn[11] = (c <= ' ') ? 1 : 0; /* Set last segment flag if end of path */
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	e1 32       	cpi	r30, 0x21	; 33
     d7e:	08 f0       	brcs	.+2      	; 0xd82 <create_name+0x88>
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	f8 01       	movw	r30, r16
     d84:	83 87       	std	Z+11, r24	; 0x0b

	return FR_OK;
}
     d86:	80 e0       	ldi	r24, 0x00	; 0
     d88:	df 91       	pop	r29
     d8a:	cf 91       	pop	r28
     d8c:	1f 91       	pop	r17
     d8e:	0f 91       	pop	r16
     d90:	08 95       	ret

00000d92 <check_fs>:

static BYTE check_fs(/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     d92:	cf 92       	push	r12
     d94:	df 92       	push	r13
     d96:	ef 92       	push	r14
     d98:	ff 92       	push	r15
     d9a:	0f 93       	push	r16
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	ec 01       	movw	r28, r24
     da4:	6a 01       	movw	r12, r20
     da6:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
     da8:	02 e0       	ldi	r16, 0x02	; 2
     daa:	10 e0       	ldi	r17, 0x00	; 0
     dac:	2e ef       	ldi	r18, 0xFE	; 254
     dae:	31 e0       	ldi	r19, 0x01	; 1
     db0:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     db4:	81 11       	cpse	r24, r1
     db6:	1d c0       	rjmp	.+58     	; 0xdf2 <check_fs+0x60>
		return 3;
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
     db8:	89 81       	ldd	r24, Y+1	; 0x01
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	98 2f       	mov	r25, r24
     dbe:	88 27       	eor	r24, r24
     dc0:	28 81       	ld	r18, Y
     dc2:	82 2b       	or	r24, r18
     dc4:	85 35       	cpi	r24, 0x55	; 85
     dc6:	9a 4a       	sbci	r25, 0xAA	; 170
     dc8:	b1 f4       	brne	.+44     	; 0xdf6 <check_fs+0x64>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
     dca:	22 e5       	ldi	r18, 0x52	; 82
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	b7 01       	movw	r22, r14
     dd0:	a6 01       	movw	r20, r12
     dd2:	ce 01       	movw	r24, r28
     dd4:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     dd8:	81 11       	cpse	r24, r1
     dda:	0f c0       	rjmp	.+30     	; 0xdfa <check_fs+0x68>
     ddc:	89 81       	ldd	r24, Y+1	; 0x01
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	98 2f       	mov	r25, r24
     de2:	88 27       	eor	r24, r24
     de4:	28 81       	ld	r18, Y
     de6:	82 2b       	or	r24, r18
     de8:	86 34       	cpi	r24, 0x46	; 70
     dea:	91 44       	sbci	r25, 0x41	; 65
     dec:	41 f0       	breq	.+16     	; 0xdfe <check_fs+0x6c>
		return 0;
	return 1;
     dee:	81 e0       	ldi	r24, 0x01	; 1
     df0:	07 c0       	rjmp	.+14     	; 0xe00 <check_fs+0x6e>
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
		return 3;
     df2:	83 e0       	ldi	r24, 0x03	; 3
     df4:	05 c0       	rjmp	.+10     	; 0xe00 <check_fs+0x6e>
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
		return 2;
     df6:	82 e0       	ldi	r24, 0x02	; 2
     df8:	03 c0       	rjmp	.+6      	; 0xe00 <check_fs+0x6e>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
	return 1;
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	01 c0       	rjmp	.+2      	; 0xe00 <check_fs+0x6e>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
     dfe:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
     e00:	df 91       	pop	r29
     e02:	cf 91       	pop	r28
     e04:	1f 91       	pop	r17
     e06:	0f 91       	pop	r16
     e08:	ff 90       	pop	r15
     e0a:	ef 90       	pop	r14
     e0c:	df 90       	pop	r13
     e0e:	cf 90       	pop	r12
     e10:	08 95       	ret

00000e12 <get_fat>:
/*-----------------------------------------------------------------------*/

static CLUST get_fat(           /* 1:IO error, Else:Cluster status */
                     CLUST clst /* Cluster# to get the link information */
)
{
     e12:	cf 92       	push	r12
     e14:	df 92       	push	r13
     e16:	ef 92       	push	r14
     e18:	ff 92       	push	r15
     e1a:	0f 93       	push	r16
     e1c:	1f 93       	push	r17
     e1e:	cf 93       	push	r28
     e20:	df 93       	push	r29
     e22:	00 d0       	rcall	.+0      	; 0xe24 <get_fat+0x12>
     e24:	00 d0       	rcall	.+0      	; 0xe26 <get_fat+0x14>
     e26:	cd b7       	in	r28, 0x3d	; 61
     e28:	de b7       	in	r29, 0x3e	; 62
	BYTE   buf[4];
	FATFS *fs = FatFs;
     e2a:	e0 91 d1 03 	lds	r30, 0x03D1	; 0x8003d1 <FatFs>
     e2e:	f0 91 d2 03 	lds	r31, 0x03D2	; 0x8003d2 <FatFs+0x1>

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
     e32:	62 30       	cpi	r22, 0x02	; 2
     e34:	71 05       	cpc	r23, r1
     e36:	81 05       	cpc	r24, r1
     e38:	91 05       	cpc	r25, r1
     e3a:	08 f4       	brcc	.+2      	; 0xe3e <get_fat+0x2c>
     e3c:	56 c0       	rjmp	.+172    	; 0xeea <get_fat+0xd8>
     e3e:	06 81       	ldd	r16, Z+6	; 0x06
     e40:	17 81       	ldd	r17, Z+7	; 0x07
     e42:	20 85       	ldd	r18, Z+8	; 0x08
     e44:	31 85       	ldd	r19, Z+9	; 0x09
     e46:	60 17       	cp	r22, r16
     e48:	71 07       	cpc	r23, r17
     e4a:	82 07       	cpc	r24, r18
     e4c:	93 07       	cpc	r25, r19
     e4e:	08 f0       	brcs	.+2      	; 0xe52 <get_fat+0x40>
     e50:	51 c0       	rjmp	.+162    	; 0xef4 <get_fat+0xe2>
		return 1;

	switch (fs->fs_type) {
     e52:	20 81       	ld	r18, Z
     e54:	23 30       	cpi	r18, 0x03	; 3
     e56:	09 f0       	breq	.+2      	; 0xe5a <get_fat+0x48>
     e58:	52 c0       	rjmp	.+164    	; 0xefe <get_fat+0xec>
     e5a:	dc 01       	movw	r26, r24
     e5c:	cb 01       	movw	r24, r22
			break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32:
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4))
     e5e:	9c 01       	movw	r18, r24
     e60:	2f 77       	andi	r18, 0x7F	; 127
     e62:	33 27       	eor	r19, r19
     e64:	c2 84       	ldd	r12, Z+10	; 0x0a
     e66:	d3 84       	ldd	r13, Z+11	; 0x0b
     e68:	e4 84       	ldd	r14, Z+12	; 0x0c
     e6a:	f5 84       	ldd	r15, Z+13	; 0x0d
     e6c:	68 94       	set
     e6e:	16 f8       	bld	r1, 6
     e70:	b6 95       	lsr	r27
     e72:	a7 95       	ror	r26
     e74:	97 95       	ror	r25
     e76:	87 95       	ror	r24
     e78:	16 94       	lsr	r1
     e7a:	d1 f7       	brne	.-12     	; 0xe70 <get_fat+0x5e>
     e7c:	22 0f       	add	r18, r18
     e7e:	33 1f       	adc	r19, r19
     e80:	22 0f       	add	r18, r18
     e82:	33 1f       	adc	r19, r19
     e84:	b7 01       	movw	r22, r14
     e86:	a6 01       	movw	r20, r12
     e88:	48 0f       	add	r20, r24
     e8a:	59 1f       	adc	r21, r25
     e8c:	6a 1f       	adc	r22, r26
     e8e:	7b 1f       	adc	r23, r27
     e90:	04 e0       	ldi	r16, 0x04	; 4
     e92:	10 e0       	ldi	r17, 0x00	; 0
     e94:	ce 01       	movw	r24, r28
     e96:	01 96       	adiw	r24, 0x01	; 1
     e98:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
     e9c:	81 11       	cpse	r24, r1
     e9e:	34 c0       	rjmp	.+104    	; 0xf08 <get_fat+0xf6>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
     ea0:	8c 81       	ldd	r24, Y+4	; 0x04
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	a0 e0       	ldi	r26, 0x00	; 0
     ea6:	b0 e0       	ldi	r27, 0x00	; 0
     ea8:	78 2f       	mov	r23, r24
     eaa:	66 27       	eor	r22, r22
     eac:	55 27       	eor	r21, r21
     eae:	44 27       	eor	r20, r20
     eb0:	9b 81       	ldd	r25, Y+3	; 0x03
     eb2:	89 2f       	mov	r24, r25
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	a0 e0       	ldi	r26, 0x00	; 0
     eb8:	b0 e0       	ldi	r27, 0x00	; 0
     eba:	dc 01       	movw	r26, r24
     ebc:	99 27       	eor	r25, r25
     ebe:	88 27       	eor	r24, r24
     ec0:	84 2b       	or	r24, r20
     ec2:	95 2b       	or	r25, r21
     ec4:	a6 2b       	or	r26, r22
     ec6:	b7 2b       	or	r27, r23
     ec8:	6a 81       	ldd	r22, Y+2	; 0x02
     eca:	70 e0       	ldi	r23, 0x00	; 0
     ecc:	76 2f       	mov	r23, r22
     ece:	66 27       	eor	r22, r22
     ed0:	ab 01       	movw	r20, r22
     ed2:	60 e0       	ldi	r22, 0x00	; 0
     ed4:	70 e0       	ldi	r23, 0x00	; 0
     ed6:	84 2b       	or	r24, r20
     ed8:	95 2b       	or	r25, r21
     eda:	a6 2b       	or	r26, r22
     edc:	b7 2b       	or	r27, r23
     ede:	29 81       	ldd	r18, Y+1	; 0x01
     ee0:	82 2b       	or	r24, r18
     ee2:	bc 01       	movw	r22, r24
     ee4:	cd 01       	movw	r24, r26
     ee6:	9f 70       	andi	r25, 0x0F	; 15
     ee8:	13 c0       	rjmp	.+38     	; 0xf10 <get_fat+0xfe>
{
	BYTE   buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
		return 1;
     eea:	61 e0       	ldi	r22, 0x01	; 1
     eec:	70 e0       	ldi	r23, 0x00	; 0
     eee:	80 e0       	ldi	r24, 0x00	; 0
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	0e c0       	rjmp	.+28     	; 0xf10 <get_fat+0xfe>
     ef4:	61 e0       	ldi	r22, 0x01	; 1
     ef6:	70 e0       	ldi	r23, 0x00	; 0
     ef8:	80 e0       	ldi	r24, 0x00	; 0
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	09 c0       	rjmp	.+18     	; 0xf10 <get_fat+0xfe>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1; /* An error occured at the disk I/O layer */
     efe:	61 e0       	ldi	r22, 0x01	; 1
     f00:	70 e0       	ldi	r23, 0x00	; 0
     f02:	80 e0       	ldi	r24, 0x00	; 0
     f04:	90 e0       	ldi	r25, 0x00	; 0
     f06:	04 c0       	rjmp	.+8      	; 0xf10 <get_fat+0xfe>
     f08:	61 e0       	ldi	r22, 0x01	; 1
     f0a:	70 e0       	ldi	r23, 0x00	; 0
     f0c:	80 e0       	ldi	r24, 0x00	; 0
     f0e:	90 e0       	ldi	r25, 0x00	; 0
}
     f10:	0f 90       	pop	r0
     f12:	0f 90       	pop	r0
     f14:	0f 90       	pop	r0
     f16:	0f 90       	pop	r0
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	1f 91       	pop	r17
     f1e:	0f 91       	pop	r16
     f20:	ff 90       	pop	r15
     f22:	ef 90       	pop	r14
     f24:	df 90       	pop	r13
     f26:	cf 90       	pop	r12
     f28:	08 95       	ret

00000f2a <dir_next>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_next(        /* FR_OK:Succeeded, FR_NO_FILE:End of table */
                        DIR *dj /* Pointer to directory object */
)
{
     f2a:	cf 92       	push	r12
     f2c:	df 92       	push	r13
     f2e:	ef 92       	push	r14
     f30:	ff 92       	push	r15
     f32:	0f 93       	push	r16
     f34:	1f 93       	push	r17
     f36:	cf 93       	push	r28
     f38:	df 93       	push	r29
	CLUST  clst;
	WORD   i;
	FATFS *fs = FatFs;
     f3a:	e0 90 d1 03 	lds	r14, 0x03D1	; 0x8003d1 <FatFs>
     f3e:	f0 90 d2 03 	lds	r15, 0x03D2	; 0x8003d2 <FatFs+0x1>

	i = dj->index + 1;
     f42:	fc 01       	movw	r30, r24
     f44:	c0 81       	ld	r28, Z
     f46:	d1 81       	ldd	r29, Z+1	; 0x01
     f48:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
     f4a:	09 f4       	brne	.+2      	; 0xf4e <dir_next+0x24>
     f4c:	5c c0       	rjmp	.+184    	; 0x1006 <dir_next+0xdc>
     f4e:	44 85       	ldd	r20, Z+12	; 0x0c
     f50:	55 85       	ldd	r21, Z+13	; 0x0d
     f52:	66 85       	ldd	r22, Z+14	; 0x0e
     f54:	77 85       	ldd	r23, Z+15	; 0x0f
     f56:	41 15       	cp	r20, r1
     f58:	51 05       	cpc	r21, r1
     f5a:	61 05       	cpc	r22, r1
     f5c:	71 05       	cpc	r23, r1
     f5e:	09 f4       	brne	.+2      	; 0xf62 <dir_next+0x38>
     f60:	54 c0       	rjmp	.+168    	; 0x100a <dir_next+0xe0>
     f62:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i % 16)) { /* Sector changed? */
     f64:	ce 01       	movw	r24, r28
     f66:	8f 70       	andi	r24, 0x0F	; 15
     f68:	99 27       	eor	r25, r25
     f6a:	89 2b       	or	r24, r25
     f6c:	09 f0       	breq	.+2      	; 0xf70 <dir_next+0x46>
     f6e:	46 c0       	rjmp	.+140    	; 0xffc <dir_next+0xd2>
		dj->sect++;  /* Next sector */
     f70:	4f 5f       	subi	r20, 0xFF	; 255
     f72:	5f 4f       	sbci	r21, 0xFF	; 255
     f74:	6f 4f       	sbci	r22, 0xFF	; 255
     f76:	7f 4f       	sbci	r23, 0xFF	; 255
     f78:	44 87       	std	Z+12, r20	; 0x0c
     f7a:	55 87       	std	Z+13, r21	; 0x0d
     f7c:	66 87       	std	Z+14, r22	; 0x0e
     f7e:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {       /* Static table */
     f80:	40 85       	ldd	r20, Z+8	; 0x08
     f82:	51 85       	ldd	r21, Z+9	; 0x09
     f84:	62 85       	ldd	r22, Z+10	; 0x0a
     f86:	73 85       	ldd	r23, Z+11	; 0x0b
     f88:	41 15       	cp	r20, r1
     f8a:	51 05       	cpc	r21, r1
     f8c:	61 05       	cpc	r22, r1
     f8e:	71 05       	cpc	r23, r1
     f90:	39 f4       	brne	.+14     	; 0xfa0 <dir_next+0x76>
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
     f92:	f7 01       	movw	r30, r14
     f94:	84 81       	ldd	r24, Z+4	; 0x04
     f96:	95 81       	ldd	r25, Z+5	; 0x05
     f98:	c8 17       	cp	r28, r24
     f9a:	d9 07       	cpc	r29, r25
     f9c:	c0 f5       	brcc	.+112    	; 0x100e <dir_next+0xe4>
     f9e:	2e c0       	rjmp	.+92     	; 0xffc <dir_next+0xd2>
				return FR_NO_FILE;
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
     fa0:	f7 01       	movw	r30, r14
     fa2:	82 81       	ldd	r24, Z+2	; 0x02
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	01 97       	sbiw	r24, 0x01	; 1
     fa8:	9e 01       	movw	r18, r28
     faa:	32 95       	swap	r19
     fac:	22 95       	swap	r18
     fae:	2f 70       	andi	r18, 0x0F	; 15
     fb0:	23 27       	eor	r18, r19
     fb2:	3f 70       	andi	r19, 0x0F	; 15
     fb4:	23 27       	eor	r18, r19
     fb6:	82 23       	and	r24, r18
     fb8:	93 23       	and	r25, r19
     fba:	89 2b       	or	r24, r25
     fbc:	f9 f4       	brne	.+62     	; 0xffc <dir_next+0xd2>
				clst = get_fat(dj->clust);           /* Get next cluster */
     fbe:	cb 01       	movw	r24, r22
     fc0:	ba 01       	movw	r22, r20
     fc2:	0e 94 09 07 	call	0xe12	; 0xe12 <get_fat>
				if (clst <= 1)
     fc6:	62 30       	cpi	r22, 0x02	; 2
     fc8:	71 05       	cpc	r23, r1
     fca:	81 05       	cpc	r24, r1
     fcc:	91 05       	cpc	r25, r1
     fce:	08 f1       	brcs	.+66     	; 0x1012 <dir_next+0xe8>
					return FR_DISK_ERR;
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
     fd0:	f7 01       	movw	r30, r14
     fd2:	c6 80       	ldd	r12, Z+6	; 0x06
     fd4:	d7 80       	ldd	r13, Z+7	; 0x07
     fd6:	e0 84       	ldd	r14, Z+8	; 0x08
     fd8:	f1 84       	ldd	r15, Z+9	; 0x09
     fda:	6c 15       	cp	r22, r12
     fdc:	7d 05       	cpc	r23, r13
     fde:	8e 05       	cpc	r24, r14
     fe0:	9f 05       	cpc	r25, r15
     fe2:	c8 f4       	brcc	.+50     	; 0x1016 <dir_next+0xec>
					return FR_NO_FILE;    /* Report EOT */
				dj->clust = clst;         /* Initialize data for new cluster */
     fe4:	f8 01       	movw	r30, r16
     fe6:	60 87       	std	Z+8, r22	; 0x08
     fe8:	71 87       	std	Z+9, r23	; 0x09
     fea:	82 87       	std	Z+10, r24	; 0x0a
     fec:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect  = clust2sect(clst);
     fee:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clust2sect>
     ff2:	f8 01       	movw	r30, r16
     ff4:	64 87       	std	Z+12, r22	; 0x0c
     ff6:	75 87       	std	Z+13, r23	; 0x0d
     ff8:	86 87       	std	Z+14, r24	; 0x0e
     ffa:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
     ffc:	f8 01       	movw	r30, r16
     ffe:	d1 83       	std	Z+1, r29	; 0x01
    1000:	c0 83       	st	Z, r28

	return FR_OK;
    1002:	80 e0       	ldi	r24, 0x00	; 0
    1004:	09 c0       	rjmp	.+18     	; 0x1018 <dir_next+0xee>
	WORD   i;
	FATFS *fs = FatFs;

	i = dj->index + 1;
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    1006:	83 e0       	ldi	r24, 0x03	; 3
    1008:	07 c0       	rjmp	.+14     	; 0x1018 <dir_next+0xee>
    100a:	83 e0       	ldi	r24, 0x03	; 3
    100c:	05 c0       	rjmp	.+10     	; 0x1018 <dir_next+0xee>
	if (!(i % 16)) { /* Sector changed? */
		dj->sect++;  /* Next sector */

		if (dj->clust == 0) {       /* Static table */
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
				return FR_NO_FILE;
    100e:	83 e0       	ldi	r24, 0x03	; 3
    1010:	03 c0       	rjmp	.+6      	; 0x1018 <dir_next+0xee>
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
				clst = get_fat(dj->clust);           /* Get next cluster */
				if (clst <= 1)
					return FR_DISK_ERR;
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	01 c0       	rjmp	.+2      	; 0x1018 <dir_next+0xee>
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
					return FR_NO_FILE;    /* Report EOT */
    1016:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	1f 91       	pop	r17
    101e:	0f 91       	pop	r16
    1020:	ff 90       	pop	r15
    1022:	ef 90       	pop	r14
    1024:	df 90       	pop	r13
    1026:	cf 90       	pop	r12
    1028:	08 95       	ret

0000102a <dir_find>:
/*-----------------------------------------------------------------------*/

	static FRESULT dir_find(DIR * dj, /* Pointer to the directory object linked to the file name */
							BYTE *dir /* 32-byte working buffer */
	)
	{
    102a:	cf 92       	push	r12
    102c:	df 92       	push	r13
    102e:	ff 92       	push	r15
    1030:	0f 93       	push	r16
    1032:	1f 93       	push	r17
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	ec 01       	movw	r28, r24
    103a:	6b 01       	movw	r12, r22
		FRESULT res;
		BYTE    c;

		res = dir_rewind(dj); /* Rewind directory object */
    103c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <dir_rewind>
		if (res != FR_OK)
    1040:	81 11       	cpse	r24, r1
    1042:	37 c0       	rjmp	.+110    	; 0x10b2 <dir_find+0x88>
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    1044:	28 81       	ld	r18, Y
    1046:	39 81       	ldd	r19, Y+1	; 0x01
    1048:	2f 70       	andi	r18, 0x0F	; 15
    104a:	33 27       	eor	r19, r19
    104c:	22 0f       	add	r18, r18
    104e:	33 1f       	adc	r19, r19
    1050:	22 95       	swap	r18
    1052:	32 95       	swap	r19
    1054:	30 7f       	andi	r19, 0xF0	; 240
    1056:	32 27       	eor	r19, r18
    1058:	20 7f       	andi	r18, 0xF0	; 240
    105a:	32 27       	eor	r19, r18
    105c:	4c 85       	ldd	r20, Y+12	; 0x0c
    105e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1060:	6e 85       	ldd	r22, Y+14	; 0x0e
    1062:	7f 85       	ldd	r23, Y+15	; 0x0f
    1064:	00 e2       	ldi	r16, 0x20	; 32
    1066:	10 e0       	ldi	r17, 0x00	; 0
    1068:	c6 01       	movw	r24, r12
    106a:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
					  ? FR_DISK_ERR
					  : FR_OK;
    106e:	91 e0       	ldi	r25, 0x01	; 1
    1070:	81 11       	cpse	r24, r1
    1072:	01 c0       	rjmp	.+2      	; 0x1076 <dir_find+0x4c>
    1074:	90 e0       	ldi	r25, 0x00	; 0
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    1076:	f9 2e       	mov	r15, r25
					  ? FR_DISK_ERR
					  : FR_OK;
			if (res != FR_OK)
    1078:	91 11       	cpse	r25, r1
    107a:	16 c0       	rjmp	.+44     	; 0x10a8 <dir_find+0x7e>
				break;
			c = dir[DIR_Name]; /* First character */
    107c:	f6 01       	movw	r30, r12
    107e:	80 81       	ld	r24, Z
			if (c == 0) { ///// hieerrr fout misschien
    1080:	88 23       	and	r24, r24
    1082:	a1 f0       	breq	.+40     	; 0x10ac <dir_find+0x82>
				res = FR_NO_FILE;
				break;
			}                                                           /* Reached to end of table */
			if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    1084:	83 85       	ldd	r24, Z+11	; 0x0b
    1086:	83 fd       	sbrc	r24, 3
    1088:	09 c0       	rjmp	.+18     	; 0x109c <dir_find+0x72>
    108a:	6a 81       	ldd	r22, Y+2	; 0x02
    108c:	7b 81       	ldd	r23, Y+3	; 0x03
    108e:	4b e0       	ldi	r20, 0x0B	; 11
    1090:	50 e0       	ldi	r21, 0x00	; 0
    1092:	c6 01       	movw	r24, r12
    1094:	0e 94 d4 05 	call	0xba8	; 0xba8 <mem_cmp>
    1098:	89 2b       	or	r24, r25
    109a:	51 f0       	breq	.+20     	; 0x10b0 <dir_find+0x86>
				break;
			res = dir_next(dj); /* Next entry */
    109c:	ce 01       	movw	r24, r28
    109e:	0e 94 95 07 	call	0xf2a	; 0xf2a <dir_next>
		} while (res == FR_OK);
    10a2:	88 23       	and	r24, r24
    10a4:	79 f2       	breq	.-98     	; 0x1044 <dir_find+0x1a>
    10a6:	05 c0       	rjmp	.+10     	; 0x10b2 <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10a8:	89 2f       	mov	r24, r25
    10aa:	03 c0       	rjmp	.+6      	; 0x10b2 <dir_find+0x88>
					  : FR_OK;
			if (res != FR_OK)
				break;
			c = dir[DIR_Name]; /* First character */
			if (c == 0) { ///// hieerrr fout misschien
				res = FR_NO_FILE;
    10ac:	83 e0       	ldi	r24, 0x03	; 3
    10ae:	01 c0       	rjmp	.+2      	; 0x10b2 <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
    10b0:	8f 2d       	mov	r24, r15
				break;
			res = dir_next(dj); /* Next entry */
		} while (res == FR_OK);

		return res;
	}
    10b2:	df 91       	pop	r29
    10b4:	cf 91       	pop	r28
    10b6:	1f 91       	pop	r17
    10b8:	0f 91       	pop	r16
    10ba:	ff 90       	pop	r15
    10bc:	df 90       	pop	r13
    10be:	cf 90       	pop	r12
    10c0:	08 95       	ret

000010c2 <follow_path>:
static FRESULT follow_path(                 /* FR_OK(0): successful, !=0: error code */
                           DIR *       dj,  /* Directory object to return last directory and found object */
                           BYTE *      dir, /* 32-byte working buffer */
                           const char *path /* Full-path string to find a file or directory */
)
{
    10c2:	ef 92       	push	r14
    10c4:	ff 92       	push	r15
    10c6:	0f 93       	push	r16
    10c8:	1f 93       	push	r17
    10ca:	cf 93       	push	r28
    10cc:	df 93       	push	r29
    10ce:	00 d0       	rcall	.+0      	; 0x10d0 <follow_path+0xe>
    10d0:	cd b7       	in	r28, 0x3d	; 61
    10d2:	de b7       	in	r29, 0x3e	; 62
    10d4:	8c 01       	movw	r16, r24
    10d6:	7b 01       	movw	r14, r22
    10d8:	5a 83       	std	Y+2, r21	; 0x02
    10da:	49 83       	std	Y+1, r20	; 0x01
	FRESULT res;

	while (*path == ' ')
    10dc:	03 c0       	rjmp	.+6      	; 0x10e4 <follow_path+0x22>
		path++; /* Strip leading spaces */
    10de:	31 96       	adiw	r30, 0x01	; 1
    10e0:	fa 83       	std	Y+2, r31	; 0x02
    10e2:	e9 83       	std	Y+1, r30	; 0x01
                           const char *path /* Full-path string to find a file or directory */
)
{
	FRESULT res;

	while (*path == ' ')
    10e4:	e9 81       	ldd	r30, Y+1	; 0x01
    10e6:	fa 81       	ldd	r31, Y+2	; 0x02
    10e8:	80 81       	ld	r24, Z
    10ea:	80 32       	cpi	r24, 0x20	; 32
    10ec:	c1 f3       	breq	.-16     	; 0x10de <follow_path+0x1c>
		path++; /* Strip leading spaces */
	if (*path == '/')
    10ee:	8f 32       	cpi	r24, 0x2F	; 47
    10f0:	19 f4       	brne	.+6      	; 0x10f8 <follow_path+0x36>
		path++;     /* Strip heading separator if exist */
    10f2:	31 96       	adiw	r30, 0x01	; 1
    10f4:	fa 83       	std	Y+2, r31	; 0x02
    10f6:	e9 83       	std	Y+1, r30	; 0x01
	dj->sclust = 0; /* Set start directory (always root dir) */
    10f8:	d8 01       	movw	r26, r16
    10fa:	14 96       	adiw	r26, 0x04	; 4
    10fc:	1d 92       	st	X+, r1
    10fe:	1d 92       	st	X+, r1
    1100:	1d 92       	st	X+, r1
    1102:	1c 92       	st	X, r1
    1104:	17 97       	sbiw	r26, 0x07	; 7

	if ((BYTE)*path < ' ') { /* Null path means the root directory */
    1106:	e9 81       	ldd	r30, Y+1	; 0x01
    1108:	fa 81       	ldd	r31, Y+2	; 0x02
    110a:	80 81       	ld	r24, Z
    110c:	80 32       	cpi	r24, 0x20	; 32
    110e:	30 f4       	brcc	.+12     	; 0x111c <follow_path+0x5a>
		res    = dir_rewind(dj);
    1110:	c8 01       	movw	r24, r16
    1112:	0e 94 3e 06 	call	0xc7c	; 0xc7c <dir_rewind>
		dir[0] = 0;
    1116:	f7 01       	movw	r30, r14
    1118:	10 82       	st	Z, r1
    111a:	26 c0       	rjmp	.+76     	; 0x1168 <follow_path+0xa6>

	} else { /* Follow path */
		for (;;) {
			res = create_name(dj, &path); /* Get a segment */
    111c:	be 01       	movw	r22, r28
    111e:	6f 5f       	subi	r22, 0xFF	; 255
    1120:	7f 4f       	sbci	r23, 0xFF	; 255
    1122:	c8 01       	movw	r24, r16
    1124:	0e 94 7d 06 	call	0xcfa	; 0xcfa <create_name>
			if (res != FR_OK)
    1128:	81 11       	cpse	r24, r1
    112a:	1e c0       	rjmp	.+60     	; 0x1168 <follow_path+0xa6>
				break;
			res = dir_find(dj, dir); /* Find it */ // het gaat denk ik hier fout
    112c:	b7 01       	movw	r22, r14
    112e:	c8 01       	movw	r24, r16
    1130:	0e 94 15 08 	call	0x102a	; 0x102a <dir_find>
			if (res != FR_OK)
    1134:	81 11       	cpse	r24, r1
    1136:	18 c0       	rjmp	.+48     	; 0x1168 <follow_path+0xa6>
				break; /* Could not find the object */
			if (dj->fn[11])
    1138:	d8 01       	movw	r26, r16
    113a:	12 96       	adiw	r26, 0x02	; 2
    113c:	ed 91       	ld	r30, X+
    113e:	fc 91       	ld	r31, X
    1140:	13 97       	sbiw	r26, 0x03	; 3
    1142:	93 85       	ldd	r25, Z+11	; 0x0b
    1144:	91 11       	cpse	r25, r1
    1146:	10 c0       	rjmp	.+32     	; 0x1168 <follow_path+0xa6>
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
    1148:	f7 01       	movw	r30, r14
    114a:	83 85       	ldd	r24, Z+11	; 0x0b
    114c:	84 ff       	sbrs	r24, 4
    114e:	0b c0       	rjmp	.+22     	; 0x1166 <follow_path+0xa4>
				res = FR_NO_FILE;
				break;
			}
			dj->sclust = get_clust(dir); /* Follow next */
    1150:	c7 01       	movw	r24, r14
    1152:	0e 94 1c 06 	call	0xc38	; 0xc38 <get_clust>
    1156:	d8 01       	movw	r26, r16
    1158:	14 96       	adiw	r26, 0x04	; 4
    115a:	6d 93       	st	X+, r22
    115c:	7d 93       	st	X+, r23
    115e:	8d 93       	st	X+, r24
    1160:	9c 93       	st	X, r25
    1162:	17 97       	sbiw	r26, 0x07	; 7
		}
    1164:	db cf       	rjmp	.-74     	; 0x111c <follow_path+0x5a>
			if (res != FR_OK)
				break; /* Could not find the object */
			if (dj->fn[11])
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE;
    1166:	83 e0       	ldi	r24, 0x03	; 3
			dj->sclust = get_clust(dir); /* Follow next */
		}
	}

	return res;
}
    1168:	0f 90       	pop	r0
    116a:	0f 90       	pop	r0
    116c:	df 91       	pop	r29
    116e:	cf 91       	pop	r28
    1170:	1f 91       	pop	r17
    1172:	0f 91       	pop	r16
    1174:	ff 90       	pop	r15
    1176:	ef 90       	pop	r14
    1178:	08 95       	ret

0000117a <pf_mount>:
/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount(FATFS *fs /* Pointer to new file system object */)
{
    117a:	4f 92       	push	r4
    117c:	5f 92       	push	r5
    117e:	6f 92       	push	r6
    1180:	7f 92       	push	r7
    1182:	8f 92       	push	r8
    1184:	9f 92       	push	r9
    1186:	af 92       	push	r10
    1188:	bf 92       	push	r11
    118a:	df 92       	push	r13
    118c:	ef 92       	push	r14
    118e:	ff 92       	push	r15
    1190:	0f 93       	push	r16
    1192:	1f 93       	push	r17
    1194:	cf 93       	push	r28
    1196:	df 93       	push	r29
    1198:	cd b7       	in	r28, 0x3d	; 61
    119a:	de b7       	in	r29, 0x3e	; 62
    119c:	a8 97       	sbiw	r28, 0x28	; 40
    119e:	0f b6       	in	r0, 0x3f	; 63
    11a0:	f8 94       	cli
    11a2:	de bf       	out	0x3e, r29	; 62
    11a4:	0f be       	out	0x3f, r0	; 63
    11a6:	cd bf       	out	0x3d, r28	; 61
    11a8:	7c 01       	movw	r14, r24
	BYTE  fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;

	FatFs = 0;
    11aa:	10 92 d2 03 	sts	0x03D2, r1	; 0x8003d2 <FatFs+0x1>
    11ae:	10 92 d1 03 	sts	0x03D1, r1	; 0x8003d1 <FatFs>

	if (disk_initialize() & STA_NOINIT)
    11b2:	0e 94 60 02 	call	0x4c0	; 0x4c0 <disk_initialize>
    11b6:	80 fd       	sbrc	r24, 0
    11b8:	62 c1       	rjmp	.+708    	; 0x147e <pf_mount+0x304>
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
    11ba:	40 e0       	ldi	r20, 0x00	; 0
    11bc:	50 e0       	ldi	r21, 0x00	; 0
    11be:	ba 01       	movw	r22, r20
    11c0:	ce 01       	movw	r24, r28
    11c2:	01 96       	adiw	r24, 0x01	; 1
    11c4:	0e 94 c9 06 	call	0xd92	; 0xd92 <check_fs>
    11c8:	d8 2e       	mov	r13, r24
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
    11ca:	21 e0       	ldi	r18, 0x01	; 1
    11cc:	82 13       	cpse	r24, r18
    11ce:	38 c0       	rjmp	.+112    	; 0x1240 <pf_mount+0xc6>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
    11d0:	00 e1       	ldi	r16, 0x10	; 16
    11d2:	10 e0       	ldi	r17, 0x00	; 0
    11d4:	2e eb       	ldi	r18, 0xBE	; 190
    11d6:	31 e0       	ldi	r19, 0x01	; 1
    11d8:	40 e0       	ldi	r20, 0x00	; 0
    11da:	50 e0       	ldi	r21, 0x00	; 0
    11dc:	ba 01       	movw	r22, r20
    11de:	ce 01       	movw	r24, r28
    11e0:	01 96       	adiw	r24, 0x01	; 1
    11e2:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    11e6:	81 11       	cpse	r24, r1
    11e8:	2f c0       	rjmp	.+94     	; 0x1248 <pf_mount+0xce>
			fmt = 3;
		} else {
			if (buf[4]) {                     /* Is the partition existing? */
    11ea:	8d 81       	ldd	r24, Y+5	; 0x05
    11ec:	88 23       	and	r24, r24
    11ee:	a1 f1       	breq	.+104    	; 0x1258 <pf_mount+0xde>
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
    11f0:	8c 84       	ldd	r8, Y+12	; 0x0c
    11f2:	91 2c       	mov	r9, r1
    11f4:	a1 2c       	mov	r10, r1
    11f6:	b1 2c       	mov	r11, r1
    11f8:	b8 2c       	mov	r11, r8
    11fa:	aa 24       	eor	r10, r10
    11fc:	99 24       	eor	r9, r9
    11fe:	88 24       	eor	r8, r8
    1200:	9b 85       	ldd	r25, Y+11	; 0x0b
    1202:	89 2f       	mov	r24, r25
    1204:	90 e0       	ldi	r25, 0x00	; 0
    1206:	a0 e0       	ldi	r26, 0x00	; 0
    1208:	b0 e0       	ldi	r27, 0x00	; 0
    120a:	dc 01       	movw	r26, r24
    120c:	99 27       	eor	r25, r25
    120e:	88 27       	eor	r24, r24
    1210:	88 29       	or	r24, r8
    1212:	99 29       	or	r25, r9
    1214:	aa 29       	or	r26, r10
    1216:	bb 29       	or	r27, r11
    1218:	8a 84       	ldd	r8, Y+10	; 0x0a
    121a:	91 2c       	mov	r9, r1
    121c:	98 2c       	mov	r9, r8
    121e:	88 24       	eor	r8, r8
    1220:	a1 2c       	mov	r10, r1
    1222:	b1 2c       	mov	r11, r1
    1224:	88 2a       	or	r8, r24
    1226:	99 2a       	or	r9, r25
    1228:	aa 2a       	or	r10, r26
    122a:	bb 2a       	or	r11, r27
    122c:	89 85       	ldd	r24, Y+9	; 0x09
    122e:	88 2a       	or	r8, r24
				fmt   = check_fs(buf, bsect); /* Check the partition */
    1230:	b5 01       	movw	r22, r10
    1232:	a4 01       	movw	r20, r8
    1234:	ce 01       	movw	r24, r28
    1236:	01 96       	adiw	r24, 0x01	; 1
    1238:	0e 94 c9 06 	call	0xd92	; 0xd92 <check_fs>
    123c:	d8 2e       	mov	r13, r24
    123e:	0f c0       	rjmp	.+30     	; 0x125e <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1240:	81 2c       	mov	r8, r1
    1242:	91 2c       	mov	r9, r1
    1244:	54 01       	movw	r10, r8
    1246:	0b c0       	rjmp	.+22     	; 0x125e <pf_mount+0xe4>
    1248:	81 2c       	mov	r8, r1
    124a:	91 2c       	mov	r9, r1
    124c:	54 01       	movw	r10, r8
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
			fmt = 3;
    124e:	0f 2e       	mov	r0, r31
    1250:	f3 e0       	ldi	r31, 0x03	; 3
    1252:	df 2e       	mov	r13, r31
    1254:	f0 2d       	mov	r31, r0
    1256:	03 c0       	rjmp	.+6      	; 0x125e <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1258:	81 2c       	mov	r8, r1
    125a:	91 2c       	mov	r9, r1
    125c:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
    125e:	43 e0       	ldi	r20, 0x03	; 3
    1260:	d4 16       	cp	r13, r20
    1262:	09 f4       	brne	.+2      	; 0x1266 <pf_mount+0xec>
    1264:	0e c1       	rjmp	.+540    	; 0x1482 <pf_mount+0x308>
		return FR_DISK_ERR;
	if (fmt)
    1266:	d1 10       	cpse	r13, r1
    1268:	0e c1       	rjmp	.+540    	; 0x1486 <pf_mount+0x30c>
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
    126a:	04 e2       	ldi	r16, 0x24	; 36
    126c:	10 e0       	ldi	r17, 0x00	; 0
    126e:	2d e0       	ldi	r18, 0x0D	; 13
    1270:	30 e0       	ldi	r19, 0x00	; 0
    1272:	b5 01       	movw	r22, r10
    1274:	a4 01       	movw	r20, r8
    1276:	ce 01       	movw	r24, r28
    1278:	01 96       	adiw	r24, 0x01	; 1
    127a:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
    127e:	81 11       	cpse	r24, r1
    1280:	04 c1       	rjmp	.+520    	; 0x148a <pf_mount+0x310>
		return FR_DISK_ERR;

	fsize = LD_WORD(buf + BPB_FATSz16 - 13); /* Number of sectors per FAT */
    1282:	2b 85       	ldd	r18, Y+11	; 0x0b
    1284:	30 e0       	ldi	r19, 0x00	; 0
    1286:	32 2f       	mov	r19, r18
    1288:	22 27       	eor	r18, r18
    128a:	8a 85       	ldd	r24, Y+10	; 0x0a
    128c:	28 2b       	or	r18, r24
    128e:	40 e0       	ldi	r20, 0x00	; 0
    1290:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize)
    1292:	21 15       	cp	r18, r1
    1294:	31 05       	cpc	r19, r1
    1296:	41 05       	cpc	r20, r1
    1298:	51 05       	cpc	r21, r1
    129a:	21 f5       	brne	.+72     	; 0x12e4 <pf_mount+0x16a>
		fsize = LD_DWORD(buf + BPB_FATSz32 - 13);
    129c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    129e:	82 2f       	mov	r24, r18
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	a0 e0       	ldi	r26, 0x00	; 0
    12a4:	b0 e0       	ldi	r27, 0x00	; 0
    12a6:	78 2f       	mov	r23, r24
    12a8:	66 27       	eor	r22, r22
    12aa:	55 27       	eor	r21, r21
    12ac:	44 27       	eor	r20, r20
    12ae:	9a 8d       	ldd	r25, Y+26	; 0x1a
    12b0:	89 2f       	mov	r24, r25
    12b2:	90 e0       	ldi	r25, 0x00	; 0
    12b4:	a0 e0       	ldi	r26, 0x00	; 0
    12b6:	b0 e0       	ldi	r27, 0x00	; 0
    12b8:	dc 01       	movw	r26, r24
    12ba:	99 27       	eor	r25, r25
    12bc:	88 27       	eor	r24, r24
    12be:	84 2b       	or	r24, r20
    12c0:	95 2b       	or	r25, r21
    12c2:	a6 2b       	or	r26, r22
    12c4:	b7 2b       	or	r27, r23
    12c6:	29 8d       	ldd	r18, Y+25	; 0x19
    12c8:	30 e0       	ldi	r19, 0x00	; 0
    12ca:	32 2f       	mov	r19, r18
    12cc:	22 27       	eor	r18, r18
    12ce:	a9 01       	movw	r20, r18
    12d0:	60 e0       	ldi	r22, 0x00	; 0
    12d2:	70 e0       	ldi	r23, 0x00	; 0
    12d4:	48 2b       	or	r20, r24
    12d6:	59 2b       	or	r21, r25
    12d8:	6a 2b       	or	r22, r26
    12da:	7b 2b       	or	r23, r27
    12dc:	88 8d       	ldd	r24, Y+24	; 0x18
    12de:	9a 01       	movw	r18, r20
    12e0:	ab 01       	movw	r20, r22
    12e2:	28 2b       	or	r18, r24

	fsize *= buf[BPB_NumFATs - 13];                             /* Number of sectors in FAT area */
    12e4:	ac 81       	ldd	r26, Y+4	; 0x04
    12e6:	b0 e0       	ldi	r27, 0x00	; 0
    12e8:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <__muluhisi3>
    12ec:	6d a3       	std	Y+37, r22	; 0x25
    12ee:	7e a3       	std	Y+38, r23	; 0x26
    12f0:	8f a3       	std	Y+39, r24	; 0x27
    12f2:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase   = bsect + LD_WORD(buf + BPB_RsvdSecCnt - 13); /* FAT start sector (lba) */
    12f4:	8b 81       	ldd	r24, Y+3	; 0x03
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	98 2f       	mov	r25, r24
    12fa:	88 27       	eor	r24, r24
    12fc:	4a 81       	ldd	r20, Y+2	; 0x02
    12fe:	50 e0       	ldi	r21, 0x00	; 0
    1300:	84 2b       	or	r24, r20
    1302:	95 2b       	or	r25, r21
    1304:	88 0e       	add	r8, r24
    1306:	99 1e       	adc	r9, r25
    1308:	a1 1c       	adc	r10, r1
    130a:	b1 1c       	adc	r11, r1
    130c:	d7 01       	movw	r26, r14
    130e:	1a 96       	adiw	r26, 0x0a	; 10
    1310:	8d 92       	st	X+, r8
    1312:	9d 92       	st	X+, r9
    1314:	ad 92       	st	X+, r10
    1316:	bc 92       	st	X, r11
    1318:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
    131a:	a9 81       	ldd	r26, Y+1	; 0x01
    131c:	f7 01       	movw	r30, r14
    131e:	a2 83       	std	Z+2, r26	; 0x02
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
    1320:	8e 81       	ldd	r24, Y+6	; 0x06
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	98 2f       	mov	r25, r24
    1326:	88 27       	eor	r24, r24
    1328:	2d 81       	ldd	r18, Y+5	; 0x05
    132a:	82 2b       	or	r24, r18
    132c:	95 83       	std	Z+5, r25	; 0x05
    132e:	84 83       	std	Z+4, r24	; 0x04
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
    1330:	08 85       	ldd	r16, Y+8	; 0x08
    1332:	10 e0       	ldi	r17, 0x00	; 0
    1334:	10 2f       	mov	r17, r16
    1336:	00 27       	eor	r16, r16
    1338:	2f 81       	ldd	r18, Y+7	; 0x07
    133a:	02 2b       	or	r16, r18
    133c:	20 e0       	ldi	r18, 0x00	; 0
    133e:	30 e0       	ldi	r19, 0x00	; 0
	if (!tsect)
    1340:	01 15       	cp	r16, r1
    1342:	11 05       	cpc	r17, r1
    1344:	21 05       	cpc	r18, r1
    1346:	31 05       	cpc	r19, r1
    1348:	01 f5       	brne	.+64     	; 0x138a <pf_mount+0x210>
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
    134a:	0f 89       	ldd	r16, Y+23	; 0x17
    134c:	10 e0       	ldi	r17, 0x00	; 0
    134e:	20 e0       	ldi	r18, 0x00	; 0
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	70 2e       	mov	r7, r16
    1354:	66 24       	eor	r6, r6
    1356:	55 24       	eor	r5, r5
    1358:	44 24       	eor	r4, r4
    135a:	0e 89       	ldd	r16, Y+22	; 0x16
    135c:	10 e0       	ldi	r17, 0x00	; 0
    135e:	20 e0       	ldi	r18, 0x00	; 0
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	98 01       	movw	r18, r16
    1364:	11 27       	eor	r17, r17
    1366:	00 27       	eor	r16, r16
    1368:	40 2a       	or	r4, r16
    136a:	51 2a       	or	r5, r17
    136c:	62 2a       	or	r6, r18
    136e:	73 2a       	or	r7, r19
    1370:	2d 89       	ldd	r18, Y+21	; 0x15
    1372:	30 e0       	ldi	r19, 0x00	; 0
    1374:	32 2f       	mov	r19, r18
    1376:	22 27       	eor	r18, r18
    1378:	89 01       	movw	r16, r18
    137a:	20 e0       	ldi	r18, 0x00	; 0
    137c:	30 e0       	ldi	r19, 0x00	; 0
    137e:	04 29       	or	r16, r4
    1380:	15 29       	or	r17, r5
    1382:	26 29       	or	r18, r6
    1384:	37 29       	or	r19, r7
    1386:	6c 89       	ldd	r22, Y+20	; 0x14
    1388:	06 2b       	or	r16, r22
	mclst = (tsect /* Last cluster# + 1 */
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
    138a:	eb 81       	ldd	r30, Y+3	; 0x03
    138c:	f0 e0       	ldi	r31, 0x00	; 0
    138e:	fe 2f       	mov	r31, r30
    1390:	ee 27       	eor	r30, r30
    1392:	4e 2b       	or	r20, r30
    1394:	5f 2b       	or	r21, r31
    1396:	04 1b       	sub	r16, r20
    1398:	15 0b       	sbc	r17, r21
    139a:	21 09       	sbc	r18, r1
    139c:	31 09       	sbc	r19, r1
    139e:	4d a1       	ldd	r20, Y+37	; 0x25
    13a0:	5e a1       	ldd	r21, Y+38	; 0x26
    13a2:	6f a1       	ldd	r22, Y+39	; 0x27
    13a4:	78 a5       	ldd	r23, Y+40	; 0x28
    13a6:	04 1b       	sub	r16, r20
    13a8:	15 0b       	sbc	r17, r21
    13aa:	26 0b       	sbc	r18, r22
    13ac:	37 0b       	sbc	r19, r23
    13ae:	92 95       	swap	r25
    13b0:	82 95       	swap	r24
    13b2:	8f 70       	andi	r24, 0x0F	; 15
    13b4:	89 27       	eor	r24, r25
    13b6:	9f 70       	andi	r25, 0x0F	; 15
    13b8:	89 27       	eor	r24, r25
    13ba:	2c 01       	movw	r4, r24
    13bc:	61 2c       	mov	r6, r1
    13be:	71 2c       	mov	r7, r1
    13c0:	c9 01       	movw	r24, r18
    13c2:	b8 01       	movw	r22, r16
    13c4:	64 19       	sub	r22, r4
    13c6:	75 09       	sbc	r23, r5
    13c8:	86 09       	sbc	r24, r6
    13ca:	97 09       	sbc	r25, r7
	            / fs->csize
    13cc:	2a 2f       	mov	r18, r26
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	40 e0       	ldi	r20, 0x00	; 0
    13d2:	50 e0       	ldi	r21, 0x00	; 0
    13d4:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__udivmodsi4>
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
	if (!tsect)
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
	mclst = (tsect /* Last cluster# + 1 */
    13d8:	da 01       	movw	r26, r20
    13da:	c9 01       	movw	r24, r18
    13dc:	02 96       	adiw	r24, 0x02	; 2
    13de:	a1 1d       	adc	r26, r1
    13e0:	b1 1d       	adc	r27, r1
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
	            / fs->csize
	        + 2;
	fs->n_fatent = (CLUST)mclst;
    13e2:	f7 01       	movw	r30, r14
    13e4:	86 83       	std	Z+6, r24	; 0x06
    13e6:	97 83       	std	Z+7, r25	; 0x07
    13e8:	a0 87       	std	Z+8, r26	; 0x08
    13ea:	b1 87       	std	Z+9, r27	; 0x09
	fmt = 0; /* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    13ec:	87 3f       	cpi	r24, 0xF7	; 247
    13ee:	9f 4f       	sbci	r25, 0xFF	; 255
    13f0:	a1 05       	cpc	r26, r1
    13f2:	b1 05       	cpc	r27, r1
    13f4:	20 f0       	brcs	.+8      	; 0x13fe <pf_mount+0x284>
		fmt = FS_FAT32;
    13f6:	0f 2e       	mov	r0, r31
    13f8:	f3 e0       	ldi	r31, 0x03	; 3
    13fa:	df 2e       	mov	r13, r31
    13fc:	f0 2d       	mov	r31, r0
	if (!fmt)
    13fe:	dd 20       	and	r13, r13
    1400:	09 f4       	brne	.+2      	; 0x1404 <pf_mount+0x28a>
    1402:	45 c0       	rjmp	.+138    	; 0x148e <pf_mount+0x314>
		return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    1404:	d7 01       	movw	r26, r14
    1406:	dc 92       	st	X, r13

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf + (BPB_RootClus - 13)); /* Root directory start cluster */
    1408:	8b a1       	ldd	r24, Y+35	; 0x23
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	a0 e0       	ldi	r26, 0x00	; 0
    140e:	b0 e0       	ldi	r27, 0x00	; 0
    1410:	78 2f       	mov	r23, r24
    1412:	66 27       	eor	r22, r22
    1414:	55 27       	eor	r21, r21
    1416:	44 27       	eor	r20, r20
    1418:	8a a1       	ldd	r24, Y+34	; 0x22
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	a0 e0       	ldi	r26, 0x00	; 0
    141e:	b0 e0       	ldi	r27, 0x00	; 0
    1420:	dc 01       	movw	r26, r24
    1422:	99 27       	eor	r25, r25
    1424:	88 27       	eor	r24, r24
    1426:	84 2b       	or	r24, r20
    1428:	95 2b       	or	r25, r21
    142a:	a6 2b       	or	r26, r22
    142c:	b7 2b       	or	r27, r23
    142e:	49 a1       	ldd	r20, Y+33	; 0x21
    1430:	50 e0       	ldi	r21, 0x00	; 0
    1432:	54 2f       	mov	r21, r20
    1434:	44 27       	eor	r20, r20
    1436:	60 e0       	ldi	r22, 0x00	; 0
    1438:	70 e0       	ldi	r23, 0x00	; 0
    143a:	84 2b       	or	r24, r20
    143c:	95 2b       	or	r25, r21
    143e:	a6 2b       	or	r26, r22
    1440:	b7 2b       	or	r27, r23
    1442:	28 a1       	ldd	r18, Y+32	; 0x20
    1444:	82 2b       	or	r24, r18
    1446:	f7 01       	movw	r30, r14
    1448:	86 87       	std	Z+14, r24	; 0x0e
    144a:	97 87       	std	Z+15, r25	; 0x0f
    144c:	a0 8b       	std	Z+16, r26	; 0x10
    144e:	b1 8b       	std	Z+17, r27	; 0x11
	else
		fs->dirbase = fs->fatbase + fsize;                   /* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16; /* Data start sector (lba) */
    1450:	4d a1       	ldd	r20, Y+37	; 0x25
    1452:	5e a1       	ldd	r21, Y+38	; 0x26
    1454:	6f a1       	ldd	r22, Y+39	; 0x27
    1456:	78 a5       	ldd	r23, Y+40	; 0x28
    1458:	84 0e       	add	r8, r20
    145a:	95 1e       	adc	r9, r21
    145c:	a6 1e       	adc	r10, r22
    145e:	b7 1e       	adc	r11, r23
    1460:	84 0c       	add	r8, r4
    1462:	95 1c       	adc	r9, r5
    1464:	a6 1c       	adc	r10, r6
    1466:	b7 1c       	adc	r11, r7
    1468:	82 8a       	std	Z+18, r8	; 0x12
    146a:	93 8a       	std	Z+19, r9	; 0x13
    146c:	a4 8a       	std	Z+20, r10	; 0x14
    146e:	b5 8a       	std	Z+21, r11	; 0x15

	fs->flag = 0;
    1470:	11 82       	std	Z+1, r1	; 0x01
	FatFs    = fs;
    1472:	f0 92 d2 03 	sts	0x03D2, r15	; 0x8003d2 <FatFs+0x1>
    1476:	e0 92 d1 03 	sts	0x03D1, r14	; 0x8003d1 <FatFs>

	return FR_OK;
    147a:	80 e0       	ldi	r24, 0x00	; 0
    147c:	09 c0       	rjmp	.+18     	; 0x1490 <pf_mount+0x316>
	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)
	{
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
    147e:	82 e0       	ldi	r24, 0x02	; 2
    1480:	07 c0       	rjmp	.+14     	; 0x1490 <pf_mount+0x316>
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
		return FR_DISK_ERR;
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	05 c0       	rjmp	.+10     	; 0x1490 <pf_mount+0x316>
	if (fmt)
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */
    1486:	86 e0       	ldi	r24, 0x06	; 6
    1488:	03 c0       	rjmp	.+6      	; 0x1490 <pf_mount+0x316>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
		return FR_DISK_ERR;
    148a:	81 e0       	ldi	r24, 0x01	; 1
    148c:	01 c0       	rjmp	.+2      	; 0x1490 <pf_mount+0x316>
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
		fmt = FS_FAT32;
	if (!fmt)
		return FR_NO_FILESYSTEM;
    148e:	86 e0       	ldi	r24, 0x06	; 6

	fs->flag = 0;
	FatFs    = fs;

	return FR_OK;
}
    1490:	a8 96       	adiw	r28, 0x28	; 40
    1492:	0f b6       	in	r0, 0x3f	; 63
    1494:	f8 94       	cli
    1496:	de bf       	out	0x3e, r29	; 62
    1498:	0f be       	out	0x3f, r0	; 63
    149a:	cd bf       	out	0x3d, r28	; 61
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	1f 91       	pop	r17
    14a2:	0f 91       	pop	r16
    14a4:	ff 90       	pop	r15
    14a6:	ef 90       	pop	r14
    14a8:	df 90       	pop	r13
    14aa:	bf 90       	pop	r11
    14ac:	af 90       	pop	r10
    14ae:	9f 90       	pop	r9
    14b0:	8f 90       	pop	r8
    14b2:	7f 90       	pop	r7
    14b4:	6f 90       	pop	r6
    14b6:	5f 90       	pop	r5
    14b8:	4f 90       	pop	r4
    14ba:	08 95       	ret

000014bc <pf_open>:
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT pf_open(const char *path /* Pointer to the file name */
)
 {
    14bc:	0f 93       	push	r16
    14be:	1f 93       	push	r17
    14c0:	cf 93       	push	r28
    14c2:	df 93       	push	r29
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
    14c8:	ec 97       	sbiw	r28, 0x3c	; 60
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	de bf       	out	0x3e, r29	; 62
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;
    14d4:	00 91 d1 03 	lds	r16, 0x03D1	; 0x8003d1 <FatFs>
    14d8:	10 91 d2 03 	lds	r17, 0x03D2	; 0x8003d2 <FatFs+0x1>

	if (!fs)
    14dc:	01 15       	cp	r16, r1
    14de:	11 05       	cpc	r17, r1
    14e0:	09 f4       	brne	.+2      	; 0x14e4 <pf_open+0x28>
    14e2:	4a c0       	rjmp	.+148    	; 0x1578 <pf_open+0xbc>
    14e4:	ac 01       	movw	r20, r24
		return FR_NOT_ENABLED; /* Check file system */

	fs->flag = 0;
    14e6:	f8 01       	movw	r30, r16
    14e8:	11 82       	std	Z+1, r1	; 0x01
	dj.fn    = sp;
    14ea:	ce 01       	movw	r24, r28
    14ec:	41 96       	adiw	r24, 0x11	; 17
    14ee:	9c 83       	std	Y+4, r25	; 0x04
    14f0:	8b 83       	std	Y+3, r24	; 0x03
	res      = follow_path(&dj, dir, path); /* Follow the file path */
    14f2:	be 01       	movw	r22, r28
    14f4:	63 5e       	subi	r22, 0xE3	; 227
    14f6:	7f 4f       	sbci	r23, 0xFF	; 255
    14f8:	40 97       	sbiw	r24, 0x10	; 16
    14fa:	0e 94 61 08 	call	0x10c2	; 0x10c2 <follow_path>
	if (res != FR_OK)
    14fe:	81 11       	cpse	r24, r1
    1500:	40 c0       	rjmp	.+128    	; 0x1582 <pf_open+0xc6>
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
    1502:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1504:	88 23       	and	r24, r24
    1506:	d1 f1       	breq	.+116    	; 0x157c <pf_open+0xc0>
    1508:	88 a5       	ldd	r24, Y+40	; 0x28
    150a:	84 fd       	sbrc	r24, 4
    150c:	39 c0       	rjmp	.+114    	; 0x1580 <pf_open+0xc4>
		return FR_NO_FILE;
	

	fs->org_clust = get_clust(dir);               /* File start cluster */
    150e:	ce 01       	movw	r24, r28
    1510:	4d 96       	adiw	r24, 0x1d	; 29
    1512:	0e 94 1c 06 	call	0xc38	; 0xc38 <get_clust>
    1516:	f8 01       	movw	r30, r16
    1518:	66 8f       	std	Z+30, r22	; 0x1e
    151a:	77 8f       	std	Z+31, r23	; 0x1f
    151c:	80 a3       	std	Z+32, r24	; 0x20
    151e:	91 a3       	std	Z+33, r25	; 0x21
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
    1520:	8c ad       	ldd	r24, Y+60	; 0x3c
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	a0 e0       	ldi	r26, 0x00	; 0
    1526:	b0 e0       	ldi	r27, 0x00	; 0
    1528:	78 2f       	mov	r23, r24
    152a:	66 27       	eor	r22, r22
    152c:	55 27       	eor	r21, r21
    152e:	44 27       	eor	r20, r20
    1530:	9b ad       	ldd	r25, Y+59	; 0x3b
    1532:	89 2f       	mov	r24, r25
    1534:	90 e0       	ldi	r25, 0x00	; 0
    1536:	a0 e0       	ldi	r26, 0x00	; 0
    1538:	b0 e0       	ldi	r27, 0x00	; 0
    153a:	dc 01       	movw	r26, r24
    153c:	99 27       	eor	r25, r25
    153e:	88 27       	eor	r24, r24
    1540:	84 2b       	or	r24, r20
    1542:	95 2b       	or	r25, r21
    1544:	a6 2b       	or	r26, r22
    1546:	b7 2b       	or	r27, r23
    1548:	4a ad       	ldd	r20, Y+58	; 0x3a
    154a:	50 e0       	ldi	r21, 0x00	; 0
    154c:	54 2f       	mov	r21, r20
    154e:	44 27       	eor	r20, r20
    1550:	60 e0       	ldi	r22, 0x00	; 0
    1552:	70 e0       	ldi	r23, 0x00	; 0
    1554:	84 2b       	or	r24, r20
    1556:	95 2b       	or	r25, r21
    1558:	a6 2b       	or	r26, r22
    155a:	b7 2b       	or	r27, r23
    155c:	29 ad       	ldd	r18, Y+57	; 0x39
    155e:	82 2b       	or	r24, r18
    1560:	82 8f       	std	Z+26, r24	; 0x1a
    1562:	93 8f       	std	Z+27, r25	; 0x1b
    1564:	a4 8f       	std	Z+28, r26	; 0x1c
    1566:	b5 8f       	std	Z+29, r27	; 0x1d
	fs->fptr      = 0;                            /* File pointer */
    1568:	16 8a       	std	Z+22, r1	; 0x16
    156a:	17 8a       	std	Z+23, r1	; 0x17
    156c:	10 8e       	std	Z+24, r1	; 0x18
    156e:	11 8e       	std	Z+25, r1	; 0x19
	fs->flag      = FA_OPENED;
    1570:	81 e0       	ldi	r24, 0x01	; 1
    1572:	81 83       	std	Z+1, r24	; 0x01

	return FR_OK;
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	05 c0       	rjmp	.+10     	; 0x1582 <pf_open+0xc6>
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED; /* Check file system */
    1578:	85 e0       	ldi	r24, 0x05	; 5
    157a:	03 c0       	rjmp	.+6      	; 0x1582 <pf_open+0xc6>
	dj.fn    = sp;
	res      = follow_path(&dj, dir, path); /* Follow the file path */
	if (res != FR_OK)
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
		return FR_NO_FILE;
    157c:	83 e0       	ldi	r24, 0x03	; 3
    157e:	01 c0       	rjmp	.+2      	; 0x1582 <pf_open+0xc6>
    1580:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
	fs->fptr      = 0;                            /* File pointer */
	fs->flag      = FA_OPENED;

	return FR_OK;
}
    1582:	ec 96       	adiw	r28, 0x3c	; 60
    1584:	0f b6       	in	r0, 0x3f	; 63
    1586:	f8 94       	cli
    1588:	de bf       	out	0x3e, r29	; 62
    158a:	0f be       	out	0x3f, r0	; 63
    158c:	cd bf       	out	0x3d, r28	; 61
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	1f 91       	pop	r17
    1594:	0f 91       	pop	r16
    1596:	08 95       	ret

00001598 <pf_read>:

FRESULT pf_read(void *buff, /* Pointer to the read buffer (NULL:Forward data to the stream)*/
                UINT  btr,  /* Number of bytes to read */
                UINT *br    /* Pointer to number of bytes read */
)
{
    1598:	6f 92       	push	r6
    159a:	7f 92       	push	r7
    159c:	8f 92       	push	r8
    159e:	9f 92       	push	r9
    15a0:	af 92       	push	r10
    15a2:	bf 92       	push	r11
    15a4:	cf 92       	push	r12
    15a6:	df 92       	push	r13
    15a8:	ef 92       	push	r14
    15aa:	ff 92       	push	r15
    15ac:	0f 93       	push	r16
    15ae:	1f 93       	push	r17
    15b0:	cf 93       	push	r28
    15b2:	df 93       	push	r29
    15b4:	3c 01       	movw	r6, r24
    15b6:	6b 01       	movw	r12, r22
    15b8:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST   clst;
	DWORD   sect, remain;
	UINT    rcnt;
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;
    15ba:	e0 90 d1 03 	lds	r14, 0x03D1	; 0x8003d1 <FatFs>
    15be:	f0 90 d2 03 	lds	r15, 0x03D2	; 0x8003d2 <FatFs+0x1>

	*br = 0;
    15c2:	fa 01       	movw	r30, r20
    15c4:	11 82       	std	Z+1, r1	; 0x01
    15c6:	10 82       	st	Z, r1
	if (!fs)
    15c8:	e1 14       	cp	r14, r1
    15ca:	f1 04       	cpc	r15, r1
    15cc:	09 f4       	brne	.+2      	; 0x15d0 <pf_read+0x38>
    15ce:	b5 c0       	rjmp	.+362    	; 0x173a <pf_read+0x1a2>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    15d0:	f7 01       	movw	r30, r14
    15d2:	81 81       	ldd	r24, Z+1	; 0x01
    15d4:	80 ff       	sbrs	r24, 0
    15d6:	b3 c0       	rjmp	.+358    	; 0x173e <pf_read+0x1a6>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    15d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    15da:	93 8d       	ldd	r25, Z+27	; 0x1b
    15dc:	a4 8d       	ldd	r26, Z+28	; 0x1c
    15de:	b5 8d       	ldd	r27, Z+29	; 0x1d
    15e0:	46 89       	ldd	r20, Z+22	; 0x16
    15e2:	57 89       	ldd	r21, Z+23	; 0x17
    15e4:	60 8d       	ldd	r22, Z+24	; 0x18
    15e6:	71 8d       	ldd	r23, Z+25	; 0x19
    15e8:	84 1b       	sub	r24, r20
    15ea:	95 0b       	sbc	r25, r21
    15ec:	a6 0b       	sbc	r26, r22
    15ee:	b7 0b       	sbc	r27, r23
	if (btr > remain)
    15f0:	a6 01       	movw	r20, r12
    15f2:	60 e0       	ldi	r22, 0x00	; 0
    15f4:	70 e0       	ldi	r23, 0x00	; 0
    15f6:	84 17       	cp	r24, r20
    15f8:	95 07       	cpc	r25, r21
    15fa:	a6 07       	cpc	r26, r22
    15fc:	b7 07       	cpc	r27, r23
    15fe:	08 f4       	brcc	.+2      	; 0x1602 <pf_read+0x6a>
		btr = (UINT)remain; /* Truncate btr by remaining bytes */
    1600:	6c 01       	movw	r12, r24
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
		if (rcnt > btr)
			rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    1602:	53 01       	movw	r10, r6
    1604:	94 c0       	rjmp	.+296    	; 0x172e <pf_read+0x196>
	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {                       /* On the sector boundary? */
    1606:	f7 01       	movw	r30, r14
    1608:	86 89       	ldd	r24, Z+22	; 0x16
    160a:	97 89       	ldd	r25, Z+23	; 0x17
    160c:	a0 8d       	ldd	r26, Z+24	; 0x18
    160e:	b1 8d       	ldd	r27, Z+25	; 0x19
    1610:	ac 01       	movw	r20, r24
    1612:	bd 01       	movw	r22, r26
    1614:	51 70       	andi	r21, 0x01	; 1
    1616:	66 27       	eor	r22, r22
    1618:	77 27       	eor	r23, r23
    161a:	45 2b       	or	r20, r21
    161c:	46 2b       	or	r20, r22
    161e:	47 2b       	or	r20, r23
    1620:	09 f0       	breq	.+2      	; 0x1624 <pf_read+0x8c>
    1622:	48 c0       	rjmp	.+144    	; 0x16b4 <pf_read+0x11c>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1624:	c2 81       	ldd	r28, Z+2	; 0x02
    1626:	c1 50       	subi	r28, 0x01	; 1
    1628:	ac 01       	movw	r20, r24
    162a:	bd 01       	movw	r22, r26
    162c:	03 2e       	mov	r0, r19
    162e:	39 e0       	ldi	r19, 0x09	; 9
    1630:	76 95       	lsr	r23
    1632:	67 95       	ror	r22
    1634:	57 95       	ror	r21
    1636:	47 95       	ror	r20
    1638:	3a 95       	dec	r19
    163a:	d1 f7       	brne	.-12     	; 0x1630 <pf_read+0x98>
    163c:	30 2d       	mov	r19, r0
    163e:	c4 23       	and	r28, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1640:	f1 f4       	brne	.+60     	; 0x167e <pf_read+0xe6>
				if (fs->fptr == 0)                         /* On the top of the file? */
    1642:	89 2b       	or	r24, r25
    1644:	8a 2b       	or	r24, r26
    1646:	8b 2b       	or	r24, r27
    1648:	29 f4       	brne	.+10     	; 0x1654 <pf_read+0xbc>
					clst = fs->org_clust;
    164a:	66 8d       	ldd	r22, Z+30	; 0x1e
    164c:	77 8d       	ldd	r23, Z+31	; 0x1f
    164e:	80 a1       	ldd	r24, Z+32	; 0x20
    1650:	91 a1       	ldd	r25, Z+33	; 0x21
    1652:	07 c0       	rjmp	.+14     	; 0x1662 <pf_read+0xca>
				else
					clst = get_fat(fs->curr_clust);
    1654:	f7 01       	movw	r30, r14
    1656:	62 a1       	ldd	r22, Z+34	; 0x22
    1658:	73 a1       	ldd	r23, Z+35	; 0x23
    165a:	84 a1       	ldd	r24, Z+36	; 0x24
    165c:	95 a1       	ldd	r25, Z+37	; 0x25
    165e:	0e 94 09 07 	call	0xe12	; 0xe12 <get_fat>
				if (clst <= 1)
    1662:	62 30       	cpi	r22, 0x02	; 2
    1664:	71 05       	cpc	r23, r1
    1666:	81 05       	cpc	r24, r1
    1668:	91 05       	cpc	r25, r1
    166a:	20 f4       	brcc	.+8      	; 0x1674 <pf_read+0xdc>
					ABORT(FR_DISK_ERR);
    166c:	f7 01       	movw	r30, r14
    166e:	11 82       	std	Z+1, r1	; 0x01
    1670:	81 e0       	ldi	r24, 0x01	; 1
    1672:	66 c0       	rjmp	.+204    	; 0x1740 <pf_read+0x1a8>
				fs->curr_clust = clst; /* Update current cluster */
    1674:	f7 01       	movw	r30, r14
    1676:	62 a3       	std	Z+34, r22	; 0x22
    1678:	73 a3       	std	Z+35, r23	; 0x23
    167a:	84 a3       	std	Z+36, r24	; 0x24
    167c:	95 a3       	std	Z+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    167e:	f7 01       	movw	r30, r14
    1680:	62 a1       	ldd	r22, Z+34	; 0x22
    1682:	73 a1       	ldd	r23, Z+35	; 0x23
    1684:	84 a1       	ldd	r24, Z+36	; 0x24
    1686:	95 a1       	ldd	r25, Z+37	; 0x25
    1688:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clust2sect>
			if (!sect)
    168c:	61 15       	cp	r22, r1
    168e:	71 05       	cpc	r23, r1
    1690:	81 05       	cpc	r24, r1
    1692:	91 05       	cpc	r25, r1
    1694:	21 f4       	brne	.+8      	; 0x169e <pf_read+0x106>
				ABORT(FR_DISK_ERR);
    1696:	f7 01       	movw	r30, r14
    1698:	11 82       	std	Z+1, r1	; 0x01
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	51 c0       	rjmp	.+162    	; 0x1740 <pf_read+0x1a8>
			fs->dsect = sect + cs;
    169e:	dc 01       	movw	r26, r24
    16a0:	cb 01       	movw	r24, r22
    16a2:	8c 0f       	add	r24, r28
    16a4:	91 1d       	adc	r25, r1
    16a6:	a1 1d       	adc	r26, r1
    16a8:	b1 1d       	adc	r27, r1
    16aa:	f7 01       	movw	r30, r14
    16ac:	86 a3       	std	Z+38, r24	; 0x26
    16ae:	97 a3       	std	Z+39, r25	; 0x27
    16b0:	a0 a7       	std	Z+40, r26	; 0x28
    16b2:	b1 a7       	std	Z+41, r27	; 0x29
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
    16b4:	f7 01       	movw	r30, r14
    16b6:	86 89       	ldd	r24, Z+22	; 0x16
    16b8:	97 89       	ldd	r25, Z+23	; 0x17
    16ba:	a0 8d       	ldd	r26, Z+24	; 0x18
    16bc:	b1 8d       	ldd	r27, Z+25	; 0x19
    16be:	9c 01       	movw	r18, r24
    16c0:	31 70       	andi	r19, 0x01	; 1
    16c2:	c0 e0       	ldi	r28, 0x00	; 0
    16c4:	d2 e0       	ldi	r29, 0x02	; 2
    16c6:	c2 1b       	sub	r28, r18
    16c8:	d3 0b       	sbc	r29, r19
		if (rcnt > btr)
    16ca:	cc 16       	cp	r12, r28
    16cc:	dd 06       	cpc	r13, r29
    16ce:	08 f4       	brcc	.+2      	; 0x16d2 <pf_read+0x13a>
			rcnt = btr;
    16d0:	e6 01       	movw	r28, r12
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    16d2:	f7 01       	movw	r30, r14
    16d4:	46 a1       	ldd	r20, Z+38	; 0x26
    16d6:	57 a1       	ldd	r21, Z+39	; 0x27
    16d8:	60 a5       	ldd	r22, Z+40	; 0x28
    16da:	71 a5       	ldd	r23, Z+41	; 0x29
    16dc:	61 14       	cp	r6, r1
    16de:	71 04       	cpc	r7, r1
    16e0:	19 f4       	brne	.+6      	; 0x16e8 <pf_read+0x150>
    16e2:	80 e0       	ldi	r24, 0x00	; 0
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	02 c0       	rjmp	.+4      	; 0x16ec <pf_read+0x154>
    16e8:	8a 2d       	mov	r24, r10
    16ea:	9b 2d       	mov	r25, r11
    16ec:	8e 01       	movw	r16, r28
    16ee:	0e 94 40 03 	call	0x680	; 0x680 <disk_readp>
		if (dr)
    16f2:	88 23       	and	r24, r24
    16f4:	21 f0       	breq	.+8      	; 0x16fe <pf_read+0x166>
			ABORT(FR_DISK_ERR);
    16f6:	f7 01       	movw	r30, r14
    16f8:	11 82       	std	Z+1, r1	; 0x01
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	21 c0       	rjmp	.+66     	; 0x1740 <pf_read+0x1a8>
		fs->fptr += rcnt;
    16fe:	f7 01       	movw	r30, r14
    1700:	86 89       	ldd	r24, Z+22	; 0x16
    1702:	97 89       	ldd	r25, Z+23	; 0x17
    1704:	a0 8d       	ldd	r26, Z+24	; 0x18
    1706:	b1 8d       	ldd	r27, Z+25	; 0x19
    1708:	8c 0f       	add	r24, r28
    170a:	9d 1f       	adc	r25, r29
    170c:	a1 1d       	adc	r26, r1
    170e:	b1 1d       	adc	r27, r1
    1710:	86 8b       	std	Z+22, r24	; 0x16
    1712:	97 8b       	std	Z+23, r25	; 0x17
    1714:	a0 8f       	std	Z+24, r26	; 0x18
    1716:	b1 8f       	std	Z+25, r27	; 0x19
		rbuff += rcnt; /* Update pointers and counters */
    1718:	ac 0e       	add	r10, r28
    171a:	bd 1e       	adc	r11, r29
		btr -= rcnt;
    171c:	cc 1a       	sub	r12, r28
    171e:	dd 0a       	sbc	r13, r29
		*br += rcnt;
    1720:	f4 01       	movw	r30, r8
    1722:	80 81       	ld	r24, Z
    1724:	91 81       	ldd	r25, Z+1	; 0x01
    1726:	c8 0f       	add	r28, r24
    1728:	d9 1f       	adc	r29, r25
    172a:	d1 83       	std	Z+1, r29	; 0x01
    172c:	c0 83       	st	Z, r28

	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
    172e:	c1 14       	cp	r12, r1
    1730:	d1 04       	cpc	r13, r1
    1732:	09 f0       	breq	.+2      	; 0x1736 <pf_read+0x19e>
    1734:	68 cf       	rjmp	.-304    	; 0x1606 <pf_read+0x6e>
		rbuff += rcnt; /* Update pointers and counters */
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
    1736:	80 e0       	ldi	r24, 0x00	; 0
    1738:	03 c0       	rjmp	.+6      	; 0x1740 <pf_read+0x1a8>
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;

	*br = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    173a:	85 e0       	ldi	r24, 0x05	; 5
    173c:	01 c0       	rjmp	.+2      	; 0x1740 <pf_read+0x1a8>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    173e:	84 e0       	ldi	r24, 0x04	; 4
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
}
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	1f 91       	pop	r17
    1746:	0f 91       	pop	r16
    1748:	ff 90       	pop	r15
    174a:	ef 90       	pop	r14
    174c:	df 90       	pop	r13
    174e:	cf 90       	pop	r12
    1750:	bf 90       	pop	r11
    1752:	af 90       	pop	r10
    1754:	9f 90       	pop	r9
    1756:	8f 90       	pop	r8
    1758:	7f 90       	pop	r7
    175a:	6f 90       	pop	r6
    175c:	08 95       	ret

0000175e <pf_write>:

FRESULT pf_write(const void *buff, /* Pointer to the data to be written */
                 UINT        btw,  /* Number of bytes to write (0:Finalize the current write operation) */
                 UINT *      bw    /* Pointer to number of bytes written */
)
{
    175e:	4f 92       	push	r4
    1760:	5f 92       	push	r5
    1762:	6f 92       	push	r6
    1764:	7f 92       	push	r7
    1766:	af 92       	push	r10
    1768:	bf 92       	push	r11
    176a:	cf 92       	push	r12
    176c:	df 92       	push	r13
    176e:	ef 92       	push	r14
    1770:	ff 92       	push	r15
    1772:	0f 93       	push	r16
    1774:	1f 93       	push	r17
    1776:	cf 93       	push	r28
    1778:	df 93       	push	r29
    177a:	7c 01       	movw	r14, r24
    177c:	5b 01       	movw	r10, r22
    177e:	6a 01       	movw	r12, r20
	CLUST       clst;
	DWORD       sect, remain;
	const BYTE *p = buff;
	BYTE        cs;
	UINT        wcnt;
	FATFS *     fs = FatFs;
    1780:	c0 91 d1 03 	lds	r28, 0x03D1	; 0x8003d1 <FatFs>
    1784:	d0 91 d2 03 	lds	r29, 0x03D2	; 0x8003d2 <FatFs+0x1>

	*bw = 0;
    1788:	fa 01       	movw	r30, r20
    178a:	11 82       	std	Z+1, r1	; 0x01
    178c:	10 82       	st	Z, r1
	if (!fs)
    178e:	20 97       	sbiw	r28, 0x00	; 0
    1790:	09 f4       	brne	.+2      	; 0x1794 <pf_write+0x36>
    1792:	df c0       	rjmp	.+446    	; 0x1952 <pf_write+0x1f4>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    1794:	89 81       	ldd	r24, Y+1	; 0x01
    1796:	80 ff       	sbrs	r24, 0
    1798:	de c0       	rjmp	.+444    	; 0x1956 <pf_write+0x1f8>
		return FR_NOT_OPENED;

	if (!btw) { /* Finalize request */
    179a:	67 2b       	or	r22, r23
    179c:	99 f4       	brne	.+38     	; 0x17c4 <pf_write+0x66>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0))
    179e:	86 ff       	sbrs	r24, 6
    17a0:	0c c0       	rjmp	.+24     	; 0x17ba <pf_write+0x5c>
    17a2:	40 e0       	ldi	r20, 0x00	; 0
    17a4:	50 e0       	ldi	r21, 0x00	; 0
    17a6:	ba 01       	movw	r22, r20
    17a8:	80 e0       	ldi	r24, 0x00	; 0
    17aa:	90 e0       	ldi	r25, 0x00	; 0
    17ac:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    17b0:	88 23       	and	r24, r24
    17b2:	19 f0       	breq	.+6      	; 0x17ba <pf_write+0x5c>
			ABORT(FR_DISK_ERR);
    17b4:	19 82       	std	Y+1, r1	; 0x01
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	cf c0       	rjmp	.+414    	; 0x1958 <pf_write+0x1fa>
		fs->flag &= ~FA__WIP;
    17ba:	89 81       	ldd	r24, Y+1	; 0x01
    17bc:	8f 7b       	andi	r24, 0xBF	; 191
    17be:	89 83       	std	Y+1, r24	; 0x01
		return FR_OK;
    17c0:	80 e0       	ldi	r24, 0x00	; 0
    17c2:	ca c0       	rjmp	.+404    	; 0x1958 <pf_write+0x1fa>
	} else {                       /* Write data request */
		if (!(fs->flag & FA__WIP)) /* Round-down fptr to the sector boundary */
    17c4:	86 fd       	sbrc	r24, 6
    17c6:	0a c0       	rjmp	.+20     	; 0x17dc <pf_write+0x7e>
			fs->fptr &= 0xFFFFFE00;
    17c8:	8e 89       	ldd	r24, Y+22	; 0x16
    17ca:	9f 89       	ldd	r25, Y+23	; 0x17
    17cc:	a8 8d       	ldd	r26, Y+24	; 0x18
    17ce:	b9 8d       	ldd	r27, Y+25	; 0x19
    17d0:	88 27       	eor	r24, r24
    17d2:	9e 7f       	andi	r25, 0xFE	; 254
    17d4:	8e 8b       	std	Y+22, r24	; 0x16
    17d6:	9f 8b       	std	Y+23, r25	; 0x17
    17d8:	a8 8f       	std	Y+24, r26	; 0x18
    17da:	b9 8f       	std	Y+25, r27	; 0x19
	}
	remain = fs->fsize - fs->fptr;
    17dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17de:	9b 8d       	ldd	r25, Y+27	; 0x1b
    17e0:	ac 8d       	ldd	r26, Y+28	; 0x1c
    17e2:	bd 8d       	ldd	r27, Y+29	; 0x1d
    17e4:	4e 89       	ldd	r20, Y+22	; 0x16
    17e6:	5f 89       	ldd	r21, Y+23	; 0x17
    17e8:	68 8d       	ldd	r22, Y+24	; 0x18
    17ea:	79 8d       	ldd	r23, Y+25	; 0x19
    17ec:	84 1b       	sub	r24, r20
    17ee:	95 0b       	sbc	r25, r21
    17f0:	a6 0b       	sbc	r26, r22
    17f2:	b7 0b       	sbc	r27, r23
	if (btw > remain)
    17f4:	a5 01       	movw	r20, r10
    17f6:	60 e0       	ldi	r22, 0x00	; 0
    17f8:	70 e0       	ldi	r23, 0x00	; 0
    17fa:	84 17       	cp	r24, r20
    17fc:	95 07       	cpc	r25, r21
    17fe:	a6 07       	cpc	r26, r22
    1800:	b7 07       	cpc	r27, r23
    1802:	08 f0       	brcs	.+2      	; 0x1806 <pf_write+0xa8>
    1804:	a0 c0       	rjmp	.+320    	; 0x1946 <pf_write+0x1e8>
		btw = (UINT)remain; /* Truncate btw by remaining bytes */
    1806:	5c 01       	movw	r10, r24
    1808:	9e c0       	rjmp	.+316    	; 0x1946 <pf_write+0x1e8>

	while (btw) {                                          /* Repeat until all data transferred */
		if ((UINT)fs->fptr % 512 == 0) {                   /* On the sector boundary? */
    180a:	8e 89       	ldd	r24, Y+22	; 0x16
    180c:	9f 89       	ldd	r25, Y+23	; 0x17
    180e:	a8 8d       	ldd	r26, Y+24	; 0x18
    1810:	b9 8d       	ldd	r27, Y+25	; 0x19
    1812:	9c 01       	movw	r18, r24
    1814:	31 70       	andi	r19, 0x01	; 1
    1816:	23 2b       	or	r18, r19
    1818:	09 f0       	breq	.+2      	; 0x181c <pf_write+0xbe>
    181a:	4e c0       	rjmp	.+156    	; 0x18b8 <pf_write+0x15a>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    181c:	1a 81       	ldd	r17, Y+2	; 0x02
    181e:	11 50       	subi	r17, 0x01	; 1
    1820:	ac 01       	movw	r20, r24
    1822:	bd 01       	movw	r22, r26
    1824:	03 2e       	mov	r0, r19
    1826:	39 e0       	ldi	r19, 0x09	; 9
    1828:	76 95       	lsr	r23
    182a:	67 95       	ror	r22
    182c:	57 95       	ror	r21
    182e:	47 95       	ror	r20
    1830:	3a 95       	dec	r19
    1832:	d1 f7       	brne	.-12     	; 0x1828 <pf_write+0xca>
    1834:	30 2d       	mov	r19, r0
    1836:	14 23       	and	r17, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1838:	d9 f4       	brne	.+54     	; 0x1870 <pf_write+0x112>
				if (fs->fptr == 0)                         /* On the top of the file? */
    183a:	89 2b       	or	r24, r25
    183c:	8a 2b       	or	r24, r26
    183e:	8b 2b       	or	r24, r27
    1840:	29 f4       	brne	.+10     	; 0x184c <pf_write+0xee>
					clst = fs->org_clust;
    1842:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1844:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1846:	88 a1       	ldd	r24, Y+32	; 0x20
    1848:	99 a1       	ldd	r25, Y+33	; 0x21
    184a:	06 c0       	rjmp	.+12     	; 0x1858 <pf_write+0xfa>
				else
					clst = get_fat(fs->curr_clust);
    184c:	6a a1       	ldd	r22, Y+34	; 0x22
    184e:	7b a1       	ldd	r23, Y+35	; 0x23
    1850:	8c a1       	ldd	r24, Y+36	; 0x24
    1852:	9d a1       	ldd	r25, Y+37	; 0x25
    1854:	0e 94 09 07 	call	0xe12	; 0xe12 <get_fat>
				if (clst <= 1)
    1858:	62 30       	cpi	r22, 0x02	; 2
    185a:	71 05       	cpc	r23, r1
    185c:	81 05       	cpc	r24, r1
    185e:	91 05       	cpc	r25, r1
    1860:	18 f4       	brcc	.+6      	; 0x1868 <pf_write+0x10a>
					ABORT(FR_DISK_ERR);
    1862:	19 82       	std	Y+1, r1	; 0x01
    1864:	81 e0       	ldi	r24, 0x01	; 1
    1866:	78 c0       	rjmp	.+240    	; 0x1958 <pf_write+0x1fa>
				fs->curr_clust = clst; /* Update current cluster */
    1868:	6a a3       	std	Y+34, r22	; 0x22
    186a:	7b a3       	std	Y+35, r23	; 0x23
    186c:	8c a3       	std	Y+36, r24	; 0x24
    186e:	9d a3       	std	Y+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    1870:	6a a1       	ldd	r22, Y+34	; 0x22
    1872:	7b a1       	ldd	r23, Y+35	; 0x23
    1874:	8c a1       	ldd	r24, Y+36	; 0x24
    1876:	9d a1       	ldd	r25, Y+37	; 0x25
    1878:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clust2sect>
			if (!sect)
    187c:	61 15       	cp	r22, r1
    187e:	71 05       	cpc	r23, r1
    1880:	81 05       	cpc	r24, r1
    1882:	91 05       	cpc	r25, r1
    1884:	19 f4       	brne	.+6      	; 0x188c <pf_write+0x12e>
				ABORT(FR_DISK_ERR);
    1886:	19 82       	std	Y+1, r1	; 0x01
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	66 c0       	rjmp	.+204    	; 0x1958 <pf_write+0x1fa>
			fs->dsect = sect + cs;
    188c:	ab 01       	movw	r20, r22
    188e:	bc 01       	movw	r22, r24
    1890:	41 0f       	add	r20, r17
    1892:	51 1d       	adc	r21, r1
    1894:	61 1d       	adc	r22, r1
    1896:	71 1d       	adc	r23, r1
    1898:	4e a3       	std	Y+38, r20	; 0x26
    189a:	5f a3       	std	Y+39, r21	; 0x27
    189c:	68 a7       	std	Y+40, r22	; 0x28
    189e:	79 a7       	std	Y+41, r23	; 0x29
			if (disk_writep(0, fs->dsect))
    18a0:	80 e0       	ldi	r24, 0x00	; 0
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    18a8:	88 23       	and	r24, r24
    18aa:	19 f0       	breq	.+6      	; 0x18b2 <pf_write+0x154>
				ABORT(FR_DISK_ERR); /* Initiate a sector write operation */
    18ac:	19 82       	std	Y+1, r1	; 0x01
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	53 c0       	rjmp	.+166    	; 0x1958 <pf_write+0x1fa>
			fs->flag |= FA__WIP;
    18b2:	89 81       	ldd	r24, Y+1	; 0x01
    18b4:	80 64       	ori	r24, 0x40	; 64
    18b6:	89 83       	std	Y+1, r24	; 0x01
		}
		wcnt = 512 - (UINT)fs->fptr % 512; /* Number of bytes to write to the sector */
    18b8:	8e 89       	ldd	r24, Y+22	; 0x16
    18ba:	9f 89       	ldd	r25, Y+23	; 0x17
    18bc:	a8 8d       	ldd	r26, Y+24	; 0x18
    18be:	b9 8d       	ldd	r27, Y+25	; 0x19
    18c0:	91 70       	andi	r25, 0x01	; 1
    18c2:	00 e0       	ldi	r16, 0x00	; 0
    18c4:	12 e0       	ldi	r17, 0x02	; 2
    18c6:	08 1b       	sub	r16, r24
    18c8:	19 0b       	sbc	r17, r25
		if (wcnt > btw)
    18ca:	a0 16       	cp	r10, r16
    18cc:	b1 06       	cpc	r11, r17
    18ce:	08 f4       	brcc	.+2      	; 0x18d2 <pf_write+0x174>
			wcnt = btw;
    18d0:	85 01       	movw	r16, r10
		if (disk_writep(p, wcnt))
    18d2:	28 01       	movw	r4, r16
    18d4:	61 2c       	mov	r6, r1
    18d6:	71 2c       	mov	r7, r1
    18d8:	b3 01       	movw	r22, r6
    18da:	a2 01       	movw	r20, r4
    18dc:	c7 01       	movw	r24, r14
    18de:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    18e2:	88 23       	and	r24, r24
    18e4:	19 f0       	breq	.+6      	; 0x18ec <pf_write+0x18e>
			ABORT(FR_DISK_ERR); /* Send data to the sector */
    18e6:	19 82       	std	Y+1, r1	; 0x01
    18e8:	81 e0       	ldi	r24, 0x01	; 1
    18ea:	36 c0       	rjmp	.+108    	; 0x1958 <pf_write+0x1fa>
		fs->fptr += wcnt;
    18ec:	8e 89       	ldd	r24, Y+22	; 0x16
    18ee:	9f 89       	ldd	r25, Y+23	; 0x17
    18f0:	a8 8d       	ldd	r26, Y+24	; 0x18
    18f2:	b9 8d       	ldd	r27, Y+25	; 0x19
    18f4:	48 0e       	add	r4, r24
    18f6:	59 1e       	adc	r5, r25
    18f8:	6a 1e       	adc	r6, r26
    18fa:	7b 1e       	adc	r7, r27
    18fc:	4e 8a       	std	Y+22, r4	; 0x16
    18fe:	5f 8a       	std	Y+23, r5	; 0x17
    1900:	68 8e       	std	Y+24, r6	; 0x18
    1902:	79 8e       	std	Y+25, r7	; 0x19
		p += wcnt; /* Update pointers and counters */
    1904:	e0 0e       	add	r14, r16
    1906:	f1 1e       	adc	r15, r17
		btw -= wcnt;
    1908:	a0 1a       	sub	r10, r16
    190a:	b1 0a       	sbc	r11, r17
		*bw += wcnt;
    190c:	f6 01       	movw	r30, r12
    190e:	80 81       	ld	r24, Z
    1910:	91 81       	ldd	r25, Z+1	; 0x01
    1912:	08 0f       	add	r16, r24
    1914:	19 1f       	adc	r17, r25
    1916:	11 83       	std	Z+1, r17	; 0x01
    1918:	00 83       	st	Z, r16
		if ((UINT)fs->fptr % 512 == 0) {
    191a:	8e 89       	ldd	r24, Y+22	; 0x16
    191c:	9f 89       	ldd	r25, Y+23	; 0x17
    191e:	a8 8d       	ldd	r26, Y+24	; 0x18
    1920:	b9 8d       	ldd	r27, Y+25	; 0x19
    1922:	91 70       	andi	r25, 0x01	; 1
    1924:	89 2b       	or	r24, r25
    1926:	79 f4       	brne	.+30     	; 0x1946 <pf_write+0x1e8>
			if (disk_writep(0, 0))
    1928:	40 e0       	ldi	r20, 0x00	; 0
    192a:	50 e0       	ldi	r21, 0x00	; 0
    192c:	ba 01       	movw	r22, r20
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	0e 94 a3 03 	call	0x746	; 0x746 <disk_writep>
    1936:	88 23       	and	r24, r24
    1938:	19 f0       	breq	.+6      	; 0x1940 <pf_write+0x1e2>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
    193a:	19 82       	std	Y+1, r1	; 0x01
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	0c c0       	rjmp	.+24     	; 0x1958 <pf_write+0x1fa>
			fs->flag &= ~FA__WIP;
    1940:	89 81       	ldd	r24, Y+1	; 0x01
    1942:	8f 7b       	andi	r24, 0xBF	; 191
    1944:	89 83       	std	Y+1, r24	; 0x01
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain)
		btw = (UINT)remain; /* Truncate btw by remaining bytes */

	while (btw) {                                          /* Repeat until all data transferred */
    1946:	a1 14       	cp	r10, r1
    1948:	b1 04       	cpc	r11, r1
    194a:	09 f0       	breq	.+2      	; 0x194e <pf_write+0x1f0>
    194c:	5e cf       	rjmp	.-324    	; 0x180a <pf_write+0xac>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    194e:	80 e0       	ldi	r24, 0x00	; 0
    1950:	03 c0       	rjmp	.+6      	; 0x1958 <pf_write+0x1fa>
	UINT        wcnt;
	FATFS *     fs = FatFs;

	*bw = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1952:	85 e0       	ldi	r24, 0x05	; 5
    1954:	01 c0       	rjmp	.+2      	; 0x1958 <pf_write+0x1fa>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1956:	84 e0       	ldi	r24, 0x04	; 4
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
}
    1958:	df 91       	pop	r29
    195a:	cf 91       	pop	r28
    195c:	1f 91       	pop	r17
    195e:	0f 91       	pop	r16
    1960:	ff 90       	pop	r15
    1962:	ef 90       	pop	r14
    1964:	df 90       	pop	r13
    1966:	cf 90       	pop	r12
    1968:	bf 90       	pop	r11
    196a:	af 90       	pop	r10
    196c:	7f 90       	pop	r7
    196e:	6f 90       	pop	r6
    1970:	5f 90       	pop	r5
    1972:	4f 90       	pop	r4
    1974:	08 95       	ret

00001976 <pf_lseek>:
/*-----------------------------------------------------------------------*/
#if _USE_LSEEK

FRESULT pf_lseek(DWORD ofs /* File pointer from top of file */
)
{
    1976:	4f 92       	push	r4
    1978:	5f 92       	push	r5
    197a:	6f 92       	push	r6
    197c:	7f 92       	push	r7
    197e:	8f 92       	push	r8
    1980:	9f 92       	push	r9
    1982:	af 92       	push	r10
    1984:	bf 92       	push	r11
    1986:	cf 92       	push	r12
    1988:	df 92       	push	r13
    198a:	ef 92       	push	r14
    198c:	ff 92       	push	r15
    198e:	cf 93       	push	r28
    1990:	df 93       	push	r29
    1992:	00 d0       	rcall	.+0      	; 0x1994 <pf_lseek+0x1e>
    1994:	00 d0       	rcall	.+0      	; 0x1996 <pf_lseek+0x20>
    1996:	00 d0       	rcall	.+0      	; 0x1998 <pf_lseek+0x22>
    1998:	cd b7       	in	r28, 0x3d	; 61
    199a:	de b7       	in	r29, 0x3e	; 62
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;
    199c:	20 91 d1 03 	lds	r18, 0x03D1	; 0x8003d1 <FatFs>
    19a0:	30 91 d2 03 	lds	r19, 0x03D2	; 0x8003d2 <FatFs+0x1>
    19a4:	3e 83       	std	Y+6, r19	; 0x06
    19a6:	2d 83       	std	Y+5, r18	; 0x05

	if (!fs)
    19a8:	21 15       	cp	r18, r1
    19aa:	31 05       	cpc	r19, r1
    19ac:	09 f4       	brne	.+2      	; 0x19b0 <pf_lseek+0x3a>
    19ae:	f4 c0       	rjmp	.+488    	; 0x1b98 <pf_lseek+0x222>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    19b0:	d9 01       	movw	r26, r18
    19b2:	11 96       	adiw	r26, 0x01	; 1
    19b4:	2c 91       	ld	r18, X
    19b6:	11 97       	sbiw	r26, 0x01	; 1
    19b8:	20 ff       	sbrs	r18, 0
    19ba:	f0 c0       	rjmp	.+480    	; 0x1b9c <pf_lseek+0x226>
		return FR_NOT_OPENED;

	if (ofs > fs->fsize)
    19bc:	5a 96       	adiw	r26, 0x1a	; 26
    19be:	cd 90       	ld	r12, X+
    19c0:	dd 90       	ld	r13, X+
    19c2:	ed 90       	ld	r14, X+
    19c4:	fc 90       	ld	r15, X
    19c6:	5d 97       	sbiw	r26, 0x1d	; 29
    19c8:	c6 16       	cp	r12, r22
    19ca:	d7 06       	cpc	r13, r23
    19cc:	e8 06       	cpc	r14, r24
    19ce:	f9 06       	cpc	r15, r25
    19d0:	10 f0       	brcs	.+4      	; 0x19d6 <pf_lseek+0x60>
    19d2:	6b 01       	movw	r12, r22
    19d4:	7c 01       	movw	r14, r24
		ofs = fs->fsize; /* Clip offset with the file size */
	ifptr    = fs->fptr;
    19d6:	ed 81       	ldd	r30, Y+5	; 0x05
    19d8:	fe 81       	ldd	r31, Y+6	; 0x06
    19da:	46 88       	ldd	r4, Z+22	; 0x16
    19dc:	57 88       	ldd	r5, Z+23	; 0x17
    19de:	60 8c       	ldd	r6, Z+24	; 0x18
    19e0:	71 8c       	ldd	r7, Z+25	; 0x19
	fs->fptr = 0;
    19e2:	16 8a       	std	Z+22, r1	; 0x16
    19e4:	17 8a       	std	Z+23, r1	; 0x17
    19e6:	10 8e       	std	Z+24, r1	; 0x18
    19e8:	11 8e       	std	Z+25, r1	; 0x19
	if (ofs > 0) {
    19ea:	c1 14       	cp	r12, r1
    19ec:	d1 04       	cpc	r13, r1
    19ee:	e1 04       	cpc	r14, r1
    19f0:	f1 04       	cpc	r15, r1
    19f2:	09 f4       	brne	.+2      	; 0x19f6 <pf_lseek+0x80>
    19f4:	d5 c0       	rjmp	.+426    	; 0x1ba0 <pf_lseek+0x22a>
		bcs = (DWORD)fs->csize * 512;                            /* Cluster size (byte) */
    19f6:	82 80       	ldd	r8, Z+2	; 0x02
    19f8:	91 2c       	mov	r9, r1
    19fa:	a1 2c       	mov	r10, r1
    19fc:	b1 2c       	mov	r11, r1
    19fe:	07 2e       	mov	r0, r23
    1a00:	79 e0       	ldi	r23, 0x09	; 9
    1a02:	88 0c       	add	r8, r8
    1a04:	99 1c       	adc	r9, r9
    1a06:	aa 1c       	adc	r10, r10
    1a08:	bb 1c       	adc	r11, r11
    1a0a:	7a 95       	dec	r23
    1a0c:	d1 f7       	brne	.-12     	; 0x1a02 <pf_lseek+0x8c>
    1a0e:	70 2d       	mov	r23, r0
		if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
    1a10:	41 14       	cp	r4, r1
    1a12:	51 04       	cpc	r5, r1
    1a14:	61 04       	cpc	r6, r1
    1a16:	71 04       	cpc	r7, r1
    1a18:	09 f4       	brne	.+2      	; 0x1a1c <pf_lseek+0xa6>
    1a1a:	40 c0       	rjmp	.+128    	; 0x1a9c <pf_lseek+0x126>
    1a1c:	c7 01       	movw	r24, r14
    1a1e:	b6 01       	movw	r22, r12
    1a20:	61 50       	subi	r22, 0x01	; 1
    1a22:	71 09       	sbc	r23, r1
    1a24:	81 09       	sbc	r24, r1
    1a26:	91 09       	sbc	r25, r1
    1a28:	a5 01       	movw	r20, r10
    1a2a:	94 01       	movw	r18, r8
    1a2c:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__udivmodsi4>
    1a30:	29 83       	std	Y+1, r18	; 0x01
    1a32:	3a 83       	std	Y+2, r19	; 0x02
    1a34:	4b 83       	std	Y+3, r20	; 0x03
    1a36:	5c 83       	std	Y+4, r21	; 0x04
    1a38:	b1 e0       	ldi	r27, 0x01	; 1
    1a3a:	4b 1a       	sub	r4, r27
    1a3c:	51 08       	sbc	r5, r1
    1a3e:	61 08       	sbc	r6, r1
    1a40:	71 08       	sbc	r7, r1
    1a42:	c3 01       	movw	r24, r6
    1a44:	b2 01       	movw	r22, r4
    1a46:	a5 01       	movw	r20, r10
    1a48:	94 01       	movw	r18, r8
    1a4a:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__udivmodsi4>
    1a4e:	89 81       	ldd	r24, Y+1	; 0x01
    1a50:	9a 81       	ldd	r25, Y+2	; 0x02
    1a52:	ab 81       	ldd	r26, Y+3	; 0x03
    1a54:	bc 81       	ldd	r27, Y+4	; 0x04
    1a56:	82 17       	cp	r24, r18
    1a58:	93 07       	cpc	r25, r19
    1a5a:	a4 07       	cpc	r26, r20
    1a5c:	b5 07       	cpc	r27, r21
    1a5e:	f0 f0       	brcs	.+60     	; 0x1a9c <pf_lseek+0x126>
			fs->fptr = (ifptr - 1) & ~(bcs - 1);                 /* start from the current cluster */
    1a60:	88 27       	eor	r24, r24
    1a62:	99 27       	eor	r25, r25
    1a64:	dc 01       	movw	r26, r24
    1a66:	88 19       	sub	r24, r8
    1a68:	99 09       	sbc	r25, r9
    1a6a:	aa 09       	sbc	r26, r10
    1a6c:	bb 09       	sbc	r27, r11
    1a6e:	48 22       	and	r4, r24
    1a70:	59 22       	and	r5, r25
    1a72:	6a 22       	and	r6, r26
    1a74:	7b 22       	and	r7, r27
    1a76:	ad 81       	ldd	r26, Y+5	; 0x05
    1a78:	be 81       	ldd	r27, Y+6	; 0x06
    1a7a:	56 96       	adiw	r26, 0x16	; 22
    1a7c:	4d 92       	st	X+, r4
    1a7e:	5d 92       	st	X+, r5
    1a80:	6d 92       	st	X+, r6
    1a82:	7c 92       	st	X, r7
    1a84:	59 97       	sbiw	r26, 0x19	; 25
			ofs -= fs->fptr;
    1a86:	c4 18       	sub	r12, r4
    1a88:	d5 08       	sbc	r13, r5
    1a8a:	e6 08       	sbc	r14, r6
    1a8c:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    1a8e:	92 96       	adiw	r26, 0x22	; 34
    1a90:	6d 91       	ld	r22, X+
    1a92:	7d 91       	ld	r23, X+
    1a94:	8d 91       	ld	r24, X+
    1a96:	9c 91       	ld	r25, X
    1a98:	95 97       	sbiw	r26, 0x25	; 37
    1a9a:	39 c0       	rjmp	.+114    	; 0x1b0e <pf_lseek+0x198>
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
    1a9c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a9e:	fe 81       	ldd	r31, Y+6	; 0x06
    1aa0:	66 8d       	ldd	r22, Z+30	; 0x1e
    1aa2:	77 8d       	ldd	r23, Z+31	; 0x1f
    1aa4:	80 a1       	ldd	r24, Z+32	; 0x20
    1aa6:	91 a1       	ldd	r25, Z+33	; 0x21
			fs->curr_clust = clst;
    1aa8:	62 a3       	std	Z+34, r22	; 0x22
    1aaa:	73 a3       	std	Z+35, r23	; 0x23
    1aac:	84 a3       	std	Z+36, r24	; 0x24
    1aae:	95 a3       	std	Z+37, r25	; 0x25
    1ab0:	2e c0       	rjmp	.+92     	; 0x1b0e <pf_lseek+0x198>
		}
		while (ofs > bcs) {       /* Cluster following loop */
			clst = get_fat(clst); /* Follow cluster chain */
    1ab2:	0e 94 09 07 	call	0xe12	; 0xe12 <get_fat>
			if (clst <= 1 || clst >= fs->n_fatent)
    1ab6:	62 30       	cpi	r22, 0x02	; 2
    1ab8:	71 05       	cpc	r23, r1
    1aba:	81 05       	cpc	r24, r1
    1abc:	91 05       	cpc	r25, r1
    1abe:	58 f0       	brcs	.+22     	; 0x1ad6 <pf_lseek+0x160>
    1ac0:	ed 81       	ldd	r30, Y+5	; 0x05
    1ac2:	fe 81       	ldd	r31, Y+6	; 0x06
    1ac4:	46 80       	ldd	r4, Z+6	; 0x06
    1ac6:	57 80       	ldd	r5, Z+7	; 0x07
    1ac8:	60 84       	ldd	r6, Z+8	; 0x08
    1aca:	71 84       	ldd	r7, Z+9	; 0x09
    1acc:	64 15       	cp	r22, r4
    1ace:	75 05       	cpc	r23, r5
    1ad0:	86 05       	cpc	r24, r6
    1ad2:	97 05       	cpc	r25, r7
    1ad4:	30 f0       	brcs	.+12     	; 0x1ae2 <pf_lseek+0x16c>
				ABORT(FR_DISK_ERR);
    1ad6:	ad 81       	ldd	r26, Y+5	; 0x05
    1ad8:	be 81       	ldd	r27, Y+6	; 0x06
    1ada:	11 96       	adiw	r26, 0x01	; 1
    1adc:	1c 92       	st	X, r1
    1ade:	81 e0       	ldi	r24, 0x01	; 1
    1ae0:	60 c0       	rjmp	.+192    	; 0x1ba2 <pf_lseek+0x22c>
			fs->curr_clust = clst;
    1ae2:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae4:	fe 81       	ldd	r31, Y+6	; 0x06
    1ae6:	62 a3       	std	Z+34, r22	; 0x22
    1ae8:	73 a3       	std	Z+35, r23	; 0x23
    1aea:	84 a3       	std	Z+36, r24	; 0x24
    1aec:	95 a3       	std	Z+37, r25	; 0x25
			fs->fptr += bcs;
    1aee:	46 88       	ldd	r4, Z+22	; 0x16
    1af0:	57 88       	ldd	r5, Z+23	; 0x17
    1af2:	60 8c       	ldd	r6, Z+24	; 0x18
    1af4:	71 8c       	ldd	r7, Z+25	; 0x19
    1af6:	48 0c       	add	r4, r8
    1af8:	59 1c       	adc	r5, r9
    1afa:	6a 1c       	adc	r6, r10
    1afc:	7b 1c       	adc	r7, r11
    1afe:	46 8a       	std	Z+22, r4	; 0x16
    1b00:	57 8a       	std	Z+23, r5	; 0x17
    1b02:	60 8e       	std	Z+24, r6	; 0x18
    1b04:	71 8e       	std	Z+25, r7	; 0x19
			ofs -= bcs;
    1b06:	c8 18       	sub	r12, r8
    1b08:	d9 08       	sbc	r13, r9
    1b0a:	ea 08       	sbc	r14, r10
    1b0c:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {       /* Cluster following loop */
    1b0e:	8c 14       	cp	r8, r12
    1b10:	9d 04       	cpc	r9, r13
    1b12:	ae 04       	cpc	r10, r14
    1b14:	bf 04       	cpc	r11, r15
    1b16:	68 f2       	brcs	.-102    	; 0x1ab2 <pf_lseek+0x13c>
				ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    1b18:	ed 81       	ldd	r30, Y+5	; 0x05
    1b1a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b1c:	86 88       	ldd	r8, Z+22	; 0x16
    1b1e:	97 88       	ldd	r9, Z+23	; 0x17
    1b20:	a0 8c       	ldd	r10, Z+24	; 0x18
    1b22:	b1 8c       	ldd	r11, Z+25	; 0x19
    1b24:	c8 0c       	add	r12, r8
    1b26:	d9 1c       	adc	r13, r9
    1b28:	ea 1c       	adc	r14, r10
    1b2a:	fb 1c       	adc	r15, r11
    1b2c:	c6 8a       	std	Z+22, r12	; 0x16
    1b2e:	d7 8a       	std	Z+23, r13	; 0x17
    1b30:	e0 8e       	std	Z+24, r14	; 0x18
    1b32:	f1 8e       	std	Z+25, r15	; 0x19
		sect = clust2sect(clst); /* Current sector */
    1b34:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <clust2sect>
		if (!sect)
    1b38:	61 15       	cp	r22, r1
    1b3a:	71 05       	cpc	r23, r1
    1b3c:	81 05       	cpc	r24, r1
    1b3e:	91 05       	cpc	r25, r1
    1b40:	29 f4       	brne	.+10     	; 0x1b4c <pf_lseek+0x1d6>
			ABORT(FR_DISK_ERR);
    1b42:	ed 81       	ldd	r30, Y+5	; 0x05
    1b44:	fe 81       	ldd	r31, Y+6	; 0x06
    1b46:	11 82       	std	Z+1, r1	; 0x01
    1b48:	81 e0       	ldi	r24, 0x01	; 1
    1b4a:	2b c0       	rjmp	.+86     	; 0x1ba2 <pf_lseek+0x22c>
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    1b4c:	0b 2e       	mov	r0, r27
    1b4e:	b9 e0       	ldi	r27, 0x09	; 9
    1b50:	f6 94       	lsr	r15
    1b52:	e7 94       	ror	r14
    1b54:	d7 94       	ror	r13
    1b56:	c7 94       	ror	r12
    1b58:	ba 95       	dec	r27
    1b5a:	d1 f7       	brne	.-12     	; 0x1b50 <pf_lseek+0x1da>
    1b5c:	b0 2d       	mov	r27, r0
    1b5e:	ad 81       	ldd	r26, Y+5	; 0x05
    1b60:	be 81       	ldd	r27, Y+6	; 0x06
    1b62:	12 96       	adiw	r26, 0x02	; 2
    1b64:	2c 91       	ld	r18, X
    1b66:	30 e0       	ldi	r19, 0x00	; 0
    1b68:	21 50       	subi	r18, 0x01	; 1
    1b6a:	31 09       	sbc	r19, r1
    1b6c:	49 01       	movw	r8, r18
    1b6e:	33 0f       	add	r19, r19
    1b70:	aa 08       	sbc	r10, r10
    1b72:	bb 08       	sbc	r11, r11
    1b74:	c8 20       	and	r12, r8
    1b76:	d9 20       	and	r13, r9
    1b78:	ea 20       	and	r14, r10
    1b7a:	fb 20       	and	r15, r11
    1b7c:	dc 01       	movw	r26, r24
    1b7e:	cb 01       	movw	r24, r22
    1b80:	8c 0d       	add	r24, r12
    1b82:	9d 1d       	adc	r25, r13
    1b84:	ae 1d       	adc	r26, r14
    1b86:	bf 1d       	adc	r27, r15
    1b88:	ed 81       	ldd	r30, Y+5	; 0x05
    1b8a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b8c:	86 a3       	std	Z+38, r24	; 0x26
    1b8e:	97 a3       	std	Z+39, r25	; 0x27
    1b90:	a0 a7       	std	Z+40, r26	; 0x28
    1b92:	b1 a7       	std	Z+41, r27	; 0x29
	}

	return FR_OK;
    1b94:	80 e0       	ldi	r24, 0x00	; 0
    1b96:	05 c0       	rjmp	.+10     	; 0x1ba2 <pf_lseek+0x22c>
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1b98:	85 e0       	ldi	r24, 0x05	; 5
    1b9a:	03 c0       	rjmp	.+6      	; 0x1ba2 <pf_lseek+0x22c>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1b9c:	84 e0       	ldi	r24, 0x04	; 4
    1b9e:	01 c0       	rjmp	.+2      	; 0x1ba2 <pf_lseek+0x22c>
		if (!sect)
			ABORT(FR_DISK_ERR);
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
    1ba0:	80 e0       	ldi	r24, 0x00	; 0
}
    1ba2:	26 96       	adiw	r28, 0x06	; 6
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	f8 94       	cli
    1ba8:	de bf       	out	0x3e, r29	; 62
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	cd bf       	out	0x3d, r28	; 61
    1bae:	df 91       	pop	r29
    1bb0:	cf 91       	pop	r28
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	df 90       	pop	r13
    1bb8:	cf 90       	pop	r12
    1bba:	bf 90       	pop	r11
    1bbc:	af 90       	pop	r10
    1bbe:	9f 90       	pop	r9
    1bc0:	8f 90       	pop	r8
    1bc2:	7f 90       	pop	r7
    1bc4:	6f 90       	pop	r6
    1bc6:	5f 90       	pop	r5
    1bc8:	4f 90       	pop	r4
    1bca:	08 95       	ret

00001bcc <__divmodhi4>:
    1bcc:	97 fb       	bst	r25, 7
    1bce:	07 2e       	mov	r0, r23
    1bd0:	16 f4       	brtc	.+4      	; 0x1bd6 <__divmodhi4+0xa>
    1bd2:	00 94       	com	r0
    1bd4:	07 d0       	rcall	.+14     	; 0x1be4 <__divmodhi4_neg1>
    1bd6:	77 fd       	sbrc	r23, 7
    1bd8:	09 d0       	rcall	.+18     	; 0x1bec <__divmodhi4_neg2>
    1bda:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <__udivmodhi4>
    1bde:	07 fc       	sbrc	r0, 7
    1be0:	05 d0       	rcall	.+10     	; 0x1bec <__divmodhi4_neg2>
    1be2:	3e f4       	brtc	.+14     	; 0x1bf2 <__divmodhi4_exit>

00001be4 <__divmodhi4_neg1>:
    1be4:	90 95       	com	r25
    1be6:	81 95       	neg	r24
    1be8:	9f 4f       	sbci	r25, 0xFF	; 255
    1bea:	08 95       	ret

00001bec <__divmodhi4_neg2>:
    1bec:	70 95       	com	r23
    1bee:	61 95       	neg	r22
    1bf0:	7f 4f       	sbci	r23, 0xFF	; 255

00001bf2 <__divmodhi4_exit>:
    1bf2:	08 95       	ret

00001bf4 <__udivmodsi4>:
    1bf4:	a1 e2       	ldi	r26, 0x21	; 33
    1bf6:	1a 2e       	mov	r1, r26
    1bf8:	aa 1b       	sub	r26, r26
    1bfa:	bb 1b       	sub	r27, r27
    1bfc:	fd 01       	movw	r30, r26
    1bfe:	0d c0       	rjmp	.+26     	; 0x1c1a <__udivmodsi4_ep>

00001c00 <__udivmodsi4_loop>:
    1c00:	aa 1f       	adc	r26, r26
    1c02:	bb 1f       	adc	r27, r27
    1c04:	ee 1f       	adc	r30, r30
    1c06:	ff 1f       	adc	r31, r31
    1c08:	a2 17       	cp	r26, r18
    1c0a:	b3 07       	cpc	r27, r19
    1c0c:	e4 07       	cpc	r30, r20
    1c0e:	f5 07       	cpc	r31, r21
    1c10:	20 f0       	brcs	.+8      	; 0x1c1a <__udivmodsi4_ep>
    1c12:	a2 1b       	sub	r26, r18
    1c14:	b3 0b       	sbc	r27, r19
    1c16:	e4 0b       	sbc	r30, r20
    1c18:	f5 0b       	sbc	r31, r21

00001c1a <__udivmodsi4_ep>:
    1c1a:	66 1f       	adc	r22, r22
    1c1c:	77 1f       	adc	r23, r23
    1c1e:	88 1f       	adc	r24, r24
    1c20:	99 1f       	adc	r25, r25
    1c22:	1a 94       	dec	r1
    1c24:	69 f7       	brne	.-38     	; 0x1c00 <__udivmodsi4_loop>
    1c26:	60 95       	com	r22
    1c28:	70 95       	com	r23
    1c2a:	80 95       	com	r24
    1c2c:	90 95       	com	r25
    1c2e:	9b 01       	movw	r18, r22
    1c30:	ac 01       	movw	r20, r24
    1c32:	bd 01       	movw	r22, r26
    1c34:	cf 01       	movw	r24, r30
    1c36:	08 95       	ret

00001c38 <__muluhisi3>:
    1c38:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__umulhisi3>
    1c3c:	a5 9f       	mul	r26, r21
    1c3e:	90 0d       	add	r25, r0
    1c40:	b4 9f       	mul	r27, r20
    1c42:	90 0d       	add	r25, r0
    1c44:	a4 9f       	mul	r26, r20
    1c46:	80 0d       	add	r24, r0
    1c48:	91 1d       	adc	r25, r1
    1c4a:	11 24       	eor	r1, r1
    1c4c:	08 95       	ret

00001c4e <__udivmodhi4>:
    1c4e:	aa 1b       	sub	r26, r26
    1c50:	bb 1b       	sub	r27, r27
    1c52:	51 e1       	ldi	r21, 0x11	; 17
    1c54:	07 c0       	rjmp	.+14     	; 0x1c64 <__udivmodhi4_ep>

00001c56 <__udivmodhi4_loop>:
    1c56:	aa 1f       	adc	r26, r26
    1c58:	bb 1f       	adc	r27, r27
    1c5a:	a6 17       	cp	r26, r22
    1c5c:	b7 07       	cpc	r27, r23
    1c5e:	10 f0       	brcs	.+4      	; 0x1c64 <__udivmodhi4_ep>
    1c60:	a6 1b       	sub	r26, r22
    1c62:	b7 0b       	sbc	r27, r23

00001c64 <__udivmodhi4_ep>:
    1c64:	88 1f       	adc	r24, r24
    1c66:	99 1f       	adc	r25, r25
    1c68:	5a 95       	dec	r21
    1c6a:	a9 f7       	brne	.-22     	; 0x1c56 <__udivmodhi4_loop>
    1c6c:	80 95       	com	r24
    1c6e:	90 95       	com	r25
    1c70:	bc 01       	movw	r22, r24
    1c72:	cd 01       	movw	r24, r26
    1c74:	08 95       	ret

00001c76 <__umulhisi3>:
    1c76:	a2 9f       	mul	r26, r18
    1c78:	b0 01       	movw	r22, r0
    1c7a:	b3 9f       	mul	r27, r19
    1c7c:	c0 01       	movw	r24, r0
    1c7e:	a3 9f       	mul	r26, r19
    1c80:	70 0d       	add	r23, r0
    1c82:	81 1d       	adc	r24, r1
    1c84:	11 24       	eor	r1, r1
    1c86:	91 1d       	adc	r25, r1
    1c88:	b2 9f       	mul	r27, r18
    1c8a:	70 0d       	add	r23, r0
    1c8c:	81 1d       	adc	r24, r1
    1c8e:	11 24       	eor	r1, r1
    1c90:	91 1d       	adc	r25, r1
    1c92:	08 95       	ret

00001c94 <sprintf>:
    1c94:	ae e0       	ldi	r26, 0x0E	; 14
    1c96:	b0 e0       	ldi	r27, 0x00	; 0
    1c98:	e0 e5       	ldi	r30, 0x50	; 80
    1c9a:	fe e0       	ldi	r31, 0x0E	; 14
    1c9c:	0c 94 0b 11 	jmp	0x2216	; 0x2216 <__prologue_saves__+0x1c>
    1ca0:	0d 89       	ldd	r16, Y+21	; 0x15
    1ca2:	1e 89       	ldd	r17, Y+22	; 0x16
    1ca4:	86 e0       	ldi	r24, 0x06	; 6
    1ca6:	8c 83       	std	Y+4, r24	; 0x04
    1ca8:	1a 83       	std	Y+2, r17	; 0x02
    1caa:	09 83       	std	Y+1, r16	; 0x01
    1cac:	8f ef       	ldi	r24, 0xFF	; 255
    1cae:	9f e7       	ldi	r25, 0x7F	; 127
    1cb0:	9e 83       	std	Y+6, r25	; 0x06
    1cb2:	8d 83       	std	Y+5, r24	; 0x05
    1cb4:	ae 01       	movw	r20, r28
    1cb6:	47 5e       	subi	r20, 0xE7	; 231
    1cb8:	5f 4f       	sbci	r21, 0xFF	; 255
    1cba:	6f 89       	ldd	r22, Y+23	; 0x17
    1cbc:	78 8d       	ldd	r23, Y+24	; 0x18
    1cbe:	ce 01       	movw	r24, r28
    1cc0:	01 96       	adiw	r24, 0x01	; 1
    1cc2:	0e 94 6c 0e 	call	0x1cd8	; 0x1cd8 <vfprintf>
    1cc6:	ef 81       	ldd	r30, Y+7	; 0x07
    1cc8:	f8 85       	ldd	r31, Y+8	; 0x08
    1cca:	e0 0f       	add	r30, r16
    1ccc:	f1 1f       	adc	r31, r17
    1cce:	10 82       	st	Z, r1
    1cd0:	2e 96       	adiw	r28, 0x0e	; 14
    1cd2:	e4 e0       	ldi	r30, 0x04	; 4
    1cd4:	0c 94 27 11 	jmp	0x224e	; 0x224e <__epilogue_restores__+0x1c>

00001cd8 <vfprintf>:
    1cd8:	ab e0       	ldi	r26, 0x0B	; 11
    1cda:	b0 e0       	ldi	r27, 0x00	; 0
    1cdc:	e2 e7       	ldi	r30, 0x72	; 114
    1cde:	fe e0       	ldi	r31, 0x0E	; 14
    1ce0:	0c 94 fd 10 	jmp	0x21fa	; 0x21fa <__prologue_saves__>
    1ce4:	6c 01       	movw	r12, r24
    1ce6:	7b 01       	movw	r14, r22
    1ce8:	8a 01       	movw	r16, r20
    1cea:	fc 01       	movw	r30, r24
    1cec:	17 82       	std	Z+7, r1	; 0x07
    1cee:	16 82       	std	Z+6, r1	; 0x06
    1cf0:	83 81       	ldd	r24, Z+3	; 0x03
    1cf2:	81 ff       	sbrs	r24, 1
    1cf4:	cc c1       	rjmp	.+920    	; 0x208e <vfprintf+0x3b6>
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	01 96       	adiw	r24, 0x01	; 1
    1cfa:	3c 01       	movw	r6, r24
    1cfc:	f6 01       	movw	r30, r12
    1cfe:	93 81       	ldd	r25, Z+3	; 0x03
    1d00:	f7 01       	movw	r30, r14
    1d02:	93 fd       	sbrc	r25, 3
    1d04:	85 91       	lpm	r24, Z+
    1d06:	93 ff       	sbrs	r25, 3
    1d08:	81 91       	ld	r24, Z+
    1d0a:	7f 01       	movw	r14, r30
    1d0c:	88 23       	and	r24, r24
    1d0e:	09 f4       	brne	.+2      	; 0x1d12 <vfprintf+0x3a>
    1d10:	ba c1       	rjmp	.+884    	; 0x2086 <vfprintf+0x3ae>
    1d12:	85 32       	cpi	r24, 0x25	; 37
    1d14:	39 f4       	brne	.+14     	; 0x1d24 <vfprintf+0x4c>
    1d16:	93 fd       	sbrc	r25, 3
    1d18:	85 91       	lpm	r24, Z+
    1d1a:	93 ff       	sbrs	r25, 3
    1d1c:	81 91       	ld	r24, Z+
    1d1e:	7f 01       	movw	r14, r30
    1d20:	85 32       	cpi	r24, 0x25	; 37
    1d22:	29 f4       	brne	.+10     	; 0x1d2e <vfprintf+0x56>
    1d24:	b6 01       	movw	r22, r12
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    1d2c:	e7 cf       	rjmp	.-50     	; 0x1cfc <vfprintf+0x24>
    1d2e:	91 2c       	mov	r9, r1
    1d30:	21 2c       	mov	r2, r1
    1d32:	31 2c       	mov	r3, r1
    1d34:	ff e1       	ldi	r31, 0x1F	; 31
    1d36:	f3 15       	cp	r31, r3
    1d38:	d8 f0       	brcs	.+54     	; 0x1d70 <vfprintf+0x98>
    1d3a:	8b 32       	cpi	r24, 0x2B	; 43
    1d3c:	79 f0       	breq	.+30     	; 0x1d5c <vfprintf+0x84>
    1d3e:	38 f4       	brcc	.+14     	; 0x1d4e <vfprintf+0x76>
    1d40:	80 32       	cpi	r24, 0x20	; 32
    1d42:	79 f0       	breq	.+30     	; 0x1d62 <vfprintf+0x8a>
    1d44:	83 32       	cpi	r24, 0x23	; 35
    1d46:	a1 f4       	brne	.+40     	; 0x1d70 <vfprintf+0x98>
    1d48:	23 2d       	mov	r18, r3
    1d4a:	20 61       	ori	r18, 0x10	; 16
    1d4c:	1d c0       	rjmp	.+58     	; 0x1d88 <vfprintf+0xb0>
    1d4e:	8d 32       	cpi	r24, 0x2D	; 45
    1d50:	61 f0       	breq	.+24     	; 0x1d6a <vfprintf+0x92>
    1d52:	80 33       	cpi	r24, 0x30	; 48
    1d54:	69 f4       	brne	.+26     	; 0x1d70 <vfprintf+0x98>
    1d56:	23 2d       	mov	r18, r3
    1d58:	21 60       	ori	r18, 0x01	; 1
    1d5a:	16 c0       	rjmp	.+44     	; 0x1d88 <vfprintf+0xb0>
    1d5c:	83 2d       	mov	r24, r3
    1d5e:	82 60       	ori	r24, 0x02	; 2
    1d60:	38 2e       	mov	r3, r24
    1d62:	e3 2d       	mov	r30, r3
    1d64:	e4 60       	ori	r30, 0x04	; 4
    1d66:	3e 2e       	mov	r3, r30
    1d68:	2a c0       	rjmp	.+84     	; 0x1dbe <vfprintf+0xe6>
    1d6a:	f3 2d       	mov	r31, r3
    1d6c:	f8 60       	ori	r31, 0x08	; 8
    1d6e:	1d c0       	rjmp	.+58     	; 0x1daa <vfprintf+0xd2>
    1d70:	37 fc       	sbrc	r3, 7
    1d72:	2d c0       	rjmp	.+90     	; 0x1dce <vfprintf+0xf6>
    1d74:	20 ed       	ldi	r18, 0xD0	; 208
    1d76:	28 0f       	add	r18, r24
    1d78:	2a 30       	cpi	r18, 0x0A	; 10
    1d7a:	40 f0       	brcs	.+16     	; 0x1d8c <vfprintf+0xb4>
    1d7c:	8e 32       	cpi	r24, 0x2E	; 46
    1d7e:	b9 f4       	brne	.+46     	; 0x1dae <vfprintf+0xd6>
    1d80:	36 fc       	sbrc	r3, 6
    1d82:	81 c1       	rjmp	.+770    	; 0x2086 <vfprintf+0x3ae>
    1d84:	23 2d       	mov	r18, r3
    1d86:	20 64       	ori	r18, 0x40	; 64
    1d88:	32 2e       	mov	r3, r18
    1d8a:	19 c0       	rjmp	.+50     	; 0x1dbe <vfprintf+0xe6>
    1d8c:	36 fe       	sbrs	r3, 6
    1d8e:	06 c0       	rjmp	.+12     	; 0x1d9c <vfprintf+0xc4>
    1d90:	8a e0       	ldi	r24, 0x0A	; 10
    1d92:	98 9e       	mul	r9, r24
    1d94:	20 0d       	add	r18, r0
    1d96:	11 24       	eor	r1, r1
    1d98:	92 2e       	mov	r9, r18
    1d9a:	11 c0       	rjmp	.+34     	; 0x1dbe <vfprintf+0xe6>
    1d9c:	ea e0       	ldi	r30, 0x0A	; 10
    1d9e:	2e 9e       	mul	r2, r30
    1da0:	20 0d       	add	r18, r0
    1da2:	11 24       	eor	r1, r1
    1da4:	22 2e       	mov	r2, r18
    1da6:	f3 2d       	mov	r31, r3
    1da8:	f0 62       	ori	r31, 0x20	; 32
    1daa:	3f 2e       	mov	r3, r31
    1dac:	08 c0       	rjmp	.+16     	; 0x1dbe <vfprintf+0xe6>
    1dae:	8c 36       	cpi	r24, 0x6C	; 108
    1db0:	21 f4       	brne	.+8      	; 0x1dba <vfprintf+0xe2>
    1db2:	83 2d       	mov	r24, r3
    1db4:	80 68       	ori	r24, 0x80	; 128
    1db6:	38 2e       	mov	r3, r24
    1db8:	02 c0       	rjmp	.+4      	; 0x1dbe <vfprintf+0xe6>
    1dba:	88 36       	cpi	r24, 0x68	; 104
    1dbc:	41 f4       	brne	.+16     	; 0x1dce <vfprintf+0xf6>
    1dbe:	f7 01       	movw	r30, r14
    1dc0:	93 fd       	sbrc	r25, 3
    1dc2:	85 91       	lpm	r24, Z+
    1dc4:	93 ff       	sbrs	r25, 3
    1dc6:	81 91       	ld	r24, Z+
    1dc8:	7f 01       	movw	r14, r30
    1dca:	81 11       	cpse	r24, r1
    1dcc:	b3 cf       	rjmp	.-154    	; 0x1d34 <vfprintf+0x5c>
    1dce:	98 2f       	mov	r25, r24
    1dd0:	9f 7d       	andi	r25, 0xDF	; 223
    1dd2:	95 54       	subi	r25, 0x45	; 69
    1dd4:	93 30       	cpi	r25, 0x03	; 3
    1dd6:	28 f4       	brcc	.+10     	; 0x1de2 <vfprintf+0x10a>
    1dd8:	0c 5f       	subi	r16, 0xFC	; 252
    1dda:	1f 4f       	sbci	r17, 0xFF	; 255
    1ddc:	9f e3       	ldi	r25, 0x3F	; 63
    1dde:	99 83       	std	Y+1, r25	; 0x01
    1de0:	0d c0       	rjmp	.+26     	; 0x1dfc <vfprintf+0x124>
    1de2:	83 36       	cpi	r24, 0x63	; 99
    1de4:	31 f0       	breq	.+12     	; 0x1df2 <vfprintf+0x11a>
    1de6:	83 37       	cpi	r24, 0x73	; 115
    1de8:	71 f0       	breq	.+28     	; 0x1e06 <vfprintf+0x12e>
    1dea:	83 35       	cpi	r24, 0x53	; 83
    1dec:	09 f0       	breq	.+2      	; 0x1df0 <vfprintf+0x118>
    1dee:	59 c0       	rjmp	.+178    	; 0x1ea2 <vfprintf+0x1ca>
    1df0:	21 c0       	rjmp	.+66     	; 0x1e34 <vfprintf+0x15c>
    1df2:	f8 01       	movw	r30, r16
    1df4:	80 81       	ld	r24, Z
    1df6:	89 83       	std	Y+1, r24	; 0x01
    1df8:	0e 5f       	subi	r16, 0xFE	; 254
    1dfa:	1f 4f       	sbci	r17, 0xFF	; 255
    1dfc:	88 24       	eor	r8, r8
    1dfe:	83 94       	inc	r8
    1e00:	91 2c       	mov	r9, r1
    1e02:	53 01       	movw	r10, r6
    1e04:	13 c0       	rjmp	.+38     	; 0x1e2c <vfprintf+0x154>
    1e06:	28 01       	movw	r4, r16
    1e08:	f2 e0       	ldi	r31, 0x02	; 2
    1e0a:	4f 0e       	add	r4, r31
    1e0c:	51 1c       	adc	r5, r1
    1e0e:	f8 01       	movw	r30, r16
    1e10:	a0 80       	ld	r10, Z
    1e12:	b1 80       	ldd	r11, Z+1	; 0x01
    1e14:	36 fe       	sbrs	r3, 6
    1e16:	03 c0       	rjmp	.+6      	; 0x1e1e <vfprintf+0x146>
    1e18:	69 2d       	mov	r22, r9
    1e1a:	70 e0       	ldi	r23, 0x00	; 0
    1e1c:	02 c0       	rjmp	.+4      	; 0x1e22 <vfprintf+0x14a>
    1e1e:	6f ef       	ldi	r22, 0xFF	; 255
    1e20:	7f ef       	ldi	r23, 0xFF	; 255
    1e22:	c5 01       	movw	r24, r10
    1e24:	0e 94 58 10 	call	0x20b0	; 0x20b0 <strnlen>
    1e28:	4c 01       	movw	r8, r24
    1e2a:	82 01       	movw	r16, r4
    1e2c:	f3 2d       	mov	r31, r3
    1e2e:	ff 77       	andi	r31, 0x7F	; 127
    1e30:	3f 2e       	mov	r3, r31
    1e32:	16 c0       	rjmp	.+44     	; 0x1e60 <vfprintf+0x188>
    1e34:	28 01       	movw	r4, r16
    1e36:	22 e0       	ldi	r18, 0x02	; 2
    1e38:	42 0e       	add	r4, r18
    1e3a:	51 1c       	adc	r5, r1
    1e3c:	f8 01       	movw	r30, r16
    1e3e:	a0 80       	ld	r10, Z
    1e40:	b1 80       	ldd	r11, Z+1	; 0x01
    1e42:	36 fe       	sbrs	r3, 6
    1e44:	03 c0       	rjmp	.+6      	; 0x1e4c <vfprintf+0x174>
    1e46:	69 2d       	mov	r22, r9
    1e48:	70 e0       	ldi	r23, 0x00	; 0
    1e4a:	02 c0       	rjmp	.+4      	; 0x1e50 <vfprintf+0x178>
    1e4c:	6f ef       	ldi	r22, 0xFF	; 255
    1e4e:	7f ef       	ldi	r23, 0xFF	; 255
    1e50:	c5 01       	movw	r24, r10
    1e52:	0e 94 4d 10 	call	0x209a	; 0x209a <strnlen_P>
    1e56:	4c 01       	movw	r8, r24
    1e58:	f3 2d       	mov	r31, r3
    1e5a:	f0 68       	ori	r31, 0x80	; 128
    1e5c:	3f 2e       	mov	r3, r31
    1e5e:	82 01       	movw	r16, r4
    1e60:	33 fc       	sbrc	r3, 3
    1e62:	1b c0       	rjmp	.+54     	; 0x1e9a <vfprintf+0x1c2>
    1e64:	82 2d       	mov	r24, r2
    1e66:	90 e0       	ldi	r25, 0x00	; 0
    1e68:	88 16       	cp	r8, r24
    1e6a:	99 06       	cpc	r9, r25
    1e6c:	b0 f4       	brcc	.+44     	; 0x1e9a <vfprintf+0x1c2>
    1e6e:	b6 01       	movw	r22, r12
    1e70:	80 e2       	ldi	r24, 0x20	; 32
    1e72:	90 e0       	ldi	r25, 0x00	; 0
    1e74:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    1e78:	2a 94       	dec	r2
    1e7a:	f4 cf       	rjmp	.-24     	; 0x1e64 <vfprintf+0x18c>
    1e7c:	f5 01       	movw	r30, r10
    1e7e:	37 fc       	sbrc	r3, 7
    1e80:	85 91       	lpm	r24, Z+
    1e82:	37 fe       	sbrs	r3, 7
    1e84:	81 91       	ld	r24, Z+
    1e86:	5f 01       	movw	r10, r30
    1e88:	b6 01       	movw	r22, r12
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    1e90:	21 10       	cpse	r2, r1
    1e92:	2a 94       	dec	r2
    1e94:	21 e0       	ldi	r18, 0x01	; 1
    1e96:	82 1a       	sub	r8, r18
    1e98:	91 08       	sbc	r9, r1
    1e9a:	81 14       	cp	r8, r1
    1e9c:	91 04       	cpc	r9, r1
    1e9e:	71 f7       	brne	.-36     	; 0x1e7c <vfprintf+0x1a4>
    1ea0:	e8 c0       	rjmp	.+464    	; 0x2072 <vfprintf+0x39a>
    1ea2:	84 36       	cpi	r24, 0x64	; 100
    1ea4:	11 f0       	breq	.+4      	; 0x1eaa <vfprintf+0x1d2>
    1ea6:	89 36       	cpi	r24, 0x69	; 105
    1ea8:	41 f5       	brne	.+80     	; 0x1efa <vfprintf+0x222>
    1eaa:	f8 01       	movw	r30, r16
    1eac:	37 fe       	sbrs	r3, 7
    1eae:	07 c0       	rjmp	.+14     	; 0x1ebe <vfprintf+0x1e6>
    1eb0:	60 81       	ld	r22, Z
    1eb2:	71 81       	ldd	r23, Z+1	; 0x01
    1eb4:	82 81       	ldd	r24, Z+2	; 0x02
    1eb6:	93 81       	ldd	r25, Z+3	; 0x03
    1eb8:	0c 5f       	subi	r16, 0xFC	; 252
    1eba:	1f 4f       	sbci	r17, 0xFF	; 255
    1ebc:	08 c0       	rjmp	.+16     	; 0x1ece <vfprintf+0x1f6>
    1ebe:	60 81       	ld	r22, Z
    1ec0:	71 81       	ldd	r23, Z+1	; 0x01
    1ec2:	07 2e       	mov	r0, r23
    1ec4:	00 0c       	add	r0, r0
    1ec6:	88 0b       	sbc	r24, r24
    1ec8:	99 0b       	sbc	r25, r25
    1eca:	0e 5f       	subi	r16, 0xFE	; 254
    1ecc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ece:	f3 2d       	mov	r31, r3
    1ed0:	ff 76       	andi	r31, 0x6F	; 111
    1ed2:	3f 2e       	mov	r3, r31
    1ed4:	97 ff       	sbrs	r25, 7
    1ed6:	09 c0       	rjmp	.+18     	; 0x1eea <vfprintf+0x212>
    1ed8:	90 95       	com	r25
    1eda:	80 95       	com	r24
    1edc:	70 95       	com	r23
    1ede:	61 95       	neg	r22
    1ee0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ee2:	8f 4f       	sbci	r24, 0xFF	; 255
    1ee4:	9f 4f       	sbci	r25, 0xFF	; 255
    1ee6:	f0 68       	ori	r31, 0x80	; 128
    1ee8:	3f 2e       	mov	r3, r31
    1eea:	2a e0       	ldi	r18, 0x0A	; 10
    1eec:	30 e0       	ldi	r19, 0x00	; 0
    1eee:	a3 01       	movw	r20, r6
    1ef0:	0e 94 9f 10 	call	0x213e	; 0x213e <__ultoa_invert>
    1ef4:	88 2e       	mov	r8, r24
    1ef6:	86 18       	sub	r8, r6
    1ef8:	45 c0       	rjmp	.+138    	; 0x1f84 <vfprintf+0x2ac>
    1efa:	85 37       	cpi	r24, 0x75	; 117
    1efc:	31 f4       	brne	.+12     	; 0x1f0a <vfprintf+0x232>
    1efe:	23 2d       	mov	r18, r3
    1f00:	2f 7e       	andi	r18, 0xEF	; 239
    1f02:	b2 2e       	mov	r11, r18
    1f04:	2a e0       	ldi	r18, 0x0A	; 10
    1f06:	30 e0       	ldi	r19, 0x00	; 0
    1f08:	25 c0       	rjmp	.+74     	; 0x1f54 <vfprintf+0x27c>
    1f0a:	93 2d       	mov	r25, r3
    1f0c:	99 7f       	andi	r25, 0xF9	; 249
    1f0e:	b9 2e       	mov	r11, r25
    1f10:	8f 36       	cpi	r24, 0x6F	; 111
    1f12:	c1 f0       	breq	.+48     	; 0x1f44 <vfprintf+0x26c>
    1f14:	18 f4       	brcc	.+6      	; 0x1f1c <vfprintf+0x244>
    1f16:	88 35       	cpi	r24, 0x58	; 88
    1f18:	79 f0       	breq	.+30     	; 0x1f38 <vfprintf+0x260>
    1f1a:	b5 c0       	rjmp	.+362    	; 0x2086 <vfprintf+0x3ae>
    1f1c:	80 37       	cpi	r24, 0x70	; 112
    1f1e:	19 f0       	breq	.+6      	; 0x1f26 <vfprintf+0x24e>
    1f20:	88 37       	cpi	r24, 0x78	; 120
    1f22:	21 f0       	breq	.+8      	; 0x1f2c <vfprintf+0x254>
    1f24:	b0 c0       	rjmp	.+352    	; 0x2086 <vfprintf+0x3ae>
    1f26:	e9 2f       	mov	r30, r25
    1f28:	e0 61       	ori	r30, 0x10	; 16
    1f2a:	be 2e       	mov	r11, r30
    1f2c:	b4 fe       	sbrs	r11, 4
    1f2e:	0d c0       	rjmp	.+26     	; 0x1f4a <vfprintf+0x272>
    1f30:	fb 2d       	mov	r31, r11
    1f32:	f4 60       	ori	r31, 0x04	; 4
    1f34:	bf 2e       	mov	r11, r31
    1f36:	09 c0       	rjmp	.+18     	; 0x1f4a <vfprintf+0x272>
    1f38:	34 fe       	sbrs	r3, 4
    1f3a:	0a c0       	rjmp	.+20     	; 0x1f50 <vfprintf+0x278>
    1f3c:	29 2f       	mov	r18, r25
    1f3e:	26 60       	ori	r18, 0x06	; 6
    1f40:	b2 2e       	mov	r11, r18
    1f42:	06 c0       	rjmp	.+12     	; 0x1f50 <vfprintf+0x278>
    1f44:	28 e0       	ldi	r18, 0x08	; 8
    1f46:	30 e0       	ldi	r19, 0x00	; 0
    1f48:	05 c0       	rjmp	.+10     	; 0x1f54 <vfprintf+0x27c>
    1f4a:	20 e1       	ldi	r18, 0x10	; 16
    1f4c:	30 e0       	ldi	r19, 0x00	; 0
    1f4e:	02 c0       	rjmp	.+4      	; 0x1f54 <vfprintf+0x27c>
    1f50:	20 e1       	ldi	r18, 0x10	; 16
    1f52:	32 e0       	ldi	r19, 0x02	; 2
    1f54:	f8 01       	movw	r30, r16
    1f56:	b7 fe       	sbrs	r11, 7
    1f58:	07 c0       	rjmp	.+14     	; 0x1f68 <vfprintf+0x290>
    1f5a:	60 81       	ld	r22, Z
    1f5c:	71 81       	ldd	r23, Z+1	; 0x01
    1f5e:	82 81       	ldd	r24, Z+2	; 0x02
    1f60:	93 81       	ldd	r25, Z+3	; 0x03
    1f62:	0c 5f       	subi	r16, 0xFC	; 252
    1f64:	1f 4f       	sbci	r17, 0xFF	; 255
    1f66:	06 c0       	rjmp	.+12     	; 0x1f74 <vfprintf+0x29c>
    1f68:	60 81       	ld	r22, Z
    1f6a:	71 81       	ldd	r23, Z+1	; 0x01
    1f6c:	80 e0       	ldi	r24, 0x00	; 0
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	0e 5f       	subi	r16, 0xFE	; 254
    1f72:	1f 4f       	sbci	r17, 0xFF	; 255
    1f74:	a3 01       	movw	r20, r6
    1f76:	0e 94 9f 10 	call	0x213e	; 0x213e <__ultoa_invert>
    1f7a:	88 2e       	mov	r8, r24
    1f7c:	86 18       	sub	r8, r6
    1f7e:	fb 2d       	mov	r31, r11
    1f80:	ff 77       	andi	r31, 0x7F	; 127
    1f82:	3f 2e       	mov	r3, r31
    1f84:	36 fe       	sbrs	r3, 6
    1f86:	0d c0       	rjmp	.+26     	; 0x1fa2 <vfprintf+0x2ca>
    1f88:	23 2d       	mov	r18, r3
    1f8a:	2e 7f       	andi	r18, 0xFE	; 254
    1f8c:	a2 2e       	mov	r10, r18
    1f8e:	89 14       	cp	r8, r9
    1f90:	58 f4       	brcc	.+22     	; 0x1fa8 <vfprintf+0x2d0>
    1f92:	34 fe       	sbrs	r3, 4
    1f94:	0b c0       	rjmp	.+22     	; 0x1fac <vfprintf+0x2d4>
    1f96:	32 fc       	sbrc	r3, 2
    1f98:	09 c0       	rjmp	.+18     	; 0x1fac <vfprintf+0x2d4>
    1f9a:	83 2d       	mov	r24, r3
    1f9c:	8e 7e       	andi	r24, 0xEE	; 238
    1f9e:	a8 2e       	mov	r10, r24
    1fa0:	05 c0       	rjmp	.+10     	; 0x1fac <vfprintf+0x2d4>
    1fa2:	b8 2c       	mov	r11, r8
    1fa4:	a3 2c       	mov	r10, r3
    1fa6:	03 c0       	rjmp	.+6      	; 0x1fae <vfprintf+0x2d6>
    1fa8:	b8 2c       	mov	r11, r8
    1faa:	01 c0       	rjmp	.+2      	; 0x1fae <vfprintf+0x2d6>
    1fac:	b9 2c       	mov	r11, r9
    1fae:	a4 fe       	sbrs	r10, 4
    1fb0:	0f c0       	rjmp	.+30     	; 0x1fd0 <vfprintf+0x2f8>
    1fb2:	fe 01       	movw	r30, r28
    1fb4:	e8 0d       	add	r30, r8
    1fb6:	f1 1d       	adc	r31, r1
    1fb8:	80 81       	ld	r24, Z
    1fba:	80 33       	cpi	r24, 0x30	; 48
    1fbc:	21 f4       	brne	.+8      	; 0x1fc6 <vfprintf+0x2ee>
    1fbe:	9a 2d       	mov	r25, r10
    1fc0:	99 7e       	andi	r25, 0xE9	; 233
    1fc2:	a9 2e       	mov	r10, r25
    1fc4:	09 c0       	rjmp	.+18     	; 0x1fd8 <vfprintf+0x300>
    1fc6:	a2 fe       	sbrs	r10, 2
    1fc8:	06 c0       	rjmp	.+12     	; 0x1fd6 <vfprintf+0x2fe>
    1fca:	b3 94       	inc	r11
    1fcc:	b3 94       	inc	r11
    1fce:	04 c0       	rjmp	.+8      	; 0x1fd8 <vfprintf+0x300>
    1fd0:	8a 2d       	mov	r24, r10
    1fd2:	86 78       	andi	r24, 0x86	; 134
    1fd4:	09 f0       	breq	.+2      	; 0x1fd8 <vfprintf+0x300>
    1fd6:	b3 94       	inc	r11
    1fd8:	a3 fc       	sbrc	r10, 3
    1fda:	11 c0       	rjmp	.+34     	; 0x1ffe <vfprintf+0x326>
    1fdc:	a0 fe       	sbrs	r10, 0
    1fde:	06 c0       	rjmp	.+12     	; 0x1fec <vfprintf+0x314>
    1fe0:	b2 14       	cp	r11, r2
    1fe2:	88 f4       	brcc	.+34     	; 0x2006 <vfprintf+0x32e>
    1fe4:	28 0c       	add	r2, r8
    1fe6:	92 2c       	mov	r9, r2
    1fe8:	9b 18       	sub	r9, r11
    1fea:	0e c0       	rjmp	.+28     	; 0x2008 <vfprintf+0x330>
    1fec:	b2 14       	cp	r11, r2
    1fee:	60 f4       	brcc	.+24     	; 0x2008 <vfprintf+0x330>
    1ff0:	b6 01       	movw	r22, r12
    1ff2:	80 e2       	ldi	r24, 0x20	; 32
    1ff4:	90 e0       	ldi	r25, 0x00	; 0
    1ff6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    1ffa:	b3 94       	inc	r11
    1ffc:	f7 cf       	rjmp	.-18     	; 0x1fec <vfprintf+0x314>
    1ffe:	b2 14       	cp	r11, r2
    2000:	18 f4       	brcc	.+6      	; 0x2008 <vfprintf+0x330>
    2002:	2b 18       	sub	r2, r11
    2004:	02 c0       	rjmp	.+4      	; 0x200a <vfprintf+0x332>
    2006:	98 2c       	mov	r9, r8
    2008:	21 2c       	mov	r2, r1
    200a:	a4 fe       	sbrs	r10, 4
    200c:	10 c0       	rjmp	.+32     	; 0x202e <vfprintf+0x356>
    200e:	b6 01       	movw	r22, r12
    2010:	80 e3       	ldi	r24, 0x30	; 48
    2012:	90 e0       	ldi	r25, 0x00	; 0
    2014:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    2018:	a2 fe       	sbrs	r10, 2
    201a:	17 c0       	rjmp	.+46     	; 0x204a <vfprintf+0x372>
    201c:	a1 fc       	sbrc	r10, 1
    201e:	03 c0       	rjmp	.+6      	; 0x2026 <vfprintf+0x34e>
    2020:	88 e7       	ldi	r24, 0x78	; 120
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	02 c0       	rjmp	.+4      	; 0x202a <vfprintf+0x352>
    2026:	88 e5       	ldi	r24, 0x58	; 88
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	b6 01       	movw	r22, r12
    202c:	0c c0       	rjmp	.+24     	; 0x2046 <vfprintf+0x36e>
    202e:	8a 2d       	mov	r24, r10
    2030:	86 78       	andi	r24, 0x86	; 134
    2032:	59 f0       	breq	.+22     	; 0x204a <vfprintf+0x372>
    2034:	a1 fe       	sbrs	r10, 1
    2036:	02 c0       	rjmp	.+4      	; 0x203c <vfprintf+0x364>
    2038:	8b e2       	ldi	r24, 0x2B	; 43
    203a:	01 c0       	rjmp	.+2      	; 0x203e <vfprintf+0x366>
    203c:	80 e2       	ldi	r24, 0x20	; 32
    203e:	a7 fc       	sbrc	r10, 7
    2040:	8d e2       	ldi	r24, 0x2D	; 45
    2042:	b6 01       	movw	r22, r12
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    204a:	89 14       	cp	r8, r9
    204c:	38 f4       	brcc	.+14     	; 0x205c <vfprintf+0x384>
    204e:	b6 01       	movw	r22, r12
    2050:	80 e3       	ldi	r24, 0x30	; 48
    2052:	90 e0       	ldi	r25, 0x00	; 0
    2054:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    2058:	9a 94       	dec	r9
    205a:	f7 cf       	rjmp	.-18     	; 0x204a <vfprintf+0x372>
    205c:	8a 94       	dec	r8
    205e:	f3 01       	movw	r30, r6
    2060:	e8 0d       	add	r30, r8
    2062:	f1 1d       	adc	r31, r1
    2064:	80 81       	ld	r24, Z
    2066:	b6 01       	movw	r22, r12
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    206e:	81 10       	cpse	r8, r1
    2070:	f5 cf       	rjmp	.-22     	; 0x205c <vfprintf+0x384>
    2072:	22 20       	and	r2, r2
    2074:	09 f4       	brne	.+2      	; 0x2078 <vfprintf+0x3a0>
    2076:	42 ce       	rjmp	.-892    	; 0x1cfc <vfprintf+0x24>
    2078:	b6 01       	movw	r22, r12
    207a:	80 e2       	ldi	r24, 0x20	; 32
    207c:	90 e0       	ldi	r25, 0x00	; 0
    207e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <fputc>
    2082:	2a 94       	dec	r2
    2084:	f6 cf       	rjmp	.-20     	; 0x2072 <vfprintf+0x39a>
    2086:	f6 01       	movw	r30, r12
    2088:	86 81       	ldd	r24, Z+6	; 0x06
    208a:	97 81       	ldd	r25, Z+7	; 0x07
    208c:	02 c0       	rjmp	.+4      	; 0x2092 <vfprintf+0x3ba>
    208e:	8f ef       	ldi	r24, 0xFF	; 255
    2090:	9f ef       	ldi	r25, 0xFF	; 255
    2092:	2b 96       	adiw	r28, 0x0b	; 11
    2094:	e2 e1       	ldi	r30, 0x12	; 18
    2096:	0c 94 19 11 	jmp	0x2232	; 0x2232 <__epilogue_restores__>

0000209a <strnlen_P>:
    209a:	fc 01       	movw	r30, r24
    209c:	05 90       	lpm	r0, Z+
    209e:	61 50       	subi	r22, 0x01	; 1
    20a0:	70 40       	sbci	r23, 0x00	; 0
    20a2:	01 10       	cpse	r0, r1
    20a4:	d8 f7       	brcc	.-10     	; 0x209c <strnlen_P+0x2>
    20a6:	80 95       	com	r24
    20a8:	90 95       	com	r25
    20aa:	8e 0f       	add	r24, r30
    20ac:	9f 1f       	adc	r25, r31
    20ae:	08 95       	ret

000020b0 <strnlen>:
    20b0:	fc 01       	movw	r30, r24
    20b2:	61 50       	subi	r22, 0x01	; 1
    20b4:	70 40       	sbci	r23, 0x00	; 0
    20b6:	01 90       	ld	r0, Z+
    20b8:	01 10       	cpse	r0, r1
    20ba:	d8 f7       	brcc	.-10     	; 0x20b2 <strnlen+0x2>
    20bc:	80 95       	com	r24
    20be:	90 95       	com	r25
    20c0:	8e 0f       	add	r24, r30
    20c2:	9f 1f       	adc	r25, r31
    20c4:	08 95       	ret

000020c6 <fputc>:
    20c6:	0f 93       	push	r16
    20c8:	1f 93       	push	r17
    20ca:	cf 93       	push	r28
    20cc:	df 93       	push	r29
    20ce:	fb 01       	movw	r30, r22
    20d0:	23 81       	ldd	r18, Z+3	; 0x03
    20d2:	21 fd       	sbrc	r18, 1
    20d4:	03 c0       	rjmp	.+6      	; 0x20dc <fputc+0x16>
    20d6:	8f ef       	ldi	r24, 0xFF	; 255
    20d8:	9f ef       	ldi	r25, 0xFF	; 255
    20da:	2c c0       	rjmp	.+88     	; 0x2134 <fputc+0x6e>
    20dc:	22 ff       	sbrs	r18, 2
    20de:	16 c0       	rjmp	.+44     	; 0x210c <fputc+0x46>
    20e0:	46 81       	ldd	r20, Z+6	; 0x06
    20e2:	57 81       	ldd	r21, Z+7	; 0x07
    20e4:	24 81       	ldd	r18, Z+4	; 0x04
    20e6:	35 81       	ldd	r19, Z+5	; 0x05
    20e8:	42 17       	cp	r20, r18
    20ea:	53 07       	cpc	r21, r19
    20ec:	44 f4       	brge	.+16     	; 0x20fe <fputc+0x38>
    20ee:	a0 81       	ld	r26, Z
    20f0:	b1 81       	ldd	r27, Z+1	; 0x01
    20f2:	9d 01       	movw	r18, r26
    20f4:	2f 5f       	subi	r18, 0xFF	; 255
    20f6:	3f 4f       	sbci	r19, 0xFF	; 255
    20f8:	31 83       	std	Z+1, r19	; 0x01
    20fa:	20 83       	st	Z, r18
    20fc:	8c 93       	st	X, r24
    20fe:	26 81       	ldd	r18, Z+6	; 0x06
    2100:	37 81       	ldd	r19, Z+7	; 0x07
    2102:	2f 5f       	subi	r18, 0xFF	; 255
    2104:	3f 4f       	sbci	r19, 0xFF	; 255
    2106:	37 83       	std	Z+7, r19	; 0x07
    2108:	26 83       	std	Z+6, r18	; 0x06
    210a:	14 c0       	rjmp	.+40     	; 0x2134 <fputc+0x6e>
    210c:	8b 01       	movw	r16, r22
    210e:	ec 01       	movw	r28, r24
    2110:	fb 01       	movw	r30, r22
    2112:	00 84       	ldd	r0, Z+8	; 0x08
    2114:	f1 85       	ldd	r31, Z+9	; 0x09
    2116:	e0 2d       	mov	r30, r0
    2118:	09 95       	icall
    211a:	89 2b       	or	r24, r25
    211c:	e1 f6       	brne	.-72     	; 0x20d6 <fputc+0x10>
    211e:	d8 01       	movw	r26, r16
    2120:	16 96       	adiw	r26, 0x06	; 6
    2122:	8d 91       	ld	r24, X+
    2124:	9c 91       	ld	r25, X
    2126:	17 97       	sbiw	r26, 0x07	; 7
    2128:	01 96       	adiw	r24, 0x01	; 1
    212a:	17 96       	adiw	r26, 0x07	; 7
    212c:	9c 93       	st	X, r25
    212e:	8e 93       	st	-X, r24
    2130:	16 97       	sbiw	r26, 0x06	; 6
    2132:	ce 01       	movw	r24, r28
    2134:	df 91       	pop	r29
    2136:	cf 91       	pop	r28
    2138:	1f 91       	pop	r17
    213a:	0f 91       	pop	r16
    213c:	08 95       	ret

0000213e <__ultoa_invert>:
    213e:	fa 01       	movw	r30, r20
    2140:	aa 27       	eor	r26, r26
    2142:	28 30       	cpi	r18, 0x08	; 8
    2144:	51 f1       	breq	.+84     	; 0x219a <__ultoa_invert+0x5c>
    2146:	20 31       	cpi	r18, 0x10	; 16
    2148:	81 f1       	breq	.+96     	; 0x21aa <__ultoa_invert+0x6c>
    214a:	e8 94       	clt
    214c:	6f 93       	push	r22
    214e:	6e 7f       	andi	r22, 0xFE	; 254
    2150:	6e 5f       	subi	r22, 0xFE	; 254
    2152:	7f 4f       	sbci	r23, 0xFF	; 255
    2154:	8f 4f       	sbci	r24, 0xFF	; 255
    2156:	9f 4f       	sbci	r25, 0xFF	; 255
    2158:	af 4f       	sbci	r26, 0xFF	; 255
    215a:	b1 e0       	ldi	r27, 0x01	; 1
    215c:	3e d0       	rcall	.+124    	; 0x21da <__ultoa_invert+0x9c>
    215e:	b4 e0       	ldi	r27, 0x04	; 4
    2160:	3c d0       	rcall	.+120    	; 0x21da <__ultoa_invert+0x9c>
    2162:	67 0f       	add	r22, r23
    2164:	78 1f       	adc	r23, r24
    2166:	89 1f       	adc	r24, r25
    2168:	9a 1f       	adc	r25, r26
    216a:	a1 1d       	adc	r26, r1
    216c:	68 0f       	add	r22, r24
    216e:	79 1f       	adc	r23, r25
    2170:	8a 1f       	adc	r24, r26
    2172:	91 1d       	adc	r25, r1
    2174:	a1 1d       	adc	r26, r1
    2176:	6a 0f       	add	r22, r26
    2178:	71 1d       	adc	r23, r1
    217a:	81 1d       	adc	r24, r1
    217c:	91 1d       	adc	r25, r1
    217e:	a1 1d       	adc	r26, r1
    2180:	20 d0       	rcall	.+64     	; 0x21c2 <__ultoa_invert+0x84>
    2182:	09 f4       	brne	.+2      	; 0x2186 <__ultoa_invert+0x48>
    2184:	68 94       	set
    2186:	3f 91       	pop	r19
    2188:	2a e0       	ldi	r18, 0x0A	; 10
    218a:	26 9f       	mul	r18, r22
    218c:	11 24       	eor	r1, r1
    218e:	30 19       	sub	r19, r0
    2190:	30 5d       	subi	r19, 0xD0	; 208
    2192:	31 93       	st	Z+, r19
    2194:	de f6       	brtc	.-74     	; 0x214c <__ultoa_invert+0xe>
    2196:	cf 01       	movw	r24, r30
    2198:	08 95       	ret
    219a:	46 2f       	mov	r20, r22
    219c:	47 70       	andi	r20, 0x07	; 7
    219e:	40 5d       	subi	r20, 0xD0	; 208
    21a0:	41 93       	st	Z+, r20
    21a2:	b3 e0       	ldi	r27, 0x03	; 3
    21a4:	0f d0       	rcall	.+30     	; 0x21c4 <__ultoa_invert+0x86>
    21a6:	c9 f7       	brne	.-14     	; 0x219a <__ultoa_invert+0x5c>
    21a8:	f6 cf       	rjmp	.-20     	; 0x2196 <__ultoa_invert+0x58>
    21aa:	46 2f       	mov	r20, r22
    21ac:	4f 70       	andi	r20, 0x0F	; 15
    21ae:	40 5d       	subi	r20, 0xD0	; 208
    21b0:	4a 33       	cpi	r20, 0x3A	; 58
    21b2:	18 f0       	brcs	.+6      	; 0x21ba <__ultoa_invert+0x7c>
    21b4:	49 5d       	subi	r20, 0xD9	; 217
    21b6:	31 fd       	sbrc	r19, 1
    21b8:	40 52       	subi	r20, 0x20	; 32
    21ba:	41 93       	st	Z+, r20
    21bc:	02 d0       	rcall	.+4      	; 0x21c2 <__ultoa_invert+0x84>
    21be:	a9 f7       	brne	.-22     	; 0x21aa <__ultoa_invert+0x6c>
    21c0:	ea cf       	rjmp	.-44     	; 0x2196 <__ultoa_invert+0x58>
    21c2:	b4 e0       	ldi	r27, 0x04	; 4
    21c4:	a6 95       	lsr	r26
    21c6:	97 95       	ror	r25
    21c8:	87 95       	ror	r24
    21ca:	77 95       	ror	r23
    21cc:	67 95       	ror	r22
    21ce:	ba 95       	dec	r27
    21d0:	c9 f7       	brne	.-14     	; 0x21c4 <__ultoa_invert+0x86>
    21d2:	00 97       	sbiw	r24, 0x00	; 0
    21d4:	61 05       	cpc	r22, r1
    21d6:	71 05       	cpc	r23, r1
    21d8:	08 95       	ret
    21da:	9b 01       	movw	r18, r22
    21dc:	ac 01       	movw	r20, r24
    21de:	0a 2e       	mov	r0, r26
    21e0:	06 94       	lsr	r0
    21e2:	57 95       	ror	r21
    21e4:	47 95       	ror	r20
    21e6:	37 95       	ror	r19
    21e8:	27 95       	ror	r18
    21ea:	ba 95       	dec	r27
    21ec:	c9 f7       	brne	.-14     	; 0x21e0 <__ultoa_invert+0xa2>
    21ee:	62 0f       	add	r22, r18
    21f0:	73 1f       	adc	r23, r19
    21f2:	84 1f       	adc	r24, r20
    21f4:	95 1f       	adc	r25, r21
    21f6:	a0 1d       	adc	r26, r0
    21f8:	08 95       	ret

000021fa <__prologue_saves__>:
    21fa:	2f 92       	push	r2
    21fc:	3f 92       	push	r3
    21fe:	4f 92       	push	r4
    2200:	5f 92       	push	r5
    2202:	6f 92       	push	r6
    2204:	7f 92       	push	r7
    2206:	8f 92       	push	r8
    2208:	9f 92       	push	r9
    220a:	af 92       	push	r10
    220c:	bf 92       	push	r11
    220e:	cf 92       	push	r12
    2210:	df 92       	push	r13
    2212:	ef 92       	push	r14
    2214:	ff 92       	push	r15
    2216:	0f 93       	push	r16
    2218:	1f 93       	push	r17
    221a:	cf 93       	push	r28
    221c:	df 93       	push	r29
    221e:	cd b7       	in	r28, 0x3d	; 61
    2220:	de b7       	in	r29, 0x3e	; 62
    2222:	ca 1b       	sub	r28, r26
    2224:	db 0b       	sbc	r29, r27
    2226:	0f b6       	in	r0, 0x3f	; 63
    2228:	f8 94       	cli
    222a:	de bf       	out	0x3e, r29	; 62
    222c:	0f be       	out	0x3f, r0	; 63
    222e:	cd bf       	out	0x3d, r28	; 61
    2230:	09 94       	ijmp

00002232 <__epilogue_restores__>:
    2232:	2a 88       	ldd	r2, Y+18	; 0x12
    2234:	39 88       	ldd	r3, Y+17	; 0x11
    2236:	48 88       	ldd	r4, Y+16	; 0x10
    2238:	5f 84       	ldd	r5, Y+15	; 0x0f
    223a:	6e 84       	ldd	r6, Y+14	; 0x0e
    223c:	7d 84       	ldd	r7, Y+13	; 0x0d
    223e:	8c 84       	ldd	r8, Y+12	; 0x0c
    2240:	9b 84       	ldd	r9, Y+11	; 0x0b
    2242:	aa 84       	ldd	r10, Y+10	; 0x0a
    2244:	b9 84       	ldd	r11, Y+9	; 0x09
    2246:	c8 84       	ldd	r12, Y+8	; 0x08
    2248:	df 80       	ldd	r13, Y+7	; 0x07
    224a:	ee 80       	ldd	r14, Y+6	; 0x06
    224c:	fd 80       	ldd	r15, Y+5	; 0x05
    224e:	0c 81       	ldd	r16, Y+4	; 0x04
    2250:	1b 81       	ldd	r17, Y+3	; 0x03
    2252:	aa 81       	ldd	r26, Y+2	; 0x02
    2254:	b9 81       	ldd	r27, Y+1	; 0x01
    2256:	ce 0f       	add	r28, r30
    2258:	d1 1d       	adc	r29, r1
    225a:	0f b6       	in	r0, 0x3f	; 63
    225c:	f8 94       	cli
    225e:	de bf       	out	0x3e, r29	; 62
    2260:	0f be       	out	0x3f, r0	; 63
    2262:	cd bf       	out	0x3d, r28	; 61
    2264:	ed 01       	movw	r28, r26
    2266:	08 95       	ret

00002268 <_exit>:
    2268:	f8 94       	cli

0000226a <__stop_program>:
    226a:	ff cf       	rjmp	.-2      	; 0x226a <__stop_program>
