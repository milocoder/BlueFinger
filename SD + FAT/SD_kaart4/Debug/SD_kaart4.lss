
SD_kaart4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a2  00800100  000018e4  00001978  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000018e4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000043c  008001a2  008001a2  00001a1a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001a1a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001a4c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000168  00000000  00000000  00001a88  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000026ff  00000000  00000000  00001bf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000107e  00000000  00000000  000042ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000143b  00000000  00000000  0000536d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000058c  00000000  00000000  000067a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000092d  00000000  00000000  00006d34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000219d  00000000  00000000  00007661  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  000097fe  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 da 03 	jmp	0x7b4	; 0x7b4 <__vector_12>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf ef       	ldi	r28, 0xFF	; 255
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e0       	ldi	r26, 0x00	; 0
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	e4 ee       	ldi	r30, 0xE4	; 228
      a8:	f8 e1       	ldi	r31, 0x18	; 24
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a2 3a       	cpi	r26, 0xA2	; 162
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	25 e0       	ldi	r18, 0x05	; 5
      b8:	a2 ea       	ldi	r26, 0xA2	; 162
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	ae 3d       	cpi	r26, 0xDE	; 222
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 bc 03 	call	0x778	; 0x778 <main>
      ca:	0c 94 70 0c 	jmp	0x18e0	; 0x18e0 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <init_spi>:
//

static void init_spi(void)
{
	/* Set MOSI and SCK output, all others input */
	DDR_SPI |= ((1 << MOSI) | (1 << SCK) | (1 << CS));
      d2:	84 b1       	in	r24, 0x04	; 4
      d4:	87 60       	ori	r24, 0x07	; 7
      d6:	84 b9       	out	0x04, r24	; 4
	
	// enable pull up resistor in MISO
	PORTB |= (1 << MISO);
      d8:	85 b1       	in	r24, 0x05	; 5
      da:	88 60       	ori	r24, 0x08	; 8
      dc:	85 b9       	out	0x05, r24	; 5
	
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPR0));
      de:	8c b5       	in	r24, 0x2c	; 44
      e0:	81 65       	ori	r24, 0x51	; 81
      e2:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<CS); 				//hoog maken CS	
      e4:	85 b1       	in	r24, 0x05	; 5
      e6:	81 60       	ori	r24, 0x01	; 1
      e8:	85 b9       	out	0x05, r24	; 5
      ea:	08 95       	ret

000000ec <xmit_spi>:
}

static BYTE xmit_spi(BYTE data)
{
	PORTB &= ~(1<<CS); //laag maken
      ec:	95 b1       	in	r25, 0x05	; 5
      ee:	9e 7f       	andi	r25, 0xFE	; 254
      f0:	95 b9       	out	0x05, r25	; 5
	/* Start transmission */
	SPDR = data;
      f2:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
      f4:	0d b4       	in	r0, 0x2d	; 45
      f6:	07 fe       	sbrs	r0, 7
      f8:	fd cf       	rjmp	.-6      	; 0xf4 <xmit_spi+0x8>
	PORTB |= (1<<CS);		//hoog maken CS
      fa:	85 b1       	in	r24, 0x05	; 5
      fc:	81 60       	ori	r24, 0x01	; 1
      fe:	85 b9       	out	0x05, r24	; 5
	
	return SPDR; 
     100:	8e b5       	in	r24, 0x2e	; 46
}
     102:	08 95       	ret

00000104 <rcv_spi>:

static BYTE rcv_spi(void)
{
	return xmit_spi(0xFF);
     104:	8f ef       	ldi	r24, 0xFF	; 255
     106:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
}
     10a:	08 95       	ret

0000010c <send_cmd>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static BYTE send_cmd(BYTE  cmd, /* 1st byte (Start + Index) */
                     DWORD arg ) /* Argument (32 bits) */
{
     10c:	ff 92       	push	r15
     10e:	0f 93       	push	r16
     110:	1f 93       	push	r17
     112:	cf 93       	push	r28
     114:	df 93       	push	r29
     116:	c8 2f       	mov	r28, r24
     118:	d4 2f       	mov	r29, r20
     11a:	15 2f       	mov	r17, r21
     11c:	06 2f       	mov	r16, r22
     11e:	f7 2e       	mov	r15, r23
	BYTE n, res;

	if (cmd & 0x80) { /* ACMD<n> is the command sequence of CMD55-CMD<n> */
     120:	88 23       	and	r24, r24
     122:	4c f4       	brge	.+18     	; 0x136 <send_cmd+0x2a>
		cmd &= 0x7F;
     124:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
     126:	40 e0       	ldi	r20, 0x00	; 0
     128:	50 e0       	ldi	r21, 0x00	; 0
     12a:	ba 01       	movw	r22, r20
     12c:	87 e7       	ldi	r24, 0x77	; 119
     12e:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
		if (res > 1)
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	50 f5       	brcc	.+84     	; 0x18a <send_cmd+0x7e>
			return res;
	}

	/* Select the card */
	DESELECT();
     136:	85 b1       	in	r24, 0x05	; 5
     138:	81 60       	ori	r24, 0x01	; 1
     13a:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     13c:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
	SELECT();
     140:	85 b1       	in	r24, 0x05	; 5
     142:	8e 7f       	andi	r24, 0xFE	; 254
     144:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     146:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>

	/* Send a command packet */
	xmit_spi(cmd);               /* Start + Command index */
     14a:	8c 2f       	mov	r24, r28
     14c:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
     150:	8f 2d       	mov	r24, r15
     152:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
     156:	80 2f       	mov	r24, r16
     158:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
     15c:	81 2f       	mov	r24, r17
     15e:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
     162:	8d 2f       	mov	r24, r29
     164:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
	n = 0x01;                    /* Dummy CRC + Stop */
	if (cmd == CMD0)
     168:	c0 34       	cpi	r28, 0x40	; 64
     16a:	11 f0       	breq	.+4      	; 0x170 <send_cmd+0x64>
	xmit_spi(cmd);               /* Start + Command index */
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
	n = 0x01;                    /* Dummy CRC + Stop */
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	01 c0       	rjmp	.+2      	; 0x172 <send_cmd+0x66>
	if (cmd == CMD0)
		n = 0x95; /* Valid CRC for CMD0(0) */
     170:	85 e9       	ldi	r24, 0x95	; 149
	if (cmd == CMD8)
     172:	c8 34       	cpi	r28, 0x48	; 72
     174:	09 f4       	brne	.+2      	; 0x178 <send_cmd+0x6c>
		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
     176:	87 e8       	ldi	r24, 0x87	; 135
	xmit_spi(n);
     178:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>

	/* Receive a command response */
	n = 10; /* Wait for a valid response in timeout of 10 attempts */
     17c:	ca e0       	ldi	r28, 0x0A	; 10
	do {
		res = rcv_spi();
     17e:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
	} while ((res & 0x80) && --n);
     182:	88 23       	and	r24, r24
     184:	14 f4       	brge	.+4      	; 0x18a <send_cmd+0x7e>
     186:	c1 50       	subi	r28, 0x01	; 1
     188:	d1 f7       	brne	.-12     	; 0x17e <send_cmd+0x72>

	return res; /* Return with the response value */
}
     18a:	df 91       	pop	r29
     18c:	cf 91       	pop	r28
     18e:	1f 91       	pop	r17
     190:	0f 91       	pop	r16
     192:	ff 90       	pop	r15
     194:	08 95       	ret

00000196 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(void)
{
     196:	ef 92       	push	r14
     198:	ff 92       	push	r15
     19a:	0f 93       	push	r16
     19c:	1f 93       	push	r17
     19e:	cf 93       	push	r28
     1a0:	df 93       	push	r29
     1a2:	00 d0       	rcall	.+0      	; 0x1a4 <disk_initialize+0xe>
     1a4:	00 d0       	rcall	.+0      	; 0x1a6 <disk_initialize+0x10>
     1a6:	cd b7       	in	r28, 0x3d	; 61
     1a8:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING)
     1aa:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     1ae:	81 11       	cpse	r24, r1
     1b0:	84 b1       	in	r24, 0x04	; 4
		disk_writep(0, 0); /* Finalize write process if it is in progress */
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
     1b2:	0e 94 69 00 	call	0xd2	; 0xd2 <init_spi>
	DESELECT();
     1b6:	85 b1       	in	r24, 0x05	; 5
     1b8:	81 60       	ori	r24, 0x01	; 1
     1ba:	85 b9       	out	0x05, r24	; 5
	for (n = 10; n; n--)
     1bc:	1a e0       	ldi	r17, 0x0A	; 10
     1be:	03 c0       	rjmp	.+6      	; 0x1c6 <disk_initialize+0x30>
		rcv_spi(); /* 80 dummy clocks with CS=H */
     1c0:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
     1c4:	11 50       	subi	r17, 0x01	; 1
     1c6:	11 11       	cpse	r17, r1
     1c8:	fb cf       	rjmp	.-10     	; 0x1c0 <disk_initialize+0x2a>
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
     1ca:	40 e0       	ldi	r20, 0x00	; 0
     1cc:	50 e0       	ldi	r21, 0x00	; 0
     1ce:	ba 01       	movw	r22, r20
     1d0:	80 e4       	ldi	r24, 0x40	; 64
     1d2:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     1d6:	81 30       	cpi	r24, 0x01	; 1
     1d8:	09 f0       	breq	.+2      	; 0x1dc <disk_initialize+0x46>
     1da:	9b c0       	rjmp	.+310    	; 0x312 <disk_initialize+0x17c>
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
     1dc:	4a ea       	ldi	r20, 0xAA	; 170
     1de:	51 e0       	ldi	r21, 0x01	; 1
     1e0:	60 e0       	ldi	r22, 0x00	; 0
     1e2:	70 e0       	ldi	r23, 0x00	; 0
     1e4:	88 e4       	ldi	r24, 0x48	; 72
     1e6:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     1ea:	81 30       	cpi	r24, 0x01	; 1
     1ec:	09 f0       	breq	.+2      	; 0x1f0 <disk_initialize+0x5a>
     1ee:	59 c0       	rjmp	.+178    	; 0x2a2 <disk_initialize+0x10c>
     1f0:	0d c0       	rjmp	.+26     	; 0x20c <disk_initialize+0x76>
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
     1f2:	e0 2e       	mov	r14, r16
     1f4:	f1 2c       	mov	r15, r1
     1f6:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
     1fa:	e1 e0       	ldi	r30, 0x01	; 1
     1fc:	f0 e0       	ldi	r31, 0x00	; 0
     1fe:	ec 0f       	add	r30, r28
     200:	fd 1f       	adc	r31, r29
     202:	ee 0d       	add	r30, r14
     204:	ff 1d       	adc	r31, r15
     206:	80 83       	st	Z, r24
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
     208:	0f 5f       	subi	r16, 0xFF	; 255
     20a:	01 c0       	rjmp	.+2      	; 0x20e <disk_initialize+0x78>
     20c:	01 2f       	mov	r16, r17
     20e:	04 30       	cpi	r16, 0x04	; 4
     210:	80 f3       	brcs	.-32     	; 0x1f2 <disk_initialize+0x5c>
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
     212:	8b 81       	ldd	r24, Y+3	; 0x03
     214:	81 30       	cpi	r24, 0x01	; 1
     216:	09 f0       	breq	.+2      	; 0x21a <disk_initialize+0x84>
     218:	7e c0       	rjmp	.+252    	; 0x316 <disk_initialize+0x180>
     21a:	8c 81       	ldd	r24, Y+4	; 0x04
     21c:	8a 3a       	cpi	r24, 0xAA	; 170
     21e:	61 f0       	breq	.+24     	; 0x238 <disk_initialize+0xa2>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     220:	f1 2c       	mov	r15, r1
     222:	84 c0       	rjmp	.+264    	; 0x32c <disk_initialize+0x196>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     224:	8f e8       	ldi	r24, 0x8F	; 143
     226:	91 e0       	ldi	r25, 0x01	; 1
     228:	01 97       	sbiw	r24, 0x01	; 1
     22a:	f1 f7       	brne	.-4      	; 0x228 <disk_initialize+0x92>
     22c:	00 c0       	rjmp	.+0      	; 0x22e <disk_initialize+0x98>
     22e:	00 00       	nop
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
     230:	91 e0       	ldi	r25, 0x01	; 1
     232:	e9 1a       	sub	r14, r25
     234:	f1 08       	sbc	r15, r1
     236:	06 c0       	rjmp	.+12     	; 0x244 <disk_initialize+0xae>
     238:	0f 2e       	mov	r0, r31
     23a:	f0 e1       	ldi	r31, 0x10	; 16
     23c:	ef 2e       	mov	r14, r31
     23e:	f7 e2       	ldi	r31, 0x27	; 39
     240:	ff 2e       	mov	r15, r31
     242:	f0 2d       	mov	r31, r0
     244:	e1 14       	cp	r14, r1
     246:	f1 04       	cpc	r15, r1
     248:	49 f0       	breq	.+18     	; 0x25c <disk_initialize+0xc6>
     24a:	40 e0       	ldi	r20, 0x00	; 0
     24c:	50 e0       	ldi	r21, 0x00	; 0
     24e:	60 e0       	ldi	r22, 0x00	; 0
     250:	70 e4       	ldi	r23, 0x40	; 64
     252:	89 ee       	ldi	r24, 0xE9	; 233
     254:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     258:	81 11       	cpse	r24, r1
     25a:	e4 cf       	rjmp	.-56     	; 0x224 <disk_initialize+0x8e>
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
     25c:	ef 28       	or	r14, r15
     25e:	09 f4       	brne	.+2      	; 0x262 <disk_initialize+0xcc>
     260:	5c c0       	rjmp	.+184    	; 0x31a <disk_initialize+0x184>
     262:	40 e0       	ldi	r20, 0x00	; 0
     264:	50 e0       	ldi	r21, 0x00	; 0
     266:	ba 01       	movw	r22, r20
     268:	8a e7       	ldi	r24, 0x7A	; 122
     26a:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     26e:	88 23       	and	r24, r24
     270:	71 f0       	breq	.+28     	; 0x28e <disk_initialize+0xf8>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     272:	f1 2c       	mov	r15, r1
     274:	5b c0       	rjmp	.+182    	; 0x32c <disk_initialize+0x196>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
     276:	e1 2e       	mov	r14, r17
     278:	f1 2c       	mov	r15, r1
     27a:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
     27e:	e1 e0       	ldi	r30, 0x01	; 1
     280:	f0 e0       	ldi	r31, 0x00	; 0
     282:	ec 0f       	add	r30, r28
     284:	fd 1f       	adc	r31, r29
     286:	ee 0d       	add	r30, r14
     288:	ff 1d       	adc	r31, r15
     28a:	80 83       	st	Z, r24
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
     28c:	1f 5f       	subi	r17, 0xFF	; 255
     28e:	14 30       	cpi	r17, 0x04	; 4
     290:	90 f3       	brcs	.-28     	; 0x276 <disk_initialize+0xe0>
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     292:	89 81       	ldd	r24, Y+1	; 0x01
     294:	86 ff       	sbrs	r24, 6
     296:	43 c0       	rjmp	.+134    	; 0x31e <disk_initialize+0x188>
     298:	0f 2e       	mov	r0, r31
     29a:	fc e0       	ldi	r31, 0x0C	; 12
     29c:	ff 2e       	mov	r15, r31
     29e:	f0 2d       	mov	r31, r0
     2a0:	45 c0       	rjmp	.+138    	; 0x32c <disk_initialize+0x196>
				}
			}
		} else { /* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) {
     2a2:	40 e0       	ldi	r20, 0x00	; 0
     2a4:	50 e0       	ldi	r21, 0x00	; 0
     2a6:	ba 01       	movw	r22, r20
     2a8:	89 ee       	ldi	r24, 0xE9	; 233
     2aa:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     2ae:	82 30       	cpi	r24, 0x02	; 2
     2b0:	40 f4       	brcc	.+16     	; 0x2c2 <disk_initialize+0x12c>
				ty  = CT_SD1;
     2b2:	68 94       	set
     2b4:	ff 24       	eor	r15, r15
     2b6:	f1 f8       	bld	r15, 1
				cmd = ACMD41; /* SDv1 */
     2b8:	0f 2e       	mov	r0, r31
     2ba:	f9 ee       	ldi	r31, 0xE9	; 233
     2bc:	ef 2e       	mov	r14, r31
     2be:	f0 2d       	mov	r31, r0
     2c0:	06 c0       	rjmp	.+12     	; 0x2ce <disk_initialize+0x138>
			} else {
				ty  = CT_MMC;
     2c2:	ff 24       	eor	r15, r15
     2c4:	f3 94       	inc	r15
				cmd = CMD1; /* MMCv3 */
     2c6:	0f 2e       	mov	r0, r31
     2c8:	f1 e4       	ldi	r31, 0x41	; 65
     2ca:	ef 2e       	mov	r14, r31
     2cc:	f0 2d       	mov	r31, r0
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
     2ce:	00 e1       	ldi	r16, 0x10	; 16
     2d0:	17 e2       	ldi	r17, 0x27	; 39
     2d2:	08 c0       	rjmp	.+16     	; 0x2e4 <disk_initialize+0x14e>
     2d4:	8f e8       	ldi	r24, 0x8F	; 143
     2d6:	91 e0       	ldi	r25, 0x01	; 1
     2d8:	01 97       	sbiw	r24, 0x01	; 1
     2da:	f1 f7       	brne	.-4      	; 0x2d8 <disk_initialize+0x142>
     2dc:	00 c0       	rjmp	.+0      	; 0x2de <disk_initialize+0x148>
     2de:	00 00       	nop
     2e0:	01 50       	subi	r16, 0x01	; 1
     2e2:	11 09       	sbc	r17, r1
     2e4:	01 15       	cp	r16, r1
     2e6:	11 05       	cpc	r17, r1
     2e8:	41 f0       	breq	.+16     	; 0x2fa <disk_initialize+0x164>
     2ea:	40 e0       	ldi	r20, 0x00	; 0
     2ec:	50 e0       	ldi	r21, 0x00	; 0
     2ee:	ba 01       	movw	r22, r20
     2f0:	8e 2d       	mov	r24, r14
     2f2:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     2f6:	81 11       	cpse	r24, r1
     2f8:	ed cf       	rjmp	.-38     	; 0x2d4 <disk_initialize+0x13e>
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
     2fa:	01 2b       	or	r16, r17
     2fc:	a1 f0       	breq	.+40     	; 0x326 <disk_initialize+0x190>
     2fe:	40 e0       	ldi	r20, 0x00	; 0
     300:	52 e0       	ldi	r21, 0x02	; 2
     302:	60 e0       	ldi	r22, 0x00	; 0
     304:	70 e0       	ldi	r23, 0x00	; 0
     306:	80 e5       	ldi	r24, 0x50	; 80
     308:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     30c:	81 11       	cpse	r24, r1
     30e:	0d c0       	rjmp	.+26     	; 0x32a <disk_initialize+0x194>
     310:	0d c0       	rjmp	.+26     	; 0x32c <disk_initialize+0x196>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     312:	f1 2c       	mov	r15, r1
     314:	0b c0       	rjmp	.+22     	; 0x32c <disk_initialize+0x196>
     316:	f1 2c       	mov	r15, r1
     318:	09 c0       	rjmp	.+18     	; 0x32c <disk_initialize+0x196>
     31a:	f1 2c       	mov	r15, r1
     31c:	07 c0       	rjmp	.+14     	; 0x32c <disk_initialize+0x196>
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     31e:	68 94       	set
     320:	ff 24       	eor	r15, r15
     322:	f2 f8       	bld	r15, 2
     324:	03 c0       	rjmp	.+6      	; 0x32c <disk_initialize+0x196>
				cmd = CMD1; /* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
				ty = 0;
     326:	f1 2c       	mov	r15, r1
     328:	01 c0       	rjmp	.+2      	; 0x32c <disk_initialize+0x196>
     32a:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     32c:	f0 92 a4 01 	sts	0x01A4, r15	; 0x8001a4 <CardType>
	DESELECT();
     330:	85 b1       	in	r24, 0x05	; 5
     332:	81 60       	ori	r24, 0x01	; 1
     334:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     336:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>

	return ty ? 0 : STA_NOINIT;
     33a:	81 e0       	ldi	r24, 0x01	; 1
     33c:	f1 10       	cpse	r15, r1
     33e:	80 e0       	ldi	r24, 0x00	; 0
}
     340:	0f 90       	pop	r0
     342:	0f 90       	pop	r0
     344:	0f 90       	pop	r0
     346:	0f 90       	pop	r0
     348:	df 91       	pop	r29
     34a:	cf 91       	pop	r28
     34c:	1f 91       	pop	r17
     34e:	0f 91       	pop	r16
     350:	ff 90       	pop	r15
     352:	ef 90       	pop	r14
     354:	08 95       	ret

00000356 <disk_readp>:
DRESULT disk_readp(BYTE *buff,   /* Pointer to the read buffer (NULL:Forward to the stream) */
                   DWORD sector, /* Sector number (LBA) */
                   UINT  offset, /* Byte offset to read from (0..511) */
                   UINT  count   /* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
     356:	af 92       	push	r10
     358:	bf 92       	push	r11
     35a:	cf 92       	push	r12
     35c:	df 92       	push	r13
     35e:	ef 92       	push	r14
     360:	ff 92       	push	r15
     362:	0f 93       	push	r16
     364:	1f 93       	push	r17
     366:	cf 93       	push	r28
     368:	df 93       	push	r29
     36a:	6c 01       	movw	r12, r24
     36c:	79 01       	movw	r14, r18
	DRESULT res;
	BYTE    rc;
	UINT    bc;

	if (!(CardType & CT_BLOCK))
     36e:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     372:	83 fd       	sbrc	r24, 3
     374:	09 c0       	rjmp	.+18     	; 0x388 <disk_readp+0x32>
		sector *= 512; /* Convert to byte address if needed */
     376:	03 2e       	mov	r0, r19
     378:	39 e0       	ldi	r19, 0x09	; 9
     37a:	44 0f       	add	r20, r20
     37c:	55 1f       	adc	r21, r21
     37e:	66 1f       	adc	r22, r22
     380:	77 1f       	adc	r23, r23
     382:	3a 95       	dec	r19
     384:	d1 f7       	brne	.-12     	; 0x37a <disk_readp+0x24>
     386:	30 2d       	mov	r19, r0

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
     388:	81 e5       	ldi	r24, 0x51	; 81
     38a:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     38e:	81 11       	cpse	r24, r1
     390:	31 c0       	rjmp	.+98     	; 0x3f4 <disk_readp+0x9e>

		// bc = 40000;	/* Time counter */
		do { /* Wait for response */
			rc = rcv_spi();
     392:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
		} while (rc == 0xFF);
     396:	8f 3f       	cpi	r24, 0xFF	; 255
     398:	e1 f3       	breq	.-8      	; 0x392 <disk_readp+0x3c>

		if (rc == 0xFE) { /* A data packet arrived */
     39a:	8e 3f       	cpi	r24, 0xFE	; 254
     39c:	69 f5       	brne	.+90     	; 0x3f8 <disk_readp+0xa2>

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */
     39e:	cc 27       	eor	r28, r28
     3a0:	dd 27       	eor	r29, r29
     3a2:	ce 19       	sub	r28, r14
     3a4:	df 09       	sbc	r29, r15
     3a6:	c0 1b       	sub	r28, r16
     3a8:	d1 0b       	sbc	r29, r17
     3aa:	ce 5f       	subi	r28, 0xFE	; 254
     3ac:	dd 4f       	sbci	r29, 0xFD	; 253

			/* Skip leading bytes */
			while (offset--)
     3ae:	03 c0       	rjmp	.+6      	; 0x3b6 <disk_readp+0x60>
				rcv_spi();
     3b0:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
		if (rc == 0xFE) { /* A data packet arrived */

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */

			/* Skip leading bytes */
			while (offset--)
     3b4:	75 01       	movw	r14, r10
     3b6:	57 01       	movw	r10, r14
     3b8:	81 e0       	ldi	r24, 0x01	; 1
     3ba:	a8 1a       	sub	r10, r24
     3bc:	b1 08       	sbc	r11, r1
     3be:	ef 28       	or	r14, r15
     3c0:	b9 f7       	brne	.-18     	; 0x3b0 <disk_readp+0x5a>
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
     3c2:	c1 14       	cp	r12, r1
     3c4:	d1 04       	cpc	r13, r1
     3c6:	69 f0       	breq	.+26     	; 0x3e2 <disk_readp+0x8c>
				do {
					*buff++ = rcv_spi();
     3c8:	76 01       	movw	r14, r12
     3ca:	ef ef       	ldi	r30, 0xFF	; 255
     3cc:	ee 1a       	sub	r14, r30
     3ce:	fe 0a       	sbc	r15, r30
     3d0:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
     3d4:	f6 01       	movw	r30, r12
     3d6:	80 83       	st	Z, r24
				} while (--count);
     3d8:	01 50       	subi	r16, 0x01	; 1
     3da:	11 09       	sbc	r17, r1
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
				do {
					*buff++ = rcv_spi();
     3dc:	67 01       	movw	r12, r14
				} while (--count);
     3de:	a1 f7       	brne	.-24     	; 0x3c8 <disk_readp+0x72>
     3e0:	03 c0       	rjmp	.+6      	; 0x3e8 <disk_readp+0x92>
			} else { /* Forward data to the outgoing stream */
				do {
					// FORWARD(rcv_spi());
				} while (--count);
     3e2:	01 50       	subi	r16, 0x01	; 1
     3e4:	11 09       	sbc	r17, r1
     3e6:	e9 f7       	brne	.-6      	; 0x3e2 <disk_readp+0x8c>
			}

			/* Skip trailing bytes and CRC */
			do
				rcv_spi();
     3e8:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
			while (--bc);
     3ec:	21 97       	sbiw	r28, 0x01	; 1
     3ee:	e1 f7       	brne	.-8      	; 0x3e8 <disk_readp+0x92>

			res = RES_OK;
     3f0:	c0 e0       	ldi	r28, 0x00	; 0
     3f2:	03 c0       	rjmp	.+6      	; 0x3fa <disk_readp+0xa4>
	UINT    bc;

	if (!(CardType & CT_BLOCK))
		sector *= 512; /* Convert to byte address if needed */

	res = RES_ERROR;
     3f4:	c1 e0       	ldi	r28, 0x01	; 1
     3f6:	01 c0       	rjmp	.+2      	; 0x3fa <disk_readp+0xa4>
     3f8:	c1 e0       	ldi	r28, 0x01	; 1

			res = RES_OK;
		}
	}

	DESELECT();
     3fa:	85 b1       	in	r24, 0x05	; 5
     3fc:	81 60       	ori	r24, 0x01	; 1
     3fe:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     400:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>

	return res;
}
     404:	8c 2f       	mov	r24, r28
     406:	df 91       	pop	r29
     408:	cf 91       	pop	r28
     40a:	1f 91       	pop	r17
     40c:	0f 91       	pop	r16
     40e:	ff 90       	pop	r15
     410:	ef 90       	pop	r14
     412:	df 90       	pop	r13
     414:	cf 90       	pop	r12
     416:	bf 90       	pop	r11
     418:	af 90       	pop	r10
     41a:	08 95       	ret

0000041c <disk_writep>:

#if _USE_WRITE
DRESULT disk_writep(const BYTE *buff, /* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
                    DWORD       sc    /* Number of bytes to send, Sector number (LBA) or zero */
)
{
     41c:	0f 93       	push	r16
     41e:	1f 93       	push	r17
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	fc 01       	movw	r30, r24
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
     426:	89 2b       	or	r24, r25
     428:	f1 f0       	breq	.+60     	; 0x466 <disk_writep+0x4a>
		bc = sc;
     42a:	ea 01       	movw	r28, r20
		while (bc && wc) { /* Send data bytes to the card */
     42c:	11 c0       	rjmp	.+34     	; 0x450 <disk_writep+0x34>
			xmit_spi(*buff++);
     42e:	8f 01       	movw	r16, r30
     430:	0f 5f       	subi	r16, 0xFF	; 255
     432:	1f 4f       	sbci	r17, 0xFF	; 255
     434:	80 81       	ld	r24, Z
     436:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
			wc--;
     43a:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <__data_end>
     43e:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <__data_end+0x1>
     442:	01 97       	sbiw	r24, 0x01	; 1
     444:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <__data_end+0x1>
     448:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <__data_end>
			bc--;
     44c:	21 97       	sbiw	r28, 0x01	; 1
	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
     44e:	f8 01       	movw	r30, r16

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
     450:	20 97       	sbiw	r28, 0x00	; 0
     452:	09 f4       	brne	.+2      	; 0x456 <disk_writep+0x3a>
     454:	5f c0       	rjmp	.+190    	; 0x514 <disk_writep+0xf8>
     456:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <__data_end>
     45a:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <__data_end+0x1>
     45e:	89 2b       	or	r24, r25
     460:	31 f7       	brne	.-52     	; 0x42e <disk_writep+0x12>
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     462:	c0 e0       	ldi	r28, 0x00	; 0
     464:	5a c0       	rjmp	.+180    	; 0x51a <disk_writep+0xfe>
	} else {
		if (sc) { /* Initiate sector write process */
     466:	41 15       	cp	r20, r1
     468:	51 05       	cpc	r21, r1
     46a:	61 05       	cpc	r22, r1
     46c:	71 05       	cpc	r23, r1
     46e:	01 f1       	breq	.+64     	; 0x4b0 <disk_writep+0x94>
			if (!(CardType & CT_BLOCK))
     470:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     474:	83 fd       	sbrc	r24, 3
     476:	09 c0       	rjmp	.+18     	; 0x48a <disk_writep+0x6e>
				sc *= 512;                  /* Convert to byte address if needed */
     478:	03 2e       	mov	r0, r19
     47a:	39 e0       	ldi	r19, 0x09	; 9
     47c:	44 0f       	add	r20, r20
     47e:	55 1f       	adc	r21, r21
     480:	66 1f       	adc	r22, r22
     482:	77 1f       	adc	r23, r23
     484:	3a 95       	dec	r19
     486:	d1 f7       	brne	.-12     	; 0x47c <disk_writep+0x60>
     488:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sc) == 0) { /* WRITE_SINGLE_BLOCK */
     48a:	88 e5       	ldi	r24, 0x58	; 88
     48c:	0e 94 86 00 	call	0x10c	; 0x10c <send_cmd>
     490:	81 11       	cpse	r24, r1
     492:	42 c0       	rjmp	.+132    	; 0x518 <disk_writep+0xfc>
				xmit_spi(0xFF);
     494:	8f ef       	ldi	r24, 0xFF	; 255
     496:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
				xmit_spi(0xFE); /* Data block header */
     49a:	8e ef       	ldi	r24, 0xFE	; 254
     49c:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
				wc  = 512;      /* Set byte counter */
     4a0:	80 e0       	ldi	r24, 0x00	; 0
     4a2:	92 e0       	ldi	r25, 0x02	; 2
     4a4:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <__data_end+0x1>
     4a8:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <__data_end>
				res = RES_OK;
     4ac:	c0 e0       	ldi	r28, 0x00	; 0
     4ae:	35 c0       	rjmp	.+106    	; 0x51a <disk_writep+0xfe>
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
     4b0:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <__data_end>
     4b4:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <__data_end+0x1>
     4b8:	02 96       	adiw	r24, 0x02	; 2
			while (bc--) {
     4ba:	04 c0       	rjmp	.+8      	; 0x4c4 <disk_writep+0xa8>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	0e 94 76 00 	call	0xec	; 0xec <xmit_spi>
				wc  = 512;      /* Set byte counter */
				res = RES_OK;
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
			while (bc--) {
     4c2:	ce 01       	movw	r24, r28
     4c4:	ec 01       	movw	r28, r24
     4c6:	21 97       	sbiw	r28, 0x01	; 1
     4c8:	89 2b       	or	r24, r25
     4ca:	c1 f7       	brne	.-16     	; 0x4bc <disk_writep+0xa0>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
			}
			do {
				res = rcv_spi();
     4cc:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
     4d0:	c8 2f       	mov	r28, r24
			} while (res == 0xFF);
     4d2:	8f 3f       	cpi	r24, 0xFF	; 255
     4d4:	d9 f3       	breq	.-10     	; 0x4cc <disk_writep+0xb0>
			if ((res & 0x1F) == 0x05) { /* Receive data resp and wait for end of write process in timeout of 500ms */
     4d6:	8f 71       	andi	r24, 0x1F	; 31
     4d8:	85 30       	cpi	r24, 0x05	; 5
     4da:	b1 f4       	brne	.+44     	; 0x508 <disk_writep+0xec>
     4dc:	09 c0       	rjmp	.+18     	; 0x4f0 <disk_writep+0xd4>
     4de:	8f e8       	ldi	r24, 0x8F	; 143
     4e0:	91 e0       	ldi	r25, 0x01	; 1
     4e2:	01 97       	sbiw	r24, 0x01	; 1
     4e4:	f1 f7       	brne	.-4      	; 0x4e2 <disk_writep+0xc6>
     4e6:	00 c0       	rjmp	.+0      	; 0x4e8 <disk_writep+0xcc>
     4e8:	00 00       	nop
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--) /* Wait for ready */
     4ea:	01 50       	subi	r16, 0x01	; 1
     4ec:	11 09       	sbc	r17, r1
     4ee:	02 c0       	rjmp	.+4      	; 0x4f4 <disk_writep+0xd8>
     4f0:	08 e8       	ldi	r16, 0x88	; 136
     4f2:	13 e1       	ldi	r17, 0x13	; 19
     4f4:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
     4f8:	8f 3f       	cpi	r24, 0xFF	; 255
     4fa:	19 f0       	breq	.+6      	; 0x502 <disk_writep+0xe6>
     4fc:	01 15       	cp	r16, r1
     4fe:	11 05       	cpc	r17, r1
     500:	71 f7       	brne	.-36     	; 0x4de <disk_writep+0xc2>
					_delay_us(100);
				if (bc)
     502:	01 2b       	or	r16, r17
     504:	09 f0       	breq	.+2      	; 0x508 <disk_writep+0xec>
					res = RES_OK;
     506:	c0 e0       	ldi	r28, 0x00	; 0
			}
			DESELECT();
     508:	85 b1       	in	r24, 0x05	; 5
     50a:	81 60       	ori	r24, 0x01	; 1
     50c:	85 b9       	out	0x05, r24	; 5
			rcv_spi();
     50e:	0e 94 82 00 	call	0x104	; 0x104 <rcv_spi>
     512:	03 c0       	rjmp	.+6      	; 0x51a <disk_writep+0xfe>
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     514:	c0 e0       	ldi	r28, 0x00	; 0
     516:	01 c0       	rjmp	.+2      	; 0x51a <disk_writep+0xfe>
{
	DRESULT     res;
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;
     518:	c1 e0       	ldi	r28, 0x01	; 1
			rcv_spi();
		}
	}

	return res;
}
     51a:	8c 2f       	mov	r24, r28
     51c:	df 91       	pop	r29
     51e:	cf 91       	pop	r28
     520:	1f 91       	pop	r17
     522:	0f 91       	pop	r16
     524:	08 95       	ret

00000526 <fill_buffer>:
void fill_buffer(void)
{
	//char* info = getCanInfo(); // haal can_bus info op en stop die waarden in de char array
	const char* string = "snelheid: ";
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     526:	20 e0       	ldi	r18, 0x00	; 0
     528:	30 e0       	ldi	r19, 0x00	; 0
     52a:	15 c0       	rjmp	.+42     	; 0x556 <fill_buffer+0x30>
	{
		write_buffer[bufferAmt++] = string[i];
     52c:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     530:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     534:	ac 01       	movw	r20, r24
     536:	4f 5f       	subi	r20, 0xFF	; 255
     538:	5f 4f       	sbci	r21, 0xFF	; 255
     53a:	50 93 ab 01 	sts	0x01AB, r21	; 0x8001ab <bufferAmt+0x1>
     53e:	40 93 aa 01 	sts	0x01AA, r20	; 0x8001aa <bufferAmt>
     542:	f9 01       	movw	r30, r18
     544:	e0 50       	subi	r30, 0x00	; 0
     546:	ff 4f       	sbci	r31, 0xFF	; 255
     548:	40 81       	ld	r20, Z
     54a:	fc 01       	movw	r30, r24
     54c:	e2 55       	subi	r30, 0x52	; 82
     54e:	fc 4f       	sbci	r31, 0xFC	; 252
     550:	40 83       	st	Z, r20
void fill_buffer(void)
{
	//char* info = getCanInfo(); // haal can_bus info op en stop die waarden in de char array
	const char* string = "snelheid: ";
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     552:	2f 5f       	subi	r18, 0xFF	; 255
     554:	3f 4f       	sbci	r19, 0xFF	; 255
     556:	2a 30       	cpi	r18, 0x0A	; 10
     558:	31 05       	cpc	r19, r1
     55a:	44 f3       	brlt	.-48     	; 0x52c <fill_buffer+0x6>
     55c:	20 e0       	ldi	r18, 0x00	; 0
     55e:	30 e0       	ldi	r19, 0x00	; 0
     560:	40 e3       	ldi	r20, 0x30	; 48
     562:	12 c0       	rjmp	.+36     	; 0x588 <fill_buffer+0x62>
	//write_buffer[bufferAmt++] = info[0];
	//write_buffer[bufferAmt++] = info[1];
	char c = 48;
	for (int i = 0; i < 10; i++)
	{
		write_buffer[bufferAmt++] = c++;
     564:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     568:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     56c:	bc 01       	movw	r22, r24
     56e:	6f 5f       	subi	r22, 0xFF	; 255
     570:	7f 4f       	sbci	r23, 0xFF	; 255
     572:	70 93 ab 01 	sts	0x01AB, r23	; 0x8001ab <bufferAmt+0x1>
     576:	60 93 aa 01 	sts	0x01AA, r22	; 0x8001aa <bufferAmt>
     57a:	fc 01       	movw	r30, r24
     57c:	e2 55       	subi	r30, 0x52	; 82
     57e:	fc 4f       	sbci	r31, 0xFC	; 252
     580:	40 83       	st	Z, r20
		write_buffer[bufferAmt++] = string[i];
	}
	//write_buffer[bufferAmt++] = info[0];
	//write_buffer[bufferAmt++] = info[1];
	char c = 48;
	for (int i = 0; i < 10; i++)
     582:	2f 5f       	subi	r18, 0xFF	; 255
     584:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		write_buffer[bufferAmt++] = c++;
     586:	4f 5f       	subi	r20, 0xFF	; 255
		write_buffer[bufferAmt++] = string[i];
	}
	//write_buffer[bufferAmt++] = info[0];
	//write_buffer[bufferAmt++] = info[1];
	char c = 48;
	for (int i = 0; i < 10; i++)
     588:	2a 30       	cpi	r18, 0x0A	; 10
     58a:	31 05       	cpc	r19, r1
     58c:	5c f3       	brlt	.-42     	; 0x564 <fill_buffer+0x3e>
	{
		write_buffer[bufferAmt++] = c++;
	}
	write_buffer[bufferAmt++] = '\n';
     58e:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     592:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     596:	9c 01       	movw	r18, r24
     598:	2f 5f       	subi	r18, 0xFF	; 255
     59a:	3f 4f       	sbci	r19, 0xFF	; 255
     59c:	30 93 ab 01 	sts	0x01AB, r19	; 0x8001ab <bufferAmt+0x1>
     5a0:	20 93 aa 01 	sts	0x01AA, r18	; 0x8001aa <bufferAmt>
     5a4:	fc 01       	movw	r30, r24
     5a6:	e2 55       	subi	r30, 0x52	; 82
     5a8:	fc 4f       	sbci	r31, 0xFC	; 252
     5aa:	4a e0       	ldi	r20, 0x0A	; 10
     5ac:	40 83       	st	Z, r20
	
	if(bufferAmt>=(512-30)) // sectorgrootte van 512 bytes - ongeveer 30 bytes (iets meer dan 2 lines)
     5ae:	22 3e       	cpi	r18, 0xE2	; 226
     5b0:	31 40       	sbci	r19, 0x01	; 1
     5b2:	3c f0       	brlt	.+14     	; 0x5c2 <fill_buffer+0x9c>
	{
		bufferAmt = 0;
     5b4:	10 92 ab 01 	sts	0x01AB, r1	; 0x8001ab <bufferAmt+0x1>
     5b8:	10 92 aa 01 	sts	0x01AA, r1	; 0x8001aa <bufferAmt>
		startWriting = true; // als dit op true staat gaat de microcontroller in de main>while(logging) in de if-statement en vult vanaf daar de sd-kaart 
     5bc:	81 e0       	ldi	r24, 0x01	; 1
     5be:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <startWriting>
     5c2:	08 95       	ret

000005c4 <writeToCard>:


void writeToCard(void)
{
	/* Set file pointer to beginning of sector */
	pf_lseek(curOffset); // offset van 0 is te vinden in sector 8.448
     5c4:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <curOffset>
     5c8:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <curOffset+0x1>
     5cc:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <curOffset+0x2>
     5d0:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <curOffset+0x3>
     5d4:	0e 94 09 0b 	call	0x1612	; 0x1612 <pf_lseek>
	/* Write buffer */
	pf_write(write_buffer, BUFFER_SIZE, &byte_counter);
     5d8:	4c ea       	ldi	r20, 0xAC	; 172
     5da:	51 e0       	ldi	r21, 0x01	; 1
     5dc:	60 e0       	ldi	r22, 0x00	; 0
     5de:	72 e0       	ldi	r23, 0x02	; 2
     5e0:	8e ea       	ldi	r24, 0xAE	; 174
     5e2:	93 e0       	ldi	r25, 0x03	; 3
     5e4:	0e 94 fd 09 	call	0x13fa	; 0x13fa <pf_write>
	if (byte_counter < BUFFER_SIZE) {
		/* End of file */
	}
	/* Finalize write */
	pf_write(0, 0, &byte_counter);
     5e8:	4c ea       	ldi	r20, 0xAC	; 172
     5ea:	51 e0       	ldi	r21, 0x01	; 1
     5ec:	60 e0       	ldi	r22, 0x00	; 0
     5ee:	70 e0       	ldi	r23, 0x00	; 0
     5f0:	80 e0       	ldi	r24, 0x00	; 0
     5f2:	90 e0       	ldi	r25, 0x00	; 0
     5f4:	0e 94 fd 09 	call	0x13fa	; 0x13fa <pf_write>
	/* Reset file pointer to beginning of sector 1 */
	pf_lseek(curOffset);
     5f8:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <curOffset>
     5fc:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <curOffset+0x1>
     600:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <curOffset+0x2>
     604:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <curOffset+0x3>
     608:	0e 94 09 0b 	call	0x1612	; 0x1612 <pf_lseek>
	/* Read back the same bytes */
	pf_read(read_buffer, BUFFER_SIZE, &byte_counter);
     60c:	4c ea       	ldi	r20, 0xAC	; 172
     60e:	51 e0       	ldi	r21, 0x01	; 1
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	72 e0       	ldi	r23, 0x02	; 2
     614:	8e ea       	ldi	r24, 0xAE	; 174
     616:	91 e0       	ldi	r25, 0x01	; 1
     618:	0e 94 1a 09 	call	0x1234	; 0x1234 <pf_read>
	/* Check they're the same */
	while (byte_counter)
     61c:	0f c0       	rjmp	.+30     	; 0x63c <writeToCard+0x78>
	{
		if (write_buffer[byte_counter] != read_buffer[byte_counter]) {
     61e:	fc 01       	movw	r30, r24
     620:	e2 55       	subi	r30, 0x52	; 82
     622:	fc 4f       	sbci	r31, 0xFC	; 252
     624:	30 81       	ld	r19, Z
     626:	fc 01       	movw	r30, r24
     628:	e2 55       	subi	r30, 0x52	; 82
     62a:	fe 4f       	sbci	r31, 0xFE	; 254
     62c:	20 81       	ld	r18, Z
     62e:	32 13       	cpse	r19, r18
     630:	ff cf       	rjmp	.-2      	; 0x630 <writeToCard+0x6c>
			while(1)
			{
				// Error
			}
		}
		byte_counter--;
     632:	01 97       	sbiw	r24, 0x01	; 1
     634:	90 93 ad 01 	sts	0x01AD, r25	; 0x8001ad <byte_counter+0x1>
     638:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <byte_counter>
	/* Reset file pointer to beginning of sector 1 */
	pf_lseek(curOffset);
	/* Read back the same bytes */
	pf_read(read_buffer, BUFFER_SIZE, &byte_counter);
	/* Check they're the same */
	while (byte_counter)
     63c:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <byte_counter>
     640:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <byte_counter+0x1>
     644:	00 97       	sbiw	r24, 0x00	; 0
     646:	59 f7       	brne	.-42     	; 0x61e <writeToCard+0x5a>
				// Error
			}
		}
		byte_counter--;
	}
	curOffset = curOffset + 512; // zet pointer naar volgende sector
     648:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <curOffset>
     64c:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <curOffset+0x1>
     650:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <curOffset+0x2>
     654:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <curOffset+0x3>
     658:	9e 5f       	subi	r25, 0xFE	; 254
     65a:	af 4f       	sbci	r26, 0xFF	; 255
     65c:	bf 4f       	sbci	r27, 0xFF	; 255
     65e:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <curOffset>
     662:	90 93 a6 01 	sts	0x01A6, r25	; 0x8001a6 <curOffset+0x1>
     666:	a0 93 a7 01 	sts	0x01A7, r26	; 0x8001a7 <curOffset+0x2>
     66a:	b0 93 a8 01 	sts	0x01A8, r27	; 0x8001a8 <curOffset+0x3>
     66e:	08 95       	ret

00000670 <find_offset>:
}

unsigned long find_offset(void)
{
     670:	cf 92       	push	r12
     672:	df 92       	push	r13
     674:	ef 92       	push	r14
     676:	ff 92       	push	r15
     678:	cf 93       	push	r28
     67a:	df 93       	push	r29
     67c:	00 d0       	rcall	.+0      	; 0x67e <find_offset+0xe>
     67e:	1f 92       	push	r1
     680:	cd b7       	in	r28, 0x3d	; 61
     682:	de b7       	in	r29, 0x3e	; 62
	// begin bij sector 0. kijk naar waarde 1e char. als die erop wijst dat de sector al geschreven is, ga naar sector 1. ga zo door. return offset als sector leeg lijkt te zijn
	uint8_t read_first[1]  = {};
     684:	19 82       	std	Y+1, r1	; 0x01
	UINT bytecounter = 1;
     686:	81 e0       	ldi	r24, 0x01	; 1
     688:	90 e0       	ldi	r25, 0x00	; 0
     68a:	9b 83       	std	Y+3, r25	; 0x03
     68c:	8a 83       	std	Y+2, r24	; 0x02
	unsigned long tempOffset = 0;
     68e:	c1 2c       	mov	r12, r1
     690:	d1 2c       	mov	r13, r1
     692:	76 01       	movw	r14, r12
	unsigned long maxOffset = 512000; // als hij geen lege sector kan vinden na de 1e 1000 sectoren
	while(1)
	{
		pf_lseek(tempOffset);
     694:	c7 01       	movw	r24, r14
     696:	b6 01       	movw	r22, r12
     698:	0e 94 09 0b 	call	0x1612	; 0x1612 <pf_lseek>
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
     69c:	ae 01       	movw	r20, r28
     69e:	4e 5f       	subi	r20, 0xFE	; 254
     6a0:	5f 4f       	sbci	r21, 0xFF	; 255
     6a2:	61 e0       	ldi	r22, 0x01	; 1
     6a4:	70 e0       	ldi	r23, 0x00	; 0
     6a6:	ce 01       	movw	r24, r28
     6a8:	01 96       	adiw	r24, 0x01	; 1
     6aa:	0e 94 1a 09 	call	0x1234	; 0x1234 <pf_read>
		if(read_first[0] == 20)
     6ae:	89 81       	ldd	r24, Y+1	; 0x01
     6b0:	84 31       	cpi	r24, 0x14	; 20
     6b2:	81 f0       	breq	.+32     	; 0x6d4 <find_offset+0x64>
		{
			return tempOffset;
		} else {
			tempOffset += 512;
     6b4:	82 e0       	ldi	r24, 0x02	; 2
     6b6:	d8 0e       	add	r13, r24
     6b8:	e1 1c       	adc	r14, r1
     6ba:	f1 1c       	adc	r15, r1
			if(tempOffset >= maxOffset)
     6bc:	c1 14       	cp	r12, r1
     6be:	80 ed       	ldi	r24, 0xD0	; 208
     6c0:	d8 06       	cpc	r13, r24
     6c2:	87 e0       	ldi	r24, 0x07	; 7
     6c4:	e8 06       	cpc	r14, r24
     6c6:	f1 04       	cpc	r15, r1
     6c8:	28 f3       	brcs	.-54     	; 0x694 <find_offset+0x24>
				break;
		}
	}
	return 0;
     6ca:	60 e0       	ldi	r22, 0x00	; 0
     6cc:	70 e0       	ldi	r23, 0x00	; 0
     6ce:	80 e0       	ldi	r24, 0x00	; 0
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	04 c0       	rjmp	.+8      	; 0x6dc <find_offset+0x6c>
	{
		pf_lseek(tempOffset);
		pf_read(read_first, 1, &bytecounter); // read first byte of sector
		if(read_first[0] == 20)
		{
			return tempOffset;
     6d4:	6c 2d       	mov	r22, r12
     6d6:	7d 2d       	mov	r23, r13
     6d8:	8e 2d       	mov	r24, r14
     6da:	9f 2d       	mov	r25, r15
			if(tempOffset >= maxOffset)
				break;
		}
	}
	return 0;
}
     6dc:	0f 90       	pop	r0
     6de:	0f 90       	pop	r0
     6e0:	0f 90       	pop	r0
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	ff 90       	pop	r15
     6e8:	ef 90       	pop	r14
     6ea:	df 90       	pop	r13
     6ec:	cf 90       	pop	r12
     6ee:	08 95       	ret

000006f0 <start_log_message>:

void start_log_message(void)
{
	const char* string = "START LOG HERE";
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     6f0:	20 e0       	ldi	r18, 0x00	; 0
     6f2:	30 e0       	ldi	r19, 0x00	; 0
     6f4:	15 c0       	rjmp	.+42     	; 0x720 <start_log_message+0x30>
	{
		write_buffer[bufferAmt++] = string[i];
     6f6:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     6fa:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     6fe:	ac 01       	movw	r20, r24
     700:	4f 5f       	subi	r20, 0xFF	; 255
     702:	5f 4f       	sbci	r21, 0xFF	; 255
     704:	50 93 ab 01 	sts	0x01AB, r21	; 0x8001ab <bufferAmt+0x1>
     708:	40 93 aa 01 	sts	0x01AA, r20	; 0x8001aa <bufferAmt>
     70c:	f9 01       	movw	r30, r18
     70e:	e5 5f       	subi	r30, 0xF5	; 245
     710:	fe 4f       	sbci	r31, 0xFE	; 254
     712:	40 81       	ld	r20, Z
     714:	fc 01       	movw	r30, r24
     716:	e2 55       	subi	r30, 0x52	; 82
     718:	fc 4f       	sbci	r31, 0xFC	; 252
     71a:	40 83       	st	Z, r20

void start_log_message(void)
{
	const char* string = "START LOG HERE";
	int length = strlen(string);
	for (int i = 0; i < length; i++)
     71c:	2f 5f       	subi	r18, 0xFF	; 255
     71e:	3f 4f       	sbci	r19, 0xFF	; 255
     720:	2e 30       	cpi	r18, 0x0E	; 14
     722:	31 05       	cpc	r19, r1
     724:	44 f3       	brlt	.-48     	; 0x6f6 <start_log_message+0x6>
	{
		write_buffer[bufferAmt++] = string[i];
	}
	write_buffer[bufferAmt++] = '\n';
     726:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     72a:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     72e:	9c 01       	movw	r18, r24
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	30 93 ab 01 	sts	0x01AB, r19	; 0x8001ab <bufferAmt+0x1>
     738:	20 93 aa 01 	sts	0x01AA, r18	; 0x8001aa <bufferAmt>
     73c:	fc 01       	movw	r30, r24
     73e:	e2 55       	subi	r30, 0x52	; 82
     740:	fc 4f       	sbci	r31, 0xFC	; 252
     742:	2a e0       	ldi	r18, 0x0A	; 10
     744:	20 83       	st	Z, r18
     746:	08 95       	ret

00000748 <init_sd_card>:
	DSTATUS status;
	FRESULT result;
	int ERROR = 0;
	/* Initialize physical drive */
	do {
		status = disk_initialize();
     748:	0e 94 cb 00 	call	0x196	; 0x196 <disk_initialize>
		if (status != 0) {
     74c:	81 11       	cpse	r24, r1
     74e:	07 c0       	rjmp	.+14     	; 0x75e <init_sd_card+0x16>
			ERROR = 1; 
		} else {
			ERROR = 0;			
			/* Set SPI clock faster after initialization */
			SPCR = (1<<MSTR) | (0<<SPR1) | (0<<SPR0) | (1<<SPE);
     750:	80 e5       	ldi	r24, 0x50	; 80
     752:	8c bd       	out	0x2c, r24	; 44
			SPSR = (1<<SPI2X); 		
     754:	81 e0       	ldi	r24, 0x01	; 1
     756:	8d bd       	out	0x2d, r24	; 45
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
		} else {
			ERROR = 0;			
     758:	80 e0       	ldi	r24, 0x00	; 0
     75a:	90 e0       	ldi	r25, 0x00	; 0
     75c:	02 c0       	rjmp	.+4      	; 0x762 <init_sd_card+0x1a>
	int ERROR = 0;
	/* Initialize physical drive */
	do {
		status = disk_initialize();
		if (status != 0) {
			ERROR = 1; 
     75e:	81 e0       	ldi	r24, 0x01	; 1
     760:	90 e0       	ldi	r25, 0x00	; 0
			//SPR1 en 0 op 0 SPI clock set to fck/4 (blaz. 174)
			//MSTR, in mastermode zetten
			//SPE, SPI enable maken.
			//SPI2X, het verdubbelen van de snelheid.			
		}
	} while (ERROR == 1);
     762:	01 97       	sbiw	r24, 0x01	; 1
     764:	89 f3       	breq	.-30     	; 0x748 <init_sd_card>

	/* Mount volume */
	result = pf_mount(&file_system);
     766:	84 eb       	ldi	r24, 0xB4	; 180
     768:	95 e0       	ldi	r25, 0x05	; 5
     76a:	0e 94 0b 07 	call	0xe16	; 0xe16 <pf_mount>
	if (result != FR_OK) {} // error

	/* Open file */
	result = pf_open("LOG.txt");
     76e:	8a e1       	ldi	r24, 0x1A	; 26
     770:	91 e0       	ldi	r25, 0x01	; 1
     772:	0e 94 ac 08 	call	0x1158	; 0x1158 <pf_open>
     776:	08 95       	ret

00000778 <main>:
char* getCanInfo(void);
	
int main(void)
{	
	_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | ((0<<CLKPS3) | (0<<CLKPS2) | (1<<CLKPS1) | (0<<CLKPS0))));
	init_sd_card(); // initialize sd-card
     778:	0e 94 a4 03 	call	0x748	; 0x748 <init_sd_card>
	init_millis(F_CPU); // init timer 
     77c:	60 e0       	ldi	r22, 0x00	; 0
     77e:	74 e2       	ldi	r23, 0x24	; 36
     780:	84 ef       	ldi	r24, 0xF4	; 244
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	0e 94 ff 03 	call	0x7fe	; 0x7fe <init_millis>
	sei();
     788:	78 94       	sei
	curOffset = find_offset(); // returnt offset van lege sector
     78a:	0e 94 38 03 	call	0x670	; 0x670 <find_offset>
     78e:	60 93 a5 01 	sts	0x01A5, r22	; 0x8001a5 <curOffset>
     792:	70 93 a6 01 	sts	0x01A6, r23	; 0x8001a6 <curOffset+0x1>
     796:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <curOffset+0x2>
     79a:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <curOffset+0x3>
	start_log_message(); // schrijf start log bericht naar de kaart zodat je kan zien wanneer de auto opnieuw aan is gezet
     79e:	0e 94 78 03 	call	0x6f0	; 0x6f0 <start_log_message>
		/*if(millis() - timer >= 1000)
		{ 	
			fill_buffer(); // 1 keer per seconde
			timer = millis();
		}*/
		fill_buffer();
     7a2:	0e 94 93 02 	call	0x526	; 0x526 <fill_buffer>
		
		if(startWriting)
     7a6:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <startWriting>
     7aa:	88 23       	and	r24, r24
     7ac:	d1 f3       	breq	.-12     	; 0x7a2 <main+0x2a>
		{
			writeToCard(); // schrijf buffer op kaart
     7ae:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <writeToCard>
     7b2:	f7 cf       	rjmp	.-18     	; 0x7a2 <main+0x2a>

000007b4 <__vector_12>:
#include <avr/interrupt.h>

#include "millis.h"

ISR(TIMER1_COMPA_vect)
{
     7b4:	1f 92       	push	r1
     7b6:	0f 92       	push	r0
     7b8:	0f b6       	in	r0, 0x3f	; 63
     7ba:	0f 92       	push	r0
     7bc:	11 24       	eor	r1, r1
     7be:	8f 93       	push	r24
     7c0:	9f 93       	push	r25
     7c2:	af 93       	push	r26
     7c4:	bf 93       	push	r27
  timer1_millis++;
     7c6:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <timer1_millis>
     7ca:	90 91 b1 05 	lds	r25, 0x05B1	; 0x8005b1 <timer1_millis+0x1>
     7ce:	a0 91 b2 05 	lds	r26, 0x05B2	; 0x8005b2 <timer1_millis+0x2>
     7d2:	b0 91 b3 05 	lds	r27, 0x05B3	; 0x8005b3 <timer1_millis+0x3>
     7d6:	01 96       	adiw	r24, 0x01	; 1
     7d8:	a1 1d       	adc	r26, r1
     7da:	b1 1d       	adc	r27, r1
     7dc:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <timer1_millis>
     7e0:	90 93 b1 05 	sts	0x05B1, r25	; 0x8005b1 <timer1_millis+0x1>
     7e4:	a0 93 b2 05 	sts	0x05B2, r26	; 0x8005b2 <timer1_millis+0x2>
     7e8:	b0 93 b3 05 	sts	0x05B3, r27	; 0x8005b3 <timer1_millis+0x3>
}
     7ec:	bf 91       	pop	r27
     7ee:	af 91       	pop	r26
     7f0:	9f 91       	pop	r25
     7f2:	8f 91       	pop	r24
     7f4:	0f 90       	pop	r0
     7f6:	0f be       	out	0x3f, r0	; 63
     7f8:	0f 90       	pop	r0
     7fa:	1f 90       	pop	r1
     7fc:	18 95       	reti

000007fe <init_millis>:

void init_millis(unsigned long f_cpu)
{
  unsigned long ctc_match_overflow;

  ctc_match_overflow = ((f_cpu / 1000) / 8); //when timer1 is this value, 1ms has passed
     7fe:	20 e4       	ldi	r18, 0x40	; 64
     800:	3f e1       	ldi	r19, 0x1F	; 31
     802:	40 e0       	ldi	r20, 0x00	; 0
     804:	50 e0       	ldi	r21, 0x00	; 0
     806:	0e 94 34 0c 	call	0x1868	; 0x1868 <__udivmodsi4>

  // (Set timer to clear when matching ctc_match_overflow) | (Set clock divisor to 8)
  TCCR1B |= (1 << WGM12) | (1 << CS11);
     80a:	e1 e8       	ldi	r30, 0x81	; 129
     80c:	f0 e0       	ldi	r31, 0x00	; 0
     80e:	80 81       	ld	r24, Z
     810:	8a 60       	ori	r24, 0x0A	; 10
     812:	80 83       	st	Z, r24

  // high byte first, then low byte
  OCR1AH = (ctc_match_overflow >> 8);
     814:	bb 27       	eor	r27, r27
     816:	a5 2f       	mov	r26, r21
     818:	94 2f       	mov	r25, r20
     81a:	83 2f       	mov	r24, r19
     81c:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
  OCR1AL = ctc_match_overflow;
     820:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

  // Enable the compare match interrupt
  TIMSK1 |= (1 << OCIE1A);
     824:	ef e6       	ldi	r30, 0x6F	; 111
     826:	f0 e0       	ldi	r31, 0x00	; 0
     828:	80 81       	ld	r24, Z
     82a:	82 60       	ori	r24, 0x02	; 2
     82c:	80 83       	st	Z, r24
     82e:	08 95       	ret

00000830 <mem_set>:

static FATFS *FatFs; /* Pointer to the file system object (logical drive) */

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
     830:	fc 01       	movw	r30, r24
	char *d = (char *)dst;
	while (cnt--)
     832:	03 c0       	rjmp	.+6      	; 0x83a <mem_set+0xa>
		*d++ = (char)val;
     834:	60 83       	st	Z, r22

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     836:	ac 01       	movw	r20, r24
		*d++ = (char)val;
     838:	31 96       	adiw	r30, 0x01	; 1

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     83a:	ca 01       	movw	r24, r20
     83c:	01 97       	sbiw	r24, 0x01	; 1
     83e:	45 2b       	or	r20, r21
     840:	c9 f7       	brne	.-14     	; 0x834 <mem_set+0x4>
		*d++ = (char)val;
}
     842:	08 95       	ret

00000844 <mem_cmp>:

/* Compare memory to memory */
static int mem_cmp(const void *dst, const void *src, int cnt)
{
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	dc 01       	movw	r26, r24
     84a:	fb 01       	movw	r30, r22
	const char *d = (const char *)dst, *s = (const char *)src;
	int         r = 0;
     84c:	80 e0       	ldi	r24, 0x00	; 0
     84e:	90 e0       	ldi	r25, 0x00	; 0
	while (cnt-- && (r = *d++ - *s++) == 0)
     850:	02 c0       	rjmp	.+4      	; 0x856 <mem_cmp+0x12>
     852:	fb 01       	movw	r30, r22
     854:	de 01       	movw	r26, r28
     856:	9a 01       	movw	r18, r20
     858:	21 50       	subi	r18, 0x01	; 1
     85a:	31 09       	sbc	r19, r1
     85c:	45 2b       	or	r20, r21
     85e:	61 f0       	breq	.+24     	; 0x878 <mem_cmp+0x34>
     860:	ed 01       	movw	r28, r26
     862:	21 96       	adiw	r28, 0x01	; 1
     864:	8c 91       	ld	r24, X
     866:	90 e0       	ldi	r25, 0x00	; 0
     868:	bf 01       	movw	r22, r30
     86a:	6f 5f       	subi	r22, 0xFF	; 255
     86c:	7f 4f       	sbci	r23, 0xFF	; 255
     86e:	40 81       	ld	r20, Z
     870:	84 1b       	sub	r24, r20
     872:	91 09       	sbc	r25, r1
     874:	a9 01       	movw	r20, r18
     876:	69 f3       	breq	.-38     	; 0x852 <mem_cmp+0xe>
		;
	return r;
}
     878:	df 91       	pop	r29
     87a:	cf 91       	pop	r28
     87c:	08 95       	ret

0000087e <clust2sect>:
/*-----------------------------------------------------------------------*/

static DWORD clust2sect(           /* !=0: Sector number, 0: Failed - invalid cluster# */
                        CLUST clst /* Cluster# to be converted */
)
{
     87e:	0f 93       	push	r16
     880:	1f 93       	push	r17
	FATFS *fs = FatFs;
     882:	e0 91 ae 05 	lds	r30, 0x05AE	; 0x8005ae <FatFs>
     886:	f0 91 af 05 	lds	r31, 0x05AF	; 0x8005af <FatFs+0x1>

	clst -= 2;
     88a:	9b 01       	movw	r18, r22
     88c:	ac 01       	movw	r20, r24
     88e:	22 50       	subi	r18, 0x02	; 2
     890:	31 09       	sbc	r19, r1
     892:	41 09       	sbc	r20, r1
     894:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2))
     896:	86 81       	ldd	r24, Z+6	; 0x06
     898:	97 81       	ldd	r25, Z+7	; 0x07
     89a:	a0 85       	ldd	r26, Z+8	; 0x08
     89c:	b1 85       	ldd	r27, Z+9	; 0x09
     89e:	02 97       	sbiw	r24, 0x02	; 2
     8a0:	a1 09       	sbc	r26, r1
     8a2:	b1 09       	sbc	r27, r1
     8a4:	28 17       	cp	r18, r24
     8a6:	39 07       	cpc	r19, r25
     8a8:	4a 07       	cpc	r20, r26
     8aa:	5b 07       	cpc	r21, r27
     8ac:	68 f4       	brcc	.+26     	; 0x8c8 <clust2sect+0x4a>
		return 0; /* Invalid cluster# */
	return (DWORD)clst * fs->csize + fs->database;
     8ae:	a2 81       	ldd	r26, Z+2	; 0x02
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	0e 94 56 0c 	call	0x18ac	; 0x18ac <__muluhisi3>
     8b6:	02 89       	ldd	r16, Z+18	; 0x12
     8b8:	13 89       	ldd	r17, Z+19	; 0x13
     8ba:	24 89       	ldd	r18, Z+20	; 0x14
     8bc:	35 89       	ldd	r19, Z+21	; 0x15
     8be:	60 0f       	add	r22, r16
     8c0:	71 1f       	adc	r23, r17
     8c2:	82 1f       	adc	r24, r18
     8c4:	93 1f       	adc	r25, r19
     8c6:	03 c0       	rjmp	.+6      	; 0x8ce <clust2sect+0x50>
{
	FATFS *fs = FatFs;

	clst -= 2;
	if (clst >= (fs->n_fatent - 2))
		return 0; /* Invalid cluster# */
     8c8:	60 e0       	ldi	r22, 0x00	; 0
     8ca:	70 e0       	ldi	r23, 0x00	; 0
     8cc:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     8ce:	1f 91       	pop	r17
     8d0:	0f 91       	pop	r16
     8d2:	08 95       	ret

000008d4 <get_clust>:

static CLUST get_clust(BYTE *dir /* Pointer to directory entry */
)
{
     8d4:	0f 93       	push	r16
     8d6:	1f 93       	push	r17
     8d8:	fc 01       	movw	r30, r24
	FATFS *fs   = FatFs;
	CLUST  clst = 0;

	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
		clst = LD_WORD(dir + DIR_FstClusHI);
     8da:	65 89       	ldd	r22, Z+21	; 0x15
     8dc:	70 e0       	ldi	r23, 0x00	; 0
     8de:	76 2f       	mov	r23, r22
     8e0:	66 27       	eor	r22, r22
     8e2:	84 89       	ldd	r24, Z+20	; 0x14
     8e4:	68 2b       	or	r22, r24
     8e6:	cb 01       	movw	r24, r22
     8e8:	a0 e0       	ldi	r26, 0x00	; 0
     8ea:	b0 e0       	ldi	r27, 0x00	; 0
		clst <<= 16;
     8ec:	bc 01       	movw	r22, r24
     8ee:	55 27       	eor	r21, r21
     8f0:	44 27       	eor	r20, r20
	}
	clst |= LD_WORD(dir + DIR_FstClusLO);
     8f2:	83 8d       	ldd	r24, Z+27	; 0x1b
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	98 2f       	mov	r25, r24
     8f8:	88 27       	eor	r24, r24
     8fa:	22 8d       	ldd	r18, Z+26	; 0x1a
     8fc:	82 2b       	or	r24, r18
     8fe:	a0 e0       	ldi	r26, 0x00	; 0
     900:	b0 e0       	ldi	r27, 0x00	; 0
     902:	8c 01       	movw	r16, r24
     904:	9d 01       	movw	r18, r26
     906:	04 2b       	or	r16, r20
     908:	15 2b       	or	r17, r21
     90a:	26 2b       	or	r18, r22
     90c:	37 2b       	or	r19, r23
     90e:	c9 01       	movw	r24, r18
     910:	b8 01       	movw	r22, r16

	return clst;
}
     912:	1f 91       	pop	r17
     914:	0f 91       	pop	r16
     916:	08 95       	ret

00000918 <dir_rewind>:
/* Directory handling - Rewind directory index                           */
/*-----------------------------------------------------------------------*/

static FRESULT dir_rewind(DIR *dj /* Pointer to directory object */
)
{
     918:	0f 93       	push	r16
     91a:	1f 93       	push	r17
     91c:	cf 93       	push	r28
     91e:	df 93       	push	r29
     920:	fc 01       	movw	r30, r24
	CLUST  clst;
	FATFS *fs = FatFs;
     922:	a0 91 ae 05 	lds	r26, 0x05AE	; 0x8005ae <FatFs>
     926:	b0 91 af 05 	lds	r27, 0x05AF	; 0x8005af <FatFs+0x1>

	dj->index = 0;
     92a:	11 82       	std	Z+1, r1	; 0x01
     92c:	10 82       	st	Z, r1
	clst      = dj->sclust;
     92e:	64 81       	ldd	r22, Z+4	; 0x04
     930:	75 81       	ldd	r23, Z+5	; 0x05
     932:	86 81       	ldd	r24, Z+6	; 0x06
     934:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
     936:	61 30       	cpi	r22, 0x01	; 1
     938:	71 05       	cpc	r23, r1
     93a:	81 05       	cpc	r24, r1
     93c:	91 05       	cpc	r25, r1
     93e:	19 f1       	breq	.+70     	; 0x986 <dir_rewind+0x6e>
     940:	16 96       	adiw	r26, 0x06	; 6
     942:	0d 91       	ld	r16, X+
     944:	1d 91       	ld	r17, X+
     946:	2d 91       	ld	r18, X+
     948:	3c 91       	ld	r19, X
     94a:	19 97       	sbiw	r26, 0x09	; 9
     94c:	60 17       	cp	r22, r16
     94e:	71 07       	cpc	r23, r17
     950:	82 07       	cpc	r24, r18
     952:	93 07       	cpc	r25, r19
     954:	d0 f4       	brcc	.+52     	; 0x98a <dir_rewind+0x72>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst
     956:	61 15       	cp	r22, r1
     958:	71 05       	cpc	r23, r1
     95a:	81 05       	cpc	r24, r1
     95c:	91 05       	cpc	r25, r1
     95e:	31 f4       	brne	.+12     	; 0x96c <dir_rewind+0x54>
	    && (_FS_32ONLY || fs->fs_type == FS_FAT32)) /* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
     960:	1e 96       	adiw	r26, 0x0e	; 14
     962:	6d 91       	ld	r22, X+
     964:	7d 91       	ld	r23, X+
     966:	8d 91       	ld	r24, X+
     968:	9c 91       	ld	r25, X
     96a:	51 97       	sbiw	r26, 0x11	; 17
     96c:	ef 01       	movw	r28, r30
	dj->clust = clst;                                                  /* Current cluster */
     96e:	60 87       	std	Z+8, r22	; 0x08
     970:	71 87       	std	Z+9, r23	; 0x09
     972:	82 87       	std	Z+10, r24	; 0x0a
     974:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */
     976:	0e 94 3f 04 	call	0x87e	; 0x87e <clust2sect>
     97a:	6c 87       	std	Y+12, r22	; 0x0c
     97c:	7d 87       	std	Y+13, r23	; 0x0d
     97e:	8e 87       	std	Y+14, r24	; 0x0e
     980:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK; /* Seek succeeded */
     982:	80 e0       	ldi	r24, 0x00	; 0
     984:	03 c0       	rjmp	.+6      	; 0x98c <dir_rewind+0x74>
	FATFS *fs = FatFs;

	dj->index = 0;
	clst      = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
		return FR_DISK_ERR;
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	01 c0       	rjmp	.+2      	; 0x98c <dir_rewind+0x74>
     98a:	81 e0       	ldi	r24, 0x01	; 1
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;                                                  /* Current cluster */
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */

	return FR_OK; /* Seek succeeded */
}
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	1f 91       	pop	r17
     992:	0f 91       	pop	r16
     994:	08 95       	ret

00000996 <create_name>:
/*-----------------------------------------------------------------------*/

static FRESULT create_name(DIR *        dj,  /* Pointer to the directory object */
                           const char **path /* Pointer to pointer to the segment in the path string */
)
{
     996:	0f 93       	push	r16
     998:	1f 93       	push	r17
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	eb 01       	movw	r28, r22
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
     9a0:	fc 01       	movw	r30, r24
     9a2:	02 81       	ldd	r16, Z+2	; 0x02
     9a4:	13 81       	ldd	r17, Z+3	; 0x03
	mem_set(sfn, ' ', 11);
     9a6:	4b e0       	ldi	r20, 0x0B	; 11
     9a8:	50 e0       	ldi	r21, 0x00	; 0
     9aa:	60 e2       	ldi	r22, 0x20	; 32
     9ac:	70 e0       	ldi	r23, 0x00	; 0
     9ae:	c8 01       	movw	r24, r16
     9b0:	0e 94 18 04 	call	0x830	; 0x830 <mem_set>
	si = i = 0;
	ni     = 8;
	p      = *path;
     9b4:	28 81       	ld	r18, Y
     9b6:	39 81       	ldd	r19, Y+1	; 0x01
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0;
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	80 e0       	ldi	r24, 0x00	; 0
	ni     = 8;
     9bc:	58 e0       	ldi	r21, 0x08	; 8
     9be:	01 c0       	rjmp	.+2      	; 0x9c2 <create_name+0x2c>
     9c0:	84 2f       	mov	r24, r20
	p      = *path;
	for (;;) {
		c = p[si++];
     9c2:	41 e0       	ldi	r20, 0x01	; 1
     9c4:	48 0f       	add	r20, r24
     9c6:	f9 01       	movw	r30, r18
     9c8:	e8 0f       	add	r30, r24
     9ca:	f1 1d       	adc	r31, r1
     9cc:	e0 81       	ld	r30, Z
		if (c <= ' ' || c == '/')
     9ce:	e1 32       	cpi	r30, 0x21	; 33
     9d0:	f0 f0       	brcs	.+60     	; 0xa0e <create_name+0x78>
     9d2:	ef 32       	cpi	r30, 0x2F	; 47
     9d4:	e1 f0       	breq	.+56     	; 0xa0e <create_name+0x78>
			break; /* Break on end of segment */
		if (c == '.' || i >= ni) {
     9d6:	ee 32       	cpi	r30, 0x2E	; 46
     9d8:	11 f0       	breq	.+4      	; 0x9de <create_name+0x48>
     9da:	95 17       	cp	r25, r21
     9dc:	38 f0       	brcs	.+14     	; 0x9ec <create_name+0x56>
			if (ni != 8 || c != '.')
     9de:	58 30       	cpi	r21, 0x08	; 8
     9e0:	b1 f4       	brne	.+44     	; 0xa0e <create_name+0x78>
     9e2:	ee 32       	cpi	r30, 0x2E	; 46
     9e4:	a1 f4       	brne	.+40     	; 0xa0e <create_name+0x78>
				break;
			i  = 8;
     9e6:	98 e0       	ldi	r25, 0x08	; 8
			ni = 11;
     9e8:	5b e0       	ldi	r21, 0x0B	; 11
     9ea:	ea cf       	rjmp	.-44     	; 0x9c0 <create_name+0x2a>
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80) /* To upper extended char (SBCS) */
     9ec:	ee 23       	and	r30, r30
     9ee:	24 f4       	brge	.+8      	; 0x9f8 <create_name+0x62>
			c = cvt[c - 0x80];
     9f0:	f0 e0       	ldi	r31, 0x00	; 0
     9f2:	ee 55       	subi	r30, 0x5E	; 94
     9f4:	ff 4f       	sbci	r31, 0xFF	; 255
     9f6:	e0 81       	ld	r30, Z
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{ /* Single byte code */
			if (_USE_LCC && IsLower(c))
     9f8:	8f e9       	ldi	r24, 0x9F	; 159
     9fa:	8e 0f       	add	r24, r30
     9fc:	8a 31       	cpi	r24, 0x1A	; 26
     9fe:	08 f4       	brcc	.+2      	; 0xa02 <create_name+0x6c>
				c -= 0x20; /* toupper */
     a00:	e0 52       	subi	r30, 0x20	; 32
			sfn[i++] = c;
     a02:	d8 01       	movw	r26, r16
     a04:	a9 0f       	add	r26, r25
     a06:	b1 1d       	adc	r27, r1
     a08:	ec 93       	st	X, r30
     a0a:	9f 5f       	subi	r25, 0xFF	; 255
     a0c:	d9 cf       	rjmp	.-78     	; 0x9c0 <create_name+0x2a>
		}
	}
	*path = &p[si]; /* Rerurn pointer to the next segment */
     a0e:	24 0f       	add	r18, r20
     a10:	31 1d       	adc	r19, r1
     a12:	39 83       	std	Y+1, r19	; 0x01
     a14:	28 83       	st	Y, r18

	sfn[11] = (c <= ' ') ? 1 : 0; /* Set last segment flag if end of path */
     a16:	81 e0       	ldi	r24, 0x01	; 1
     a18:	e1 32       	cpi	r30, 0x21	; 33
     a1a:	08 f0       	brcs	.+2      	; 0xa1e <create_name+0x88>
     a1c:	80 e0       	ldi	r24, 0x00	; 0
     a1e:	f8 01       	movw	r30, r16
     a20:	83 87       	std	Z+11, r24	; 0x0b

	return FR_OK;
}
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	df 91       	pop	r29
     a26:	cf 91       	pop	r28
     a28:	1f 91       	pop	r17
     a2a:	0f 91       	pop	r16
     a2c:	08 95       	ret

00000a2e <check_fs>:

static BYTE check_fs(/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     a2e:	cf 92       	push	r12
     a30:	df 92       	push	r13
     a32:	ef 92       	push	r14
     a34:	ff 92       	push	r15
     a36:	0f 93       	push	r16
     a38:	1f 93       	push	r17
     a3a:	cf 93       	push	r28
     a3c:	df 93       	push	r29
     a3e:	ec 01       	movw	r28, r24
     a40:	6a 01       	movw	r12, r20
     a42:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
     a44:	02 e0       	ldi	r16, 0x02	; 2
     a46:	10 e0       	ldi	r17, 0x00	; 0
     a48:	2e ef       	ldi	r18, 0xFE	; 254
     a4a:	31 e0       	ldi	r19, 0x01	; 1
     a4c:	0e 94 ab 01 	call	0x356	; 0x356 <disk_readp>
     a50:	81 11       	cpse	r24, r1
     a52:	1d c0       	rjmp	.+58     	; 0xa8e <check_fs+0x60>
		return 3;
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
     a54:	89 81       	ldd	r24, Y+1	; 0x01
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	98 2f       	mov	r25, r24
     a5a:	88 27       	eor	r24, r24
     a5c:	28 81       	ld	r18, Y
     a5e:	82 2b       	or	r24, r18
     a60:	85 35       	cpi	r24, 0x55	; 85
     a62:	9a 4a       	sbci	r25, 0xAA	; 170
     a64:	b1 f4       	brne	.+44     	; 0xa92 <check_fs+0x64>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
     a66:	22 e5       	ldi	r18, 0x52	; 82
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	b7 01       	movw	r22, r14
     a6c:	a6 01       	movw	r20, r12
     a6e:	ce 01       	movw	r24, r28
     a70:	0e 94 ab 01 	call	0x356	; 0x356 <disk_readp>
     a74:	81 11       	cpse	r24, r1
     a76:	0f c0       	rjmp	.+30     	; 0xa96 <check_fs+0x68>
     a78:	89 81       	ldd	r24, Y+1	; 0x01
     a7a:	90 e0       	ldi	r25, 0x00	; 0
     a7c:	98 2f       	mov	r25, r24
     a7e:	88 27       	eor	r24, r24
     a80:	28 81       	ld	r18, Y
     a82:	82 2b       	or	r24, r18
     a84:	86 34       	cpi	r24, 0x46	; 70
     a86:	91 44       	sbci	r25, 0x41	; 65
     a88:	41 f0       	breq	.+16     	; 0xa9a <check_fs+0x6c>
		return 0;
	return 1;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	07 c0       	rjmp	.+14     	; 0xa9c <check_fs+0x6e>
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
		return 3;
     a8e:	83 e0       	ldi	r24, 0x03	; 3
     a90:	05 c0       	rjmp	.+10     	; 0xa9c <check_fs+0x6e>
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
		return 2;
     a92:	82 e0       	ldi	r24, 0x02	; 2
     a94:	03 c0       	rjmp	.+6      	; 0xa9c <check_fs+0x6e>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
	return 1;
     a96:	81 e0       	ldi	r24, 0x01	; 1
     a98:	01 c0       	rjmp	.+2      	; 0xa9c <check_fs+0x6e>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
     a9a:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
     a9c:	df 91       	pop	r29
     a9e:	cf 91       	pop	r28
     aa0:	1f 91       	pop	r17
     aa2:	0f 91       	pop	r16
     aa4:	ff 90       	pop	r15
     aa6:	ef 90       	pop	r14
     aa8:	df 90       	pop	r13
     aaa:	cf 90       	pop	r12
     aac:	08 95       	ret

00000aae <get_fat>:
/*-----------------------------------------------------------------------*/

static CLUST get_fat(           /* 1:IO error, Else:Cluster status */
                     CLUST clst /* Cluster# to get the link information */
)
{
     aae:	cf 92       	push	r12
     ab0:	df 92       	push	r13
     ab2:	ef 92       	push	r14
     ab4:	ff 92       	push	r15
     ab6:	0f 93       	push	r16
     ab8:	1f 93       	push	r17
     aba:	cf 93       	push	r28
     abc:	df 93       	push	r29
     abe:	00 d0       	rcall	.+0      	; 0xac0 <get_fat+0x12>
     ac0:	00 d0       	rcall	.+0      	; 0xac2 <get_fat+0x14>
     ac2:	cd b7       	in	r28, 0x3d	; 61
     ac4:	de b7       	in	r29, 0x3e	; 62
	BYTE   buf[4];
	FATFS *fs = FatFs;
     ac6:	e0 91 ae 05 	lds	r30, 0x05AE	; 0x8005ae <FatFs>
     aca:	f0 91 af 05 	lds	r31, 0x05AF	; 0x8005af <FatFs+0x1>

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
     ace:	62 30       	cpi	r22, 0x02	; 2
     ad0:	71 05       	cpc	r23, r1
     ad2:	81 05       	cpc	r24, r1
     ad4:	91 05       	cpc	r25, r1
     ad6:	08 f4       	brcc	.+2      	; 0xada <get_fat+0x2c>
     ad8:	56 c0       	rjmp	.+172    	; 0xb86 <get_fat+0xd8>
     ada:	06 81       	ldd	r16, Z+6	; 0x06
     adc:	17 81       	ldd	r17, Z+7	; 0x07
     ade:	20 85       	ldd	r18, Z+8	; 0x08
     ae0:	31 85       	ldd	r19, Z+9	; 0x09
     ae2:	60 17       	cp	r22, r16
     ae4:	71 07       	cpc	r23, r17
     ae6:	82 07       	cpc	r24, r18
     ae8:	93 07       	cpc	r25, r19
     aea:	08 f0       	brcs	.+2      	; 0xaee <get_fat+0x40>
     aec:	51 c0       	rjmp	.+162    	; 0xb90 <get_fat+0xe2>
		return 1;

	switch (fs->fs_type) {
     aee:	20 81       	ld	r18, Z
     af0:	23 30       	cpi	r18, 0x03	; 3
     af2:	09 f0       	breq	.+2      	; 0xaf6 <get_fat+0x48>
     af4:	52 c0       	rjmp	.+164    	; 0xb9a <get_fat+0xec>
     af6:	dc 01       	movw	r26, r24
     af8:	cb 01       	movw	r24, r22
			break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32:
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4))
     afa:	9c 01       	movw	r18, r24
     afc:	2f 77       	andi	r18, 0x7F	; 127
     afe:	33 27       	eor	r19, r19
     b00:	c2 84       	ldd	r12, Z+10	; 0x0a
     b02:	d3 84       	ldd	r13, Z+11	; 0x0b
     b04:	e4 84       	ldd	r14, Z+12	; 0x0c
     b06:	f5 84       	ldd	r15, Z+13	; 0x0d
     b08:	68 94       	set
     b0a:	16 f8       	bld	r1, 6
     b0c:	b6 95       	lsr	r27
     b0e:	a7 95       	ror	r26
     b10:	97 95       	ror	r25
     b12:	87 95       	ror	r24
     b14:	16 94       	lsr	r1
     b16:	d1 f7       	brne	.-12     	; 0xb0c <get_fat+0x5e>
     b18:	22 0f       	add	r18, r18
     b1a:	33 1f       	adc	r19, r19
     b1c:	22 0f       	add	r18, r18
     b1e:	33 1f       	adc	r19, r19
     b20:	b7 01       	movw	r22, r14
     b22:	a6 01       	movw	r20, r12
     b24:	48 0f       	add	r20, r24
     b26:	59 1f       	adc	r21, r25
     b28:	6a 1f       	adc	r22, r26
     b2a:	7b 1f       	adc	r23, r27
     b2c:	04 e0       	ldi	r16, 0x04	; 4
     b2e:	10 e0       	ldi	r17, 0x00	; 0
     b30:	ce 01       	movw	r24, r28
     b32:	01 96       	adiw	r24, 0x01	; 1
     b34:	0e 94 ab 01 	call	0x356	; 0x356 <disk_readp>
     b38:	81 11       	cpse	r24, r1
     b3a:	34 c0       	rjmp	.+104    	; 0xba4 <get_fat+0xf6>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
     b3c:	8c 81       	ldd	r24, Y+4	; 0x04
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	a0 e0       	ldi	r26, 0x00	; 0
     b42:	b0 e0       	ldi	r27, 0x00	; 0
     b44:	78 2f       	mov	r23, r24
     b46:	66 27       	eor	r22, r22
     b48:	55 27       	eor	r21, r21
     b4a:	44 27       	eor	r20, r20
     b4c:	9b 81       	ldd	r25, Y+3	; 0x03
     b4e:	89 2f       	mov	r24, r25
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	a0 e0       	ldi	r26, 0x00	; 0
     b54:	b0 e0       	ldi	r27, 0x00	; 0
     b56:	dc 01       	movw	r26, r24
     b58:	99 27       	eor	r25, r25
     b5a:	88 27       	eor	r24, r24
     b5c:	84 2b       	or	r24, r20
     b5e:	95 2b       	or	r25, r21
     b60:	a6 2b       	or	r26, r22
     b62:	b7 2b       	or	r27, r23
     b64:	6a 81       	ldd	r22, Y+2	; 0x02
     b66:	70 e0       	ldi	r23, 0x00	; 0
     b68:	76 2f       	mov	r23, r22
     b6a:	66 27       	eor	r22, r22
     b6c:	ab 01       	movw	r20, r22
     b6e:	60 e0       	ldi	r22, 0x00	; 0
     b70:	70 e0       	ldi	r23, 0x00	; 0
     b72:	84 2b       	or	r24, r20
     b74:	95 2b       	or	r25, r21
     b76:	a6 2b       	or	r26, r22
     b78:	b7 2b       	or	r27, r23
     b7a:	29 81       	ldd	r18, Y+1	; 0x01
     b7c:	82 2b       	or	r24, r18
     b7e:	bc 01       	movw	r22, r24
     b80:	cd 01       	movw	r24, r26
     b82:	9f 70       	andi	r25, 0x0F	; 15
     b84:	13 c0       	rjmp	.+38     	; 0xbac <get_fat+0xfe>
{
	BYTE   buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
		return 1;
     b86:	61 e0       	ldi	r22, 0x01	; 1
     b88:	70 e0       	ldi	r23, 0x00	; 0
     b8a:	80 e0       	ldi	r24, 0x00	; 0
     b8c:	90 e0       	ldi	r25, 0x00	; 0
     b8e:	0e c0       	rjmp	.+28     	; 0xbac <get_fat+0xfe>
     b90:	61 e0       	ldi	r22, 0x01	; 1
     b92:	70 e0       	ldi	r23, 0x00	; 0
     b94:	80 e0       	ldi	r24, 0x00	; 0
     b96:	90 e0       	ldi	r25, 0x00	; 0
     b98:	09 c0       	rjmp	.+18     	; 0xbac <get_fat+0xfe>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1; /* An error occured at the disk I/O layer */
     b9a:	61 e0       	ldi	r22, 0x01	; 1
     b9c:	70 e0       	ldi	r23, 0x00	; 0
     b9e:	80 e0       	ldi	r24, 0x00	; 0
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	04 c0       	rjmp	.+8      	; 0xbac <get_fat+0xfe>
     ba4:	61 e0       	ldi	r22, 0x01	; 1
     ba6:	70 e0       	ldi	r23, 0x00	; 0
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	90 e0       	ldi	r25, 0x00	; 0
}
     bac:	0f 90       	pop	r0
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	1f 91       	pop	r17
     bba:	0f 91       	pop	r16
     bbc:	ff 90       	pop	r15
     bbe:	ef 90       	pop	r14
     bc0:	df 90       	pop	r13
     bc2:	cf 90       	pop	r12
     bc4:	08 95       	ret

00000bc6 <dir_next>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_next(        /* FR_OK:Succeeded, FR_NO_FILE:End of table */
                        DIR *dj /* Pointer to directory object */
)
{
     bc6:	cf 92       	push	r12
     bc8:	df 92       	push	r13
     bca:	ef 92       	push	r14
     bcc:	ff 92       	push	r15
     bce:	0f 93       	push	r16
     bd0:	1f 93       	push	r17
     bd2:	cf 93       	push	r28
     bd4:	df 93       	push	r29
	CLUST  clst;
	WORD   i;
	FATFS *fs = FatFs;
     bd6:	e0 90 ae 05 	lds	r14, 0x05AE	; 0x8005ae <FatFs>
     bda:	f0 90 af 05 	lds	r15, 0x05AF	; 0x8005af <FatFs+0x1>

	i = dj->index + 1;
     bde:	fc 01       	movw	r30, r24
     be0:	c0 81       	ld	r28, Z
     be2:	d1 81       	ldd	r29, Z+1	; 0x01
     be4:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
     be6:	09 f4       	brne	.+2      	; 0xbea <dir_next+0x24>
     be8:	5c c0       	rjmp	.+184    	; 0xca2 <dir_next+0xdc>
     bea:	44 85       	ldd	r20, Z+12	; 0x0c
     bec:	55 85       	ldd	r21, Z+13	; 0x0d
     bee:	66 85       	ldd	r22, Z+14	; 0x0e
     bf0:	77 85       	ldd	r23, Z+15	; 0x0f
     bf2:	41 15       	cp	r20, r1
     bf4:	51 05       	cpc	r21, r1
     bf6:	61 05       	cpc	r22, r1
     bf8:	71 05       	cpc	r23, r1
     bfa:	09 f4       	brne	.+2      	; 0xbfe <dir_next+0x38>
     bfc:	54 c0       	rjmp	.+168    	; 0xca6 <dir_next+0xe0>
     bfe:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i % 16)) { /* Sector changed? */
     c00:	ce 01       	movw	r24, r28
     c02:	8f 70       	andi	r24, 0x0F	; 15
     c04:	99 27       	eor	r25, r25
     c06:	89 2b       	or	r24, r25
     c08:	09 f0       	breq	.+2      	; 0xc0c <dir_next+0x46>
     c0a:	46 c0       	rjmp	.+140    	; 0xc98 <dir_next+0xd2>
		dj->sect++;  /* Next sector */
     c0c:	4f 5f       	subi	r20, 0xFF	; 255
     c0e:	5f 4f       	sbci	r21, 0xFF	; 255
     c10:	6f 4f       	sbci	r22, 0xFF	; 255
     c12:	7f 4f       	sbci	r23, 0xFF	; 255
     c14:	44 87       	std	Z+12, r20	; 0x0c
     c16:	55 87       	std	Z+13, r21	; 0x0d
     c18:	66 87       	std	Z+14, r22	; 0x0e
     c1a:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {       /* Static table */
     c1c:	40 85       	ldd	r20, Z+8	; 0x08
     c1e:	51 85       	ldd	r21, Z+9	; 0x09
     c20:	62 85       	ldd	r22, Z+10	; 0x0a
     c22:	73 85       	ldd	r23, Z+11	; 0x0b
     c24:	41 15       	cp	r20, r1
     c26:	51 05       	cpc	r21, r1
     c28:	61 05       	cpc	r22, r1
     c2a:	71 05       	cpc	r23, r1
     c2c:	39 f4       	brne	.+14     	; 0xc3c <dir_next+0x76>
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
     c2e:	f7 01       	movw	r30, r14
     c30:	84 81       	ldd	r24, Z+4	; 0x04
     c32:	95 81       	ldd	r25, Z+5	; 0x05
     c34:	c8 17       	cp	r28, r24
     c36:	d9 07       	cpc	r29, r25
     c38:	c0 f5       	brcc	.+112    	; 0xcaa <dir_next+0xe4>
     c3a:	2e c0       	rjmp	.+92     	; 0xc98 <dir_next+0xd2>
				return FR_NO_FILE;
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
     c3c:	f7 01       	movw	r30, r14
     c3e:	82 81       	ldd	r24, Z+2	; 0x02
     c40:	90 e0       	ldi	r25, 0x00	; 0
     c42:	01 97       	sbiw	r24, 0x01	; 1
     c44:	9e 01       	movw	r18, r28
     c46:	32 95       	swap	r19
     c48:	22 95       	swap	r18
     c4a:	2f 70       	andi	r18, 0x0F	; 15
     c4c:	23 27       	eor	r18, r19
     c4e:	3f 70       	andi	r19, 0x0F	; 15
     c50:	23 27       	eor	r18, r19
     c52:	82 23       	and	r24, r18
     c54:	93 23       	and	r25, r19
     c56:	89 2b       	or	r24, r25
     c58:	f9 f4       	brne	.+62     	; 0xc98 <dir_next+0xd2>
				clst = get_fat(dj->clust);           /* Get next cluster */
     c5a:	cb 01       	movw	r24, r22
     c5c:	ba 01       	movw	r22, r20
     c5e:	0e 94 57 05 	call	0xaae	; 0xaae <get_fat>
				if (clst <= 1)
     c62:	62 30       	cpi	r22, 0x02	; 2
     c64:	71 05       	cpc	r23, r1
     c66:	81 05       	cpc	r24, r1
     c68:	91 05       	cpc	r25, r1
     c6a:	08 f1       	brcs	.+66     	; 0xcae <dir_next+0xe8>
					return FR_DISK_ERR;
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
     c6c:	f7 01       	movw	r30, r14
     c6e:	c6 80       	ldd	r12, Z+6	; 0x06
     c70:	d7 80       	ldd	r13, Z+7	; 0x07
     c72:	e0 84       	ldd	r14, Z+8	; 0x08
     c74:	f1 84       	ldd	r15, Z+9	; 0x09
     c76:	6c 15       	cp	r22, r12
     c78:	7d 05       	cpc	r23, r13
     c7a:	8e 05       	cpc	r24, r14
     c7c:	9f 05       	cpc	r25, r15
     c7e:	c8 f4       	brcc	.+50     	; 0xcb2 <dir_next+0xec>
					return FR_NO_FILE;    /* Report EOT */
				dj->clust = clst;         /* Initialize data for new cluster */
     c80:	f8 01       	movw	r30, r16
     c82:	60 87       	std	Z+8, r22	; 0x08
     c84:	71 87       	std	Z+9, r23	; 0x09
     c86:	82 87       	std	Z+10, r24	; 0x0a
     c88:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect  = clust2sect(clst);
     c8a:	0e 94 3f 04 	call	0x87e	; 0x87e <clust2sect>
     c8e:	f8 01       	movw	r30, r16
     c90:	64 87       	std	Z+12, r22	; 0x0c
     c92:	75 87       	std	Z+13, r23	; 0x0d
     c94:	86 87       	std	Z+14, r24	; 0x0e
     c96:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
     c98:	f8 01       	movw	r30, r16
     c9a:	d1 83       	std	Z+1, r29	; 0x01
     c9c:	c0 83       	st	Z, r28

	return FR_OK;
     c9e:	80 e0       	ldi	r24, 0x00	; 0
     ca0:	09 c0       	rjmp	.+18     	; 0xcb4 <dir_next+0xee>
	WORD   i;
	FATFS *fs = FatFs;

	i = dj->index + 1;
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
     ca2:	83 e0       	ldi	r24, 0x03	; 3
     ca4:	07 c0       	rjmp	.+14     	; 0xcb4 <dir_next+0xee>
     ca6:	83 e0       	ldi	r24, 0x03	; 3
     ca8:	05 c0       	rjmp	.+10     	; 0xcb4 <dir_next+0xee>
	if (!(i % 16)) { /* Sector changed? */
		dj->sect++;  /* Next sector */

		if (dj->clust == 0) {       /* Static table */
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
				return FR_NO_FILE;
     caa:	83 e0       	ldi	r24, 0x03	; 3
     cac:	03 c0       	rjmp	.+6      	; 0xcb4 <dir_next+0xee>
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
				clst = get_fat(dj->clust);           /* Get next cluster */
				if (clst <= 1)
					return FR_DISK_ERR;
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	01 c0       	rjmp	.+2      	; 0xcb4 <dir_next+0xee>
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
					return FR_NO_FILE;    /* Report EOT */
     cb2:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
     cb4:	df 91       	pop	r29
     cb6:	cf 91       	pop	r28
     cb8:	1f 91       	pop	r17
     cba:	0f 91       	pop	r16
     cbc:	ff 90       	pop	r15
     cbe:	ef 90       	pop	r14
     cc0:	df 90       	pop	r13
     cc2:	cf 90       	pop	r12
     cc4:	08 95       	ret

00000cc6 <dir_find>:
/*-----------------------------------------------------------------------*/

	static FRESULT dir_find(DIR * dj, /* Pointer to the directory object linked to the file name */
							BYTE *dir /* 32-byte working buffer */
	)
	{
     cc6:	cf 92       	push	r12
     cc8:	df 92       	push	r13
     cca:	ff 92       	push	r15
     ccc:	0f 93       	push	r16
     cce:	1f 93       	push	r17
     cd0:	cf 93       	push	r28
     cd2:	df 93       	push	r29
     cd4:	ec 01       	movw	r28, r24
     cd6:	6b 01       	movw	r12, r22
		FRESULT res;
		BYTE    c;

		res = dir_rewind(dj); /* Rewind directory object */
     cd8:	0e 94 8c 04 	call	0x918	; 0x918 <dir_rewind>
		if (res != FR_OK)
     cdc:	81 11       	cpse	r24, r1
     cde:	37 c0       	rjmp	.+110    	; 0xd4e <dir_find+0x88>
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     ce0:	28 81       	ld	r18, Y
     ce2:	39 81       	ldd	r19, Y+1	; 0x01
     ce4:	2f 70       	andi	r18, 0x0F	; 15
     ce6:	33 27       	eor	r19, r19
     ce8:	22 0f       	add	r18, r18
     cea:	33 1f       	adc	r19, r19
     cec:	22 95       	swap	r18
     cee:	32 95       	swap	r19
     cf0:	30 7f       	andi	r19, 0xF0	; 240
     cf2:	32 27       	eor	r19, r18
     cf4:	20 7f       	andi	r18, 0xF0	; 240
     cf6:	32 27       	eor	r19, r18
     cf8:	4c 85       	ldd	r20, Y+12	; 0x0c
     cfa:	5d 85       	ldd	r21, Y+13	; 0x0d
     cfc:	6e 85       	ldd	r22, Y+14	; 0x0e
     cfe:	7f 85       	ldd	r23, Y+15	; 0x0f
     d00:	00 e2       	ldi	r16, 0x20	; 32
     d02:	10 e0       	ldi	r17, 0x00	; 0
     d04:	c6 01       	movw	r24, r12
     d06:	0e 94 ab 01 	call	0x356	; 0x356 <disk_readp>
					  ? FR_DISK_ERR
					  : FR_OK;
     d0a:	91 e0       	ldi	r25, 0x01	; 1
     d0c:	81 11       	cpse	r24, r1
     d0e:	01 c0       	rjmp	.+2      	; 0xd12 <dir_find+0x4c>
     d10:	90 e0       	ldi	r25, 0x00	; 0
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     d12:	f9 2e       	mov	r15, r25
					  ? FR_DISK_ERR
					  : FR_OK;
			if (res != FR_OK)
     d14:	91 11       	cpse	r25, r1
     d16:	16 c0       	rjmp	.+44     	; 0xd44 <dir_find+0x7e>
				break;
			c = dir[DIR_Name]; /* First character */
     d18:	f6 01       	movw	r30, r12
     d1a:	80 81       	ld	r24, Z
			if (c == 0) { ///// hieerrr fout misschien
     d1c:	88 23       	and	r24, r24
     d1e:	a1 f0       	breq	.+40     	; 0xd48 <dir_find+0x82>
				res = FR_NO_FILE;
				break;
			}                                                           /* Reached to end of table */
			if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
     d20:	83 85       	ldd	r24, Z+11	; 0x0b
     d22:	83 fd       	sbrc	r24, 3
     d24:	09 c0       	rjmp	.+18     	; 0xd38 <dir_find+0x72>
     d26:	6a 81       	ldd	r22, Y+2	; 0x02
     d28:	7b 81       	ldd	r23, Y+3	; 0x03
     d2a:	4b e0       	ldi	r20, 0x0B	; 11
     d2c:	50 e0       	ldi	r21, 0x00	; 0
     d2e:	c6 01       	movw	r24, r12
     d30:	0e 94 22 04 	call	0x844	; 0x844 <mem_cmp>
     d34:	89 2b       	or	r24, r25
     d36:	51 f0       	breq	.+20     	; 0xd4c <dir_find+0x86>
				break;
			res = dir_next(dj); /* Next entry */
     d38:	ce 01       	movw	r24, r28
     d3a:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <dir_next>
		} while (res == FR_OK);
     d3e:	88 23       	and	r24, r24
     d40:	79 f2       	breq	.-98     	; 0xce0 <dir_find+0x1a>
     d42:	05 c0       	rjmp	.+10     	; 0xd4e <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     d44:	89 2f       	mov	r24, r25
     d46:	03 c0       	rjmp	.+6      	; 0xd4e <dir_find+0x88>
					  : FR_OK;
			if (res != FR_OK)
				break;
			c = dir[DIR_Name]; /* First character */
			if (c == 0) { ///// hieerrr fout misschien
				res = FR_NO_FILE;
     d48:	83 e0       	ldi	r24, 0x03	; 3
     d4a:	01 c0       	rjmp	.+2      	; 0xd4e <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     d4c:	8f 2d       	mov	r24, r15
				break;
			res = dir_next(dj); /* Next entry */
		} while (res == FR_OK);

		return res;
	}
     d4e:	df 91       	pop	r29
     d50:	cf 91       	pop	r28
     d52:	1f 91       	pop	r17
     d54:	0f 91       	pop	r16
     d56:	ff 90       	pop	r15
     d58:	df 90       	pop	r13
     d5a:	cf 90       	pop	r12
     d5c:	08 95       	ret

00000d5e <follow_path>:
static FRESULT follow_path(                 /* FR_OK(0): successful, !=0: error code */
                           DIR *       dj,  /* Directory object to return last directory and found object */
                           BYTE *      dir, /* 32-byte working buffer */
                           const char *path /* Full-path string to find a file or directory */
)
{
     d5e:	ef 92       	push	r14
     d60:	ff 92       	push	r15
     d62:	0f 93       	push	r16
     d64:	1f 93       	push	r17
     d66:	cf 93       	push	r28
     d68:	df 93       	push	r29
     d6a:	00 d0       	rcall	.+0      	; 0xd6c <follow_path+0xe>
     d6c:	cd b7       	in	r28, 0x3d	; 61
     d6e:	de b7       	in	r29, 0x3e	; 62
     d70:	8c 01       	movw	r16, r24
     d72:	7b 01       	movw	r14, r22
     d74:	5a 83       	std	Y+2, r21	; 0x02
     d76:	49 83       	std	Y+1, r20	; 0x01
	FRESULT res;

	while (*path == ' ')
     d78:	03 c0       	rjmp	.+6      	; 0xd80 <follow_path+0x22>
		path++; /* Strip leading spaces */
     d7a:	31 96       	adiw	r30, 0x01	; 1
     d7c:	fa 83       	std	Y+2, r31	; 0x02
     d7e:	e9 83       	std	Y+1, r30	; 0x01
                           const char *path /* Full-path string to find a file or directory */
)
{
	FRESULT res;

	while (*path == ' ')
     d80:	e9 81       	ldd	r30, Y+1	; 0x01
     d82:	fa 81       	ldd	r31, Y+2	; 0x02
     d84:	80 81       	ld	r24, Z
     d86:	80 32       	cpi	r24, 0x20	; 32
     d88:	c1 f3       	breq	.-16     	; 0xd7a <follow_path+0x1c>
		path++; /* Strip leading spaces */
	if (*path == '/')
     d8a:	8f 32       	cpi	r24, 0x2F	; 47
     d8c:	19 f4       	brne	.+6      	; 0xd94 <follow_path+0x36>
		path++;     /* Strip heading separator if exist */
     d8e:	31 96       	adiw	r30, 0x01	; 1
     d90:	fa 83       	std	Y+2, r31	; 0x02
     d92:	e9 83       	std	Y+1, r30	; 0x01
	dj->sclust = 0; /* Set start directory (always root dir) */
     d94:	d8 01       	movw	r26, r16
     d96:	14 96       	adiw	r26, 0x04	; 4
     d98:	1d 92       	st	X+, r1
     d9a:	1d 92       	st	X+, r1
     d9c:	1d 92       	st	X+, r1
     d9e:	1c 92       	st	X, r1
     da0:	17 97       	sbiw	r26, 0x07	; 7

	if ((BYTE)*path < ' ') { /* Null path means the root directory */
     da2:	e9 81       	ldd	r30, Y+1	; 0x01
     da4:	fa 81       	ldd	r31, Y+2	; 0x02
     da6:	80 81       	ld	r24, Z
     da8:	80 32       	cpi	r24, 0x20	; 32
     daa:	30 f4       	brcc	.+12     	; 0xdb8 <follow_path+0x5a>
		res    = dir_rewind(dj);
     dac:	c8 01       	movw	r24, r16
     dae:	0e 94 8c 04 	call	0x918	; 0x918 <dir_rewind>
		dir[0] = 0;
     db2:	f7 01       	movw	r30, r14
     db4:	10 82       	st	Z, r1
     db6:	26 c0       	rjmp	.+76     	; 0xe04 <follow_path+0xa6>

	} else { /* Follow path */
		for (;;) {
			res = create_name(dj, &path); /* Get a segment */
     db8:	be 01       	movw	r22, r28
     dba:	6f 5f       	subi	r22, 0xFF	; 255
     dbc:	7f 4f       	sbci	r23, 0xFF	; 255
     dbe:	c8 01       	movw	r24, r16
     dc0:	0e 94 cb 04 	call	0x996	; 0x996 <create_name>
			if (res != FR_OK)
     dc4:	81 11       	cpse	r24, r1
     dc6:	1e c0       	rjmp	.+60     	; 0xe04 <follow_path+0xa6>
				break;
			res = dir_find(dj, dir); /* Find it */ // het gaat denk ik hier fout
     dc8:	b7 01       	movw	r22, r14
     dca:	c8 01       	movw	r24, r16
     dcc:	0e 94 63 06 	call	0xcc6	; 0xcc6 <dir_find>
			if (res != FR_OK)
     dd0:	81 11       	cpse	r24, r1
     dd2:	18 c0       	rjmp	.+48     	; 0xe04 <follow_path+0xa6>
				break; /* Could not find the object */
			if (dj->fn[11])
     dd4:	d8 01       	movw	r26, r16
     dd6:	12 96       	adiw	r26, 0x02	; 2
     dd8:	ed 91       	ld	r30, X+
     dda:	fc 91       	ld	r31, X
     ddc:	13 97       	sbiw	r26, 0x03	; 3
     dde:	93 85       	ldd	r25, Z+11	; 0x0b
     de0:	91 11       	cpse	r25, r1
     de2:	10 c0       	rjmp	.+32     	; 0xe04 <follow_path+0xa6>
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
     de4:	f7 01       	movw	r30, r14
     de6:	83 85       	ldd	r24, Z+11	; 0x0b
     de8:	84 ff       	sbrs	r24, 4
     dea:	0b c0       	rjmp	.+22     	; 0xe02 <follow_path+0xa4>
				res = FR_NO_FILE;
				break;
			}
			dj->sclust = get_clust(dir); /* Follow next */
     dec:	c7 01       	movw	r24, r14
     dee:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <get_clust>
     df2:	d8 01       	movw	r26, r16
     df4:	14 96       	adiw	r26, 0x04	; 4
     df6:	6d 93       	st	X+, r22
     df8:	7d 93       	st	X+, r23
     dfa:	8d 93       	st	X+, r24
     dfc:	9c 93       	st	X, r25
     dfe:	17 97       	sbiw	r26, 0x07	; 7
		}
     e00:	db cf       	rjmp	.-74     	; 0xdb8 <follow_path+0x5a>
			if (res != FR_OK)
				break; /* Could not find the object */
			if (dj->fn[11])
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE;
     e02:	83 e0       	ldi	r24, 0x03	; 3
			dj->sclust = get_clust(dir); /* Follow next */
		}
	}

	return res;
}
     e04:	0f 90       	pop	r0
     e06:	0f 90       	pop	r0
     e08:	df 91       	pop	r29
     e0a:	cf 91       	pop	r28
     e0c:	1f 91       	pop	r17
     e0e:	0f 91       	pop	r16
     e10:	ff 90       	pop	r15
     e12:	ef 90       	pop	r14
     e14:	08 95       	ret

00000e16 <pf_mount>:
/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount(FATFS *fs /* Pointer to new file system object */)
{
     e16:	4f 92       	push	r4
     e18:	5f 92       	push	r5
     e1a:	6f 92       	push	r6
     e1c:	7f 92       	push	r7
     e1e:	8f 92       	push	r8
     e20:	9f 92       	push	r9
     e22:	af 92       	push	r10
     e24:	bf 92       	push	r11
     e26:	df 92       	push	r13
     e28:	ef 92       	push	r14
     e2a:	ff 92       	push	r15
     e2c:	0f 93       	push	r16
     e2e:	1f 93       	push	r17
     e30:	cf 93       	push	r28
     e32:	df 93       	push	r29
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	a8 97       	sbiw	r28, 0x28	; 40
     e3a:	0f b6       	in	r0, 0x3f	; 63
     e3c:	f8 94       	cli
     e3e:	de bf       	out	0x3e, r29	; 62
     e40:	0f be       	out	0x3f, r0	; 63
     e42:	cd bf       	out	0x3d, r28	; 61
     e44:	7c 01       	movw	r14, r24
	BYTE  fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;

	FatFs = 0;
     e46:	10 92 af 05 	sts	0x05AF, r1	; 0x8005af <FatFs+0x1>
     e4a:	10 92 ae 05 	sts	0x05AE, r1	; 0x8005ae <FatFs>

	if (disk_initialize() & STA_NOINIT)
     e4e:	0e 94 cb 00 	call	0x196	; 0x196 <disk_initialize>
     e52:	80 fd       	sbrc	r24, 0
     e54:	62 c1       	rjmp	.+708    	; 0x111a <pf_mount+0x304>
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
     e56:	40 e0       	ldi	r20, 0x00	; 0
     e58:	50 e0       	ldi	r21, 0x00	; 0
     e5a:	ba 01       	movw	r22, r20
     e5c:	ce 01       	movw	r24, r28
     e5e:	01 96       	adiw	r24, 0x01	; 1
     e60:	0e 94 17 05 	call	0xa2e	; 0xa2e <check_fs>
     e64:	d8 2e       	mov	r13, r24
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
     e66:	21 e0       	ldi	r18, 0x01	; 1
     e68:	82 13       	cpse	r24, r18
     e6a:	38 c0       	rjmp	.+112    	; 0xedc <pf_mount+0xc6>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
     e6c:	00 e1       	ldi	r16, 0x10	; 16
     e6e:	10 e0       	ldi	r17, 0x00	; 0
     e70:	2e eb       	ldi	r18, 0xBE	; 190
     e72:	31 e0       	ldi	r19, 0x01	; 1
     e74:	40 e0       	ldi	r20, 0x00	; 0
     e76:	50 e0       	ldi	r21, 0x00	; 0
     e78:	ba 01       	movw	r22, r20
     e7a:	ce 01       	movw	r24, r28
     e7c:	01 96       	adiw	r24, 0x01	; 1
     e7e:	0e 94 ab 01 	call	0x356	; 0x356 <disk_readp>
     e82:	81 11       	cpse	r24, r1
     e84:	2f c0       	rjmp	.+94     	; 0xee4 <pf_mount+0xce>
			fmt = 3;
		} else {
			if (buf[4]) {                     /* Is the partition existing? */
     e86:	8d 81       	ldd	r24, Y+5	; 0x05
     e88:	88 23       	and	r24, r24
     e8a:	a1 f1       	breq	.+104    	; 0xef4 <pf_mount+0xde>
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
     e8c:	8c 84       	ldd	r8, Y+12	; 0x0c
     e8e:	91 2c       	mov	r9, r1
     e90:	a1 2c       	mov	r10, r1
     e92:	b1 2c       	mov	r11, r1
     e94:	b8 2c       	mov	r11, r8
     e96:	aa 24       	eor	r10, r10
     e98:	99 24       	eor	r9, r9
     e9a:	88 24       	eor	r8, r8
     e9c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9e:	89 2f       	mov	r24, r25
     ea0:	90 e0       	ldi	r25, 0x00	; 0
     ea2:	a0 e0       	ldi	r26, 0x00	; 0
     ea4:	b0 e0       	ldi	r27, 0x00	; 0
     ea6:	dc 01       	movw	r26, r24
     ea8:	99 27       	eor	r25, r25
     eaa:	88 27       	eor	r24, r24
     eac:	88 29       	or	r24, r8
     eae:	99 29       	or	r25, r9
     eb0:	aa 29       	or	r26, r10
     eb2:	bb 29       	or	r27, r11
     eb4:	8a 84       	ldd	r8, Y+10	; 0x0a
     eb6:	91 2c       	mov	r9, r1
     eb8:	98 2c       	mov	r9, r8
     eba:	88 24       	eor	r8, r8
     ebc:	a1 2c       	mov	r10, r1
     ebe:	b1 2c       	mov	r11, r1
     ec0:	88 2a       	or	r8, r24
     ec2:	99 2a       	or	r9, r25
     ec4:	aa 2a       	or	r10, r26
     ec6:	bb 2a       	or	r11, r27
     ec8:	89 85       	ldd	r24, Y+9	; 0x09
     eca:	88 2a       	or	r8, r24
				fmt   = check_fs(buf, bsect); /* Check the partition */
     ecc:	b5 01       	movw	r22, r10
     ece:	a4 01       	movw	r20, r8
     ed0:	ce 01       	movw	r24, r28
     ed2:	01 96       	adiw	r24, 0x01	; 1
     ed4:	0e 94 17 05 	call	0xa2e	; 0xa2e <check_fs>
     ed8:	d8 2e       	mov	r13, r24
     eda:	0f c0       	rjmp	.+30     	; 0xefa <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
     edc:	81 2c       	mov	r8, r1
     ede:	91 2c       	mov	r9, r1
     ee0:	54 01       	movw	r10, r8
     ee2:	0b c0       	rjmp	.+22     	; 0xefa <pf_mount+0xe4>
     ee4:	81 2c       	mov	r8, r1
     ee6:	91 2c       	mov	r9, r1
     ee8:	54 01       	movw	r10, r8
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
			fmt = 3;
     eea:	0f 2e       	mov	r0, r31
     eec:	f3 e0       	ldi	r31, 0x03	; 3
     eee:	df 2e       	mov	r13, r31
     ef0:	f0 2d       	mov	r31, r0
     ef2:	03 c0       	rjmp	.+6      	; 0xefa <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
     ef4:	81 2c       	mov	r8, r1
     ef6:	91 2c       	mov	r9, r1
     ef8:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
     efa:	43 e0       	ldi	r20, 0x03	; 3
     efc:	d4 16       	cp	r13, r20
     efe:	09 f4       	brne	.+2      	; 0xf02 <pf_mount+0xec>
     f00:	0e c1       	rjmp	.+540    	; 0x111e <pf_mount+0x308>
		return FR_DISK_ERR;
	if (fmt)
     f02:	d1 10       	cpse	r13, r1
     f04:	0e c1       	rjmp	.+540    	; 0x1122 <pf_mount+0x30c>
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
     f06:	04 e2       	ldi	r16, 0x24	; 36
     f08:	10 e0       	ldi	r17, 0x00	; 0
     f0a:	2d e0       	ldi	r18, 0x0D	; 13
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	b5 01       	movw	r22, r10
     f10:	a4 01       	movw	r20, r8
     f12:	ce 01       	movw	r24, r28
     f14:	01 96       	adiw	r24, 0x01	; 1
     f16:	0e 94 ab 01 	call	0x356	; 0x356 <disk_readp>
     f1a:	81 11       	cpse	r24, r1
     f1c:	04 c1       	rjmp	.+520    	; 0x1126 <pf_mount+0x310>
		return FR_DISK_ERR;

	fsize = LD_WORD(buf + BPB_FATSz16 - 13); /* Number of sectors per FAT */
     f1e:	2b 85       	ldd	r18, Y+11	; 0x0b
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	32 2f       	mov	r19, r18
     f24:	22 27       	eor	r18, r18
     f26:	8a 85       	ldd	r24, Y+10	; 0x0a
     f28:	28 2b       	or	r18, r24
     f2a:	40 e0       	ldi	r20, 0x00	; 0
     f2c:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize)
     f2e:	21 15       	cp	r18, r1
     f30:	31 05       	cpc	r19, r1
     f32:	41 05       	cpc	r20, r1
     f34:	51 05       	cpc	r21, r1
     f36:	21 f5       	brne	.+72     	; 0xf80 <pf_mount+0x16a>
		fsize = LD_DWORD(buf + BPB_FATSz32 - 13);
     f38:	2b 8d       	ldd	r18, Y+27	; 0x1b
     f3a:	82 2f       	mov	r24, r18
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	a0 e0       	ldi	r26, 0x00	; 0
     f40:	b0 e0       	ldi	r27, 0x00	; 0
     f42:	78 2f       	mov	r23, r24
     f44:	66 27       	eor	r22, r22
     f46:	55 27       	eor	r21, r21
     f48:	44 27       	eor	r20, r20
     f4a:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f4c:	89 2f       	mov	r24, r25
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	a0 e0       	ldi	r26, 0x00	; 0
     f52:	b0 e0       	ldi	r27, 0x00	; 0
     f54:	dc 01       	movw	r26, r24
     f56:	99 27       	eor	r25, r25
     f58:	88 27       	eor	r24, r24
     f5a:	84 2b       	or	r24, r20
     f5c:	95 2b       	or	r25, r21
     f5e:	a6 2b       	or	r26, r22
     f60:	b7 2b       	or	r27, r23
     f62:	29 8d       	ldd	r18, Y+25	; 0x19
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	32 2f       	mov	r19, r18
     f68:	22 27       	eor	r18, r18
     f6a:	a9 01       	movw	r20, r18
     f6c:	60 e0       	ldi	r22, 0x00	; 0
     f6e:	70 e0       	ldi	r23, 0x00	; 0
     f70:	48 2b       	or	r20, r24
     f72:	59 2b       	or	r21, r25
     f74:	6a 2b       	or	r22, r26
     f76:	7b 2b       	or	r23, r27
     f78:	88 8d       	ldd	r24, Y+24	; 0x18
     f7a:	9a 01       	movw	r18, r20
     f7c:	ab 01       	movw	r20, r22
     f7e:	28 2b       	or	r18, r24

	fsize *= buf[BPB_NumFATs - 13];                             /* Number of sectors in FAT area */
     f80:	ac 81       	ldd	r26, Y+4	; 0x04
     f82:	b0 e0       	ldi	r27, 0x00	; 0
     f84:	0e 94 56 0c 	call	0x18ac	; 0x18ac <__muluhisi3>
     f88:	6d a3       	std	Y+37, r22	; 0x25
     f8a:	7e a3       	std	Y+38, r23	; 0x26
     f8c:	8f a3       	std	Y+39, r24	; 0x27
     f8e:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase   = bsect + LD_WORD(buf + BPB_RsvdSecCnt - 13); /* FAT start sector (lba) */
     f90:	8b 81       	ldd	r24, Y+3	; 0x03
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	98 2f       	mov	r25, r24
     f96:	88 27       	eor	r24, r24
     f98:	4a 81       	ldd	r20, Y+2	; 0x02
     f9a:	50 e0       	ldi	r21, 0x00	; 0
     f9c:	84 2b       	or	r24, r20
     f9e:	95 2b       	or	r25, r21
     fa0:	88 0e       	add	r8, r24
     fa2:	99 1e       	adc	r9, r25
     fa4:	a1 1c       	adc	r10, r1
     fa6:	b1 1c       	adc	r11, r1
     fa8:	d7 01       	movw	r26, r14
     faa:	1a 96       	adiw	r26, 0x0a	; 10
     fac:	8d 92       	st	X+, r8
     fae:	9d 92       	st	X+, r9
     fb0:	ad 92       	st	X+, r10
     fb2:	bc 92       	st	X, r11
     fb4:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
     fb6:	a9 81       	ldd	r26, Y+1	; 0x01
     fb8:	f7 01       	movw	r30, r14
     fba:	a2 83       	std	Z+2, r26	; 0x02
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
     fbc:	8e 81       	ldd	r24, Y+6	; 0x06
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	98 2f       	mov	r25, r24
     fc2:	88 27       	eor	r24, r24
     fc4:	2d 81       	ldd	r18, Y+5	; 0x05
     fc6:	82 2b       	or	r24, r18
     fc8:	95 83       	std	Z+5, r25	; 0x05
     fca:	84 83       	std	Z+4, r24	; 0x04
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
     fcc:	08 85       	ldd	r16, Y+8	; 0x08
     fce:	10 e0       	ldi	r17, 0x00	; 0
     fd0:	10 2f       	mov	r17, r16
     fd2:	00 27       	eor	r16, r16
     fd4:	2f 81       	ldd	r18, Y+7	; 0x07
     fd6:	02 2b       	or	r16, r18
     fd8:	20 e0       	ldi	r18, 0x00	; 0
     fda:	30 e0       	ldi	r19, 0x00	; 0
	if (!tsect)
     fdc:	01 15       	cp	r16, r1
     fde:	11 05       	cpc	r17, r1
     fe0:	21 05       	cpc	r18, r1
     fe2:	31 05       	cpc	r19, r1
     fe4:	01 f5       	brne	.+64     	; 0x1026 <pf_mount+0x210>
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
     fe6:	0f 89       	ldd	r16, Y+23	; 0x17
     fe8:	10 e0       	ldi	r17, 0x00	; 0
     fea:	20 e0       	ldi	r18, 0x00	; 0
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	70 2e       	mov	r7, r16
     ff0:	66 24       	eor	r6, r6
     ff2:	55 24       	eor	r5, r5
     ff4:	44 24       	eor	r4, r4
     ff6:	0e 89       	ldd	r16, Y+22	; 0x16
     ff8:	10 e0       	ldi	r17, 0x00	; 0
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	98 01       	movw	r18, r16
    1000:	11 27       	eor	r17, r17
    1002:	00 27       	eor	r16, r16
    1004:	40 2a       	or	r4, r16
    1006:	51 2a       	or	r5, r17
    1008:	62 2a       	or	r6, r18
    100a:	73 2a       	or	r7, r19
    100c:	2d 89       	ldd	r18, Y+21	; 0x15
    100e:	30 e0       	ldi	r19, 0x00	; 0
    1010:	32 2f       	mov	r19, r18
    1012:	22 27       	eor	r18, r18
    1014:	89 01       	movw	r16, r18
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	04 29       	or	r16, r4
    101c:	15 29       	or	r17, r5
    101e:	26 29       	or	r18, r6
    1020:	37 29       	or	r19, r7
    1022:	6c 89       	ldd	r22, Y+20	; 0x14
    1024:	06 2b       	or	r16, r22
	mclst = (tsect /* Last cluster# + 1 */
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
    1026:	eb 81       	ldd	r30, Y+3	; 0x03
    1028:	f0 e0       	ldi	r31, 0x00	; 0
    102a:	fe 2f       	mov	r31, r30
    102c:	ee 27       	eor	r30, r30
    102e:	4e 2b       	or	r20, r30
    1030:	5f 2b       	or	r21, r31
    1032:	04 1b       	sub	r16, r20
    1034:	15 0b       	sbc	r17, r21
    1036:	21 09       	sbc	r18, r1
    1038:	31 09       	sbc	r19, r1
    103a:	4d a1       	ldd	r20, Y+37	; 0x25
    103c:	5e a1       	ldd	r21, Y+38	; 0x26
    103e:	6f a1       	ldd	r22, Y+39	; 0x27
    1040:	78 a5       	ldd	r23, Y+40	; 0x28
    1042:	04 1b       	sub	r16, r20
    1044:	15 0b       	sbc	r17, r21
    1046:	26 0b       	sbc	r18, r22
    1048:	37 0b       	sbc	r19, r23
    104a:	92 95       	swap	r25
    104c:	82 95       	swap	r24
    104e:	8f 70       	andi	r24, 0x0F	; 15
    1050:	89 27       	eor	r24, r25
    1052:	9f 70       	andi	r25, 0x0F	; 15
    1054:	89 27       	eor	r24, r25
    1056:	2c 01       	movw	r4, r24
    1058:	61 2c       	mov	r6, r1
    105a:	71 2c       	mov	r7, r1
    105c:	c9 01       	movw	r24, r18
    105e:	b8 01       	movw	r22, r16
    1060:	64 19       	sub	r22, r4
    1062:	75 09       	sbc	r23, r5
    1064:	86 09       	sbc	r24, r6
    1066:	97 09       	sbc	r25, r7
	            / fs->csize
    1068:	2a 2f       	mov	r18, r26
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	40 e0       	ldi	r20, 0x00	; 0
    106e:	50 e0       	ldi	r21, 0x00	; 0
    1070:	0e 94 34 0c 	call	0x1868	; 0x1868 <__udivmodsi4>
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
	if (!tsect)
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
	mclst = (tsect /* Last cluster# + 1 */
    1074:	da 01       	movw	r26, r20
    1076:	c9 01       	movw	r24, r18
    1078:	02 96       	adiw	r24, 0x02	; 2
    107a:	a1 1d       	adc	r26, r1
    107c:	b1 1d       	adc	r27, r1
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
	            / fs->csize
	        + 2;
	fs->n_fatent = (CLUST)mclst;
    107e:	f7 01       	movw	r30, r14
    1080:	86 83       	std	Z+6, r24	; 0x06
    1082:	97 83       	std	Z+7, r25	; 0x07
    1084:	a0 87       	std	Z+8, r26	; 0x08
    1086:	b1 87       	std	Z+9, r27	; 0x09
	fmt = 0; /* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    1088:	87 3f       	cpi	r24, 0xF7	; 247
    108a:	9f 4f       	sbci	r25, 0xFF	; 255
    108c:	a1 05       	cpc	r26, r1
    108e:	b1 05       	cpc	r27, r1
    1090:	20 f0       	brcs	.+8      	; 0x109a <pf_mount+0x284>
		fmt = FS_FAT32;
    1092:	0f 2e       	mov	r0, r31
    1094:	f3 e0       	ldi	r31, 0x03	; 3
    1096:	df 2e       	mov	r13, r31
    1098:	f0 2d       	mov	r31, r0
	if (!fmt)
    109a:	dd 20       	and	r13, r13
    109c:	09 f4       	brne	.+2      	; 0x10a0 <pf_mount+0x28a>
    109e:	45 c0       	rjmp	.+138    	; 0x112a <pf_mount+0x314>
		return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    10a0:	d7 01       	movw	r26, r14
    10a2:	dc 92       	st	X, r13

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf + (BPB_RootClus - 13)); /* Root directory start cluster */
    10a4:	8b a1       	ldd	r24, Y+35	; 0x23
    10a6:	90 e0       	ldi	r25, 0x00	; 0
    10a8:	a0 e0       	ldi	r26, 0x00	; 0
    10aa:	b0 e0       	ldi	r27, 0x00	; 0
    10ac:	78 2f       	mov	r23, r24
    10ae:	66 27       	eor	r22, r22
    10b0:	55 27       	eor	r21, r21
    10b2:	44 27       	eor	r20, r20
    10b4:	8a a1       	ldd	r24, Y+34	; 0x22
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	a0 e0       	ldi	r26, 0x00	; 0
    10ba:	b0 e0       	ldi	r27, 0x00	; 0
    10bc:	dc 01       	movw	r26, r24
    10be:	99 27       	eor	r25, r25
    10c0:	88 27       	eor	r24, r24
    10c2:	84 2b       	or	r24, r20
    10c4:	95 2b       	or	r25, r21
    10c6:	a6 2b       	or	r26, r22
    10c8:	b7 2b       	or	r27, r23
    10ca:	49 a1       	ldd	r20, Y+33	; 0x21
    10cc:	50 e0       	ldi	r21, 0x00	; 0
    10ce:	54 2f       	mov	r21, r20
    10d0:	44 27       	eor	r20, r20
    10d2:	60 e0       	ldi	r22, 0x00	; 0
    10d4:	70 e0       	ldi	r23, 0x00	; 0
    10d6:	84 2b       	or	r24, r20
    10d8:	95 2b       	or	r25, r21
    10da:	a6 2b       	or	r26, r22
    10dc:	b7 2b       	or	r27, r23
    10de:	28 a1       	ldd	r18, Y+32	; 0x20
    10e0:	82 2b       	or	r24, r18
    10e2:	f7 01       	movw	r30, r14
    10e4:	86 87       	std	Z+14, r24	; 0x0e
    10e6:	97 87       	std	Z+15, r25	; 0x0f
    10e8:	a0 8b       	std	Z+16, r26	; 0x10
    10ea:	b1 8b       	std	Z+17, r27	; 0x11
	else
		fs->dirbase = fs->fatbase + fsize;                   /* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16; /* Data start sector (lba) */
    10ec:	4d a1       	ldd	r20, Y+37	; 0x25
    10ee:	5e a1       	ldd	r21, Y+38	; 0x26
    10f0:	6f a1       	ldd	r22, Y+39	; 0x27
    10f2:	78 a5       	ldd	r23, Y+40	; 0x28
    10f4:	84 0e       	add	r8, r20
    10f6:	95 1e       	adc	r9, r21
    10f8:	a6 1e       	adc	r10, r22
    10fa:	b7 1e       	adc	r11, r23
    10fc:	84 0c       	add	r8, r4
    10fe:	95 1c       	adc	r9, r5
    1100:	a6 1c       	adc	r10, r6
    1102:	b7 1c       	adc	r11, r7
    1104:	82 8a       	std	Z+18, r8	; 0x12
    1106:	93 8a       	std	Z+19, r9	; 0x13
    1108:	a4 8a       	std	Z+20, r10	; 0x14
    110a:	b5 8a       	std	Z+21, r11	; 0x15

	fs->flag = 0;
    110c:	11 82       	std	Z+1, r1	; 0x01
	FatFs    = fs;
    110e:	f0 92 af 05 	sts	0x05AF, r15	; 0x8005af <FatFs+0x1>
    1112:	e0 92 ae 05 	sts	0x05AE, r14	; 0x8005ae <FatFs>

	return FR_OK;
    1116:	80 e0       	ldi	r24, 0x00	; 0
    1118:	09 c0       	rjmp	.+18     	; 0x112c <pf_mount+0x316>
	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)
	{
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
    111a:	82 e0       	ldi	r24, 0x02	; 2
    111c:	07 c0       	rjmp	.+14     	; 0x112c <pf_mount+0x316>
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
		return FR_DISK_ERR;
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	05 c0       	rjmp	.+10     	; 0x112c <pf_mount+0x316>
	if (fmt)
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */
    1122:	86 e0       	ldi	r24, 0x06	; 6
    1124:	03 c0       	rjmp	.+6      	; 0x112c <pf_mount+0x316>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
		return FR_DISK_ERR;
    1126:	81 e0       	ldi	r24, 0x01	; 1
    1128:	01 c0       	rjmp	.+2      	; 0x112c <pf_mount+0x316>
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
		fmt = FS_FAT32;
	if (!fmt)
		return FR_NO_FILESYSTEM;
    112a:	86 e0       	ldi	r24, 0x06	; 6

	fs->flag = 0;
	FatFs    = fs;

	return FR_OK;
}
    112c:	a8 96       	adiw	r28, 0x28	; 40
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	de bf       	out	0x3e, r29	; 62
    1134:	0f be       	out	0x3f, r0	; 63
    1136:	cd bf       	out	0x3d, r28	; 61
    1138:	df 91       	pop	r29
    113a:	cf 91       	pop	r28
    113c:	1f 91       	pop	r17
    113e:	0f 91       	pop	r16
    1140:	ff 90       	pop	r15
    1142:	ef 90       	pop	r14
    1144:	df 90       	pop	r13
    1146:	bf 90       	pop	r11
    1148:	af 90       	pop	r10
    114a:	9f 90       	pop	r9
    114c:	8f 90       	pop	r8
    114e:	7f 90       	pop	r7
    1150:	6f 90       	pop	r6
    1152:	5f 90       	pop	r5
    1154:	4f 90       	pop	r4
    1156:	08 95       	ret

00001158 <pf_open>:
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT pf_open(const char *path /* Pointer to the file name */
)
 {
    1158:	0f 93       	push	r16
    115a:	1f 93       	push	r17
    115c:	cf 93       	push	r28
    115e:	df 93       	push	r29
    1160:	cd b7       	in	r28, 0x3d	; 61
    1162:	de b7       	in	r29, 0x3e	; 62
    1164:	ec 97       	sbiw	r28, 0x3c	; 60
    1166:	0f b6       	in	r0, 0x3f	; 63
    1168:	f8 94       	cli
    116a:	de bf       	out	0x3e, r29	; 62
    116c:	0f be       	out	0x3f, r0	; 63
    116e:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;
    1170:	00 91 ae 05 	lds	r16, 0x05AE	; 0x8005ae <FatFs>
    1174:	10 91 af 05 	lds	r17, 0x05AF	; 0x8005af <FatFs+0x1>

	if (!fs)
    1178:	01 15       	cp	r16, r1
    117a:	11 05       	cpc	r17, r1
    117c:	09 f4       	brne	.+2      	; 0x1180 <pf_open+0x28>
    117e:	4a c0       	rjmp	.+148    	; 0x1214 <pf_open+0xbc>
    1180:	ac 01       	movw	r20, r24
		return FR_NOT_ENABLED; /* Check file system */

	fs->flag = 0;
    1182:	f8 01       	movw	r30, r16
    1184:	11 82       	std	Z+1, r1	; 0x01
	dj.fn    = sp;
    1186:	ce 01       	movw	r24, r28
    1188:	41 96       	adiw	r24, 0x11	; 17
    118a:	9c 83       	std	Y+4, r25	; 0x04
    118c:	8b 83       	std	Y+3, r24	; 0x03
	res      = follow_path(&dj, dir, path); /* Follow the file path */
    118e:	be 01       	movw	r22, r28
    1190:	63 5e       	subi	r22, 0xE3	; 227
    1192:	7f 4f       	sbci	r23, 0xFF	; 255
    1194:	40 97       	sbiw	r24, 0x10	; 16
    1196:	0e 94 af 06 	call	0xd5e	; 0xd5e <follow_path>
	if (res != FR_OK)
    119a:	81 11       	cpse	r24, r1
    119c:	40 c0       	rjmp	.+128    	; 0x121e <pf_open+0xc6>
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
    119e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11a0:	88 23       	and	r24, r24
    11a2:	d1 f1       	breq	.+116    	; 0x1218 <pf_open+0xc0>
    11a4:	88 a5       	ldd	r24, Y+40	; 0x28
    11a6:	84 fd       	sbrc	r24, 4
    11a8:	39 c0       	rjmp	.+114    	; 0x121c <pf_open+0xc4>
		return FR_NO_FILE;
	

	fs->org_clust = get_clust(dir);               /* File start cluster */
    11aa:	ce 01       	movw	r24, r28
    11ac:	4d 96       	adiw	r24, 0x1d	; 29
    11ae:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <get_clust>
    11b2:	f8 01       	movw	r30, r16
    11b4:	66 8f       	std	Z+30, r22	; 0x1e
    11b6:	77 8f       	std	Z+31, r23	; 0x1f
    11b8:	80 a3       	std	Z+32, r24	; 0x20
    11ba:	91 a3       	std	Z+33, r25	; 0x21
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
    11bc:	8c ad       	ldd	r24, Y+60	; 0x3c
    11be:	90 e0       	ldi	r25, 0x00	; 0
    11c0:	a0 e0       	ldi	r26, 0x00	; 0
    11c2:	b0 e0       	ldi	r27, 0x00	; 0
    11c4:	78 2f       	mov	r23, r24
    11c6:	66 27       	eor	r22, r22
    11c8:	55 27       	eor	r21, r21
    11ca:	44 27       	eor	r20, r20
    11cc:	9b ad       	ldd	r25, Y+59	; 0x3b
    11ce:	89 2f       	mov	r24, r25
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	a0 e0       	ldi	r26, 0x00	; 0
    11d4:	b0 e0       	ldi	r27, 0x00	; 0
    11d6:	dc 01       	movw	r26, r24
    11d8:	99 27       	eor	r25, r25
    11da:	88 27       	eor	r24, r24
    11dc:	84 2b       	or	r24, r20
    11de:	95 2b       	or	r25, r21
    11e0:	a6 2b       	or	r26, r22
    11e2:	b7 2b       	or	r27, r23
    11e4:	4a ad       	ldd	r20, Y+58	; 0x3a
    11e6:	50 e0       	ldi	r21, 0x00	; 0
    11e8:	54 2f       	mov	r21, r20
    11ea:	44 27       	eor	r20, r20
    11ec:	60 e0       	ldi	r22, 0x00	; 0
    11ee:	70 e0       	ldi	r23, 0x00	; 0
    11f0:	84 2b       	or	r24, r20
    11f2:	95 2b       	or	r25, r21
    11f4:	a6 2b       	or	r26, r22
    11f6:	b7 2b       	or	r27, r23
    11f8:	29 ad       	ldd	r18, Y+57	; 0x39
    11fa:	82 2b       	or	r24, r18
    11fc:	82 8f       	std	Z+26, r24	; 0x1a
    11fe:	93 8f       	std	Z+27, r25	; 0x1b
    1200:	a4 8f       	std	Z+28, r26	; 0x1c
    1202:	b5 8f       	std	Z+29, r27	; 0x1d
	fs->fptr      = 0;                            /* File pointer */
    1204:	16 8a       	std	Z+22, r1	; 0x16
    1206:	17 8a       	std	Z+23, r1	; 0x17
    1208:	10 8e       	std	Z+24, r1	; 0x18
    120a:	11 8e       	std	Z+25, r1	; 0x19
	fs->flag      = FA_OPENED;
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	81 83       	std	Z+1, r24	; 0x01

	return FR_OK;
    1210:	80 e0       	ldi	r24, 0x00	; 0
    1212:	05 c0       	rjmp	.+10     	; 0x121e <pf_open+0xc6>
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED; /* Check file system */
    1214:	85 e0       	ldi	r24, 0x05	; 5
    1216:	03 c0       	rjmp	.+6      	; 0x121e <pf_open+0xc6>
	dj.fn    = sp;
	res      = follow_path(&dj, dir, path); /* Follow the file path */
	if (res != FR_OK)
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
		return FR_NO_FILE;
    1218:	83 e0       	ldi	r24, 0x03	; 3
    121a:	01 c0       	rjmp	.+2      	; 0x121e <pf_open+0xc6>
    121c:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
	fs->fptr      = 0;                            /* File pointer */
	fs->flag      = FA_OPENED;

	return FR_OK;
}
    121e:	ec 96       	adiw	r28, 0x3c	; 60
    1220:	0f b6       	in	r0, 0x3f	; 63
    1222:	f8 94       	cli
    1224:	de bf       	out	0x3e, r29	; 62
    1226:	0f be       	out	0x3f, r0	; 63
    1228:	cd bf       	out	0x3d, r28	; 61
    122a:	df 91       	pop	r29
    122c:	cf 91       	pop	r28
    122e:	1f 91       	pop	r17
    1230:	0f 91       	pop	r16
    1232:	08 95       	ret

00001234 <pf_read>:

FRESULT pf_read(void *buff, /* Pointer to the read buffer (NULL:Forward data to the stream)*/
                UINT  btr,  /* Number of bytes to read */
                UINT *br    /* Pointer to number of bytes read */
)
{
    1234:	6f 92       	push	r6
    1236:	7f 92       	push	r7
    1238:	8f 92       	push	r8
    123a:	9f 92       	push	r9
    123c:	af 92       	push	r10
    123e:	bf 92       	push	r11
    1240:	cf 92       	push	r12
    1242:	df 92       	push	r13
    1244:	ef 92       	push	r14
    1246:	ff 92       	push	r15
    1248:	0f 93       	push	r16
    124a:	1f 93       	push	r17
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    1250:	3c 01       	movw	r6, r24
    1252:	6b 01       	movw	r12, r22
    1254:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST   clst;
	DWORD   sect, remain;
	UINT    rcnt;
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;
    1256:	e0 90 ae 05 	lds	r14, 0x05AE	; 0x8005ae <FatFs>
    125a:	f0 90 af 05 	lds	r15, 0x05AF	; 0x8005af <FatFs+0x1>

	*br = 0;
    125e:	fa 01       	movw	r30, r20
    1260:	11 82       	std	Z+1, r1	; 0x01
    1262:	10 82       	st	Z, r1
	if (!fs)
    1264:	e1 14       	cp	r14, r1
    1266:	f1 04       	cpc	r15, r1
    1268:	09 f4       	brne	.+2      	; 0x126c <pf_read+0x38>
    126a:	b5 c0       	rjmp	.+362    	; 0x13d6 <pf_read+0x1a2>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    126c:	f7 01       	movw	r30, r14
    126e:	81 81       	ldd	r24, Z+1	; 0x01
    1270:	80 ff       	sbrs	r24, 0
    1272:	b3 c0       	rjmp	.+358    	; 0x13da <pf_read+0x1a6>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    1274:	82 8d       	ldd	r24, Z+26	; 0x1a
    1276:	93 8d       	ldd	r25, Z+27	; 0x1b
    1278:	a4 8d       	ldd	r26, Z+28	; 0x1c
    127a:	b5 8d       	ldd	r27, Z+29	; 0x1d
    127c:	46 89       	ldd	r20, Z+22	; 0x16
    127e:	57 89       	ldd	r21, Z+23	; 0x17
    1280:	60 8d       	ldd	r22, Z+24	; 0x18
    1282:	71 8d       	ldd	r23, Z+25	; 0x19
    1284:	84 1b       	sub	r24, r20
    1286:	95 0b       	sbc	r25, r21
    1288:	a6 0b       	sbc	r26, r22
    128a:	b7 0b       	sbc	r27, r23
	if (btr > remain)
    128c:	a6 01       	movw	r20, r12
    128e:	60 e0       	ldi	r22, 0x00	; 0
    1290:	70 e0       	ldi	r23, 0x00	; 0
    1292:	84 17       	cp	r24, r20
    1294:	95 07       	cpc	r25, r21
    1296:	a6 07       	cpc	r26, r22
    1298:	b7 07       	cpc	r27, r23
    129a:	08 f4       	brcc	.+2      	; 0x129e <pf_read+0x6a>
		btr = (UINT)remain; /* Truncate btr by remaining bytes */
    129c:	6c 01       	movw	r12, r24
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
		if (rcnt > btr)
			rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    129e:	53 01       	movw	r10, r6
    12a0:	94 c0       	rjmp	.+296    	; 0x13ca <pf_read+0x196>
	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {                       /* On the sector boundary? */
    12a2:	f7 01       	movw	r30, r14
    12a4:	86 89       	ldd	r24, Z+22	; 0x16
    12a6:	97 89       	ldd	r25, Z+23	; 0x17
    12a8:	a0 8d       	ldd	r26, Z+24	; 0x18
    12aa:	b1 8d       	ldd	r27, Z+25	; 0x19
    12ac:	ac 01       	movw	r20, r24
    12ae:	bd 01       	movw	r22, r26
    12b0:	51 70       	andi	r21, 0x01	; 1
    12b2:	66 27       	eor	r22, r22
    12b4:	77 27       	eor	r23, r23
    12b6:	45 2b       	or	r20, r21
    12b8:	46 2b       	or	r20, r22
    12ba:	47 2b       	or	r20, r23
    12bc:	09 f0       	breq	.+2      	; 0x12c0 <pf_read+0x8c>
    12be:	48 c0       	rjmp	.+144    	; 0x1350 <pf_read+0x11c>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    12c0:	c2 81       	ldd	r28, Z+2	; 0x02
    12c2:	c1 50       	subi	r28, 0x01	; 1
    12c4:	ac 01       	movw	r20, r24
    12c6:	bd 01       	movw	r22, r26
    12c8:	03 2e       	mov	r0, r19
    12ca:	39 e0       	ldi	r19, 0x09	; 9
    12cc:	76 95       	lsr	r23
    12ce:	67 95       	ror	r22
    12d0:	57 95       	ror	r21
    12d2:	47 95       	ror	r20
    12d4:	3a 95       	dec	r19
    12d6:	d1 f7       	brne	.-12     	; 0x12cc <pf_read+0x98>
    12d8:	30 2d       	mov	r19, r0
    12da:	c4 23       	and	r28, r20
			if (!cs) {                                     /* On the cluster boundary? */
    12dc:	f1 f4       	brne	.+60     	; 0x131a <pf_read+0xe6>
				if (fs->fptr == 0)                         /* On the top of the file? */
    12de:	89 2b       	or	r24, r25
    12e0:	8a 2b       	or	r24, r26
    12e2:	8b 2b       	or	r24, r27
    12e4:	29 f4       	brne	.+10     	; 0x12f0 <pf_read+0xbc>
					clst = fs->org_clust;
    12e6:	66 8d       	ldd	r22, Z+30	; 0x1e
    12e8:	77 8d       	ldd	r23, Z+31	; 0x1f
    12ea:	80 a1       	ldd	r24, Z+32	; 0x20
    12ec:	91 a1       	ldd	r25, Z+33	; 0x21
    12ee:	07 c0       	rjmp	.+14     	; 0x12fe <pf_read+0xca>
				else
					clst = get_fat(fs->curr_clust);
    12f0:	f7 01       	movw	r30, r14
    12f2:	62 a1       	ldd	r22, Z+34	; 0x22
    12f4:	73 a1       	ldd	r23, Z+35	; 0x23
    12f6:	84 a1       	ldd	r24, Z+36	; 0x24
    12f8:	95 a1       	ldd	r25, Z+37	; 0x25
    12fa:	0e 94 57 05 	call	0xaae	; 0xaae <get_fat>
				if (clst <= 1)
    12fe:	62 30       	cpi	r22, 0x02	; 2
    1300:	71 05       	cpc	r23, r1
    1302:	81 05       	cpc	r24, r1
    1304:	91 05       	cpc	r25, r1
    1306:	20 f4       	brcc	.+8      	; 0x1310 <pf_read+0xdc>
					ABORT(FR_DISK_ERR);
    1308:	f7 01       	movw	r30, r14
    130a:	11 82       	std	Z+1, r1	; 0x01
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	66 c0       	rjmp	.+204    	; 0x13dc <pf_read+0x1a8>
				fs->curr_clust = clst; /* Update current cluster */
    1310:	f7 01       	movw	r30, r14
    1312:	62 a3       	std	Z+34, r22	; 0x22
    1314:	73 a3       	std	Z+35, r23	; 0x23
    1316:	84 a3       	std	Z+36, r24	; 0x24
    1318:	95 a3       	std	Z+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    131a:	f7 01       	movw	r30, r14
    131c:	62 a1       	ldd	r22, Z+34	; 0x22
    131e:	73 a1       	ldd	r23, Z+35	; 0x23
    1320:	84 a1       	ldd	r24, Z+36	; 0x24
    1322:	95 a1       	ldd	r25, Z+37	; 0x25
    1324:	0e 94 3f 04 	call	0x87e	; 0x87e <clust2sect>
			if (!sect)
    1328:	61 15       	cp	r22, r1
    132a:	71 05       	cpc	r23, r1
    132c:	81 05       	cpc	r24, r1
    132e:	91 05       	cpc	r25, r1
    1330:	21 f4       	brne	.+8      	; 0x133a <pf_read+0x106>
				ABORT(FR_DISK_ERR);
    1332:	f7 01       	movw	r30, r14
    1334:	11 82       	std	Z+1, r1	; 0x01
    1336:	81 e0       	ldi	r24, 0x01	; 1
    1338:	51 c0       	rjmp	.+162    	; 0x13dc <pf_read+0x1a8>
			fs->dsect = sect + cs;
    133a:	dc 01       	movw	r26, r24
    133c:	cb 01       	movw	r24, r22
    133e:	8c 0f       	add	r24, r28
    1340:	91 1d       	adc	r25, r1
    1342:	a1 1d       	adc	r26, r1
    1344:	b1 1d       	adc	r27, r1
    1346:	f7 01       	movw	r30, r14
    1348:	86 a3       	std	Z+38, r24	; 0x26
    134a:	97 a3       	std	Z+39, r25	; 0x27
    134c:	a0 a7       	std	Z+40, r26	; 0x28
    134e:	b1 a7       	std	Z+41, r27	; 0x29
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
    1350:	f7 01       	movw	r30, r14
    1352:	86 89       	ldd	r24, Z+22	; 0x16
    1354:	97 89       	ldd	r25, Z+23	; 0x17
    1356:	a0 8d       	ldd	r26, Z+24	; 0x18
    1358:	b1 8d       	ldd	r27, Z+25	; 0x19
    135a:	9c 01       	movw	r18, r24
    135c:	31 70       	andi	r19, 0x01	; 1
    135e:	c0 e0       	ldi	r28, 0x00	; 0
    1360:	d2 e0       	ldi	r29, 0x02	; 2
    1362:	c2 1b       	sub	r28, r18
    1364:	d3 0b       	sbc	r29, r19
		if (rcnt > btr)
    1366:	cc 16       	cp	r12, r28
    1368:	dd 06       	cpc	r13, r29
    136a:	08 f4       	brcc	.+2      	; 0x136e <pf_read+0x13a>
			rcnt = btr;
    136c:	e6 01       	movw	r28, r12
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    136e:	f7 01       	movw	r30, r14
    1370:	46 a1       	ldd	r20, Z+38	; 0x26
    1372:	57 a1       	ldd	r21, Z+39	; 0x27
    1374:	60 a5       	ldd	r22, Z+40	; 0x28
    1376:	71 a5       	ldd	r23, Z+41	; 0x29
    1378:	61 14       	cp	r6, r1
    137a:	71 04       	cpc	r7, r1
    137c:	19 f4       	brne	.+6      	; 0x1384 <pf_read+0x150>
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	90 e0       	ldi	r25, 0x00	; 0
    1382:	02 c0       	rjmp	.+4      	; 0x1388 <pf_read+0x154>
    1384:	8a 2d       	mov	r24, r10
    1386:	9b 2d       	mov	r25, r11
    1388:	8e 01       	movw	r16, r28
    138a:	0e 94 ab 01 	call	0x356	; 0x356 <disk_readp>
		if (dr)
    138e:	88 23       	and	r24, r24
    1390:	21 f0       	breq	.+8      	; 0x139a <pf_read+0x166>
			ABORT(FR_DISK_ERR);
    1392:	f7 01       	movw	r30, r14
    1394:	11 82       	std	Z+1, r1	; 0x01
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	21 c0       	rjmp	.+66     	; 0x13dc <pf_read+0x1a8>
		fs->fptr += rcnt;
    139a:	f7 01       	movw	r30, r14
    139c:	86 89       	ldd	r24, Z+22	; 0x16
    139e:	97 89       	ldd	r25, Z+23	; 0x17
    13a0:	a0 8d       	ldd	r26, Z+24	; 0x18
    13a2:	b1 8d       	ldd	r27, Z+25	; 0x19
    13a4:	8c 0f       	add	r24, r28
    13a6:	9d 1f       	adc	r25, r29
    13a8:	a1 1d       	adc	r26, r1
    13aa:	b1 1d       	adc	r27, r1
    13ac:	86 8b       	std	Z+22, r24	; 0x16
    13ae:	97 8b       	std	Z+23, r25	; 0x17
    13b0:	a0 8f       	std	Z+24, r26	; 0x18
    13b2:	b1 8f       	std	Z+25, r27	; 0x19
		rbuff += rcnt; /* Update pointers and counters */
    13b4:	ac 0e       	add	r10, r28
    13b6:	bd 1e       	adc	r11, r29
		btr -= rcnt;
    13b8:	cc 1a       	sub	r12, r28
    13ba:	dd 0a       	sbc	r13, r29
		*br += rcnt;
    13bc:	f4 01       	movw	r30, r8
    13be:	80 81       	ld	r24, Z
    13c0:	91 81       	ldd	r25, Z+1	; 0x01
    13c2:	c8 0f       	add	r28, r24
    13c4:	d9 1f       	adc	r29, r25
    13c6:	d1 83       	std	Z+1, r29	; 0x01
    13c8:	c0 83       	st	Z, r28

	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
    13ca:	c1 14       	cp	r12, r1
    13cc:	d1 04       	cpc	r13, r1
    13ce:	09 f0       	breq	.+2      	; 0x13d2 <pf_read+0x19e>
    13d0:	68 cf       	rjmp	.-304    	; 0x12a2 <pf_read+0x6e>
		rbuff += rcnt; /* Update pointers and counters */
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	03 c0       	rjmp	.+6      	; 0x13dc <pf_read+0x1a8>
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;

	*br = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    13d6:	85 e0       	ldi	r24, 0x05	; 5
    13d8:	01 c0       	rjmp	.+2      	; 0x13dc <pf_read+0x1a8>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    13da:	84 e0       	ldi	r24, 0x04	; 4
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
}
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	1f 91       	pop	r17
    13e2:	0f 91       	pop	r16
    13e4:	ff 90       	pop	r15
    13e6:	ef 90       	pop	r14
    13e8:	df 90       	pop	r13
    13ea:	cf 90       	pop	r12
    13ec:	bf 90       	pop	r11
    13ee:	af 90       	pop	r10
    13f0:	9f 90       	pop	r9
    13f2:	8f 90       	pop	r8
    13f4:	7f 90       	pop	r7
    13f6:	6f 90       	pop	r6
    13f8:	08 95       	ret

000013fa <pf_write>:

FRESULT pf_write(const void *buff, /* Pointer to the data to be written */
                 UINT        btw,  /* Number of bytes to write (0:Finalize the current write operation) */
                 UINT *      bw    /* Pointer to number of bytes written */
)
{
    13fa:	4f 92       	push	r4
    13fc:	5f 92       	push	r5
    13fe:	6f 92       	push	r6
    1400:	7f 92       	push	r7
    1402:	af 92       	push	r10
    1404:	bf 92       	push	r11
    1406:	cf 92       	push	r12
    1408:	df 92       	push	r13
    140a:	ef 92       	push	r14
    140c:	ff 92       	push	r15
    140e:	0f 93       	push	r16
    1410:	1f 93       	push	r17
    1412:	cf 93       	push	r28
    1414:	df 93       	push	r29
    1416:	7c 01       	movw	r14, r24
    1418:	5b 01       	movw	r10, r22
    141a:	6a 01       	movw	r12, r20
	CLUST       clst;
	DWORD       sect, remain;
	const BYTE *p = buff;
	BYTE        cs;
	UINT        wcnt;
	FATFS *     fs = FatFs;
    141c:	c0 91 ae 05 	lds	r28, 0x05AE	; 0x8005ae <FatFs>
    1420:	d0 91 af 05 	lds	r29, 0x05AF	; 0x8005af <FatFs+0x1>

	*bw = 0;
    1424:	fa 01       	movw	r30, r20
    1426:	11 82       	std	Z+1, r1	; 0x01
    1428:	10 82       	st	Z, r1
	if (!fs)
    142a:	20 97       	sbiw	r28, 0x00	; 0
    142c:	09 f4       	brne	.+2      	; 0x1430 <pf_write+0x36>
    142e:	df c0       	rjmp	.+446    	; 0x15ee <pf_write+0x1f4>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    1430:	89 81       	ldd	r24, Y+1	; 0x01
    1432:	80 ff       	sbrs	r24, 0
    1434:	de c0       	rjmp	.+444    	; 0x15f2 <pf_write+0x1f8>
		return FR_NOT_OPENED;

	if (!btw) { /* Finalize request */
    1436:	67 2b       	or	r22, r23
    1438:	99 f4       	brne	.+38     	; 0x1460 <pf_write+0x66>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0))
    143a:	86 ff       	sbrs	r24, 6
    143c:	0c c0       	rjmp	.+24     	; 0x1456 <pf_write+0x5c>
    143e:	40 e0       	ldi	r20, 0x00	; 0
    1440:	50 e0       	ldi	r21, 0x00	; 0
    1442:	ba 01       	movw	r22, r20
    1444:	80 e0       	ldi	r24, 0x00	; 0
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	0e 94 0e 02 	call	0x41c	; 0x41c <disk_writep>
    144c:	88 23       	and	r24, r24
    144e:	19 f0       	breq	.+6      	; 0x1456 <pf_write+0x5c>
			ABORT(FR_DISK_ERR);
    1450:	19 82       	std	Y+1, r1	; 0x01
    1452:	81 e0       	ldi	r24, 0x01	; 1
    1454:	cf c0       	rjmp	.+414    	; 0x15f4 <pf_write+0x1fa>
		fs->flag &= ~FA__WIP;
    1456:	89 81       	ldd	r24, Y+1	; 0x01
    1458:	8f 7b       	andi	r24, 0xBF	; 191
    145a:	89 83       	std	Y+1, r24	; 0x01
		return FR_OK;
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	ca c0       	rjmp	.+404    	; 0x15f4 <pf_write+0x1fa>
	} else {                       /* Write data request */
		if (!(fs->flag & FA__WIP)) /* Round-down fptr to the sector boundary */
    1460:	86 fd       	sbrc	r24, 6
    1462:	0a c0       	rjmp	.+20     	; 0x1478 <pf_write+0x7e>
			fs->fptr &= 0xFFFFFE00;
    1464:	8e 89       	ldd	r24, Y+22	; 0x16
    1466:	9f 89       	ldd	r25, Y+23	; 0x17
    1468:	a8 8d       	ldd	r26, Y+24	; 0x18
    146a:	b9 8d       	ldd	r27, Y+25	; 0x19
    146c:	88 27       	eor	r24, r24
    146e:	9e 7f       	andi	r25, 0xFE	; 254
    1470:	8e 8b       	std	Y+22, r24	; 0x16
    1472:	9f 8b       	std	Y+23, r25	; 0x17
    1474:	a8 8f       	std	Y+24, r26	; 0x18
    1476:	b9 8f       	std	Y+25, r27	; 0x19
	}
	remain = fs->fsize - fs->fptr;
    1478:	8a 8d       	ldd	r24, Y+26	; 0x1a
    147a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    147c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    147e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1480:	4e 89       	ldd	r20, Y+22	; 0x16
    1482:	5f 89       	ldd	r21, Y+23	; 0x17
    1484:	68 8d       	ldd	r22, Y+24	; 0x18
    1486:	79 8d       	ldd	r23, Y+25	; 0x19
    1488:	84 1b       	sub	r24, r20
    148a:	95 0b       	sbc	r25, r21
    148c:	a6 0b       	sbc	r26, r22
    148e:	b7 0b       	sbc	r27, r23
	if (btw > remain)
    1490:	a5 01       	movw	r20, r10
    1492:	60 e0       	ldi	r22, 0x00	; 0
    1494:	70 e0       	ldi	r23, 0x00	; 0
    1496:	84 17       	cp	r24, r20
    1498:	95 07       	cpc	r25, r21
    149a:	a6 07       	cpc	r26, r22
    149c:	b7 07       	cpc	r27, r23
    149e:	08 f0       	brcs	.+2      	; 0x14a2 <pf_write+0xa8>
    14a0:	a0 c0       	rjmp	.+320    	; 0x15e2 <pf_write+0x1e8>
		btw = (UINT)remain; /* Truncate btw by remaining bytes */
    14a2:	5c 01       	movw	r10, r24
    14a4:	9e c0       	rjmp	.+316    	; 0x15e2 <pf_write+0x1e8>

	while (btw) {                                          /* Repeat until all data transferred */
		if ((UINT)fs->fptr % 512 == 0) {                   /* On the sector boundary? */
    14a6:	8e 89       	ldd	r24, Y+22	; 0x16
    14a8:	9f 89       	ldd	r25, Y+23	; 0x17
    14aa:	a8 8d       	ldd	r26, Y+24	; 0x18
    14ac:	b9 8d       	ldd	r27, Y+25	; 0x19
    14ae:	9c 01       	movw	r18, r24
    14b0:	31 70       	andi	r19, 0x01	; 1
    14b2:	23 2b       	or	r18, r19
    14b4:	09 f0       	breq	.+2      	; 0x14b8 <pf_write+0xbe>
    14b6:	4e c0       	rjmp	.+156    	; 0x1554 <pf_write+0x15a>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    14b8:	1a 81       	ldd	r17, Y+2	; 0x02
    14ba:	11 50       	subi	r17, 0x01	; 1
    14bc:	ac 01       	movw	r20, r24
    14be:	bd 01       	movw	r22, r26
    14c0:	03 2e       	mov	r0, r19
    14c2:	39 e0       	ldi	r19, 0x09	; 9
    14c4:	76 95       	lsr	r23
    14c6:	67 95       	ror	r22
    14c8:	57 95       	ror	r21
    14ca:	47 95       	ror	r20
    14cc:	3a 95       	dec	r19
    14ce:	d1 f7       	brne	.-12     	; 0x14c4 <pf_write+0xca>
    14d0:	30 2d       	mov	r19, r0
    14d2:	14 23       	and	r17, r20
			if (!cs) {                                     /* On the cluster boundary? */
    14d4:	d9 f4       	brne	.+54     	; 0x150c <pf_write+0x112>
				if (fs->fptr == 0)                         /* On the top of the file? */
    14d6:	89 2b       	or	r24, r25
    14d8:	8a 2b       	or	r24, r26
    14da:	8b 2b       	or	r24, r27
    14dc:	29 f4       	brne	.+10     	; 0x14e8 <pf_write+0xee>
					clst = fs->org_clust;
    14de:	6e 8d       	ldd	r22, Y+30	; 0x1e
    14e0:	7f 8d       	ldd	r23, Y+31	; 0x1f
    14e2:	88 a1       	ldd	r24, Y+32	; 0x20
    14e4:	99 a1       	ldd	r25, Y+33	; 0x21
    14e6:	06 c0       	rjmp	.+12     	; 0x14f4 <pf_write+0xfa>
				else
					clst = get_fat(fs->curr_clust);
    14e8:	6a a1       	ldd	r22, Y+34	; 0x22
    14ea:	7b a1       	ldd	r23, Y+35	; 0x23
    14ec:	8c a1       	ldd	r24, Y+36	; 0x24
    14ee:	9d a1       	ldd	r25, Y+37	; 0x25
    14f0:	0e 94 57 05 	call	0xaae	; 0xaae <get_fat>
				if (clst <= 1)
    14f4:	62 30       	cpi	r22, 0x02	; 2
    14f6:	71 05       	cpc	r23, r1
    14f8:	81 05       	cpc	r24, r1
    14fa:	91 05       	cpc	r25, r1
    14fc:	18 f4       	brcc	.+6      	; 0x1504 <pf_write+0x10a>
					ABORT(FR_DISK_ERR);
    14fe:	19 82       	std	Y+1, r1	; 0x01
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	78 c0       	rjmp	.+240    	; 0x15f4 <pf_write+0x1fa>
				fs->curr_clust = clst; /* Update current cluster */
    1504:	6a a3       	std	Y+34, r22	; 0x22
    1506:	7b a3       	std	Y+35, r23	; 0x23
    1508:	8c a3       	std	Y+36, r24	; 0x24
    150a:	9d a3       	std	Y+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    150c:	6a a1       	ldd	r22, Y+34	; 0x22
    150e:	7b a1       	ldd	r23, Y+35	; 0x23
    1510:	8c a1       	ldd	r24, Y+36	; 0x24
    1512:	9d a1       	ldd	r25, Y+37	; 0x25
    1514:	0e 94 3f 04 	call	0x87e	; 0x87e <clust2sect>
			if (!sect)
    1518:	61 15       	cp	r22, r1
    151a:	71 05       	cpc	r23, r1
    151c:	81 05       	cpc	r24, r1
    151e:	91 05       	cpc	r25, r1
    1520:	19 f4       	brne	.+6      	; 0x1528 <pf_write+0x12e>
				ABORT(FR_DISK_ERR);
    1522:	19 82       	std	Y+1, r1	; 0x01
    1524:	81 e0       	ldi	r24, 0x01	; 1
    1526:	66 c0       	rjmp	.+204    	; 0x15f4 <pf_write+0x1fa>
			fs->dsect = sect + cs;
    1528:	ab 01       	movw	r20, r22
    152a:	bc 01       	movw	r22, r24
    152c:	41 0f       	add	r20, r17
    152e:	51 1d       	adc	r21, r1
    1530:	61 1d       	adc	r22, r1
    1532:	71 1d       	adc	r23, r1
    1534:	4e a3       	std	Y+38, r20	; 0x26
    1536:	5f a3       	std	Y+39, r21	; 0x27
    1538:	68 a7       	std	Y+40, r22	; 0x28
    153a:	79 a7       	std	Y+41, r23	; 0x29
			if (disk_writep(0, fs->dsect))
    153c:	80 e0       	ldi	r24, 0x00	; 0
    153e:	90 e0       	ldi	r25, 0x00	; 0
    1540:	0e 94 0e 02 	call	0x41c	; 0x41c <disk_writep>
    1544:	88 23       	and	r24, r24
    1546:	19 f0       	breq	.+6      	; 0x154e <pf_write+0x154>
				ABORT(FR_DISK_ERR); /* Initiate a sector write operation */
    1548:	19 82       	std	Y+1, r1	; 0x01
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	53 c0       	rjmp	.+166    	; 0x15f4 <pf_write+0x1fa>
			fs->flag |= FA__WIP;
    154e:	89 81       	ldd	r24, Y+1	; 0x01
    1550:	80 64       	ori	r24, 0x40	; 64
    1552:	89 83       	std	Y+1, r24	; 0x01
		}
		wcnt = 512 - (UINT)fs->fptr % 512; /* Number of bytes to write to the sector */
    1554:	8e 89       	ldd	r24, Y+22	; 0x16
    1556:	9f 89       	ldd	r25, Y+23	; 0x17
    1558:	a8 8d       	ldd	r26, Y+24	; 0x18
    155a:	b9 8d       	ldd	r27, Y+25	; 0x19
    155c:	91 70       	andi	r25, 0x01	; 1
    155e:	00 e0       	ldi	r16, 0x00	; 0
    1560:	12 e0       	ldi	r17, 0x02	; 2
    1562:	08 1b       	sub	r16, r24
    1564:	19 0b       	sbc	r17, r25
		if (wcnt > btw)
    1566:	a0 16       	cp	r10, r16
    1568:	b1 06       	cpc	r11, r17
    156a:	08 f4       	brcc	.+2      	; 0x156e <pf_write+0x174>
			wcnt = btw;
    156c:	85 01       	movw	r16, r10
		if (disk_writep(p, wcnt))
    156e:	28 01       	movw	r4, r16
    1570:	61 2c       	mov	r6, r1
    1572:	71 2c       	mov	r7, r1
    1574:	b3 01       	movw	r22, r6
    1576:	a2 01       	movw	r20, r4
    1578:	c7 01       	movw	r24, r14
    157a:	0e 94 0e 02 	call	0x41c	; 0x41c <disk_writep>
    157e:	88 23       	and	r24, r24
    1580:	19 f0       	breq	.+6      	; 0x1588 <pf_write+0x18e>
			ABORT(FR_DISK_ERR); /* Send data to the sector */
    1582:	19 82       	std	Y+1, r1	; 0x01
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	36 c0       	rjmp	.+108    	; 0x15f4 <pf_write+0x1fa>
		fs->fptr += wcnt;
    1588:	8e 89       	ldd	r24, Y+22	; 0x16
    158a:	9f 89       	ldd	r25, Y+23	; 0x17
    158c:	a8 8d       	ldd	r26, Y+24	; 0x18
    158e:	b9 8d       	ldd	r27, Y+25	; 0x19
    1590:	48 0e       	add	r4, r24
    1592:	59 1e       	adc	r5, r25
    1594:	6a 1e       	adc	r6, r26
    1596:	7b 1e       	adc	r7, r27
    1598:	4e 8a       	std	Y+22, r4	; 0x16
    159a:	5f 8a       	std	Y+23, r5	; 0x17
    159c:	68 8e       	std	Y+24, r6	; 0x18
    159e:	79 8e       	std	Y+25, r7	; 0x19
		p += wcnt; /* Update pointers and counters */
    15a0:	e0 0e       	add	r14, r16
    15a2:	f1 1e       	adc	r15, r17
		btw -= wcnt;
    15a4:	a0 1a       	sub	r10, r16
    15a6:	b1 0a       	sbc	r11, r17
		*bw += wcnt;
    15a8:	f6 01       	movw	r30, r12
    15aa:	80 81       	ld	r24, Z
    15ac:	91 81       	ldd	r25, Z+1	; 0x01
    15ae:	08 0f       	add	r16, r24
    15b0:	19 1f       	adc	r17, r25
    15b2:	11 83       	std	Z+1, r17	; 0x01
    15b4:	00 83       	st	Z, r16
		if ((UINT)fs->fptr % 512 == 0) {
    15b6:	8e 89       	ldd	r24, Y+22	; 0x16
    15b8:	9f 89       	ldd	r25, Y+23	; 0x17
    15ba:	a8 8d       	ldd	r26, Y+24	; 0x18
    15bc:	b9 8d       	ldd	r27, Y+25	; 0x19
    15be:	91 70       	andi	r25, 0x01	; 1
    15c0:	89 2b       	or	r24, r25
    15c2:	79 f4       	brne	.+30     	; 0x15e2 <pf_write+0x1e8>
			if (disk_writep(0, 0))
    15c4:	40 e0       	ldi	r20, 0x00	; 0
    15c6:	50 e0       	ldi	r21, 0x00	; 0
    15c8:	ba 01       	movw	r22, r20
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	90 e0       	ldi	r25, 0x00	; 0
    15ce:	0e 94 0e 02 	call	0x41c	; 0x41c <disk_writep>
    15d2:	88 23       	and	r24, r24
    15d4:	19 f0       	breq	.+6      	; 0x15dc <pf_write+0x1e2>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
    15d6:	19 82       	std	Y+1, r1	; 0x01
    15d8:	81 e0       	ldi	r24, 0x01	; 1
    15da:	0c c0       	rjmp	.+24     	; 0x15f4 <pf_write+0x1fa>
			fs->flag &= ~FA__WIP;
    15dc:	89 81       	ldd	r24, Y+1	; 0x01
    15de:	8f 7b       	andi	r24, 0xBF	; 191
    15e0:	89 83       	std	Y+1, r24	; 0x01
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain)
		btw = (UINT)remain; /* Truncate btw by remaining bytes */

	while (btw) {                                          /* Repeat until all data transferred */
    15e2:	a1 14       	cp	r10, r1
    15e4:	b1 04       	cpc	r11, r1
    15e6:	09 f0       	breq	.+2      	; 0x15ea <pf_write+0x1f0>
    15e8:	5e cf       	rjmp	.-324    	; 0x14a6 <pf_write+0xac>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	03 c0       	rjmp	.+6      	; 0x15f4 <pf_write+0x1fa>
	UINT        wcnt;
	FATFS *     fs = FatFs;

	*bw = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    15ee:	85 e0       	ldi	r24, 0x05	; 5
    15f0:	01 c0       	rjmp	.+2      	; 0x15f4 <pf_write+0x1fa>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    15f2:	84 e0       	ldi	r24, 0x04	; 4
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
}
    15f4:	df 91       	pop	r29
    15f6:	cf 91       	pop	r28
    15f8:	1f 91       	pop	r17
    15fa:	0f 91       	pop	r16
    15fc:	ff 90       	pop	r15
    15fe:	ef 90       	pop	r14
    1600:	df 90       	pop	r13
    1602:	cf 90       	pop	r12
    1604:	bf 90       	pop	r11
    1606:	af 90       	pop	r10
    1608:	7f 90       	pop	r7
    160a:	6f 90       	pop	r6
    160c:	5f 90       	pop	r5
    160e:	4f 90       	pop	r4
    1610:	08 95       	ret

00001612 <pf_lseek>:
/*-----------------------------------------------------------------------*/
#if _USE_LSEEK

FRESULT pf_lseek(DWORD ofs /* File pointer from top of file */
)
{
    1612:	4f 92       	push	r4
    1614:	5f 92       	push	r5
    1616:	6f 92       	push	r6
    1618:	7f 92       	push	r7
    161a:	8f 92       	push	r8
    161c:	9f 92       	push	r9
    161e:	af 92       	push	r10
    1620:	bf 92       	push	r11
    1622:	cf 92       	push	r12
    1624:	df 92       	push	r13
    1626:	ef 92       	push	r14
    1628:	ff 92       	push	r15
    162a:	cf 93       	push	r28
    162c:	df 93       	push	r29
    162e:	00 d0       	rcall	.+0      	; 0x1630 <pf_lseek+0x1e>
    1630:	00 d0       	rcall	.+0      	; 0x1632 <pf_lseek+0x20>
    1632:	00 d0       	rcall	.+0      	; 0x1634 <pf_lseek+0x22>
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;
    1638:	20 91 ae 05 	lds	r18, 0x05AE	; 0x8005ae <FatFs>
    163c:	30 91 af 05 	lds	r19, 0x05AF	; 0x8005af <FatFs+0x1>
    1640:	3e 83       	std	Y+6, r19	; 0x06
    1642:	2d 83       	std	Y+5, r18	; 0x05

	if (!fs)
    1644:	21 15       	cp	r18, r1
    1646:	31 05       	cpc	r19, r1
    1648:	09 f4       	brne	.+2      	; 0x164c <pf_lseek+0x3a>
    164a:	f4 c0       	rjmp	.+488    	; 0x1834 <pf_lseek+0x222>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    164c:	d9 01       	movw	r26, r18
    164e:	11 96       	adiw	r26, 0x01	; 1
    1650:	2c 91       	ld	r18, X
    1652:	11 97       	sbiw	r26, 0x01	; 1
    1654:	20 ff       	sbrs	r18, 0
    1656:	f0 c0       	rjmp	.+480    	; 0x1838 <pf_lseek+0x226>
		return FR_NOT_OPENED;

	if (ofs > fs->fsize)
    1658:	5a 96       	adiw	r26, 0x1a	; 26
    165a:	cd 90       	ld	r12, X+
    165c:	dd 90       	ld	r13, X+
    165e:	ed 90       	ld	r14, X+
    1660:	fc 90       	ld	r15, X
    1662:	5d 97       	sbiw	r26, 0x1d	; 29
    1664:	c6 16       	cp	r12, r22
    1666:	d7 06       	cpc	r13, r23
    1668:	e8 06       	cpc	r14, r24
    166a:	f9 06       	cpc	r15, r25
    166c:	10 f0       	brcs	.+4      	; 0x1672 <pf_lseek+0x60>
    166e:	6b 01       	movw	r12, r22
    1670:	7c 01       	movw	r14, r24
		ofs = fs->fsize; /* Clip offset with the file size */
	ifptr    = fs->fptr;
    1672:	ed 81       	ldd	r30, Y+5	; 0x05
    1674:	fe 81       	ldd	r31, Y+6	; 0x06
    1676:	46 88       	ldd	r4, Z+22	; 0x16
    1678:	57 88       	ldd	r5, Z+23	; 0x17
    167a:	60 8c       	ldd	r6, Z+24	; 0x18
    167c:	71 8c       	ldd	r7, Z+25	; 0x19
	fs->fptr = 0;
    167e:	16 8a       	std	Z+22, r1	; 0x16
    1680:	17 8a       	std	Z+23, r1	; 0x17
    1682:	10 8e       	std	Z+24, r1	; 0x18
    1684:	11 8e       	std	Z+25, r1	; 0x19
	if (ofs > 0) {
    1686:	c1 14       	cp	r12, r1
    1688:	d1 04       	cpc	r13, r1
    168a:	e1 04       	cpc	r14, r1
    168c:	f1 04       	cpc	r15, r1
    168e:	09 f4       	brne	.+2      	; 0x1692 <pf_lseek+0x80>
    1690:	d5 c0       	rjmp	.+426    	; 0x183c <pf_lseek+0x22a>
		bcs = (DWORD)fs->csize * 512;                            /* Cluster size (byte) */
    1692:	82 80       	ldd	r8, Z+2	; 0x02
    1694:	91 2c       	mov	r9, r1
    1696:	a1 2c       	mov	r10, r1
    1698:	b1 2c       	mov	r11, r1
    169a:	07 2e       	mov	r0, r23
    169c:	79 e0       	ldi	r23, 0x09	; 9
    169e:	88 0c       	add	r8, r8
    16a0:	99 1c       	adc	r9, r9
    16a2:	aa 1c       	adc	r10, r10
    16a4:	bb 1c       	adc	r11, r11
    16a6:	7a 95       	dec	r23
    16a8:	d1 f7       	brne	.-12     	; 0x169e <pf_lseek+0x8c>
    16aa:	70 2d       	mov	r23, r0
		if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
    16ac:	41 14       	cp	r4, r1
    16ae:	51 04       	cpc	r5, r1
    16b0:	61 04       	cpc	r6, r1
    16b2:	71 04       	cpc	r7, r1
    16b4:	09 f4       	brne	.+2      	; 0x16b8 <pf_lseek+0xa6>
    16b6:	40 c0       	rjmp	.+128    	; 0x1738 <pf_lseek+0x126>
    16b8:	c7 01       	movw	r24, r14
    16ba:	b6 01       	movw	r22, r12
    16bc:	61 50       	subi	r22, 0x01	; 1
    16be:	71 09       	sbc	r23, r1
    16c0:	81 09       	sbc	r24, r1
    16c2:	91 09       	sbc	r25, r1
    16c4:	a5 01       	movw	r20, r10
    16c6:	94 01       	movw	r18, r8
    16c8:	0e 94 34 0c 	call	0x1868	; 0x1868 <__udivmodsi4>
    16cc:	29 83       	std	Y+1, r18	; 0x01
    16ce:	3a 83       	std	Y+2, r19	; 0x02
    16d0:	4b 83       	std	Y+3, r20	; 0x03
    16d2:	5c 83       	std	Y+4, r21	; 0x04
    16d4:	b1 e0       	ldi	r27, 0x01	; 1
    16d6:	4b 1a       	sub	r4, r27
    16d8:	51 08       	sbc	r5, r1
    16da:	61 08       	sbc	r6, r1
    16dc:	71 08       	sbc	r7, r1
    16de:	c3 01       	movw	r24, r6
    16e0:	b2 01       	movw	r22, r4
    16e2:	a5 01       	movw	r20, r10
    16e4:	94 01       	movw	r18, r8
    16e6:	0e 94 34 0c 	call	0x1868	; 0x1868 <__udivmodsi4>
    16ea:	89 81       	ldd	r24, Y+1	; 0x01
    16ec:	9a 81       	ldd	r25, Y+2	; 0x02
    16ee:	ab 81       	ldd	r26, Y+3	; 0x03
    16f0:	bc 81       	ldd	r27, Y+4	; 0x04
    16f2:	82 17       	cp	r24, r18
    16f4:	93 07       	cpc	r25, r19
    16f6:	a4 07       	cpc	r26, r20
    16f8:	b5 07       	cpc	r27, r21
    16fa:	f0 f0       	brcs	.+60     	; 0x1738 <pf_lseek+0x126>
			fs->fptr = (ifptr - 1) & ~(bcs - 1);                 /* start from the current cluster */
    16fc:	88 27       	eor	r24, r24
    16fe:	99 27       	eor	r25, r25
    1700:	dc 01       	movw	r26, r24
    1702:	88 19       	sub	r24, r8
    1704:	99 09       	sbc	r25, r9
    1706:	aa 09       	sbc	r26, r10
    1708:	bb 09       	sbc	r27, r11
    170a:	48 22       	and	r4, r24
    170c:	59 22       	and	r5, r25
    170e:	6a 22       	and	r6, r26
    1710:	7b 22       	and	r7, r27
    1712:	ad 81       	ldd	r26, Y+5	; 0x05
    1714:	be 81       	ldd	r27, Y+6	; 0x06
    1716:	56 96       	adiw	r26, 0x16	; 22
    1718:	4d 92       	st	X+, r4
    171a:	5d 92       	st	X+, r5
    171c:	6d 92       	st	X+, r6
    171e:	7c 92       	st	X, r7
    1720:	59 97       	sbiw	r26, 0x19	; 25
			ofs -= fs->fptr;
    1722:	c4 18       	sub	r12, r4
    1724:	d5 08       	sbc	r13, r5
    1726:	e6 08       	sbc	r14, r6
    1728:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    172a:	92 96       	adiw	r26, 0x22	; 34
    172c:	6d 91       	ld	r22, X+
    172e:	7d 91       	ld	r23, X+
    1730:	8d 91       	ld	r24, X+
    1732:	9c 91       	ld	r25, X
    1734:	95 97       	sbiw	r26, 0x25	; 37
    1736:	39 c0       	rjmp	.+114    	; 0x17aa <pf_lseek+0x198>
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
    1738:	ed 81       	ldd	r30, Y+5	; 0x05
    173a:	fe 81       	ldd	r31, Y+6	; 0x06
    173c:	66 8d       	ldd	r22, Z+30	; 0x1e
    173e:	77 8d       	ldd	r23, Z+31	; 0x1f
    1740:	80 a1       	ldd	r24, Z+32	; 0x20
    1742:	91 a1       	ldd	r25, Z+33	; 0x21
			fs->curr_clust = clst;
    1744:	62 a3       	std	Z+34, r22	; 0x22
    1746:	73 a3       	std	Z+35, r23	; 0x23
    1748:	84 a3       	std	Z+36, r24	; 0x24
    174a:	95 a3       	std	Z+37, r25	; 0x25
    174c:	2e c0       	rjmp	.+92     	; 0x17aa <pf_lseek+0x198>
		}
		while (ofs > bcs) {       /* Cluster following loop */
			clst = get_fat(clst); /* Follow cluster chain */
    174e:	0e 94 57 05 	call	0xaae	; 0xaae <get_fat>
			if (clst <= 1 || clst >= fs->n_fatent)
    1752:	62 30       	cpi	r22, 0x02	; 2
    1754:	71 05       	cpc	r23, r1
    1756:	81 05       	cpc	r24, r1
    1758:	91 05       	cpc	r25, r1
    175a:	58 f0       	brcs	.+22     	; 0x1772 <pf_lseek+0x160>
    175c:	ed 81       	ldd	r30, Y+5	; 0x05
    175e:	fe 81       	ldd	r31, Y+6	; 0x06
    1760:	46 80       	ldd	r4, Z+6	; 0x06
    1762:	57 80       	ldd	r5, Z+7	; 0x07
    1764:	60 84       	ldd	r6, Z+8	; 0x08
    1766:	71 84       	ldd	r7, Z+9	; 0x09
    1768:	64 15       	cp	r22, r4
    176a:	75 05       	cpc	r23, r5
    176c:	86 05       	cpc	r24, r6
    176e:	97 05       	cpc	r25, r7
    1770:	30 f0       	brcs	.+12     	; 0x177e <pf_lseek+0x16c>
				ABORT(FR_DISK_ERR);
    1772:	ad 81       	ldd	r26, Y+5	; 0x05
    1774:	be 81       	ldd	r27, Y+6	; 0x06
    1776:	11 96       	adiw	r26, 0x01	; 1
    1778:	1c 92       	st	X, r1
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	60 c0       	rjmp	.+192    	; 0x183e <pf_lseek+0x22c>
			fs->curr_clust = clst;
    177e:	ed 81       	ldd	r30, Y+5	; 0x05
    1780:	fe 81       	ldd	r31, Y+6	; 0x06
    1782:	62 a3       	std	Z+34, r22	; 0x22
    1784:	73 a3       	std	Z+35, r23	; 0x23
    1786:	84 a3       	std	Z+36, r24	; 0x24
    1788:	95 a3       	std	Z+37, r25	; 0x25
			fs->fptr += bcs;
    178a:	46 88       	ldd	r4, Z+22	; 0x16
    178c:	57 88       	ldd	r5, Z+23	; 0x17
    178e:	60 8c       	ldd	r6, Z+24	; 0x18
    1790:	71 8c       	ldd	r7, Z+25	; 0x19
    1792:	48 0c       	add	r4, r8
    1794:	59 1c       	adc	r5, r9
    1796:	6a 1c       	adc	r6, r10
    1798:	7b 1c       	adc	r7, r11
    179a:	46 8a       	std	Z+22, r4	; 0x16
    179c:	57 8a       	std	Z+23, r5	; 0x17
    179e:	60 8e       	std	Z+24, r6	; 0x18
    17a0:	71 8e       	std	Z+25, r7	; 0x19
			ofs -= bcs;
    17a2:	c8 18       	sub	r12, r8
    17a4:	d9 08       	sbc	r13, r9
    17a6:	ea 08       	sbc	r14, r10
    17a8:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {       /* Cluster following loop */
    17aa:	8c 14       	cp	r8, r12
    17ac:	9d 04       	cpc	r9, r13
    17ae:	ae 04       	cpc	r10, r14
    17b0:	bf 04       	cpc	r11, r15
    17b2:	68 f2       	brcs	.-102    	; 0x174e <pf_lseek+0x13c>
				ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    17b4:	ed 81       	ldd	r30, Y+5	; 0x05
    17b6:	fe 81       	ldd	r31, Y+6	; 0x06
    17b8:	86 88       	ldd	r8, Z+22	; 0x16
    17ba:	97 88       	ldd	r9, Z+23	; 0x17
    17bc:	a0 8c       	ldd	r10, Z+24	; 0x18
    17be:	b1 8c       	ldd	r11, Z+25	; 0x19
    17c0:	c8 0c       	add	r12, r8
    17c2:	d9 1c       	adc	r13, r9
    17c4:	ea 1c       	adc	r14, r10
    17c6:	fb 1c       	adc	r15, r11
    17c8:	c6 8a       	std	Z+22, r12	; 0x16
    17ca:	d7 8a       	std	Z+23, r13	; 0x17
    17cc:	e0 8e       	std	Z+24, r14	; 0x18
    17ce:	f1 8e       	std	Z+25, r15	; 0x19
		sect = clust2sect(clst); /* Current sector */
    17d0:	0e 94 3f 04 	call	0x87e	; 0x87e <clust2sect>
		if (!sect)
    17d4:	61 15       	cp	r22, r1
    17d6:	71 05       	cpc	r23, r1
    17d8:	81 05       	cpc	r24, r1
    17da:	91 05       	cpc	r25, r1
    17dc:	29 f4       	brne	.+10     	; 0x17e8 <pf_lseek+0x1d6>
			ABORT(FR_DISK_ERR);
    17de:	ed 81       	ldd	r30, Y+5	; 0x05
    17e0:	fe 81       	ldd	r31, Y+6	; 0x06
    17e2:	11 82       	std	Z+1, r1	; 0x01
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	2b c0       	rjmp	.+86     	; 0x183e <pf_lseek+0x22c>
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    17e8:	0b 2e       	mov	r0, r27
    17ea:	b9 e0       	ldi	r27, 0x09	; 9
    17ec:	f6 94       	lsr	r15
    17ee:	e7 94       	ror	r14
    17f0:	d7 94       	ror	r13
    17f2:	c7 94       	ror	r12
    17f4:	ba 95       	dec	r27
    17f6:	d1 f7       	brne	.-12     	; 0x17ec <pf_lseek+0x1da>
    17f8:	b0 2d       	mov	r27, r0
    17fa:	ad 81       	ldd	r26, Y+5	; 0x05
    17fc:	be 81       	ldd	r27, Y+6	; 0x06
    17fe:	12 96       	adiw	r26, 0x02	; 2
    1800:	2c 91       	ld	r18, X
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	21 50       	subi	r18, 0x01	; 1
    1806:	31 09       	sbc	r19, r1
    1808:	49 01       	movw	r8, r18
    180a:	33 0f       	add	r19, r19
    180c:	aa 08       	sbc	r10, r10
    180e:	bb 08       	sbc	r11, r11
    1810:	c8 20       	and	r12, r8
    1812:	d9 20       	and	r13, r9
    1814:	ea 20       	and	r14, r10
    1816:	fb 20       	and	r15, r11
    1818:	dc 01       	movw	r26, r24
    181a:	cb 01       	movw	r24, r22
    181c:	8c 0d       	add	r24, r12
    181e:	9d 1d       	adc	r25, r13
    1820:	ae 1d       	adc	r26, r14
    1822:	bf 1d       	adc	r27, r15
    1824:	ed 81       	ldd	r30, Y+5	; 0x05
    1826:	fe 81       	ldd	r31, Y+6	; 0x06
    1828:	86 a3       	std	Z+38, r24	; 0x26
    182a:	97 a3       	std	Z+39, r25	; 0x27
    182c:	a0 a7       	std	Z+40, r26	; 0x28
    182e:	b1 a7       	std	Z+41, r27	; 0x29
	}

	return FR_OK;
    1830:	80 e0       	ldi	r24, 0x00	; 0
    1832:	05 c0       	rjmp	.+10     	; 0x183e <pf_lseek+0x22c>
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1834:	85 e0       	ldi	r24, 0x05	; 5
    1836:	03 c0       	rjmp	.+6      	; 0x183e <pf_lseek+0x22c>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1838:	84 e0       	ldi	r24, 0x04	; 4
    183a:	01 c0       	rjmp	.+2      	; 0x183e <pf_lseek+0x22c>
		if (!sect)
			ABORT(FR_DISK_ERR);
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
    183c:	80 e0       	ldi	r24, 0x00	; 0
}
    183e:	26 96       	adiw	r28, 0x06	; 6
    1840:	0f b6       	in	r0, 0x3f	; 63
    1842:	f8 94       	cli
    1844:	de bf       	out	0x3e, r29	; 62
    1846:	0f be       	out	0x3f, r0	; 63
    1848:	cd bf       	out	0x3d, r28	; 61
    184a:	df 91       	pop	r29
    184c:	cf 91       	pop	r28
    184e:	ff 90       	pop	r15
    1850:	ef 90       	pop	r14
    1852:	df 90       	pop	r13
    1854:	cf 90       	pop	r12
    1856:	bf 90       	pop	r11
    1858:	af 90       	pop	r10
    185a:	9f 90       	pop	r9
    185c:	8f 90       	pop	r8
    185e:	7f 90       	pop	r7
    1860:	6f 90       	pop	r6
    1862:	5f 90       	pop	r5
    1864:	4f 90       	pop	r4
    1866:	08 95       	ret

00001868 <__udivmodsi4>:
    1868:	a1 e2       	ldi	r26, 0x21	; 33
    186a:	1a 2e       	mov	r1, r26
    186c:	aa 1b       	sub	r26, r26
    186e:	bb 1b       	sub	r27, r27
    1870:	fd 01       	movw	r30, r26
    1872:	0d c0       	rjmp	.+26     	; 0x188e <__udivmodsi4_ep>

00001874 <__udivmodsi4_loop>:
    1874:	aa 1f       	adc	r26, r26
    1876:	bb 1f       	adc	r27, r27
    1878:	ee 1f       	adc	r30, r30
    187a:	ff 1f       	adc	r31, r31
    187c:	a2 17       	cp	r26, r18
    187e:	b3 07       	cpc	r27, r19
    1880:	e4 07       	cpc	r30, r20
    1882:	f5 07       	cpc	r31, r21
    1884:	20 f0       	brcs	.+8      	; 0x188e <__udivmodsi4_ep>
    1886:	a2 1b       	sub	r26, r18
    1888:	b3 0b       	sbc	r27, r19
    188a:	e4 0b       	sbc	r30, r20
    188c:	f5 0b       	sbc	r31, r21

0000188e <__udivmodsi4_ep>:
    188e:	66 1f       	adc	r22, r22
    1890:	77 1f       	adc	r23, r23
    1892:	88 1f       	adc	r24, r24
    1894:	99 1f       	adc	r25, r25
    1896:	1a 94       	dec	r1
    1898:	69 f7       	brne	.-38     	; 0x1874 <__udivmodsi4_loop>
    189a:	60 95       	com	r22
    189c:	70 95       	com	r23
    189e:	80 95       	com	r24
    18a0:	90 95       	com	r25
    18a2:	9b 01       	movw	r18, r22
    18a4:	ac 01       	movw	r20, r24
    18a6:	bd 01       	movw	r22, r26
    18a8:	cf 01       	movw	r24, r30
    18aa:	08 95       	ret

000018ac <__muluhisi3>:
    18ac:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <__umulhisi3>
    18b0:	a5 9f       	mul	r26, r21
    18b2:	90 0d       	add	r25, r0
    18b4:	b4 9f       	mul	r27, r20
    18b6:	90 0d       	add	r25, r0
    18b8:	a4 9f       	mul	r26, r20
    18ba:	80 0d       	add	r24, r0
    18bc:	91 1d       	adc	r25, r1
    18be:	11 24       	eor	r1, r1
    18c0:	08 95       	ret

000018c2 <__umulhisi3>:
    18c2:	a2 9f       	mul	r26, r18
    18c4:	b0 01       	movw	r22, r0
    18c6:	b3 9f       	mul	r27, r19
    18c8:	c0 01       	movw	r24, r0
    18ca:	a3 9f       	mul	r26, r19
    18cc:	70 0d       	add	r23, r0
    18ce:	81 1d       	adc	r24, r1
    18d0:	11 24       	eor	r1, r1
    18d2:	91 1d       	adc	r25, r1
    18d4:	b2 9f       	mul	r27, r18
    18d6:	70 0d       	add	r23, r0
    18d8:	81 1d       	adc	r24, r1
    18da:	11 24       	eor	r1, r1
    18dc:	91 1d       	adc	r25, r1
    18de:	08 95       	ret

000018e0 <_exit>:
    18e0:	f8 94       	cli

000018e2 <__stop_program>:
    18e2:	ff cf       	rjmp	.-2      	; 0x18e2 <__stop_program>
