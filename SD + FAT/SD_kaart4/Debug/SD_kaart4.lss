
SD_kaart4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a0  00800100  00001bac  00001c40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001bac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000051a  008001a0  008001a0  00001ce0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001ce0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001d10  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001b0  00000000  00000000  00001d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002acc  00000000  00000000  00001efc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000120a  00000000  00000000  000049c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000017e8  00000000  00000000  00005bd2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000668  00000000  00000000  000073bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a3a  00000000  00000000  00007a24  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002580  00000000  00000000  0000845e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000160  00000000  00000000  0000a9de  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      30:	0c 94 16 05 	jmp	0xa2c	; 0xa2c <__vector_12>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 fc 00 	jmp	0x1f8	; 0x1f8 <__vector_18>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      7c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      80:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      84:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      88:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      8c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      90:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000094 <__ctors_end>:
      94:	11 24       	eor	r1, r1
      96:	1f be       	out	0x3f, r1	; 63
      98:	cf ef       	ldi	r28, 0xFF	; 255
      9a:	d8 e0       	ldi	r29, 0x08	; 8
      9c:	de bf       	out	0x3e, r29	; 62
      9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e0       	ldi	r26, 0x00	; 0
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	ec ea       	ldi	r30, 0xAC	; 172
      a8:	fb e1       	ldi	r31, 0x1B	; 27
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
      ac:	05 90       	lpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a0 3a       	cpi	r26, 0xA0	; 160
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
      b6:	26 e0       	ldi	r18, 0x06	; 6
      b8:	a0 ea       	ldi	r26, 0xA0	; 160
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	aa 3b       	cpi	r26, 0xBA	; 186
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
      c6:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <main>
      ca:	0c 94 d4 0d 	jmp	0x1ba8	; 0x1ba8 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <initCAN>:

		messageAvailable = 1;
	}

	return messageAvailable;
}
      d2:	e8 ed       	ldi	r30, 0xD8	; 216
      d4:	f0 e0       	ldi	r31, 0x00	; 0
      d6:	80 81       	ld	r24, Z
      d8:	81 60       	ori	r24, 0x01	; 1
      da:	80 83       	st	Z, r24
      dc:	86 e0       	ldi	r24, 0x06	; 6
      de:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7f80e2>
      e2:	84 e0       	ldi	r24, 0x04	; 4
      e4:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7f80e3>
      e8:	83 e1       	ldi	r24, 0x13	; 19
      ea:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7f80e4>
      ee:	80 e0       	ldi	r24, 0x00	; 0
      f0:	08 c0       	rjmp	.+16     	; 0x102 <initCAN+0x30>
      f2:	98 2f       	mov	r25, r24
      f4:	92 95       	swap	r25
      f6:	90 7f       	andi	r25, 0xF0	; 240
      f8:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
      fc:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     100:	8f 5f       	subi	r24, 0xFF	; 255
     102:	8f 30       	cpi	r24, 0x0F	; 15
     104:	b0 f3       	brcs	.-20     	; 0xf2 <initCAN+0x20>
     106:	78 94       	sei
     108:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     10c:	80 eb       	ldi	r24, 0xB0	; 176
     10e:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7f80db>
     112:	e8 ed       	ldi	r30, 0xD8	; 216
     114:	f0 e0       	ldi	r31, 0x00	; 0
     116:	80 81       	ld	r24, Z
     118:	82 60       	ori	r24, 0x02	; 2
     11a:	80 83       	st	Z, r24
     11c:	08 95       	ret

0000011e <getFreeMob>:
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	0a c0       	rjmp	.+20     	; 0x136 <getFreeMob+0x18>
     122:	98 2f       	mov	r25, r24
     124:	92 95       	swap	r25
     126:	90 7f       	andi	r25, 0xF0	; 240
     128:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     12c:	90 91 ef 00 	lds	r25, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     130:	90 7c       	andi	r25, 0xC0	; 192
     132:	21 f0       	breq	.+8      	; 0x13c <getFreeMob+0x1e>
     134:	8f 5f       	subi	r24, 0xFF	; 255
     136:	8f 30       	cpi	r24, 0x0F	; 15
     138:	a0 f3       	brcs	.-24     	; 0x122 <getFreeMob+0x4>
     13a:	8f ef       	ldi	r24, 0xFF	; 255
     13c:	08 95       	ret

0000013e <listenForMessage>:
     13e:	1f 93       	push	r17
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	ec 01       	movw	r28, r24
     146:	16 2f       	mov	r17, r22
     148:	0e 94 8f 00 	call	0x11e	; 0x11e <getFreeMob>
     14c:	8f 3f       	cpi	r24, 0xFF	; 255
     14e:	09 f4       	brne	.+2      	; 0x152 <listenForMessage+0x14>
     150:	4e c0       	rjmp	.+156    	; 0x1ee <listenForMessage+0xb0>
     152:	ed ee       	ldi	r30, 0xED	; 237
     154:	f0 e0       	ldi	r31, 0x00	; 0
     156:	90 81       	ld	r25, Z
     158:	48 2f       	mov	r20, r24
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	9a 01       	movw	r18, r20
     15e:	22 95       	swap	r18
     160:	32 95       	swap	r19
     162:	30 7f       	andi	r19, 0xF0	; 240
     164:	32 27       	eor	r19, r18
     166:	20 7f       	andi	r18, 0xF0	; 240
     168:	32 27       	eor	r19, r18
     16a:	29 2b       	or	r18, r25
     16c:	20 83       	st	Z, r18
     16e:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     172:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     176:	9c 2f       	mov	r25, r28
     178:	92 95       	swap	r25
     17a:	99 0f       	add	r25, r25
     17c:	90 7e       	andi	r25, 0xE0	; 224
     17e:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     182:	d6 95       	lsr	r29
     184:	c7 95       	ror	r28
     186:	d6 95       	lsr	r29
     188:	c7 95       	ror	r28
     18a:	d6 95       	lsr	r29
     18c:	c7 95       	ror	r28
     18e:	c0 93 f3 00 	sts	0x00F3, r28	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     192:	19 30       	cpi	r17, 0x09	; 9
     194:	08 f0       	brcs	.+2      	; 0x198 <listenForMessage+0x5a>
     196:	18 e0       	ldi	r17, 0x08	; 8
     198:	ef ee       	ldi	r30, 0xEF	; 239
     19a:	f0 e0       	ldi	r31, 0x00	; 0
     19c:	60 81       	ld	r22, Z
     19e:	61 2b       	or	r22, r17
     1a0:	60 83       	st	Z, r22
     1a2:	88 30       	cpi	r24, 0x08	; 8
     1a4:	78 f4       	brcc	.+30     	; 0x1c4 <listenForMessage+0x86>
     1a6:	ee ed       	ldi	r30, 0xDE	; 222
     1a8:	f0 e0       	ldi	r31, 0x00	; 0
     1aa:	40 81       	ld	r20, Z
     1ac:	21 e0       	ldi	r18, 0x01	; 1
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	b9 01       	movw	r22, r18
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <listenForMessage+0x7a>
     1b4:	66 0f       	add	r22, r22
     1b6:	77 1f       	adc	r23, r23
     1b8:	8a 95       	dec	r24
     1ba:	e2 f7       	brpl	.-8      	; 0x1b4 <listenForMessage+0x76>
     1bc:	cb 01       	movw	r24, r22
     1be:	84 2b       	or	r24, r20
     1c0:	80 83       	st	Z, r24
     1c2:	0e c0       	rjmp	.+28     	; 0x1e0 <listenForMessage+0xa2>
     1c4:	ef ed       	ldi	r30, 0xDF	; 223
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	20 81       	ld	r18, Z
     1ca:	48 50       	subi	r20, 0x08	; 8
     1cc:	51 09       	sbc	r21, r1
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <listenForMessage+0x9a>
     1d4:	88 0f       	add	r24, r24
     1d6:	99 1f       	adc	r25, r25
     1d8:	4a 95       	dec	r20
     1da:	e2 f7       	brpl	.-8      	; 0x1d4 <listenForMessage+0x96>
     1dc:	82 2b       	or	r24, r18
     1de:	80 83       	st	Z, r24
     1e0:	ef ee       	ldi	r30, 0xEF	; 239
     1e2:	f0 e0       	ldi	r31, 0x00	; 0
     1e4:	80 81       	ld	r24, Z
     1e6:	80 68       	ori	r24, 0x80	; 128
     1e8:	80 83       	st	Z, r24
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <listenForMessage+0xb2>
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	1f 91       	pop	r17
     1f6:	08 95       	ret

000001f8 <__vector_18>:
 * Note that the NO_BLOCK attribute is not applied here, so while this is running,
 * all interrupts are blocked.
 *
 */
ISR( CANIT_vect )
{
     1f8:	1f 92       	push	r1
     1fa:	0f 92       	push	r0
     1fc:	0f b6       	in	r0, 0x3f	; 63
     1fe:	0f 92       	push	r0
     200:	11 24       	eor	r1, r1
     202:	2f 93       	push	r18
     204:	3f 93       	push	r19
     206:	4f 93       	push	r20
     208:	5f 93       	push	r21
     20a:	6f 93       	push	r22
     20c:	7f 93       	push	r23
     20e:	8f 93       	push	r24
     210:	9f 93       	push	r25
     212:	af 93       	push	r26
     214:	bf 93       	push	r27
     216:	cf 93       	push	r28
     218:	ef 93       	push	r30
     21a:	ff 93       	push	r31
	// **Save off CANPAGE to prevent application code bugs**
	uint8_t canPage = CANPAGE;
     21c:	c0 91 ed 00 	lds	r28, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     220:	87 c0       	rjmp	.+270    	; 0x330 <__vector_18+0x138>
	{
		// Point to the Message Object that needs to be serviced
		CANPAGE = CANHPMOB & 0xF0;
     222:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     226:	80 7f       	andi	r24, 0xF0	; 240
     228:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

		// Service the correct kind of interrupt
		// Transmit Interrupts
		if( CANSTMOB & (1 << TXOK) )
     22c:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     230:	86 ff       	sbrs	r24, 6
     232:	0c c0       	rjmp	.+24     	; 0x24c <__vector_18+0x54>
		{
			// Acknowledge the interrupt
			CANSTMOB = 0;
     234:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			// Free up the MOb
			CANCDMOB = 0;
     238:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>

			// Determine the MOb index
			uint8_t mob = (CANPAGE & 0xF0) >> 8;
     23c:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>

			// Disable interrupts for this MOb
			if( mob < 8 )
			{
				CANIE2 &= ~(1 << mob);
     240:	ee ed       	ldi	r30, 0xDE	; 222
     242:	f0 e0       	ldi	r31, 0x00	; 0
     244:	80 81       	ld	r24, Z
     246:	8e 7f       	andi	r24, 0xFE	; 254
     248:	80 83       	st	Z, r24
     24a:	72 c0       	rjmp	.+228    	; 0x330 <__vector_18+0x138>
			{
				CANIE1 &= ~(1 << (mob-8));
			}
		}
		// Receive Interrupts
		else if ( CANSTMOB & (1 << RXOK) )
     24c:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>
     250:	85 ff       	sbrs	r24, 5
     252:	62 c0       	rjmp	.+196    	; 0x318 <__vector_18+0x120>
		{
			// Default to impossible ID
			uint16_t id = 0xFFFF;

			// Load the message data into a free message buffer object
			if( CANCDMOB & (1 << IDE) )
     254:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     258:	84 ff       	sbrs	r24, 4
     25a:	0e c0       	rjmp	.+28     	; 0x278 <__vector_18+0x80>
			{
				// Message type is CAN 2.0B
				id = (CANIDT4 >> 3) | ((CANIDT3 & 0x7F) << 5); 
     25c:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7f80f0>
     260:	86 95       	lsr	r24
     262:	86 95       	lsr	r24
     264:	86 95       	lsr	r24
     266:	40 91 f1 00 	lds	r20, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7f80f1>
     26a:	4f 77       	andi	r20, 0x7F	; 127
     26c:	90 e2       	ldi	r25, 0x20	; 32
     26e:	49 9f       	mul	r20, r25
     270:	a0 01       	movw	r20, r0
     272:	11 24       	eor	r1, r1
     274:	48 2b       	or	r20, r24
     276:	0f c0       	rjmp	.+30     	; 0x296 <__vector_18+0x9e>
			}
			else
			{
				// Message type is CAN 2.0A
				id = (CANIDT2 >> 5) | (((uint16_t)CANIDT1 << 3));
     278:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7f80f2>
     27c:	82 95       	swap	r24
     27e:	86 95       	lsr	r24
     280:	87 70       	andi	r24, 0x07	; 7
     282:	40 91 f3 00 	lds	r20, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7f80f3>
     286:	50 e0       	ldi	r21, 0x00	; 0
     288:	44 0f       	add	r20, r20
     28a:	55 1f       	adc	r21, r21
     28c:	44 0f       	add	r20, r20
     28e:	55 1f       	adc	r21, r21
     290:	44 0f       	add	r20, r20
     292:	55 1f       	adc	r21, r21
     294:	48 2b       	or	r20, r24
			}

			messageBuffer[bufIndex].id = id;
     296:	20 91 a1 01 	lds	r18, 0x01A1	; 0x8001a1 <bufIndex>
     29a:	30 e0       	ldi	r19, 0x00	; 0
     29c:	8b e0       	ldi	r24, 0x0B	; 11
     29e:	82 9f       	mul	r24, r18
     2a0:	f0 01       	movw	r30, r0
     2a2:	83 9f       	mul	r24, r19
     2a4:	f0 0d       	add	r31, r0
     2a6:	11 24       	eor	r1, r1
     2a8:	e0 55       	subi	r30, 0x50	; 80
     2aa:	fa 4f       	sbci	r31, 0xFA	; 250
     2ac:	40 83       	st	Z, r20
     2ae:	95 2f       	mov	r25, r21
     2b0:	97 70       	andi	r25, 0x07	; 7
     2b2:	81 81       	ldd	r24, Z+1	; 0x01
     2b4:	88 7f       	andi	r24, 0xF8	; 248
     2b6:	89 2b       	or	r24, r25
     2b8:	81 83       	std	Z+1, r24	; 0x01

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;
     2ba:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7f80ef>
     2be:	8f 70       	andi	r24, 0x0F	; 15
     2c0:	82 87       	std	Z+10, r24	; 0x0a

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	0e c0       	rjmp	.+28     	; 0x2e2 <__vector_18+0xea>
			{
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
     2c6:	80 91 fa 00 	lds	r24, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7f80fa>
     2ca:	4b e0       	ldi	r20, 0x0B	; 11
     2cc:	42 9f       	mul	r20, r18
     2ce:	f0 01       	movw	r30, r0
     2d0:	43 9f       	mul	r20, r19
     2d2:	f0 0d       	add	r31, r0
     2d4:	11 24       	eor	r1, r1
     2d6:	e0 55       	subi	r30, 0x50	; 80
     2d8:	fa 4f       	sbci	r31, 0xFA	; 250
     2da:	e9 0f       	add	r30, r25
     2dc:	f1 1d       	adc	r31, r1
     2de:	82 83       	std	Z+2, r24	; 0x02
			messageBuffer[bufIndex].id = id;

			messageBuffer[bufIndex].length = CANCDMOB & 0x0F;

			// This trusts the length field in CANCDMOB is between 1 and 8...
			for( uint8_t i = 0; i < messageBuffer[bufIndex].length; ++i )
     2e0:	9f 5f       	subi	r25, 0xFF	; 255
     2e2:	8b e0       	ldi	r24, 0x0B	; 11
     2e4:	82 9f       	mul	r24, r18
     2e6:	f0 01       	movw	r30, r0
     2e8:	83 9f       	mul	r24, r19
     2ea:	f0 0d       	add	r31, r0
     2ec:	11 24       	eor	r1, r1
     2ee:	e0 55       	subi	r30, 0x50	; 80
     2f0:	fa 4f       	sbci	r31, 0xFA	; 250
     2f2:	82 85       	ldd	r24, Z+10	; 0x0a
     2f4:	98 17       	cp	r25, r24
     2f6:	38 f3       	brcs	.-50     	; 0x2c6 <__vector_18+0xce>
				// Load the next byte from the MOb data register into the buffer
				// CANMSG is set to auto increment to the next byte after each read
				messageBuffer[bufIndex].data[i] = CANMSG;
			}

			bufIndex = (bufIndex + 1) % MESSAGE_BUFFER_LENGTH;
     2f8:	c9 01       	movw	r24, r18
     2fa:	01 96       	adiw	r24, 0x01	; 1
     2fc:	64 e1       	ldi	r22, 0x14	; 20
     2fe:	70 e0       	ldi	r23, 0x00	; 0
     300:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <__divmodhi4>
     304:	80 93 a1 01 	sts	0x01A1, r24	; 0x8001a1 <bufIndex>

			// Acknowledge the interrupt
			CANSTMOB = 0;
     308:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7f80ee>

			CANCDMOB |= (2 << CONMOB0);
     30c:	ef ee       	ldi	r30, 0xEF	; 239
     30e:	f0 e0       	ldi	r31, 0x00	; 0
     310:	80 81       	ld	r24, Z
     312:	80 68       	ori	r24, 0x80	; 128
     314:	80 83       	st	Z, r24
     316:	0c c0       	rjmp	.+24     	; 0x330 <__vector_18+0x138>
			
		}
		else if ( CANGIT & ~(1 << CANIT) )
     318:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7f80da>
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	8f 77       	andi	r24, 0x7F	; 127
     320:	89 2b       	or	r24, r25
     322:	31 f0       	breq	.+12     	; 0x330 <__vector_18+0x138>
		{
			// Preserve the last error received
			lastError = CANGIT;
     324:	ea ed       	ldi	r30, 0xDA	; 218
     326:	f0 e0       	ldi	r31, 0x00	; 0
     328:	80 81       	ld	r24, Z
     32a:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <__data_end>

			// Clear the error
			CANGIT = 0;
     32e:	10 82       	st	Z, r1
	uint8_t canPage = CANPAGE;

	// CANHPMOB will contain the mob index of the highest priority mob that has interrupted,
	// or 0xFF if no mob has interrupted. If multiple mobs have interrupted, they need to all be
	// serviced, so this loop is required.
	while( ((CANHPMOB & 0xF0) >> 4) != 0x0F )
     330:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7f80ec>
     334:	82 95       	swap	r24
     336:	8f 70       	andi	r24, 0x0F	; 15
     338:	8f 30       	cpi	r24, 0x0F	; 15
     33a:	09 f0       	breq	.+2      	; 0x33e <__vector_18+0x146>
     33c:	72 cf       	rjmp	.-284    	; 0x222 <__vector_18+0x2a>
			CANGIT = 0;
		}
	}

	// Restore CANPAGE register to where application code had it before interrupt
	CANPAGE = canPage;
     33e:	c0 93 ed 00 	sts	0x00ED, r28	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7f80ed>
     342:	ff 91       	pop	r31
     344:	ef 91       	pop	r30
     346:	cf 91       	pop	r28
     348:	bf 91       	pop	r27
     34a:	af 91       	pop	r26
     34c:	9f 91       	pop	r25
     34e:	8f 91       	pop	r24
     350:	7f 91       	pop	r23
     352:	6f 91       	pop	r22
     354:	5f 91       	pop	r21
     356:	4f 91       	pop	r20
     358:	3f 91       	pop	r19
     35a:	2f 91       	pop	r18
     35c:	0f 90       	pop	r0
     35e:	0f be       	out	0x3f, r0	; 63
     360:	0f 90       	pop	r0
     362:	1f 90       	pop	r1
     364:	18 95       	reti

00000366 <init_spi>:
//

static void init_spi(void)
{
	/* Set MOSI and SCK output, all others input */
	DDR_SPI |= ((1 << MOSI) | (1 << SCK) | (1 << CS));
     366:	84 b1       	in	r24, 0x04	; 4
     368:	87 60       	ori	r24, 0x07	; 7
     36a:	84 b9       	out	0x04, r24	; 4
	
	// enable pull up resistor in MISO
	PORTB |= (1 << MISO);
     36c:	85 b1       	in	r24, 0x05	; 5
     36e:	88 60       	ori	r24, 0x08	; 8
     370:	85 b9       	out	0x05, r24	; 5
	
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPR0));
     372:	8c b5       	in	r24, 0x2c	; 44
     374:	81 65       	ori	r24, 0x51	; 81
     376:	8c bd       	out	0x2c, r24	; 44
	PORTB |= (1<<CS); 				//hoog maken CS	
     378:	85 b1       	in	r24, 0x05	; 5
     37a:	81 60       	ori	r24, 0x01	; 1
     37c:	85 b9       	out	0x05, r24	; 5
     37e:	08 95       	ret

00000380 <xmit_spi>:
}

static BYTE xmit_spi(BYTE data)
{
	PORTB &= ~(1<<CS); //laag maken
     380:	95 b1       	in	r25, 0x05	; 5
     382:	9e 7f       	andi	r25, 0xFE	; 254
     384:	95 b9       	out	0x05, r25	; 5
	/* Start transmission */
	SPDR = data;
     386:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     388:	0d b4       	in	r0, 0x2d	; 45
     38a:	07 fe       	sbrs	r0, 7
     38c:	fd cf       	rjmp	.-6      	; 0x388 <xmit_spi+0x8>
	PORTB |= (1<<CS);		//hoog maken CS
     38e:	85 b1       	in	r24, 0x05	; 5
     390:	81 60       	ori	r24, 0x01	; 1
     392:	85 b9       	out	0x05, r24	; 5
	
	return SPDR; 
     394:	8e b5       	in	r24, 0x2e	; 46
}
     396:	08 95       	ret

00000398 <rcv_spi>:

static BYTE rcv_spi(void)
{
	return xmit_spi(0xFF);
     398:	8f ef       	ldi	r24, 0xFF	; 255
     39a:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
}
     39e:	08 95       	ret

000003a0 <send_cmd>:
/*-----------------------------------------------------------------------*/
/* Send a command packet to MMC                                          */
/*-----------------------------------------------------------------------*/
static BYTE send_cmd(BYTE  cmd, /* 1st byte (Start + Index) */
                     DWORD arg ) /* Argument (32 bits) */
{
     3a0:	ff 92       	push	r15
     3a2:	0f 93       	push	r16
     3a4:	1f 93       	push	r17
     3a6:	cf 93       	push	r28
     3a8:	df 93       	push	r29
     3aa:	c8 2f       	mov	r28, r24
     3ac:	d4 2f       	mov	r29, r20
     3ae:	15 2f       	mov	r17, r21
     3b0:	06 2f       	mov	r16, r22
     3b2:	f7 2e       	mov	r15, r23
	BYTE n, res;

	if (cmd & 0x80) { /* ACMD<n> is the command sequence of CMD55-CMD<n> */
     3b4:	88 23       	and	r24, r24
     3b6:	4c f4       	brge	.+18     	; 0x3ca <send_cmd+0x2a>
		cmd &= 0x7F;
     3b8:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
     3ba:	40 e0       	ldi	r20, 0x00	; 0
     3bc:	50 e0       	ldi	r21, 0x00	; 0
     3be:	ba 01       	movw	r22, r20
     3c0:	87 e7       	ldi	r24, 0x77	; 119
     3c2:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
		if (res > 1)
     3c6:	82 30       	cpi	r24, 0x02	; 2
     3c8:	50 f5       	brcc	.+84     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
			return res;
	}

	/* Select the card */
	DESELECT();
     3ca:	85 b1       	in	r24, 0x05	; 5
     3cc:	81 60       	ori	r24, 0x01	; 1
     3ce:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     3d0:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
	SELECT();
     3d4:	85 b1       	in	r24, 0x05	; 5
     3d6:	8e 7f       	andi	r24, 0xFE	; 254
     3d8:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     3da:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>

	/* Send a command packet */
	xmit_spi(cmd);               /* Start + Command index */
     3de:	8c 2f       	mov	r24, r28
     3e0:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
     3e4:	8f 2d       	mov	r24, r15
     3e6:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
     3ea:	80 2f       	mov	r24, r16
     3ec:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
     3f0:	81 2f       	mov	r24, r17
     3f2:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
     3f6:	8d 2f       	mov	r24, r29
     3f8:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
	n = 0x01;                    /* Dummy CRC + Stop */
	if (cmd == CMD0)
     3fc:	c0 34       	cpi	r28, 0x40	; 64
     3fe:	11 f0       	breq	.+4      	; 0x404 <__EEPROM_REGION_LENGTH__+0x4>
	xmit_spi(cmd);               /* Start + Command index */
	xmit_spi((BYTE)(arg >> 24)); /* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16)); /* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));  /* Argument[15..8] */
	xmit_spi((BYTE)arg);         /* Argument[7..0] */
	n = 0x01;                    /* Dummy CRC + Stop */
     400:	81 e0       	ldi	r24, 0x01	; 1
     402:	01 c0       	rjmp	.+2      	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
	if (cmd == CMD0)
		n = 0x95; /* Valid CRC for CMD0(0) */
     404:	85 e9       	ldi	r24, 0x95	; 149
	if (cmd == CMD8)
     406:	c8 34       	cpi	r28, 0x48	; 72
     408:	09 f4       	brne	.+2      	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
     40a:	87 e8       	ldi	r24, 0x87	; 135
	xmit_spi(n);
     40c:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>

	/* Receive a command response */
	n = 10; /* Wait for a valid response in timeout of 10 attempts */
     410:	ca e0       	ldi	r28, 0x0A	; 10
	do {
		res = rcv_spi();
     412:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
	} while ((res & 0x80) && --n);
     416:	88 23       	and	r24, r24
     418:	14 f4       	brge	.+4      	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
     41a:	c1 50       	subi	r28, 0x01	; 1
     41c:	d1 f7       	brne	.-12     	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>

	return res; /* Return with the response value */
}
     41e:	df 91       	pop	r29
     420:	cf 91       	pop	r28
     422:	1f 91       	pop	r17
     424:	0f 91       	pop	r16
     426:	ff 90       	pop	r15
     428:	08 95       	ret

0000042a <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize(void)
{
     42a:	ef 92       	push	r14
     42c:	ff 92       	push	r15
     42e:	0f 93       	push	r16
     430:	1f 93       	push	r17
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	00 d0       	rcall	.+0      	; 0x438 <disk_initialize+0xe>
     438:	00 d0       	rcall	.+0      	; 0x43a <disk_initialize+0x10>
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	UINT tmr;

#if _USE_WRITE
	if (CardType && SELECTING)
     43e:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     442:	81 11       	cpse	r24, r1
     444:	84 b1       	in	r24, 0x04	; 4
		disk_writep(0, 0); /* Finalize write process if it is in progress */
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
     446:	0e 94 b3 01 	call	0x366	; 0x366 <init_spi>
	DESELECT();
     44a:	85 b1       	in	r24, 0x05	; 5
     44c:	81 60       	ori	r24, 0x01	; 1
     44e:	85 b9       	out	0x05, r24	; 5
	for (n = 10; n; n--)
     450:	1a e0       	ldi	r17, 0x0A	; 10
     452:	03 c0       	rjmp	.+6      	; 0x45a <disk_initialize+0x30>
		rcv_spi(); /* 80 dummy clocks with CS=H */
     454:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
	
#endif

	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
     458:	11 50       	subi	r17, 0x01	; 1
     45a:	11 11       	cpse	r17, r1
     45c:	fb cf       	rjmp	.-10     	; 0x454 <disk_initialize+0x2a>
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
     45e:	40 e0       	ldi	r20, 0x00	; 0
     460:	50 e0       	ldi	r21, 0x00	; 0
     462:	ba 01       	movw	r22, r20
     464:	80 e4       	ldi	r24, 0x40	; 64
     466:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     46a:	81 30       	cpi	r24, 0x01	; 1
     46c:	09 f0       	breq	.+2      	; 0x470 <disk_initialize+0x46>
     46e:	9b c0       	rjmp	.+310    	; 0x5a6 <disk_initialize+0x17c>
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
     470:	4a ea       	ldi	r20, 0xAA	; 170
     472:	51 e0       	ldi	r21, 0x01	; 1
     474:	60 e0       	ldi	r22, 0x00	; 0
     476:	70 e0       	ldi	r23, 0x00	; 0
     478:	88 e4       	ldi	r24, 0x48	; 72
     47a:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     47e:	81 30       	cpi	r24, 0x01	; 1
     480:	09 f0       	breq	.+2      	; 0x484 <disk_initialize+0x5a>
     482:	59 c0       	rjmp	.+178    	; 0x536 <disk_initialize+0x10c>
     484:	0d c0       	rjmp	.+26     	; 0x4a0 <disk_initialize+0x76>
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
     486:	e0 2e       	mov	r14, r16
     488:	f1 2c       	mov	r15, r1
     48a:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     48e:	e1 e0       	ldi	r30, 0x01	; 1
     490:	f0 e0       	ldi	r31, 0x00	; 0
     492:	ec 0f       	add	r30, r28
     494:	fd 1f       	adc	r31, r29
     496:	ee 0d       	add	r30, r14
     498:	ff 1d       	adc	r31, r15
     49a:	80 83       	st	Z, r24
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
     49c:	0f 5f       	subi	r16, 0xFF	; 255
     49e:	01 c0       	rjmp	.+2      	; 0x4a2 <disk_initialize+0x78>
     4a0:	01 2f       	mov	r16, r17
     4a2:	04 30       	cpi	r16, 0x04	; 4
     4a4:	80 f3       	brcs	.-32     	; 0x486 <disk_initialize+0x5c>
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
     4a6:	8b 81       	ldd	r24, Y+3	; 0x03
     4a8:	81 30       	cpi	r24, 0x01	; 1
     4aa:	09 f0       	breq	.+2      	; 0x4ae <disk_initialize+0x84>
     4ac:	7e c0       	rjmp	.+252    	; 0x5aa <disk_initialize+0x180>
     4ae:	8c 81       	ldd	r24, Y+4	; 0x04
     4b0:	8a 3a       	cpi	r24, 0xAA	; 170
     4b2:	61 f0       	breq	.+24     	; 0x4cc <disk_initialize+0xa2>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     4b4:	f1 2c       	mov	r15, r1
     4b6:	84 c0       	rjmp	.+264    	; 0x5c0 <disk_initialize+0x196>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     4b8:	8f e8       	ldi	r24, 0x8F	; 143
     4ba:	91 e0       	ldi	r25, 0x01	; 1
     4bc:	01 97       	sbiw	r24, 0x01	; 1
     4be:	f1 f7       	brne	.-4      	; 0x4bc <disk_initialize+0x92>
     4c0:	00 c0       	rjmp	.+0      	; 0x4c2 <disk_initialize+0x98>
     4c2:	00 00       	nop
	if (send_cmd(CMD0, 0) == 1) { 
		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2 */
			for (n = 0; n < 4; n++)
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
     4c4:	91 e0       	ldi	r25, 0x01	; 1
     4c6:	e9 1a       	sub	r14, r25
     4c8:	f1 08       	sbc	r15, r1
     4ca:	06 c0       	rjmp	.+12     	; 0x4d8 <disk_initialize+0xae>
     4cc:	0f 2e       	mov	r0, r31
     4ce:	f0 e1       	ldi	r31, 0x10	; 16
     4d0:	ef 2e       	mov	r14, r31
     4d2:	f7 e2       	ldi	r31, 0x27	; 39
     4d4:	ff 2e       	mov	r15, r31
     4d6:	f0 2d       	mov	r31, r0
     4d8:	e1 14       	cp	r14, r1
     4da:	f1 04       	cpc	r15, r1
     4dc:	49 f0       	breq	.+18     	; 0x4f0 <disk_initialize+0xc6>
     4de:	40 e0       	ldi	r20, 0x00	; 0
     4e0:	50 e0       	ldi	r21, 0x00	; 0
     4e2:	60 e0       	ldi	r22, 0x00	; 0
     4e4:	70 e4       	ldi	r23, 0x40	; 64
     4e6:	89 ee       	ldi	r24, 0xE9	; 233
     4e8:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     4ec:	81 11       	cpse	r24, r1
     4ee:	e4 cf       	rjmp	.-56     	; 0x4b8 <disk_initialize+0x8e>
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
     4f0:	ef 28       	or	r14, r15
     4f2:	09 f4       	brne	.+2      	; 0x4f6 <disk_initialize+0xcc>
     4f4:	5c c0       	rjmp	.+184    	; 0x5ae <disk_initialize+0x184>
     4f6:	40 e0       	ldi	r20, 0x00	; 0
     4f8:	50 e0       	ldi	r21, 0x00	; 0
     4fa:	ba 01       	movw	r22, r20
     4fc:	8a e7       	ldi	r24, 0x7A	; 122
     4fe:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     502:	88 23       	and	r24, r24
     504:	71 f0       	breq	.+28     	; 0x522 <disk_initialize+0xf8>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     506:	f1 2c       	mov	r15, r1
     508:	5b c0       	rjmp	.+182    	; 0x5c0 <disk_initialize+0x196>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
     50a:	e1 2e       	mov	r14, r17
     50c:	f1 2c       	mov	r15, r1
     50e:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     512:	e1 e0       	ldi	r30, 0x01	; 1
     514:	f0 e0       	ldi	r31, 0x00	; 0
     516:	ec 0f       	add	r30, r28
     518:	fd 1f       	adc	r31, r29
     51a:	ee 0d       	add	r30, r14
     51c:	ff 1d       	adc	r31, r15
     51e:	80 83       	st	Z, r24
				ocr[n] = rcv_spi();                 /* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
     520:	1f 5f       	subi	r17, 0xFF	; 255
     522:	14 30       	cpi	r17, 0x04	; 4
     524:	90 f3       	brcs	.-28     	; 0x50a <disk_initialize+0xe0>
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     526:	89 81       	ldd	r24, Y+1	; 0x01
     528:	86 ff       	sbrs	r24, 6
     52a:	43 c0       	rjmp	.+134    	; 0x5b2 <disk_initialize+0x188>
     52c:	0f 2e       	mov	r0, r31
     52e:	fc e0       	ldi	r31, 0x0C	; 12
     530:	ff 2e       	mov	r15, r31
     532:	f0 2d       	mov	r31, r0
     534:	45 c0       	rjmp	.+138    	; 0x5c0 <disk_initialize+0x196>
				}
			}
		} else { /* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) {
     536:	40 e0       	ldi	r20, 0x00	; 0
     538:	50 e0       	ldi	r21, 0x00	; 0
     53a:	ba 01       	movw	r22, r20
     53c:	89 ee       	ldi	r24, 0xE9	; 233
     53e:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     542:	82 30       	cpi	r24, 0x02	; 2
     544:	40 f4       	brcc	.+16     	; 0x556 <disk_initialize+0x12c>
				ty  = CT_SD1;
     546:	68 94       	set
     548:	ff 24       	eor	r15, r15
     54a:	f1 f8       	bld	r15, 1
				cmd = ACMD41; /* SDv1 */
     54c:	0f 2e       	mov	r0, r31
     54e:	f9 ee       	ldi	r31, 0xE9	; 233
     550:	ef 2e       	mov	r14, r31
     552:	f0 2d       	mov	r31, r0
     554:	06 c0       	rjmp	.+12     	; 0x562 <disk_initialize+0x138>
			} else {
				ty  = CT_MMC;
     556:	ff 24       	eor	r15, r15
     558:	f3 94       	inc	r15
				cmd = CMD1; /* MMCv3 */
     55a:	0f 2e       	mov	r0, r31
     55c:	f1 e4       	ldi	r31, 0x41	; 65
     55e:	ef 2e       	mov	r14, r31
     560:	f0 2d       	mov	r31, r0
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
     562:	00 e1       	ldi	r16, 0x10	; 16
     564:	17 e2       	ldi	r17, 0x27	; 39
     566:	08 c0       	rjmp	.+16     	; 0x578 <disk_initialize+0x14e>
     568:	8f e8       	ldi	r24, 0x8F	; 143
     56a:	91 e0       	ldi	r25, 0x01	; 1
     56c:	01 97       	sbiw	r24, 0x01	; 1
     56e:	f1 f7       	brne	.-4      	; 0x56c <disk_initialize+0x142>
     570:	00 c0       	rjmp	.+0      	; 0x572 <disk_initialize+0x148>
     572:	00 00       	nop
     574:	01 50       	subi	r16, 0x01	; 1
     576:	11 09       	sbc	r17, r1
     578:	01 15       	cp	r16, r1
     57a:	11 05       	cpc	r17, r1
     57c:	41 f0       	breq	.+16     	; 0x58e <disk_initialize+0x164>
     57e:	40 e0       	ldi	r20, 0x00	; 0
     580:	50 e0       	ldi	r21, 0x00	; 0
     582:	ba 01       	movw	r22, r20
     584:	8e 2d       	mov	r24, r14
     586:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     58a:	81 11       	cpse	r24, r1
     58c:	ed cf       	rjmp	.-38     	; 0x568 <disk_initialize+0x13e>
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
     58e:	01 2b       	or	r16, r17
     590:	a1 f0       	breq	.+40     	; 0x5ba <disk_initialize+0x190>
     592:	40 e0       	ldi	r20, 0x00	; 0
     594:	52 e0       	ldi	r21, 0x02	; 2
     596:	60 e0       	ldi	r22, 0x00	; 0
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	80 e5       	ldi	r24, 0x50	; 80
     59c:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     5a0:	81 11       	cpse	r24, r1
     5a2:	0d c0       	rjmp	.+26     	; 0x5be <disk_initialize+0x194>
     5a4:	0d c0       	rjmp	.+26     	; 0x5c0 <disk_initialize+0x196>
	init_spi(); /* Initialize ports to control MMC */ 
	DESELECT();
	for (n = 10; n; n--)
		rcv_spi(); /* 80 dummy clocks with CS=H */

	ty = 0;
     5a6:	f1 2c       	mov	r15, r1
     5a8:	0b c0       	rjmp	.+22     	; 0x5c0 <disk_initialize+0x196>
     5aa:	f1 2c       	mov	r15, r1
     5ac:	09 c0       	rjmp	.+18     	; 0x5c0 <disk_initialize+0x196>
     5ae:	f1 2c       	mov	r15, r1
     5b0:	07 c0       	rjmp	.+14     	; 0x5c0 <disk_initialize+0x196>
				for (tmr = 10000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--)
					_delay_us(100);                   /* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++)
						ocr[n] = rcv_spi();
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 (HC or SC) */
     5b2:	68 94       	set
     5b4:	ff 24       	eor	r15, r15
     5b6:	f2 f8       	bld	r15, 2
     5b8:	03 c0       	rjmp	.+6      	; 0x5c0 <disk_initialize+0x196>
				cmd = CMD1; /* MMCv3 */
			}
			for (tmr = 10000; tmr && send_cmd(cmd, 0); tmr--)
				_delay_us(100);                    /* Wait for leaving idle state */
			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
				ty = 0;
     5ba:	f1 2c       	mov	r15, r1
     5bc:	01 c0       	rjmp	.+2      	; 0x5c0 <disk_initialize+0x196>
     5be:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     5c0:	f0 92 a4 01 	sts	0x01A4, r15	; 0x8001a4 <CardType>
	DESELECT();
     5c4:	85 b1       	in	r24, 0x05	; 5
     5c6:	81 60       	ori	r24, 0x01	; 1
     5c8:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     5ca:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>

	return ty ? 0 : STA_NOINIT;
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	f1 10       	cpse	r15, r1
     5d2:	80 e0       	ldi	r24, 0x00	; 0
}
     5d4:	0f 90       	pop	r0
     5d6:	0f 90       	pop	r0
     5d8:	0f 90       	pop	r0
     5da:	0f 90       	pop	r0
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	1f 91       	pop	r17
     5e2:	0f 91       	pop	r16
     5e4:	ff 90       	pop	r15
     5e6:	ef 90       	pop	r14
     5e8:	08 95       	ret

000005ea <disk_readp>:
DRESULT disk_readp(BYTE *buff,   /* Pointer to the read buffer (NULL:Forward to the stream) */
                   DWORD sector, /* Sector number (LBA) */
                   UINT  offset, /* Byte offset to read from (0..511) */
                   UINT  count   /* Number of bytes to read (ofs + cnt mus be <= 512) */
)
{
     5ea:	af 92       	push	r10
     5ec:	bf 92       	push	r11
     5ee:	cf 92       	push	r12
     5f0:	df 92       	push	r13
     5f2:	ef 92       	push	r14
     5f4:	ff 92       	push	r15
     5f6:	0f 93       	push	r16
     5f8:	1f 93       	push	r17
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	6c 01       	movw	r12, r24
     600:	79 01       	movw	r14, r18
	DRESULT res;
	BYTE    rc;
	UINT    bc;

	if (!(CardType & CT_BLOCK))
     602:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     606:	83 fd       	sbrc	r24, 3
     608:	09 c0       	rjmp	.+18     	; 0x61c <disk_readp+0x32>
		sector *= 512; /* Convert to byte address if needed */
     60a:	03 2e       	mov	r0, r19
     60c:	39 e0       	ldi	r19, 0x09	; 9
     60e:	44 0f       	add	r20, r20
     610:	55 1f       	adc	r21, r21
     612:	66 1f       	adc	r22, r22
     614:	77 1f       	adc	r23, r23
     616:	3a 95       	dec	r19
     618:	d1 f7       	brne	.-12     	; 0x60e <disk_readp+0x24>
     61a:	30 2d       	mov	r19, r0

	res = RES_ERROR;
	if (send_cmd(CMD17, sector) == 0) { /* READ_SINGLE_BLOCK */
     61c:	81 e5       	ldi	r24, 0x51	; 81
     61e:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     622:	81 11       	cpse	r24, r1
     624:	31 c0       	rjmp	.+98     	; 0x688 <disk_readp+0x9e>

		// bc = 40000;	/* Time counter */
		do { /* Wait for response */
			rc = rcv_spi();
     626:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
		} while (rc == 0xFF);
     62a:	8f 3f       	cpi	r24, 0xFF	; 255
     62c:	e1 f3       	breq	.-8      	; 0x626 <disk_readp+0x3c>

		if (rc == 0xFE) { /* A data packet arrived */
     62e:	8e 3f       	cpi	r24, 0xFE	; 254
     630:	69 f5       	brne	.+90     	; 0x68c <disk_readp+0xa2>

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */
     632:	cc 27       	eor	r28, r28
     634:	dd 27       	eor	r29, r29
     636:	ce 19       	sub	r28, r14
     638:	df 09       	sbc	r29, r15
     63a:	c0 1b       	sub	r28, r16
     63c:	d1 0b       	sbc	r29, r17
     63e:	ce 5f       	subi	r28, 0xFE	; 254
     640:	dd 4f       	sbci	r29, 0xFD	; 253

			/* Skip leading bytes */
			while (offset--)
     642:	03 c0       	rjmp	.+6      	; 0x64a <disk_readp+0x60>
				rcv_spi();
     644:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
		if (rc == 0xFE) { /* A data packet arrived */

			bc = 512 + 2 - offset - count; /* Number of trailing bytes to skip */

			/* Skip leading bytes */
			while (offset--)
     648:	75 01       	movw	r14, r10
     64a:	57 01       	movw	r10, r14
     64c:	81 e0       	ldi	r24, 0x01	; 1
     64e:	a8 1a       	sub	r10, r24
     650:	b1 08       	sbc	r11, r1
     652:	ef 28       	or	r14, r15
     654:	b9 f7       	brne	.-18     	; 0x644 <disk_readp+0x5a>
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
     656:	c1 14       	cp	r12, r1
     658:	d1 04       	cpc	r13, r1
     65a:	69 f0       	breq	.+26     	; 0x676 <disk_readp+0x8c>
				do {
					*buff++ = rcv_spi();
     65c:	76 01       	movw	r14, r12
     65e:	ef ef       	ldi	r30, 0xFF	; 255
     660:	ee 1a       	sub	r14, r30
     662:	fe 0a       	sbc	r15, r30
     664:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     668:	f6 01       	movw	r30, r12
     66a:	80 83       	st	Z, r24
				} while (--count);
     66c:	01 50       	subi	r16, 0x01	; 1
     66e:	11 09       	sbc	r17, r1
				rcv_spi();

			/* Receive a part of the sector */
			if (buff) { /* Store data to the memory */
				do {
					*buff++ = rcv_spi();
     670:	67 01       	movw	r12, r14
				} while (--count);
     672:	a1 f7       	brne	.-24     	; 0x65c <disk_readp+0x72>
     674:	03 c0       	rjmp	.+6      	; 0x67c <disk_readp+0x92>
			} else { /* Forward data to the outgoing stream */
				do {
					// FORWARD(rcv_spi());
				} while (--count);
     676:	01 50       	subi	r16, 0x01	; 1
     678:	11 09       	sbc	r17, r1
     67a:	e9 f7       	brne	.-6      	; 0x676 <disk_readp+0x8c>
			}

			/* Skip trailing bytes and CRC */
			do
				rcv_spi();
     67c:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
			while (--bc);
     680:	21 97       	sbiw	r28, 0x01	; 1
     682:	e1 f7       	brne	.-8      	; 0x67c <disk_readp+0x92>

			res = RES_OK;
     684:	c0 e0       	ldi	r28, 0x00	; 0
     686:	03 c0       	rjmp	.+6      	; 0x68e <disk_readp+0xa4>
	UINT    bc;

	if (!(CardType & CT_BLOCK))
		sector *= 512; /* Convert to byte address if needed */

	res = RES_ERROR;
     688:	c1 e0       	ldi	r28, 0x01	; 1
     68a:	01 c0       	rjmp	.+2      	; 0x68e <disk_readp+0xa4>
     68c:	c1 e0       	ldi	r28, 0x01	; 1

			res = RES_OK;
		}
	}

	DESELECT();
     68e:	85 b1       	in	r24, 0x05	; 5
     690:	81 60       	ori	r24, 0x01	; 1
     692:	85 b9       	out	0x05, r24	; 5
	rcv_spi();
     694:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>

	return res;
}
     698:	8c 2f       	mov	r24, r28
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	1f 91       	pop	r17
     6a0:	0f 91       	pop	r16
     6a2:	ff 90       	pop	r15
     6a4:	ef 90       	pop	r14
     6a6:	df 90       	pop	r13
     6a8:	cf 90       	pop	r12
     6aa:	bf 90       	pop	r11
     6ac:	af 90       	pop	r10
     6ae:	08 95       	ret

000006b0 <disk_writep>:

#if _USE_WRITE
DRESULT disk_writep(const BYTE *buff, /* Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) */
                    DWORD       sc    /* Number of bytes to send, Sector number (LBA) or zero */
)
{
     6b0:	0f 93       	push	r16
     6b2:	1f 93       	push	r17
     6b4:	cf 93       	push	r28
     6b6:	df 93       	push	r29
     6b8:	fc 01       	movw	r30, r24
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
     6ba:	89 2b       	or	r24, r25
     6bc:	f1 f0       	breq	.+60     	; 0x6fa <disk_writep+0x4a>
		bc = sc;
     6be:	ea 01       	movw	r28, r20
		while (bc && wc) { /* Send data bytes to the card */
     6c0:	11 c0       	rjmp	.+34     	; 0x6e4 <disk_writep+0x34>
			xmit_spi(*buff++);
     6c2:	8f 01       	movw	r16, r30
     6c4:	0f 5f       	subi	r16, 0xFF	; 255
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	80 81       	ld	r24, Z
     6ca:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
			wc--;
     6ce:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <wc.1882>
     6d2:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <wc.1882+0x1>
     6d6:	01 97       	sbiw	r24, 0x01	; 1
     6d8:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <wc.1882+0x1>
     6dc:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <wc.1882>
			bc--;
     6e0:	21 97       	sbiw	r28, 0x01	; 1
	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
     6e2:	f8 01       	movw	r30, r16

	res = RES_ERROR;

	if (buff) { /* Send data bytes */
		bc = sc;
		while (bc && wc) { /* Send data bytes to the card */
     6e4:	20 97       	sbiw	r28, 0x00	; 0
     6e6:	09 f4       	brne	.+2      	; 0x6ea <disk_writep+0x3a>
     6e8:	5f c0       	rjmp	.+190    	; 0x7a8 <disk_writep+0xf8>
     6ea:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <wc.1882>
     6ee:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <wc.1882+0x1>
     6f2:	89 2b       	or	r24, r25
     6f4:	31 f7       	brne	.-52     	; 0x6c2 <disk_writep+0x12>
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     6f6:	c0 e0       	ldi	r28, 0x00	; 0
     6f8:	5a c0       	rjmp	.+180    	; 0x7ae <disk_writep+0xfe>
	} else {
		if (sc) { /* Initiate sector write process */
     6fa:	41 15       	cp	r20, r1
     6fc:	51 05       	cpc	r21, r1
     6fe:	61 05       	cpc	r22, r1
     700:	71 05       	cpc	r23, r1
     702:	01 f1       	breq	.+64     	; 0x744 <disk_writep+0x94>
			if (!(CardType & CT_BLOCK))
     704:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <CardType>
     708:	83 fd       	sbrc	r24, 3
     70a:	09 c0       	rjmp	.+18     	; 0x71e <disk_writep+0x6e>
				sc *= 512;                  /* Convert to byte address if needed */
     70c:	03 2e       	mov	r0, r19
     70e:	39 e0       	ldi	r19, 0x09	; 9
     710:	44 0f       	add	r20, r20
     712:	55 1f       	adc	r21, r21
     714:	66 1f       	adc	r22, r22
     716:	77 1f       	adc	r23, r23
     718:	3a 95       	dec	r19
     71a:	d1 f7       	brne	.-12     	; 0x710 <disk_writep+0x60>
     71c:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sc) == 0) { /* WRITE_SINGLE_BLOCK */
     71e:	88 e5       	ldi	r24, 0x58	; 88
     720:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_cmd>
     724:	81 11       	cpse	r24, r1
     726:	42 c0       	rjmp	.+132    	; 0x7ac <disk_writep+0xfc>
				xmit_spi(0xFF);
     728:	8f ef       	ldi	r24, 0xFF	; 255
     72a:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
				xmit_spi(0xFE); /* Data block header */
     72e:	8e ef       	ldi	r24, 0xFE	; 254
     730:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
				wc  = 512;      /* Set byte counter */
     734:	80 e0       	ldi	r24, 0x00	; 0
     736:	92 e0       	ldi	r25, 0x02	; 2
     738:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <wc.1882+0x1>
     73c:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <wc.1882>
				res = RES_OK;
     740:	c0 e0       	ldi	r28, 0x00	; 0
     742:	35 c0       	rjmp	.+106    	; 0x7ae <disk_writep+0xfe>
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
     744:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <wc.1882>
     748:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <wc.1882+0x1>
     74c:	02 96       	adiw	r24, 0x02	; 2
			while (bc--) {
     74e:	04 c0       	rjmp	.+8      	; 0x758 <disk_writep+0xa8>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
     750:	80 e0       	ldi	r24, 0x00	; 0
     752:	0e 94 c0 01 	call	0x380	; 0x380 <xmit_spi>
				wc  = 512;      /* Set byte counter */
				res = RES_OK;
			}
		} else { /* Finalize sector write process */
			bc = wc + 2;
			while (bc--) {
     756:	ce 01       	movw	r24, r28
     758:	ec 01       	movw	r28, r24
     75a:	21 97       	sbiw	r28, 0x01	; 1
     75c:	89 2b       	or	r24, r25
     75e:	c1 f7       	brne	.-16     	; 0x750 <disk_writep+0xa0>
				xmit_spi(0); /* Fill left bytes and CRC with zeros */
			}
			do {
				res = rcv_spi();
     760:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     764:	c8 2f       	mov	r28, r24
			} while (res == 0xFF);
     766:	8f 3f       	cpi	r24, 0xFF	; 255
     768:	d9 f3       	breq	.-10     	; 0x760 <disk_writep+0xb0>
			if ((res & 0x1F) == 0x05) { /* Receive data resp and wait for end of write process in timeout of 500ms */
     76a:	8f 71       	andi	r24, 0x1F	; 31
     76c:	85 30       	cpi	r24, 0x05	; 5
     76e:	b1 f4       	brne	.+44     	; 0x79c <disk_writep+0xec>
     770:	09 c0       	rjmp	.+18     	; 0x784 <disk_writep+0xd4>
     772:	8f e8       	ldi	r24, 0x8F	; 143
     774:	91 e0       	ldi	r25, 0x01	; 1
     776:	01 97       	sbiw	r24, 0x01	; 1
     778:	f1 f7       	brne	.-4      	; 0x776 <disk_writep+0xc6>
     77a:	00 c0       	rjmp	.+0      	; 0x77c <disk_writep+0xcc>
     77c:	00 00       	nop
				for (bc = 5000; rcv_spi() != 0xFF && bc; bc--) /* Wait for ready */
     77e:	01 50       	subi	r16, 0x01	; 1
     780:	11 09       	sbc	r17, r1
     782:	02 c0       	rjmp	.+4      	; 0x788 <disk_writep+0xd8>
     784:	08 e8       	ldi	r16, 0x88	; 136
     786:	13 e1       	ldi	r17, 0x13	; 19
     788:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     78c:	8f 3f       	cpi	r24, 0xFF	; 255
     78e:	19 f0       	breq	.+6      	; 0x796 <disk_writep+0xe6>
     790:	01 15       	cp	r16, r1
     792:	11 05       	cpc	r17, r1
     794:	71 f7       	brne	.-36     	; 0x772 <disk_writep+0xc2>
					_delay_us(100);
				if (bc)
     796:	01 2b       	or	r16, r17
     798:	09 f0       	breq	.+2      	; 0x79c <disk_writep+0xec>
					res = RES_OK;
     79a:	c0 e0       	ldi	r28, 0x00	; 0
			}
			DESELECT();
     79c:	85 b1       	in	r24, 0x05	; 5
     79e:	81 60       	ori	r24, 0x01	; 1
     7a0:	85 b9       	out	0x05, r24	; 5
			rcv_spi();
     7a2:	0e 94 cc 01 	call	0x398	; 0x398 <rcv_spi>
     7a6:	03 c0       	rjmp	.+6      	; 0x7ae <disk_writep+0xfe>
		while (bc && wc) { /* Send data bytes to the card */
			xmit_spi(*buff++);
			wc--;
			bc--;
		}
		res = RES_OK;
     7a8:	c0 e0       	ldi	r28, 0x00	; 0
     7aa:	01 c0       	rjmp	.+2      	; 0x7ae <disk_writep+0xfe>
{
	DRESULT     res;
	UINT        bc;
	static UINT wc; /* Sector write counter */

	res = RES_ERROR;
     7ac:	c1 e0       	ldi	r28, 0x01	; 1
			rcv_spi();
		}
	}

	return res;
}
     7ae:	8c 2f       	mov	r24, r28
     7b0:	df 91       	pop	r29
     7b2:	cf 91       	pop	r28
     7b4:	1f 91       	pop	r17
     7b6:	0f 91       	pop	r16
     7b8:	08 95       	ret

000007ba <fill_buffer>:
			// if statement hierboven kan herhaald worden voor andere ID's.
		}*/
	
		const char* string = "testen: ";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	30 e0       	ldi	r19, 0x00	; 0
     7be:	15 c0       	rjmp	.+42     	; 0x7ea <fill_buffer+0x30>
		{
			write_buffer[bufferAmt++] = string[i];
     7c0:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     7c4:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     7c8:	ac 01       	movw	r20, r24
     7ca:	4f 5f       	subi	r20, 0xFF	; 255
     7cc:	5f 4f       	sbci	r21, 0xFF	; 255
     7ce:	50 93 ab 01 	sts	0x01AB, r21	; 0x8001ab <bufferAmt+0x1>
     7d2:	40 93 aa 01 	sts	0x01AA, r20	; 0x8001aa <bufferAmt>
     7d6:	f9 01       	movw	r30, r18
     7d8:	e0 50       	subi	r30, 0x00	; 0
     7da:	ff 4f       	sbci	r31, 0xFF	; 255
     7dc:	40 81       	ld	r20, Z
     7de:	fc 01       	movw	r30, r24
     7e0:	e2 55       	subi	r30, 0x52	; 82
     7e2:	fc 4f       	sbci	r31, 0xFC	; 252
     7e4:	40 83       	st	Z, r20
			// if statement hierboven kan herhaald worden voor andere ID's.
		}*/
	
		const char* string = "testen: ";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
     7e6:	2f 5f       	subi	r18, 0xFF	; 255
     7e8:	3f 4f       	sbci	r19, 0xFF	; 255
     7ea:	28 30       	cpi	r18, 0x08	; 8
     7ec:	31 05       	cpc	r19, r1
     7ee:	44 f3       	brlt	.-48     	; 0x7c0 <fill_buffer+0x6>
     7f0:	20 e0       	ldi	r18, 0x00	; 0
     7f2:	30 e0       	ldi	r19, 0x00	; 0
     7f4:	40 e3       	ldi	r20, 0x30	; 48
     7f6:	12 c0       	rjmp	.+36     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
			write_buffer[bufferAmt++] = string[i];
		}
		char c = 48;
		for (int i = 0; i < 10; i++)
		{
			write_buffer[bufferAmt++] = c++;
     7f8:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     7fc:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     800:	bc 01       	movw	r22, r24
     802:	6f 5f       	subi	r22, 0xFF	; 255
     804:	7f 4f       	sbci	r23, 0xFF	; 255
     806:	70 93 ab 01 	sts	0x01AB, r23	; 0x8001ab <bufferAmt+0x1>
     80a:	60 93 aa 01 	sts	0x01AA, r22	; 0x8001aa <bufferAmt>
     80e:	fc 01       	movw	r30, r24
     810:	e2 55       	subi	r30, 0x52	; 82
     812:	fc 4f       	sbci	r31, 0xFC	; 252
     814:	40 83       	st	Z, r20
		for (int i = 0; i < length; i++)
		{
			write_buffer[bufferAmt++] = string[i];
		}
		char c = 48;
		for (int i = 0; i < 10; i++)
     816:	2f 5f       	subi	r18, 0xFF	; 255
     818:	3f 4f       	sbci	r19, 0xFF	; 255
		{
			write_buffer[bufferAmt++] = c++;
     81a:	4f 5f       	subi	r20, 0xFF	; 255
		for (int i = 0; i < length; i++)
		{
			write_buffer[bufferAmt++] = string[i];
		}
		char c = 48;
		for (int i = 0; i < 10; i++)
     81c:	2a 30       	cpi	r18, 0x0A	; 10
     81e:	31 05       	cpc	r19, r1
     820:	5c f3       	brlt	.-42     	; 0x7f8 <fill_buffer+0x3e>
		{
			write_buffer[bufferAmt++] = c++;
		}
		write_buffer[bufferAmt++] = '\n'; // einde regel
     822:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     826:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     82a:	9c 01       	movw	r18, r24
     82c:	2f 5f       	subi	r18, 0xFF	; 255
     82e:	3f 4f       	sbci	r19, 0xFF	; 255
     830:	30 93 ab 01 	sts	0x01AB, r19	; 0x8001ab <bufferAmt+0x1>
     834:	20 93 aa 01 	sts	0x01AA, r18	; 0x8001aa <bufferAmt>
     838:	fc 01       	movw	r30, r24
     83a:	e2 55       	subi	r30, 0x52	; 82
     83c:	fc 4f       	sbci	r31, 0xFC	; 252
     83e:	4a e0       	ldi	r20, 0x0A	; 10
     840:	40 83       	st	Z, r20
	
		if(bufferAmt>=(512-30)) // sectorgrootte van 512 bytes - ongeveer 30 bytes (iets meer dan 2 lines)
     842:	22 3e       	cpi	r18, 0xE2	; 226
     844:	31 40       	sbci	r19, 0x01	; 1
     846:	3c f0       	brlt	.+14     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
		{
			
			bufferAmt = 0;
     848:	10 92 ab 01 	sts	0x01AB, r1	; 0x8001ab <bufferAmt+0x1>
     84c:	10 92 aa 01 	sts	0x01AA, r1	; 0x8001aa <bufferAmt>
			startWriting = true; // als dit op true staat gaat de microcontroller in de main>while(logging) in de if-statement en vult vanaf daar de sd-kaart 
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <startWriting>
     856:	08 95       	ret

00000858 <writeToCard>:


	void writeToCard(void)
	{
		/* Set file pointer to beginning of sector */
		pf_lseek(curOffset); // offset van 0 is te vinden in sector 8448 van de sd-kaart
     858:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <curOffset>
     85c:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <curOffset+0x1>
     860:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <curOffset+0x2>
     864:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <curOffset+0x3>
     868:	0e 94 45 0c 	call	0x188a	; 0x188a <pf_lseek>
		/* Write buffer */
		pf_write(write_buffer, BUFFER_SIZE, &byte_counter);
     86c:	4c ea       	ldi	r20, 0xAC	; 172
     86e:	51 e0       	ldi	r21, 0x01	; 1
     870:	60 e0       	ldi	r22, 0x00	; 0
     872:	72 e0       	ldi	r23, 0x02	; 2
     874:	8e ea       	ldi	r24, 0xAE	; 174
     876:	93 e0       	ldi	r25, 0x03	; 3
     878:	0e 94 39 0b 	call	0x1672	; 0x1672 <pf_write>
		if (byte_counter < BUFFER_SIZE) {
			/* End of file */
		}
		/* Finalize write */
		pf_write(0, 0, &byte_counter);
     87c:	4c ea       	ldi	r20, 0xAC	; 172
     87e:	51 e0       	ldi	r21, 0x01	; 1
     880:	60 e0       	ldi	r22, 0x00	; 0
     882:	70 e0       	ldi	r23, 0x00	; 0
     884:	80 e0       	ldi	r24, 0x00	; 0
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	0e 94 39 0b 	call	0x1672	; 0x1672 <pf_write>
		/* Reset file pointer to beginning of sector 1 */
		pf_lseek(curOffset);
     88c:	60 91 a5 01 	lds	r22, 0x01A5	; 0x8001a5 <curOffset>
     890:	70 91 a6 01 	lds	r23, 0x01A6	; 0x8001a6 <curOffset+0x1>
     894:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <curOffset+0x2>
     898:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <curOffset+0x3>
     89c:	0e 94 45 0c 	call	0x188a	; 0x188a <pf_lseek>
		/* Read back the same bytes */
		pf_read(read_buffer, BUFFER_SIZE, &byte_counter);
     8a0:	4c ea       	ldi	r20, 0xAC	; 172
     8a2:	51 e0       	ldi	r21, 0x01	; 1
     8a4:	60 e0       	ldi	r22, 0x00	; 0
     8a6:	72 e0       	ldi	r23, 0x02	; 2
     8a8:	8e ea       	ldi	r24, 0xAE	; 174
     8aa:	91 e0       	ldi	r25, 0x01	; 1
     8ac:	0e 94 56 0a 	call	0x14ac	; 0x14ac <pf_read>
     8b0:	08 95       	ret

000008b2 <find_offset>:
		}
		*/ 
	}

	unsigned long find_offset(void)
	{
     8b2:	cf 92       	push	r12
     8b4:	df 92       	push	r13
     8b6:	ef 92       	push	r14
     8b8:	ff 92       	push	r15
     8ba:	cf 93       	push	r28
     8bc:	df 93       	push	r29
     8be:	00 d0       	rcall	.+0      	; 0x8c0 <find_offset+0xe>
     8c0:	1f 92       	push	r1
     8c2:	cd b7       	in	r28, 0x3d	; 61
     8c4:	de b7       	in	r29, 0x3e	; 62
		// begin bij sector 0. kijk naar waarde 1e char. als die erop wijst dat de sector al geschreven is, ga naar sector 1. ga zo door. return offset als sector leeg lijkt te zijn
		uint8_t read_first[1]  = {};
     8c6:	19 82       	std	Y+1, r1	; 0x01
		UINT bytecounter = 1;
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	90 e0       	ldi	r25, 0x00	; 0
     8cc:	9b 83       	std	Y+3, r25	; 0x03
     8ce:	8a 83       	std	Y+2, r24	; 0x02
		unsigned long tempOffset = 0;
     8d0:	c1 2c       	mov	r12, r1
     8d2:	d1 2c       	mov	r13, r1
     8d4:	76 01       	movw	r14, r12
		unsigned long maxOffset = 51200; // als hij geen lege sector kan vinden na de 1e 100 sectoren
		while(1)
		{
			pf_lseek(tempOffset);
     8d6:	c7 01       	movw	r24, r14
     8d8:	b6 01       	movw	r22, r12
     8da:	0e 94 45 0c 	call	0x188a	; 0x188a <pf_lseek>
			pf_read(read_first, 1, &bytecounter); // read first byte of sector
     8de:	ae 01       	movw	r20, r28
     8e0:	4e 5f       	subi	r20, 0xFE	; 254
     8e2:	5f 4f       	sbci	r21, 0xFF	; 255
     8e4:	61 e0       	ldi	r22, 0x01	; 1
     8e6:	70 e0       	ldi	r23, 0x00	; 0
     8e8:	ce 01       	movw	r24, r28
     8ea:	01 96       	adiw	r24, 0x01	; 1
     8ec:	0e 94 56 0a 	call	0x14ac	; 0x14ac <pf_read>
			if(read_first[0] == 32)
     8f0:	89 81       	ldd	r24, Y+1	; 0x01
     8f2:	80 32       	cpi	r24, 0x20	; 32
     8f4:	79 f0       	breq	.+30     	; 0x914 <__stack+0x15>
			{
				return tempOffset;
			} else {
				tempOffset += 512;
     8f6:	82 e0       	ldi	r24, 0x02	; 2
     8f8:	d8 0e       	add	r13, r24
     8fa:	e1 1c       	adc	r14, r1
     8fc:	f1 1c       	adc	r15, r1
				if(tempOffset >= maxOffset)
     8fe:	c1 14       	cp	r12, r1
     900:	88 ec       	ldi	r24, 0xC8	; 200
     902:	d8 06       	cpc	r13, r24
     904:	e1 04       	cpc	r14, r1
     906:	f1 04       	cpc	r15, r1
     908:	30 f3       	brcs	.-52     	; 0x8d6 <find_offset+0x24>
				break;
			}
		}
		return 0;
     90a:	60 e0       	ldi	r22, 0x00	; 0
     90c:	70 e0       	ldi	r23, 0x00	; 0
     90e:	80 e0       	ldi	r24, 0x00	; 0
     910:	90 e0       	ldi	r25, 0x00	; 0
     912:	04 c0       	rjmp	.+8      	; 0x91c <__stack+0x1d>
		{
			pf_lseek(tempOffset);
			pf_read(read_first, 1, &bytecounter); // read first byte of sector
			if(read_first[0] == 32)
			{
				return tempOffset;
     914:	6c 2d       	mov	r22, r12
     916:	7d 2d       	mov	r23, r13
     918:	8e 2d       	mov	r24, r14
     91a:	9f 2d       	mov	r25, r15
				if(tempOffset >= maxOffset)
				break;
			}
		}
		return 0;
	}
     91c:	0f 90       	pop	r0
     91e:	0f 90       	pop	r0
     920:	0f 90       	pop	r0
     922:	df 91       	pop	r29
     924:	cf 91       	pop	r28
     926:	ff 90       	pop	r15
     928:	ef 90       	pop	r14
     92a:	df 90       	pop	r13
     92c:	cf 90       	pop	r12
     92e:	08 95       	ret

00000930 <start_log_message>:

	void start_log_message(void)
	{
		const char* string = "START LOG HIER";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
     930:	20 e0       	ldi	r18, 0x00	; 0
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	15 c0       	rjmp	.+42     	; 0x960 <start_log_message+0x30>
		{
			write_buffer[bufferAmt++] = string[i];
     936:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     93a:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     93e:	ac 01       	movw	r20, r24
     940:	4f 5f       	subi	r20, 0xFF	; 255
     942:	5f 4f       	sbci	r21, 0xFF	; 255
     944:	50 93 ab 01 	sts	0x01AB, r21	; 0x8001ab <bufferAmt+0x1>
     948:	40 93 aa 01 	sts	0x01AA, r20	; 0x8001aa <bufferAmt>
     94c:	f9 01       	movw	r30, r18
     94e:	e7 5f       	subi	r30, 0xF7	; 247
     950:	fe 4f       	sbci	r31, 0xFE	; 254
     952:	40 81       	ld	r20, Z
     954:	fc 01       	movw	r30, r24
     956:	e2 55       	subi	r30, 0x52	; 82
     958:	fc 4f       	sbci	r31, 0xFC	; 252
     95a:	40 83       	st	Z, r20

	void start_log_message(void)
	{
		const char* string = "START LOG HIER";
		int length = strlen(string);
		for (int i = 0; i < length; i++)
     95c:	2f 5f       	subi	r18, 0xFF	; 255
     95e:	3f 4f       	sbci	r19, 0xFF	; 255
     960:	2e 30       	cpi	r18, 0x0E	; 14
     962:	31 05       	cpc	r19, r1
     964:	44 f3       	brlt	.-48     	; 0x936 <start_log_message+0x6>
		{
			write_buffer[bufferAmt++] = string[i];
		}
		write_buffer[bufferAmt++] = '\n';
     966:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <bufferAmt>
     96a:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <bufferAmt+0x1>
     96e:	9c 01       	movw	r18, r24
     970:	2f 5f       	subi	r18, 0xFF	; 255
     972:	3f 4f       	sbci	r19, 0xFF	; 255
     974:	30 93 ab 01 	sts	0x01AB, r19	; 0x8001ab <bufferAmt+0x1>
     978:	20 93 aa 01 	sts	0x01AA, r18	; 0x8001aa <bufferAmt>
     97c:	fc 01       	movw	r30, r24
     97e:	e2 55       	subi	r30, 0x52	; 82
     980:	fc 4f       	sbci	r31, 0xFC	; 252
     982:	2a e0       	ldi	r18, 0x0A	; 10
     984:	20 83       	st	Z, r18
     986:	08 95       	ret

00000988 <init_sd_card>:
		DSTATUS status;
		FRESULT result;
		int ERROR = 0;
		/* Initialize physical drive */
		do {
			status = disk_initialize();
     988:	0e 94 15 02 	call	0x42a	; 0x42a <disk_initialize>
			if (status != 0) {
     98c:	81 11       	cpse	r24, r1
     98e:	07 c0       	rjmp	.+14     	; 0x99e <init_sd_card+0x16>
				ERROR = 1; 
			} else {
				ERROR = 0;			
				/* Set SPI clock faster after initialization */
				SPCR = (1<<MSTR) | (0<<SPR1) | (0<<SPR0) | (1<<SPE);
     990:	80 e5       	ldi	r24, 0x50	; 80
     992:	8c bd       	out	0x2c, r24	; 44
				SPSR = (1<<SPI2X); 		
     994:	81 e0       	ldi	r24, 0x01	; 1
     996:	8d bd       	out	0x2d, r24	; 45
		do {
			status = disk_initialize();
			if (status != 0) {
				ERROR = 1; 
			} else {
				ERROR = 0;			
     998:	80 e0       	ldi	r24, 0x00	; 0
     99a:	90 e0       	ldi	r25, 0x00	; 0
     99c:	02 c0       	rjmp	.+4      	; 0x9a2 <init_sd_card+0x1a>
		int ERROR = 0;
		/* Initialize physical drive */
		do {
			status = disk_initialize();
			if (status != 0) {
				ERROR = 1; 
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	90 e0       	ldi	r25, 0x00	; 0
				//SPR1 en 0 op 0 SPI clock set to fck/4 (blaz. 174)
				//MSTR, in mastermode zetten
				//SPE, SPI enable maken.
				//SPI2X, het verdubbelen van de snelheid.			
			}
		} while (ERROR == 1);
     9a2:	01 97       	sbiw	r24, 0x01	; 1
     9a4:	89 f3       	breq	.-30     	; 0x988 <init_sd_card>

		/* Mount volume */
		result = pf_mount(&file_system);
     9a6:	80 e9       	ldi	r24, 0x90	; 144
     9a8:	96 e0       	ldi	r25, 0x06	; 6
     9aa:	0e 94 47 08 	call	0x108e	; 0x108e <pf_mount>
		if (result != FR_OK) {} // error

		/* Open file */
		result = pf_open("LOG.txt");
     9ae:	88 e1       	ldi	r24, 0x18	; 24
     9b0:	91 e0       	ldi	r25, 0x01	; 1
     9b2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <pf_open>
     9b6:	08 95       	ret

000009b8 <main>:
	void writeToCard(void);
	
	int main(void)
	{	
		_PROTECTED_WRITE(CLKPR, ( (1<<CLKPCE) | ((0<<CLKPS3) | (0<<CLKPS2) | (1<<CLKPS1) | (0<<CLKPS0))));
		init_sd_card(); // initialize sd-card
     9b8:	0e 94 c4 04 	call	0x988	; 0x988 <init_sd_card>
		initCAN(); // init can-bus
     9bc:	0e 94 69 00 	call	0xd2	; 0xd2 <initCAN>
		listenForMessage(CAN_ID_SNELHEIDSMETER, 8);
     9c0:	68 e0       	ldi	r22, 0x08	; 8
     9c2:	80 e1       	ldi	r24, 0x10	; 16
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	0e 94 9f 00 	call	0x13e	; 0x13e <listenForMessage>
		init_millis(F_CPU); // init timer 
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	74 e2       	ldi	r23, 0x24	; 36
     9ce:	84 ef       	ldi	r24, 0xF4	; 244
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	0e 94 3b 05 	call	0xa76	; 0xa76 <init_millis>
		sei(); // enable interrupts
     9d6:	78 94       	sei
		curOffset = find_offset(); // returnt offset van eerstvolgende lege sector
     9d8:	0e 94 59 04 	call	0x8b2	; 0x8b2 <find_offset>
     9dc:	60 93 a5 01 	sts	0x01A5, r22	; 0x8001a5 <curOffset>
     9e0:	70 93 a6 01 	sts	0x01A6, r23	; 0x8001a6 <curOffset+0x1>
     9e4:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <curOffset+0x2>
     9e8:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <curOffset+0x3>
		start_log_message(); // schrijf start log bericht naar de kaart zodat je kan zien wanneer de auto opnieuw aan is gezet
     9ec:	0e 94 98 04 	call	0x930	; 0x930 <start_log_message>
			/*if(millis() - timer >= 1000)
			{ 	
				fill_buffer(); // 1 keer per seconde
				timer = millis();
			}*/
			fill_buffer();
     9f0:	0e 94 dd 03 	call	0x7ba	; 0x7ba <fill_buffer>
		
			if(startWriting)
     9f4:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <startWriting>
     9f8:	88 23       	and	r24, r24
     9fa:	d1 f3       	breq	.-12     	; 0x9f0 <main+0x38>
			{
				writeToCard(); // schrijf buffer op kaart
     9fc:	0e 94 2c 04 	call	0x858	; 0x858 <writeToCard>
				curOffset += 512; // zet pointer naar volgende sector
     a00:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <curOffset>
     a04:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <curOffset+0x1>
     a08:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <curOffset+0x2>
     a0c:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <curOffset+0x3>
     a10:	9e 5f       	subi	r25, 0xFE	; 254
     a12:	af 4f       	sbci	r26, 0xFF	; 255
     a14:	bf 4f       	sbci	r27, 0xFF	; 255
     a16:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <curOffset>
     a1a:	90 93 a6 01 	sts	0x01A6, r25	; 0x8001a6 <curOffset+0x1>
     a1e:	a0 93 a7 01 	sts	0x01A7, r26	; 0x8001a7 <curOffset+0x2>
     a22:	b0 93 a8 01 	sts	0x01A8, r27	; 0x8001a8 <curOffset+0x3>
				startWriting = false;
     a26:	10 92 a9 01 	sts	0x01A9, r1	; 0x8001a9 <startWriting>
     a2a:	e2 cf       	rjmp	.-60     	; 0x9f0 <main+0x38>

00000a2c <__vector_12>:
#include <avr/interrupt.h>

#include "millis.h"

ISR(TIMER1_COMPA_vect)
{
     a2c:	1f 92       	push	r1
     a2e:	0f 92       	push	r0
     a30:	0f b6       	in	r0, 0x3f	; 63
     a32:	0f 92       	push	r0
     a34:	11 24       	eor	r1, r1
     a36:	8f 93       	push	r24
     a38:	9f 93       	push	r25
     a3a:	af 93       	push	r26
     a3c:	bf 93       	push	r27
  timer1_millis++;
     a3e:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <timer1_millis>
     a42:	90 91 8d 06 	lds	r25, 0x068D	; 0x80068d <timer1_millis+0x1>
     a46:	a0 91 8e 06 	lds	r26, 0x068E	; 0x80068e <timer1_millis+0x2>
     a4a:	b0 91 8f 06 	lds	r27, 0x068F	; 0x80068f <timer1_millis+0x3>
     a4e:	01 96       	adiw	r24, 0x01	; 1
     a50:	a1 1d       	adc	r26, r1
     a52:	b1 1d       	adc	r27, r1
     a54:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <timer1_millis>
     a58:	90 93 8d 06 	sts	0x068D, r25	; 0x80068d <timer1_millis+0x1>
     a5c:	a0 93 8e 06 	sts	0x068E, r26	; 0x80068e <timer1_millis+0x2>
     a60:	b0 93 8f 06 	sts	0x068F, r27	; 0x80068f <timer1_millis+0x3>
}
     a64:	bf 91       	pop	r27
     a66:	af 91       	pop	r26
     a68:	9f 91       	pop	r25
     a6a:	8f 91       	pop	r24
     a6c:	0f 90       	pop	r0
     a6e:	0f be       	out	0x3f, r0	; 63
     a70:	0f 90       	pop	r0
     a72:	1f 90       	pop	r1
     a74:	18 95       	reti

00000a76 <init_millis>:

void init_millis(unsigned long f_cpu)
{
  unsigned long ctc_match_overflow;

  ctc_match_overflow = ((f_cpu / 1000) / 8); //when timer1 is this value, 1ms has passed
     a76:	20 e4       	ldi	r18, 0x40	; 64
     a78:	3f e1       	ldi	r19, 0x1F	; 31
     a7a:	40 e0       	ldi	r20, 0x00	; 0
     a7c:	50 e0       	ldi	r21, 0x00	; 0
     a7e:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <__udivmodsi4>

  // (Set timer to clear when matching ctc_match_overflow) | (Set clock divisor to 8)
  TCCR1B |= (1 << WGM12) | (1 << CS11);
     a82:	e1 e8       	ldi	r30, 0x81	; 129
     a84:	f0 e0       	ldi	r31, 0x00	; 0
     a86:	80 81       	ld	r24, Z
     a88:	8a 60       	ori	r24, 0x0A	; 10
     a8a:	80 83       	st	Z, r24

  // high byte first, then low byte
  OCR1AH = (ctc_match_overflow >> 8);
     a8c:	bb 27       	eor	r27, r27
     a8e:	a5 2f       	mov	r26, r21
     a90:	94 2f       	mov	r25, r20
     a92:	83 2f       	mov	r24, r19
     a94:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
  OCR1AL = ctc_match_overflow;
     a98:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

  // Enable the compare match interrupt
  TIMSK1 |= (1 << OCIE1A);
     a9c:	ef e6       	ldi	r30, 0x6F	; 111
     a9e:	f0 e0       	ldi	r31, 0x00	; 0
     aa0:	80 81       	ld	r24, Z
     aa2:	82 60       	ori	r24, 0x02	; 2
     aa4:	80 83       	st	Z, r24
     aa6:	08 95       	ret

00000aa8 <mem_set>:

static FATFS *FatFs; /* Pointer to the file system object (logical drive) */

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
     aa8:	fc 01       	movw	r30, r24
	char *d = (char *)dst;
	while (cnt--)
     aaa:	03 c0       	rjmp	.+6      	; 0xab2 <mem_set+0xa>
		*d++ = (char)val;
     aac:	60 83       	st	Z, r22

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     aae:	ac 01       	movw	r20, r24
		*d++ = (char)val;
     ab0:	31 96       	adiw	r30, 0x01	; 1

/* Fill memory */
static void mem_set(void *dst, int val, int cnt)
{
	char *d = (char *)dst;
	while (cnt--)
     ab2:	ca 01       	movw	r24, r20
     ab4:	01 97       	sbiw	r24, 0x01	; 1
     ab6:	45 2b       	or	r20, r21
     ab8:	c9 f7       	brne	.-14     	; 0xaac <mem_set+0x4>
		*d++ = (char)val;
}
     aba:	08 95       	ret

00000abc <mem_cmp>:

/* Compare memory to memory */
static int mem_cmp(const void *dst, const void *src, int cnt)
{
     abc:	cf 93       	push	r28
     abe:	df 93       	push	r29
     ac0:	dc 01       	movw	r26, r24
     ac2:	fb 01       	movw	r30, r22
	const char *d = (const char *)dst, *s = (const char *)src;
	int         r = 0;
     ac4:	80 e0       	ldi	r24, 0x00	; 0
     ac6:	90 e0       	ldi	r25, 0x00	; 0
	while (cnt-- && (r = *d++ - *s++) == 0)
     ac8:	02 c0       	rjmp	.+4      	; 0xace <mem_cmp+0x12>
     aca:	fb 01       	movw	r30, r22
     acc:	de 01       	movw	r26, r28
     ace:	9a 01       	movw	r18, r20
     ad0:	21 50       	subi	r18, 0x01	; 1
     ad2:	31 09       	sbc	r19, r1
     ad4:	45 2b       	or	r20, r21
     ad6:	61 f0       	breq	.+24     	; 0xaf0 <mem_cmp+0x34>
     ad8:	ed 01       	movw	r28, r26
     ada:	21 96       	adiw	r28, 0x01	; 1
     adc:	8c 91       	ld	r24, X
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	bf 01       	movw	r22, r30
     ae2:	6f 5f       	subi	r22, 0xFF	; 255
     ae4:	7f 4f       	sbci	r23, 0xFF	; 255
     ae6:	40 81       	ld	r20, Z
     ae8:	84 1b       	sub	r24, r20
     aea:	91 09       	sbc	r25, r1
     aec:	a9 01       	movw	r20, r18
     aee:	69 f3       	breq	.-38     	; 0xaca <mem_cmp+0xe>
		;
	return r;
}
     af0:	df 91       	pop	r29
     af2:	cf 91       	pop	r28
     af4:	08 95       	ret

00000af6 <clust2sect>:
/*-----------------------------------------------------------------------*/

static DWORD clust2sect(           /* !=0: Sector number, 0: Failed - invalid cluster# */
                        CLUST clst /* Cluster# to be converted */
)
{
     af6:	0f 93       	push	r16
     af8:	1f 93       	push	r17
	FATFS *fs = FatFs;
     afa:	e0 91 ae 05 	lds	r30, 0x05AE	; 0x8005ae <FatFs>
     afe:	f0 91 af 05 	lds	r31, 0x05AF	; 0x8005af <FatFs+0x1>

	clst -= 2;
     b02:	9b 01       	movw	r18, r22
     b04:	ac 01       	movw	r20, r24
     b06:	22 50       	subi	r18, 0x02	; 2
     b08:	31 09       	sbc	r19, r1
     b0a:	41 09       	sbc	r20, r1
     b0c:	51 09       	sbc	r21, r1
	if (clst >= (fs->n_fatent - 2))
     b0e:	86 81       	ldd	r24, Z+6	; 0x06
     b10:	97 81       	ldd	r25, Z+7	; 0x07
     b12:	a0 85       	ldd	r26, Z+8	; 0x08
     b14:	b1 85       	ldd	r27, Z+9	; 0x09
     b16:	02 97       	sbiw	r24, 0x02	; 2
     b18:	a1 09       	sbc	r26, r1
     b1a:	b1 09       	sbc	r27, r1
     b1c:	28 17       	cp	r18, r24
     b1e:	39 07       	cpc	r19, r25
     b20:	4a 07       	cpc	r20, r26
     b22:	5b 07       	cpc	r21, r27
     b24:	68 f4       	brcc	.+26     	; 0xb40 <clust2sect+0x4a>
		return 0; /* Invalid cluster# */
	return (DWORD)clst * fs->csize + fs->database;
     b26:	a2 81       	ldd	r26, Z+2	; 0x02
     b28:	b0 e0       	ldi	r27, 0x00	; 0
     b2a:	0e 94 a6 0d 	call	0x1b4c	; 0x1b4c <__muluhisi3>
     b2e:	02 89       	ldd	r16, Z+18	; 0x12
     b30:	13 89       	ldd	r17, Z+19	; 0x13
     b32:	24 89       	ldd	r18, Z+20	; 0x14
     b34:	35 89       	ldd	r19, Z+21	; 0x15
     b36:	60 0f       	add	r22, r16
     b38:	71 1f       	adc	r23, r17
     b3a:	82 1f       	adc	r24, r18
     b3c:	93 1f       	adc	r25, r19
     b3e:	03 c0       	rjmp	.+6      	; 0xb46 <clust2sect+0x50>
{
	FATFS *fs = FatFs;

	clst -= 2;
	if (clst >= (fs->n_fatent - 2))
		return 0; /* Invalid cluster# */
     b40:	60 e0       	ldi	r22, 0x00	; 0
     b42:	70 e0       	ldi	r23, 0x00	; 0
     b44:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     b46:	1f 91       	pop	r17
     b48:	0f 91       	pop	r16
     b4a:	08 95       	ret

00000b4c <get_clust>:

static CLUST get_clust(BYTE *dir /* Pointer to directory entry */
)
{
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	fc 01       	movw	r30, r24
	FATFS *fs   = FatFs;
	CLUST  clst = 0;

	if (_FS_32ONLY || (_FS_FAT32 && fs->fs_type == FS_FAT32)) {
		clst = LD_WORD(dir + DIR_FstClusHI);
     b52:	65 89       	ldd	r22, Z+21	; 0x15
     b54:	70 e0       	ldi	r23, 0x00	; 0
     b56:	76 2f       	mov	r23, r22
     b58:	66 27       	eor	r22, r22
     b5a:	84 89       	ldd	r24, Z+20	; 0x14
     b5c:	68 2b       	or	r22, r24
     b5e:	cb 01       	movw	r24, r22
     b60:	a0 e0       	ldi	r26, 0x00	; 0
     b62:	b0 e0       	ldi	r27, 0x00	; 0
		clst <<= 16;
     b64:	bc 01       	movw	r22, r24
     b66:	55 27       	eor	r21, r21
     b68:	44 27       	eor	r20, r20
	}
	clst |= LD_WORD(dir + DIR_FstClusLO);
     b6a:	83 8d       	ldd	r24, Z+27	; 0x1b
     b6c:	90 e0       	ldi	r25, 0x00	; 0
     b6e:	98 2f       	mov	r25, r24
     b70:	88 27       	eor	r24, r24
     b72:	22 8d       	ldd	r18, Z+26	; 0x1a
     b74:	82 2b       	or	r24, r18
     b76:	a0 e0       	ldi	r26, 0x00	; 0
     b78:	b0 e0       	ldi	r27, 0x00	; 0
     b7a:	8c 01       	movw	r16, r24
     b7c:	9d 01       	movw	r18, r26
     b7e:	04 2b       	or	r16, r20
     b80:	15 2b       	or	r17, r21
     b82:	26 2b       	or	r18, r22
     b84:	37 2b       	or	r19, r23
     b86:	c9 01       	movw	r24, r18
     b88:	b8 01       	movw	r22, r16

	return clst;
}
     b8a:	1f 91       	pop	r17
     b8c:	0f 91       	pop	r16
     b8e:	08 95       	ret

00000b90 <dir_rewind>:
/* Directory handling - Rewind directory index                           */
/*-----------------------------------------------------------------------*/

static FRESULT dir_rewind(DIR *dj /* Pointer to directory object */
)
{
     b90:	0f 93       	push	r16
     b92:	1f 93       	push	r17
     b94:	cf 93       	push	r28
     b96:	df 93       	push	r29
     b98:	fc 01       	movw	r30, r24
	CLUST  clst;
	FATFS *fs = FatFs;
     b9a:	a0 91 ae 05 	lds	r26, 0x05AE	; 0x8005ae <FatFs>
     b9e:	b0 91 af 05 	lds	r27, 0x05AF	; 0x8005af <FatFs+0x1>

	dj->index = 0;
     ba2:	11 82       	std	Z+1, r1	; 0x01
     ba4:	10 82       	st	Z, r1
	clst      = dj->sclust;
     ba6:	64 81       	ldd	r22, Z+4	; 0x04
     ba8:	75 81       	ldd	r23, Z+5	; 0x05
     baa:	86 81       	ldd	r24, Z+6	; 0x06
     bac:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
     bae:	61 30       	cpi	r22, 0x01	; 1
     bb0:	71 05       	cpc	r23, r1
     bb2:	81 05       	cpc	r24, r1
     bb4:	91 05       	cpc	r25, r1
     bb6:	19 f1       	breq	.+70     	; 0xbfe <dir_rewind+0x6e>
     bb8:	16 96       	adiw	r26, 0x06	; 6
     bba:	0d 91       	ld	r16, X+
     bbc:	1d 91       	ld	r17, X+
     bbe:	2d 91       	ld	r18, X+
     bc0:	3c 91       	ld	r19, X
     bc2:	19 97       	sbiw	r26, 0x09	; 9
     bc4:	60 17       	cp	r22, r16
     bc6:	71 07       	cpc	r23, r17
     bc8:	82 07       	cpc	r24, r18
     bca:	93 07       	cpc	r25, r19
     bcc:	d0 f4       	brcc	.+52     	; 0xc02 <dir_rewind+0x72>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst
     bce:	61 15       	cp	r22, r1
     bd0:	71 05       	cpc	r23, r1
     bd2:	81 05       	cpc	r24, r1
     bd4:	91 05       	cpc	r25, r1
     bd6:	31 f4       	brne	.+12     	; 0xbe4 <dir_rewind+0x54>
	    && (_FS_32ONLY || fs->fs_type == FS_FAT32)) /* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
     bd8:	1e 96       	adiw	r26, 0x0e	; 14
     bda:	6d 91       	ld	r22, X+
     bdc:	7d 91       	ld	r23, X+
     bde:	8d 91       	ld	r24, X+
     be0:	9c 91       	ld	r25, X
     be2:	51 97       	sbiw	r26, 0x11	; 17
     be4:	ef 01       	movw	r28, r30
	dj->clust = clst;                                                  /* Current cluster */
     be6:	60 87       	std	Z+8, r22	; 0x08
     be8:	71 87       	std	Z+9, r23	; 0x09
     bea:	82 87       	std	Z+10, r24	; 0x0a
     bec:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */
     bee:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <clust2sect>
     bf2:	6c 87       	std	Y+12, r22	; 0x0c
     bf4:	7d 87       	std	Y+13, r23	; 0x0d
     bf6:	8e 87       	std	Y+14, r24	; 0x0e
     bf8:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK; /* Seek succeeded */
     bfa:	80 e0       	ldi	r24, 0x00	; 0
     bfc:	03 c0       	rjmp	.+6      	; 0xc04 <dir_rewind+0x74>
	FATFS *fs = FatFs;

	dj->index = 0;
	clst      = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent) /* Check start cluster range */
		return FR_DISK_ERR;
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	01 c0       	rjmp	.+2      	; 0xc04 <dir_rewind+0x74>
     c02:	81 e0       	ldi	r24, 0x01	; 1
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;                                                  /* Current cluster */
	dj->sect  = (_FS_32ONLY || clst) ? clust2sect(clst) : fs->dirbase; /* Current sector */

	return FR_OK; /* Seek succeeded */
}
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	08 95       	ret

00000c0e <create_name>:
/*-----------------------------------------------------------------------*/

static FRESULT create_name(DIR *        dj,  /* Pointer to the directory object */
                           const char **path /* Pointer to pointer to the segment in the path string */
)
{
     c0e:	0f 93       	push	r16
     c10:	1f 93       	push	r17
     c12:	cf 93       	push	r28
     c14:	df 93       	push	r29
     c16:	eb 01       	movw	r28, r22
	static const BYTE cvt[] = _EXCVT;
#endif
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
     c18:	fc 01       	movw	r30, r24
     c1a:	02 81       	ldd	r16, Z+2	; 0x02
     c1c:	13 81       	ldd	r17, Z+3	; 0x03
	mem_set(sfn, ' ', 11);
     c1e:	4b e0       	ldi	r20, 0x0B	; 11
     c20:	50 e0       	ldi	r21, 0x00	; 0
     c22:	60 e2       	ldi	r22, 0x20	; 32
     c24:	70 e0       	ldi	r23, 0x00	; 0
     c26:	c8 01       	movw	r24, r16
     c28:	0e 94 54 05 	call	0xaa8	; 0xaa8 <mem_set>
	si = i = 0;
	ni     = 8;
	p      = *path;
     c2c:	28 81       	ld	r18, Y
     c2e:	39 81       	ldd	r19, Y+1	; 0x01
#endif

	/* Create file name in directory form */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0;
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	80 e0       	ldi	r24, 0x00	; 0
	ni     = 8;
     c34:	58 e0       	ldi	r21, 0x08	; 8
     c36:	01 c0       	rjmp	.+2      	; 0xc3a <create_name+0x2c>
     c38:	84 2f       	mov	r24, r20
	p      = *path;
	for (;;) {
		c = p[si++];
     c3a:	41 e0       	ldi	r20, 0x01	; 1
     c3c:	48 0f       	add	r20, r24
     c3e:	f9 01       	movw	r30, r18
     c40:	e8 0f       	add	r30, r24
     c42:	f1 1d       	adc	r31, r1
     c44:	e0 81       	ld	r30, Z
		if (c <= ' ' || c == '/')
     c46:	e1 32       	cpi	r30, 0x21	; 33
     c48:	f0 f0       	brcs	.+60     	; 0xc86 <create_name+0x78>
     c4a:	ef 32       	cpi	r30, 0x2F	; 47
     c4c:	e1 f0       	breq	.+56     	; 0xc86 <create_name+0x78>
			break; /* Break on end of segment */
		if (c == '.' || i >= ni) {
     c4e:	ee 32       	cpi	r30, 0x2E	; 46
     c50:	11 f0       	breq	.+4      	; 0xc56 <create_name+0x48>
     c52:	95 17       	cp	r25, r21
     c54:	38 f0       	brcs	.+14     	; 0xc64 <create_name+0x56>
			if (ni != 8 || c != '.')
     c56:	58 30       	cpi	r21, 0x08	; 8
     c58:	b1 f4       	brne	.+44     	; 0xc86 <create_name+0x78>
     c5a:	ee 32       	cpi	r30, 0x2E	; 46
     c5c:	a1 f4       	brne	.+40     	; 0xc86 <create_name+0x78>
				break;
			i  = 8;
     c5e:	98 e0       	ldi	r25, 0x08	; 8
			ni = 11;
     c60:	5b e0       	ldi	r21, 0x0B	; 11
     c62:	ea cf       	rjmp	.-44     	; 0xc38 <create_name+0x2a>
			continue;
		}
#if _USE_LCC
#ifdef _EXCVT
		if (c >= 0x80) /* To upper extended char (SBCS) */
     c64:	ee 23       	and	r30, r30
     c66:	24 f4       	brge	.+8      	; 0xc70 <create_name+0x62>
			c = cvt[c - 0x80];
     c68:	f0 e0       	ldi	r31, 0x00	; 0
     c6a:	e0 56       	subi	r30, 0x60	; 96
     c6c:	ff 4f       	sbci	r31, 0xFF	; 255
     c6e:	e0 81       	ld	r30, Z
			sfn[i++] = c;
			sfn[i++] = d;
		} else
#endif
		{ /* Single byte code */
			if (_USE_LCC && IsLower(c))
     c70:	8f e9       	ldi	r24, 0x9F	; 159
     c72:	8e 0f       	add	r24, r30
     c74:	8a 31       	cpi	r24, 0x1A	; 26
     c76:	08 f4       	brcc	.+2      	; 0xc7a <create_name+0x6c>
				c -= 0x20; /* toupper */
     c78:	e0 52       	subi	r30, 0x20	; 32
			sfn[i++] = c;
     c7a:	d8 01       	movw	r26, r16
     c7c:	a9 0f       	add	r26, r25
     c7e:	b1 1d       	adc	r27, r1
     c80:	ec 93       	st	X, r30
     c82:	9f 5f       	subi	r25, 0xFF	; 255
     c84:	d9 cf       	rjmp	.-78     	; 0xc38 <create_name+0x2a>
		}
	}
	*path = &p[si]; /* Rerurn pointer to the next segment */
     c86:	24 0f       	add	r18, r20
     c88:	31 1d       	adc	r19, r1
     c8a:	39 83       	std	Y+1, r19	; 0x01
     c8c:	28 83       	st	Y, r18

	sfn[11] = (c <= ' ') ? 1 : 0; /* Set last segment flag if end of path */
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	e1 32       	cpi	r30, 0x21	; 33
     c92:	08 f0       	brcs	.+2      	; 0xc96 <create_name+0x88>
     c94:	80 e0       	ldi	r24, 0x00	; 0
     c96:	f8 01       	movw	r30, r16
     c98:	83 87       	std	Z+11, r24	; 0x0b

	return FR_OK;
}
     c9a:	80 e0       	ldi	r24, 0x00	; 0
     c9c:	df 91       	pop	r29
     c9e:	cf 91       	pop	r28
     ca0:	1f 91       	pop	r17
     ca2:	0f 91       	pop	r16
     ca4:	08 95       	ret

00000ca6 <check_fs>:

static BYTE check_fs(/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     ca6:	cf 92       	push	r12
     ca8:	df 92       	push	r13
     caa:	ef 92       	push	r14
     cac:	ff 92       	push	r15
     cae:	0f 93       	push	r16
     cb0:	1f 93       	push	r17
     cb2:	cf 93       	push	r28
     cb4:	df 93       	push	r29
     cb6:	ec 01       	movw	r28, r24
     cb8:	6a 01       	movw	r12, r20
     cba:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
     cbc:	02 e0       	ldi	r16, 0x02	; 2
     cbe:	10 e0       	ldi	r17, 0x00	; 0
     cc0:	2e ef       	ldi	r18, 0xFE	; 254
     cc2:	31 e0       	ldi	r19, 0x01	; 1
     cc4:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
     cc8:	81 11       	cpse	r24, r1
     cca:	1d c0       	rjmp	.+58     	; 0xd06 <check_fs+0x60>
		return 3;
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
     ccc:	89 81       	ldd	r24, Y+1	; 0x01
     cce:	90 e0       	ldi	r25, 0x00	; 0
     cd0:	98 2f       	mov	r25, r24
     cd2:	88 27       	eor	r24, r24
     cd4:	28 81       	ld	r18, Y
     cd6:	82 2b       	or	r24, r18
     cd8:	85 35       	cpi	r24, 0x55	; 85
     cda:	9a 4a       	sbci	r25, 0xAA	; 170
     cdc:	b1 f4       	brne	.+44     	; 0xd0a <check_fs+0x64>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
     cde:	22 e5       	ldi	r18, 0x52	; 82
     ce0:	30 e0       	ldi	r19, 0x00	; 0
     ce2:	b7 01       	movw	r22, r14
     ce4:	a6 01       	movw	r20, r12
     ce6:	ce 01       	movw	r24, r28
     ce8:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
     cec:	81 11       	cpse	r24, r1
     cee:	0f c0       	rjmp	.+30     	; 0xd0e <check_fs+0x68>
     cf0:	89 81       	ldd	r24, Y+1	; 0x01
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	98 2f       	mov	r25, r24
     cf6:	88 27       	eor	r24, r24
     cf8:	28 81       	ld	r18, Y
     cfa:	82 2b       	or	r24, r18
     cfc:	86 34       	cpi	r24, 0x46	; 70
     cfe:	91 44       	sbci	r25, 0x41	; 65
     d00:	41 f0       	breq	.+16     	; 0xd12 <check_fs+0x6c>
		return 0;
	return 1;
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	07 c0       	rjmp	.+14     	; 0xd14 <check_fs+0x6e>
                     BYTE *buf, /* Working buffer */
                     DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2)) /* Read the boot record */
		return 3;
     d06:	83 e0       	ldi	r24, 0x03	; 3
     d08:	05 c0       	rjmp	.+10     	; 0xd14 <check_fs+0x6e>
	if (LD_WORD(buf) != 0xAA55) /* Check record signature */
		return 2;
     d0a:	82 e0       	ldi	r24, 0x02	; 2
     d0c:	03 c0       	rjmp	.+6      	; 0xd14 <check_fs+0x6e>

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
	return 1;
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	01 c0       	rjmp	.+2      	; 0xd14 <check_fs+0x6e>
		return 2;

	if (!_FS_32ONLY && !disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146) /* Check FAT32 */
		return 0;
     d12:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
     d14:	df 91       	pop	r29
     d16:	cf 91       	pop	r28
     d18:	1f 91       	pop	r17
     d1a:	0f 91       	pop	r16
     d1c:	ff 90       	pop	r15
     d1e:	ef 90       	pop	r14
     d20:	df 90       	pop	r13
     d22:	cf 90       	pop	r12
     d24:	08 95       	ret

00000d26 <get_fat>:
/*-----------------------------------------------------------------------*/

static CLUST get_fat(           /* 1:IO error, Else:Cluster status */
                     CLUST clst /* Cluster# to get the link information */
)
{
     d26:	cf 92       	push	r12
     d28:	df 92       	push	r13
     d2a:	ef 92       	push	r14
     d2c:	ff 92       	push	r15
     d2e:	0f 93       	push	r16
     d30:	1f 93       	push	r17
     d32:	cf 93       	push	r28
     d34:	df 93       	push	r29
     d36:	00 d0       	rcall	.+0      	; 0xd38 <get_fat+0x12>
     d38:	00 d0       	rcall	.+0      	; 0xd3a <get_fat+0x14>
     d3a:	cd b7       	in	r28, 0x3d	; 61
     d3c:	de b7       	in	r29, 0x3e	; 62
	BYTE   buf[4];
	FATFS *fs = FatFs;
     d3e:	e0 91 ae 05 	lds	r30, 0x05AE	; 0x8005ae <FatFs>
     d42:	f0 91 af 05 	lds	r31, 0x05AF	; 0x8005af <FatFs+0x1>

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
     d46:	62 30       	cpi	r22, 0x02	; 2
     d48:	71 05       	cpc	r23, r1
     d4a:	81 05       	cpc	r24, r1
     d4c:	91 05       	cpc	r25, r1
     d4e:	08 f4       	brcc	.+2      	; 0xd52 <get_fat+0x2c>
     d50:	56 c0       	rjmp	.+172    	; 0xdfe <get_fat+0xd8>
     d52:	06 81       	ldd	r16, Z+6	; 0x06
     d54:	17 81       	ldd	r17, Z+7	; 0x07
     d56:	20 85       	ldd	r18, Z+8	; 0x08
     d58:	31 85       	ldd	r19, Z+9	; 0x09
     d5a:	60 17       	cp	r22, r16
     d5c:	71 07       	cpc	r23, r17
     d5e:	82 07       	cpc	r24, r18
     d60:	93 07       	cpc	r25, r19
     d62:	08 f0       	brcs	.+2      	; 0xd66 <get_fat+0x40>
     d64:	51 c0       	rjmp	.+162    	; 0xe08 <get_fat+0xe2>
		return 1;

	switch (fs->fs_type) {
     d66:	20 81       	ld	r18, Z
     d68:	23 30       	cpi	r18, 0x03	; 3
     d6a:	09 f0       	breq	.+2      	; 0xd6e <get_fat+0x48>
     d6c:	52 c0       	rjmp	.+164    	; 0xe12 <get_fat+0xec>
     d6e:	dc 01       	movw	r26, r24
     d70:	cb 01       	movw	r24, r22
			break;
		return LD_WORD(buf);
#endif
#if _FS_FAT32
	case FS_FAT32:
		if (disk_readp(buf, fs->fatbase + clst / 128, ((UINT)clst % 128) * 4, 4))
     d72:	9c 01       	movw	r18, r24
     d74:	2f 77       	andi	r18, 0x7F	; 127
     d76:	33 27       	eor	r19, r19
     d78:	c2 84       	ldd	r12, Z+10	; 0x0a
     d7a:	d3 84       	ldd	r13, Z+11	; 0x0b
     d7c:	e4 84       	ldd	r14, Z+12	; 0x0c
     d7e:	f5 84       	ldd	r15, Z+13	; 0x0d
     d80:	68 94       	set
     d82:	16 f8       	bld	r1, 6
     d84:	b6 95       	lsr	r27
     d86:	a7 95       	ror	r26
     d88:	97 95       	ror	r25
     d8a:	87 95       	ror	r24
     d8c:	16 94       	lsr	r1
     d8e:	d1 f7       	brne	.-12     	; 0xd84 <get_fat+0x5e>
     d90:	22 0f       	add	r18, r18
     d92:	33 1f       	adc	r19, r19
     d94:	22 0f       	add	r18, r18
     d96:	33 1f       	adc	r19, r19
     d98:	b7 01       	movw	r22, r14
     d9a:	a6 01       	movw	r20, r12
     d9c:	48 0f       	add	r20, r24
     d9e:	59 1f       	adc	r21, r25
     da0:	6a 1f       	adc	r22, r26
     da2:	7b 1f       	adc	r23, r27
     da4:	04 e0       	ldi	r16, 0x04	; 4
     da6:	10 e0       	ldi	r17, 0x00	; 0
     da8:	ce 01       	movw	r24, r28
     daa:	01 96       	adiw	r24, 0x01	; 1
     dac:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
     db0:	81 11       	cpse	r24, r1
     db2:	34 c0       	rjmp	.+104    	; 0xe1c <get_fat+0xf6>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
     db4:	8c 81       	ldd	r24, Y+4	; 0x04
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	a0 e0       	ldi	r26, 0x00	; 0
     dba:	b0 e0       	ldi	r27, 0x00	; 0
     dbc:	78 2f       	mov	r23, r24
     dbe:	66 27       	eor	r22, r22
     dc0:	55 27       	eor	r21, r21
     dc2:	44 27       	eor	r20, r20
     dc4:	9b 81       	ldd	r25, Y+3	; 0x03
     dc6:	89 2f       	mov	r24, r25
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	a0 e0       	ldi	r26, 0x00	; 0
     dcc:	b0 e0       	ldi	r27, 0x00	; 0
     dce:	dc 01       	movw	r26, r24
     dd0:	99 27       	eor	r25, r25
     dd2:	88 27       	eor	r24, r24
     dd4:	84 2b       	or	r24, r20
     dd6:	95 2b       	or	r25, r21
     dd8:	a6 2b       	or	r26, r22
     dda:	b7 2b       	or	r27, r23
     ddc:	6a 81       	ldd	r22, Y+2	; 0x02
     dde:	70 e0       	ldi	r23, 0x00	; 0
     de0:	76 2f       	mov	r23, r22
     de2:	66 27       	eor	r22, r22
     de4:	ab 01       	movw	r20, r22
     de6:	60 e0       	ldi	r22, 0x00	; 0
     de8:	70 e0       	ldi	r23, 0x00	; 0
     dea:	84 2b       	or	r24, r20
     dec:	95 2b       	or	r25, r21
     dee:	a6 2b       	or	r26, r22
     df0:	b7 2b       	or	r27, r23
     df2:	29 81       	ldd	r18, Y+1	; 0x01
     df4:	82 2b       	or	r24, r18
     df6:	bc 01       	movw	r22, r24
     df8:	cd 01       	movw	r24, r26
     dfa:	9f 70       	andi	r25, 0x0F	; 15
     dfc:	13 c0       	rjmp	.+38     	; 0xe24 <get_fat+0xfe>
{
	BYTE   buf[4];
	FATFS *fs = FatFs;

	if (clst < 2 || clst >= fs->n_fatent) /* Range check */
		return 1;
     dfe:	61 e0       	ldi	r22, 0x01	; 1
     e00:	70 e0       	ldi	r23, 0x00	; 0
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	0e c0       	rjmp	.+28     	; 0xe24 <get_fat+0xfe>
     e08:	61 e0       	ldi	r22, 0x01	; 1
     e0a:	70 e0       	ldi	r23, 0x00	; 0
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	09 c0       	rjmp	.+18     	; 0xe24 <get_fat+0xfe>
			break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1; /* An error occured at the disk I/O layer */
     e12:	61 e0       	ldi	r22, 0x01	; 1
     e14:	70 e0       	ldi	r23, 0x00	; 0
     e16:	80 e0       	ldi	r24, 0x00	; 0
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	04 c0       	rjmp	.+8      	; 0xe24 <get_fat+0xfe>
     e1c:	61 e0       	ldi	r22, 0x01	; 1
     e1e:	70 e0       	ldi	r23, 0x00	; 0
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	90 e0       	ldi	r25, 0x00	; 0
}
     e24:	0f 90       	pop	r0
     e26:	0f 90       	pop	r0
     e28:	0f 90       	pop	r0
     e2a:	0f 90       	pop	r0
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	ff 90       	pop	r15
     e36:	ef 90       	pop	r14
     e38:	df 90       	pop	r13
     e3a:	cf 90       	pop	r12
     e3c:	08 95       	ret

00000e3e <dir_next>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_next(        /* FR_OK:Succeeded, FR_NO_FILE:End of table */
                        DIR *dj /* Pointer to directory object */
)
{
     e3e:	cf 92       	push	r12
     e40:	df 92       	push	r13
     e42:	ef 92       	push	r14
     e44:	ff 92       	push	r15
     e46:	0f 93       	push	r16
     e48:	1f 93       	push	r17
     e4a:	cf 93       	push	r28
     e4c:	df 93       	push	r29
	CLUST  clst;
	WORD   i;
	FATFS *fs = FatFs;
     e4e:	e0 90 ae 05 	lds	r14, 0x05AE	; 0x8005ae <FatFs>
     e52:	f0 90 af 05 	lds	r15, 0x05AF	; 0x8005af <FatFs+0x1>

	i = dj->index + 1;
     e56:	fc 01       	movw	r30, r24
     e58:	c0 81       	ld	r28, Z
     e5a:	d1 81       	ldd	r29, Z+1	; 0x01
     e5c:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
     e5e:	09 f4       	brne	.+2      	; 0xe62 <dir_next+0x24>
     e60:	5c c0       	rjmp	.+184    	; 0xf1a <dir_next+0xdc>
     e62:	44 85       	ldd	r20, Z+12	; 0x0c
     e64:	55 85       	ldd	r21, Z+13	; 0x0d
     e66:	66 85       	ldd	r22, Z+14	; 0x0e
     e68:	77 85       	ldd	r23, Z+15	; 0x0f
     e6a:	41 15       	cp	r20, r1
     e6c:	51 05       	cpc	r21, r1
     e6e:	61 05       	cpc	r22, r1
     e70:	71 05       	cpc	r23, r1
     e72:	09 f4       	brne	.+2      	; 0xe76 <dir_next+0x38>
     e74:	54 c0       	rjmp	.+168    	; 0xf1e <dir_next+0xe0>
     e76:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i % 16)) { /* Sector changed? */
     e78:	ce 01       	movw	r24, r28
     e7a:	8f 70       	andi	r24, 0x0F	; 15
     e7c:	99 27       	eor	r25, r25
     e7e:	89 2b       	or	r24, r25
     e80:	09 f0       	breq	.+2      	; 0xe84 <dir_next+0x46>
     e82:	46 c0       	rjmp	.+140    	; 0xf10 <dir_next+0xd2>
		dj->sect++;  /* Next sector */
     e84:	4f 5f       	subi	r20, 0xFF	; 255
     e86:	5f 4f       	sbci	r21, 0xFF	; 255
     e88:	6f 4f       	sbci	r22, 0xFF	; 255
     e8a:	7f 4f       	sbci	r23, 0xFF	; 255
     e8c:	44 87       	std	Z+12, r20	; 0x0c
     e8e:	55 87       	std	Z+13, r21	; 0x0d
     e90:	66 87       	std	Z+14, r22	; 0x0e
     e92:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {       /* Static table */
     e94:	40 85       	ldd	r20, Z+8	; 0x08
     e96:	51 85       	ldd	r21, Z+9	; 0x09
     e98:	62 85       	ldd	r22, Z+10	; 0x0a
     e9a:	73 85       	ldd	r23, Z+11	; 0x0b
     e9c:	41 15       	cp	r20, r1
     e9e:	51 05       	cpc	r21, r1
     ea0:	61 05       	cpc	r22, r1
     ea2:	71 05       	cpc	r23, r1
     ea4:	39 f4       	brne	.+14     	; 0xeb4 <dir_next+0x76>
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
     ea6:	f7 01       	movw	r30, r14
     ea8:	84 81       	ldd	r24, Z+4	; 0x04
     eaa:	95 81       	ldd	r25, Z+5	; 0x05
     eac:	c8 17       	cp	r28, r24
     eae:	d9 07       	cpc	r29, r25
     eb0:	c0 f5       	brcc	.+112    	; 0xf22 <dir_next+0xe4>
     eb2:	2e c0       	rjmp	.+92     	; 0xf10 <dir_next+0xd2>
				return FR_NO_FILE;
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
     eb4:	f7 01       	movw	r30, r14
     eb6:	82 81       	ldd	r24, Z+2	; 0x02
     eb8:	90 e0       	ldi	r25, 0x00	; 0
     eba:	01 97       	sbiw	r24, 0x01	; 1
     ebc:	9e 01       	movw	r18, r28
     ebe:	32 95       	swap	r19
     ec0:	22 95       	swap	r18
     ec2:	2f 70       	andi	r18, 0x0F	; 15
     ec4:	23 27       	eor	r18, r19
     ec6:	3f 70       	andi	r19, 0x0F	; 15
     ec8:	23 27       	eor	r18, r19
     eca:	82 23       	and	r24, r18
     ecc:	93 23       	and	r25, r19
     ece:	89 2b       	or	r24, r25
     ed0:	f9 f4       	brne	.+62     	; 0xf10 <dir_next+0xd2>
				clst = get_fat(dj->clust);           /* Get next cluster */
     ed2:	cb 01       	movw	r24, r22
     ed4:	ba 01       	movw	r22, r20
     ed6:	0e 94 93 06 	call	0xd26	; 0xd26 <get_fat>
				if (clst <= 1)
     eda:	62 30       	cpi	r22, 0x02	; 2
     edc:	71 05       	cpc	r23, r1
     ede:	81 05       	cpc	r24, r1
     ee0:	91 05       	cpc	r25, r1
     ee2:	08 f1       	brcs	.+66     	; 0xf26 <dir_next+0xe8>
					return FR_DISK_ERR;
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
     ee4:	f7 01       	movw	r30, r14
     ee6:	c6 80       	ldd	r12, Z+6	; 0x06
     ee8:	d7 80       	ldd	r13, Z+7	; 0x07
     eea:	e0 84       	ldd	r14, Z+8	; 0x08
     eec:	f1 84       	ldd	r15, Z+9	; 0x09
     eee:	6c 15       	cp	r22, r12
     ef0:	7d 05       	cpc	r23, r13
     ef2:	8e 05       	cpc	r24, r14
     ef4:	9f 05       	cpc	r25, r15
     ef6:	c8 f4       	brcc	.+50     	; 0xf2a <dir_next+0xec>
					return FR_NO_FILE;    /* Report EOT */
				dj->clust = clst;         /* Initialize data for new cluster */
     ef8:	f8 01       	movw	r30, r16
     efa:	60 87       	std	Z+8, r22	; 0x08
     efc:	71 87       	std	Z+9, r23	; 0x09
     efe:	82 87       	std	Z+10, r24	; 0x0a
     f00:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect  = clust2sect(clst);
     f02:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <clust2sect>
     f06:	f8 01       	movw	r30, r16
     f08:	64 87       	std	Z+12, r22	; 0x0c
     f0a:	75 87       	std	Z+13, r23	; 0x0d
     f0c:	86 87       	std	Z+14, r24	; 0x0e
     f0e:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
     f10:	f8 01       	movw	r30, r16
     f12:	d1 83       	std	Z+1, r29	; 0x01
     f14:	c0 83       	st	Z, r28

	return FR_OK;
     f16:	80 e0       	ldi	r24, 0x00	; 0
     f18:	09 c0       	rjmp	.+18     	; 0xf2c <dir_next+0xee>
	WORD   i;
	FATFS *fs = FatFs;

	i = dj->index + 1;
	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
     f1a:	83 e0       	ldi	r24, 0x03	; 3
     f1c:	07 c0       	rjmp	.+14     	; 0xf2c <dir_next+0xee>
     f1e:	83 e0       	ldi	r24, 0x03	; 3
     f20:	05 c0       	rjmp	.+10     	; 0xf2c <dir_next+0xee>
	if (!(i % 16)) { /* Sector changed? */
		dj->sect++;  /* Next sector */

		if (dj->clust == 0) {       /* Static table */
			if (i >= fs->n_rootdir) /* Report EOT when end of table */
				return FR_NO_FILE;
     f22:	83 e0       	ldi	r24, 0x03	; 3
     f24:	03 c0       	rjmp	.+6      	; 0xf2c <dir_next+0xee>
		} else {                                     /* Dynamic table */
			if (((i / 16) & (fs->csize - 1)) == 0) { /* Cluster changed? */
				clst = get_fat(dj->clust);           /* Get next cluster */
				if (clst <= 1)
					return FR_DISK_ERR;
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	01 c0       	rjmp	.+2      	; 0xf2c <dir_next+0xee>
				if (clst >= fs->n_fatent) /* When it reached end of dynamic table */
					return FR_NO_FILE;    /* Report EOT */
     f2a:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	1f 91       	pop	r17
     f32:	0f 91       	pop	r16
     f34:	ff 90       	pop	r15
     f36:	ef 90       	pop	r14
     f38:	df 90       	pop	r13
     f3a:	cf 90       	pop	r12
     f3c:	08 95       	ret

00000f3e <dir_find>:
/*-----------------------------------------------------------------------*/

	static FRESULT dir_find(DIR * dj, /* Pointer to the directory object linked to the file name */
							BYTE *dir /* 32-byte working buffer */
	)
	{
     f3e:	cf 92       	push	r12
     f40:	df 92       	push	r13
     f42:	ff 92       	push	r15
     f44:	0f 93       	push	r16
     f46:	1f 93       	push	r17
     f48:	cf 93       	push	r28
     f4a:	df 93       	push	r29
     f4c:	ec 01       	movw	r28, r24
     f4e:	6b 01       	movw	r12, r22
		FRESULT res;
		BYTE    c;

		res = dir_rewind(dj); /* Rewind directory object */
     f50:	0e 94 c8 05 	call	0xb90	; 0xb90 <dir_rewind>
		if (res != FR_OK)
     f54:	81 11       	cpse	r24, r1
     f56:	37 c0       	rjmp	.+110    	; 0xfc6 <dir_find+0x88>
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     f58:	28 81       	ld	r18, Y
     f5a:	39 81       	ldd	r19, Y+1	; 0x01
     f5c:	2f 70       	andi	r18, 0x0F	; 15
     f5e:	33 27       	eor	r19, r19
     f60:	22 0f       	add	r18, r18
     f62:	33 1f       	adc	r19, r19
     f64:	22 95       	swap	r18
     f66:	32 95       	swap	r19
     f68:	30 7f       	andi	r19, 0xF0	; 240
     f6a:	32 27       	eor	r19, r18
     f6c:	20 7f       	andi	r18, 0xF0	; 240
     f6e:	32 27       	eor	r19, r18
     f70:	4c 85       	ldd	r20, Y+12	; 0x0c
     f72:	5d 85       	ldd	r21, Y+13	; 0x0d
     f74:	6e 85       	ldd	r22, Y+14	; 0x0e
     f76:	7f 85       	ldd	r23, Y+15	; 0x0f
     f78:	00 e2       	ldi	r16, 0x20	; 32
     f7a:	10 e0       	ldi	r17, 0x00	; 0
     f7c:	c6 01       	movw	r24, r12
     f7e:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
					  ? FR_DISK_ERR
					  : FR_OK;
     f82:	91 e0       	ldi	r25, 0x01	; 1
     f84:	81 11       	cpse	r24, r1
     f86:	01 c0       	rjmp	.+2      	; 0xf8a <dir_find+0x4c>
     f88:	90 e0       	ldi	r25, 0x00	; 0
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     f8a:	f9 2e       	mov	r15, r25
					  ? FR_DISK_ERR
					  : FR_OK;
			if (res != FR_OK)
     f8c:	91 11       	cpse	r25, r1
     f8e:	16 c0       	rjmp	.+44     	; 0xfbc <dir_find+0x7e>
				break;
			c = dir[DIR_Name]; /* First character */
     f90:	f6 01       	movw	r30, r12
     f92:	80 81       	ld	r24, Z
			if (c == 0) { ///// hieerrr fout misschien
     f94:	88 23       	and	r24, r24
     f96:	a1 f0       	breq	.+40     	; 0xfc0 <dir_find+0x82>
				res = FR_NO_FILE;
				break;
			}                                                           /* Reached to end of table */
			if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
     f98:	83 85       	ldd	r24, Z+11	; 0x0b
     f9a:	83 fd       	sbrc	r24, 3
     f9c:	09 c0       	rjmp	.+18     	; 0xfb0 <dir_find+0x72>
     f9e:	6a 81       	ldd	r22, Y+2	; 0x02
     fa0:	7b 81       	ldd	r23, Y+3	; 0x03
     fa2:	4b e0       	ldi	r20, 0x0B	; 11
     fa4:	50 e0       	ldi	r21, 0x00	; 0
     fa6:	c6 01       	movw	r24, r12
     fa8:	0e 94 5e 05 	call	0xabc	; 0xabc <mem_cmp>
     fac:	89 2b       	or	r24, r25
     fae:	51 f0       	breq	.+20     	; 0xfc4 <dir_find+0x86>
				break;
			res = dir_next(dj); /* Next entry */
     fb0:	ce 01       	movw	r24, r28
     fb2:	0e 94 1f 07 	call	0xe3e	; 0xe3e <dir_next>
		} while (res == FR_OK);
     fb6:	88 23       	and	r24, r24
     fb8:	79 f2       	breq	.-98     	; 0xf58 <dir_find+0x1a>
     fba:	05 c0       	rjmp	.+10     	; 0xfc6 <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     fbc:	89 2f       	mov	r24, r25
     fbe:	03 c0       	rjmp	.+6      	; 0xfc6 <dir_find+0x88>
					  : FR_OK;
			if (res != FR_OK)
				break;
			c = dir[DIR_Name]; /* First character */
			if (c == 0) { ///// hieerrr fout misschien
				res = FR_NO_FILE;
     fc0:	83 e0       	ldi	r24, 0x03	; 3
     fc2:	01 c0       	rjmp	.+2      	; 0xfc6 <dir_find+0x88>
		res = dir_rewind(dj); /* Rewind directory object */
		if (res != FR_OK)
			return res;

		do {
			res = disk_readp(dir, dj->sect, (dj->index % 16) * 32, 32) /* Read an entry */
     fc4:	8f 2d       	mov	r24, r15
				break;
			res = dir_next(dj); /* Next entry */
		} while (res == FR_OK);

		return res;
	}
     fc6:	df 91       	pop	r29
     fc8:	cf 91       	pop	r28
     fca:	1f 91       	pop	r17
     fcc:	0f 91       	pop	r16
     fce:	ff 90       	pop	r15
     fd0:	df 90       	pop	r13
     fd2:	cf 90       	pop	r12
     fd4:	08 95       	ret

00000fd6 <follow_path>:
static FRESULT follow_path(                 /* FR_OK(0): successful, !=0: error code */
                           DIR *       dj,  /* Directory object to return last directory and found object */
                           BYTE *      dir, /* 32-byte working buffer */
                           const char *path /* Full-path string to find a file or directory */
)
{
     fd6:	ef 92       	push	r14
     fd8:	ff 92       	push	r15
     fda:	0f 93       	push	r16
     fdc:	1f 93       	push	r17
     fde:	cf 93       	push	r28
     fe0:	df 93       	push	r29
     fe2:	00 d0       	rcall	.+0      	; 0xfe4 <follow_path+0xe>
     fe4:	cd b7       	in	r28, 0x3d	; 61
     fe6:	de b7       	in	r29, 0x3e	; 62
     fe8:	8c 01       	movw	r16, r24
     fea:	7b 01       	movw	r14, r22
     fec:	5a 83       	std	Y+2, r21	; 0x02
     fee:	49 83       	std	Y+1, r20	; 0x01
	FRESULT res;

	while (*path == ' ')
     ff0:	03 c0       	rjmp	.+6      	; 0xff8 <follow_path+0x22>
		path++; /* Strip leading spaces */
     ff2:	31 96       	adiw	r30, 0x01	; 1
     ff4:	fa 83       	std	Y+2, r31	; 0x02
     ff6:	e9 83       	std	Y+1, r30	; 0x01
                           const char *path /* Full-path string to find a file or directory */
)
{
	FRESULT res;

	while (*path == ' ')
     ff8:	e9 81       	ldd	r30, Y+1	; 0x01
     ffa:	fa 81       	ldd	r31, Y+2	; 0x02
     ffc:	80 81       	ld	r24, Z
     ffe:	80 32       	cpi	r24, 0x20	; 32
    1000:	c1 f3       	breq	.-16     	; 0xff2 <follow_path+0x1c>
		path++; /* Strip leading spaces */
	if (*path == '/')
    1002:	8f 32       	cpi	r24, 0x2F	; 47
    1004:	19 f4       	brne	.+6      	; 0x100c <follow_path+0x36>
		path++;     /* Strip heading separator if exist */
    1006:	31 96       	adiw	r30, 0x01	; 1
    1008:	fa 83       	std	Y+2, r31	; 0x02
    100a:	e9 83       	std	Y+1, r30	; 0x01
	dj->sclust = 0; /* Set start directory (always root dir) */
    100c:	d8 01       	movw	r26, r16
    100e:	14 96       	adiw	r26, 0x04	; 4
    1010:	1d 92       	st	X+, r1
    1012:	1d 92       	st	X+, r1
    1014:	1d 92       	st	X+, r1
    1016:	1c 92       	st	X, r1
    1018:	17 97       	sbiw	r26, 0x07	; 7

	if ((BYTE)*path < ' ') { /* Null path means the root directory */
    101a:	e9 81       	ldd	r30, Y+1	; 0x01
    101c:	fa 81       	ldd	r31, Y+2	; 0x02
    101e:	80 81       	ld	r24, Z
    1020:	80 32       	cpi	r24, 0x20	; 32
    1022:	30 f4       	brcc	.+12     	; 0x1030 <follow_path+0x5a>
		res    = dir_rewind(dj);
    1024:	c8 01       	movw	r24, r16
    1026:	0e 94 c8 05 	call	0xb90	; 0xb90 <dir_rewind>
		dir[0] = 0;
    102a:	f7 01       	movw	r30, r14
    102c:	10 82       	st	Z, r1
    102e:	26 c0       	rjmp	.+76     	; 0x107c <follow_path+0xa6>

	} else { /* Follow path */
		for (;;) {
			res = create_name(dj, &path); /* Get a segment */
    1030:	be 01       	movw	r22, r28
    1032:	6f 5f       	subi	r22, 0xFF	; 255
    1034:	7f 4f       	sbci	r23, 0xFF	; 255
    1036:	c8 01       	movw	r24, r16
    1038:	0e 94 07 06 	call	0xc0e	; 0xc0e <create_name>
			if (res != FR_OK)
    103c:	81 11       	cpse	r24, r1
    103e:	1e c0       	rjmp	.+60     	; 0x107c <follow_path+0xa6>
				break;
			res = dir_find(dj, dir); /* Find it */ // het gaat denk ik hier fout
    1040:	b7 01       	movw	r22, r14
    1042:	c8 01       	movw	r24, r16
    1044:	0e 94 9f 07 	call	0xf3e	; 0xf3e <dir_find>
			if (res != FR_OK)
    1048:	81 11       	cpse	r24, r1
    104a:	18 c0       	rjmp	.+48     	; 0x107c <follow_path+0xa6>
				break; /* Could not find the object */
			if (dj->fn[11])
    104c:	d8 01       	movw	r26, r16
    104e:	12 96       	adiw	r26, 0x02	; 2
    1050:	ed 91       	ld	r30, X+
    1052:	fc 91       	ld	r31, X
    1054:	13 97       	sbiw	r26, 0x03	; 3
    1056:	93 85       	ldd	r25, Z+11	; 0x0b
    1058:	91 11       	cpse	r25, r1
    105a:	10 c0       	rjmp	.+32     	; 0x107c <follow_path+0xa6>
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
    105c:	f7 01       	movw	r30, r14
    105e:	83 85       	ldd	r24, Z+11	; 0x0b
    1060:	84 ff       	sbrs	r24, 4
    1062:	0b c0       	rjmp	.+22     	; 0x107a <follow_path+0xa4>
				res = FR_NO_FILE;
				break;
			}
			dj->sclust = get_clust(dir); /* Follow next */
    1064:	c7 01       	movw	r24, r14
    1066:	0e 94 a6 05 	call	0xb4c	; 0xb4c <get_clust>
    106a:	d8 01       	movw	r26, r16
    106c:	14 96       	adiw	r26, 0x04	; 4
    106e:	6d 93       	st	X+, r22
    1070:	7d 93       	st	X+, r23
    1072:	8d 93       	st	X+, r24
    1074:	9c 93       	st	X, r25
    1076:	17 97       	sbiw	r26, 0x07	; 7
		}
    1078:	db cf       	rjmp	.-74     	; 0x1030 <follow_path+0x5a>
			if (res != FR_OK)
				break; /* Could not find the object */
			if (dj->fn[11])
				break;                       /* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow path because it is a file */
				res = FR_NO_FILE;
    107a:	83 e0       	ldi	r24, 0x03	; 3
			dj->sclust = get_clust(dir); /* Follow next */
		}
	}

	return res;
}
    107c:	0f 90       	pop	r0
    107e:	0f 90       	pop	r0
    1080:	df 91       	pop	r29
    1082:	cf 91       	pop	r28
    1084:	1f 91       	pop	r17
    1086:	0f 91       	pop	r16
    1088:	ff 90       	pop	r15
    108a:	ef 90       	pop	r14
    108c:	08 95       	ret

0000108e <pf_mount>:
/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Locical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT pf_mount(FATFS *fs /* Pointer to new file system object */)
{
    108e:	4f 92       	push	r4
    1090:	5f 92       	push	r5
    1092:	6f 92       	push	r6
    1094:	7f 92       	push	r7
    1096:	8f 92       	push	r8
    1098:	9f 92       	push	r9
    109a:	af 92       	push	r10
    109c:	bf 92       	push	r11
    109e:	df 92       	push	r13
    10a0:	ef 92       	push	r14
    10a2:	ff 92       	push	r15
    10a4:	0f 93       	push	r16
    10a6:	1f 93       	push	r17
    10a8:	cf 93       	push	r28
    10aa:	df 93       	push	r29
    10ac:	cd b7       	in	r28, 0x3d	; 61
    10ae:	de b7       	in	r29, 0x3e	; 62
    10b0:	a8 97       	sbiw	r28, 0x28	; 40
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	f8 94       	cli
    10b6:	de bf       	out	0x3e, r29	; 62
    10b8:	0f be       	out	0x3f, r0	; 63
    10ba:	cd bf       	out	0x3d, r28	; 61
    10bc:	7c 01       	movw	r14, r24
	BYTE  fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;

	FatFs = 0;
    10be:	10 92 af 05 	sts	0x05AF, r1	; 0x8005af <FatFs+0x1>
    10c2:	10 92 ae 05 	sts	0x05AE, r1	; 0x8005ae <FatFs>

	if (disk_initialize() & STA_NOINIT)
    10c6:	0e 94 15 02 	call	0x42a	; 0x42a <disk_initialize>
    10ca:	80 fd       	sbrc	r24, 0
    10cc:	62 c1       	rjmp	.+708    	; 0x1392 <pf_mount+0x304>
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
    10ce:	40 e0       	ldi	r20, 0x00	; 0
    10d0:	50 e0       	ldi	r21, 0x00	; 0
    10d2:	ba 01       	movw	r22, r20
    10d4:	ce 01       	movw	r24, r28
    10d6:	01 96       	adiw	r24, 0x01	; 1
    10d8:	0e 94 53 06 	call	0xca6	; 0xca6 <check_fs>
    10dc:	d8 2e       	mov	r13, r24
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
    10de:	21 e0       	ldi	r18, 0x01	; 1
    10e0:	82 13       	cpse	r24, r18
    10e2:	38 c0       	rjmp	.+112    	; 0x1154 <pf_mount+0xc6>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
    10e4:	00 e1       	ldi	r16, 0x10	; 16
    10e6:	10 e0       	ldi	r17, 0x00	; 0
    10e8:	2e eb       	ldi	r18, 0xBE	; 190
    10ea:	31 e0       	ldi	r19, 0x01	; 1
    10ec:	40 e0       	ldi	r20, 0x00	; 0
    10ee:	50 e0       	ldi	r21, 0x00	; 0
    10f0:	ba 01       	movw	r22, r20
    10f2:	ce 01       	movw	r24, r28
    10f4:	01 96       	adiw	r24, 0x01	; 1
    10f6:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
    10fa:	81 11       	cpse	r24, r1
    10fc:	2f c0       	rjmp	.+94     	; 0x115c <pf_mount+0xce>
			fmt = 3;
		} else {
			if (buf[4]) {                     /* Is the partition existing? */
    10fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1100:	88 23       	and	r24, r24
    1102:	a1 f1       	breq	.+104    	; 0x116c <pf_mount+0xde>
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
    1104:	8c 84       	ldd	r8, Y+12	; 0x0c
    1106:	91 2c       	mov	r9, r1
    1108:	a1 2c       	mov	r10, r1
    110a:	b1 2c       	mov	r11, r1
    110c:	b8 2c       	mov	r11, r8
    110e:	aa 24       	eor	r10, r10
    1110:	99 24       	eor	r9, r9
    1112:	88 24       	eor	r8, r8
    1114:	9b 85       	ldd	r25, Y+11	; 0x0b
    1116:	89 2f       	mov	r24, r25
    1118:	90 e0       	ldi	r25, 0x00	; 0
    111a:	a0 e0       	ldi	r26, 0x00	; 0
    111c:	b0 e0       	ldi	r27, 0x00	; 0
    111e:	dc 01       	movw	r26, r24
    1120:	99 27       	eor	r25, r25
    1122:	88 27       	eor	r24, r24
    1124:	88 29       	or	r24, r8
    1126:	99 29       	or	r25, r9
    1128:	aa 29       	or	r26, r10
    112a:	bb 29       	or	r27, r11
    112c:	8a 84       	ldd	r8, Y+10	; 0x0a
    112e:	91 2c       	mov	r9, r1
    1130:	98 2c       	mov	r9, r8
    1132:	88 24       	eor	r8, r8
    1134:	a1 2c       	mov	r10, r1
    1136:	b1 2c       	mov	r11, r1
    1138:	88 2a       	or	r8, r24
    113a:	99 2a       	or	r9, r25
    113c:	aa 2a       	or	r10, r26
    113e:	bb 2a       	or	r11, r27
    1140:	89 85       	ldd	r24, Y+9	; 0x09
    1142:	88 2a       	or	r8, r24
				fmt   = check_fs(buf, bsect); /* Check the partition */
    1144:	b5 01       	movw	r22, r10
    1146:	a4 01       	movw	r20, r8
    1148:	ce 01       	movw	r24, r28
    114a:	01 96       	adiw	r24, 0x01	; 1
    114c:	0e 94 53 06 	call	0xca6	; 0xca6 <check_fs>
    1150:	d8 2e       	mov	r13, r24
    1152:	0f c0       	rjmp	.+30     	; 0x1172 <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    1154:	81 2c       	mov	r8, r1
    1156:	91 2c       	mov	r9, r1
    1158:	54 01       	movw	r10, r8
    115a:	0b c0       	rjmp	.+22     	; 0x1172 <pf_mount+0xe4>
    115c:	81 2c       	mov	r8, r1
    115e:	91 2c       	mov	r9, r1
    1160:	54 01       	movw	r10, r8
	fmt   = check_fs(buf, bsect); /* Check sector 0 as an SFD format */
	if (fmt == 1) {               /* Not an FAT boot record, it may be FDISK format */
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) { /* 1st partition entry */
			fmt = 3;
    1162:	0f 2e       	mov	r0, r31
    1164:	f3 e0       	ldi	r31, 0x03	; 3
    1166:	df 2e       	mov	r13, r31
    1168:	f0 2d       	mov	r31, r0
    116a:	03 c0       	rjmp	.+6      	; 0x1172 <pf_mount+0xe4>
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
	} 

	/* Search FAT partition on the drive */
	bsect = 0;
    116c:	81 2c       	mov	r8, r1
    116e:	91 2c       	mov	r9, r1
    1170:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);    /* Partition offset in LBA */
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
    1172:	43 e0       	ldi	r20, 0x03	; 3
    1174:	d4 16       	cp	r13, r20
    1176:	09 f4       	brne	.+2      	; 0x117a <pf_mount+0xec>
    1178:	0e c1       	rjmp	.+540    	; 0x1396 <pf_mount+0x308>
		return FR_DISK_ERR;
	if (fmt)
    117a:	d1 10       	cpse	r13, r1
    117c:	0e c1       	rjmp	.+540    	; 0x139a <pf_mount+0x30c>
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
    117e:	04 e2       	ldi	r16, 0x24	; 36
    1180:	10 e0       	ldi	r17, 0x00	; 0
    1182:	2d e0       	ldi	r18, 0x0D	; 13
    1184:	30 e0       	ldi	r19, 0x00	; 0
    1186:	b5 01       	movw	r22, r10
    1188:	a4 01       	movw	r20, r8
    118a:	ce 01       	movw	r24, r28
    118c:	01 96       	adiw	r24, 0x01	; 1
    118e:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
    1192:	81 11       	cpse	r24, r1
    1194:	04 c1       	rjmp	.+520    	; 0x139e <pf_mount+0x310>
		return FR_DISK_ERR;

	fsize = LD_WORD(buf + BPB_FATSz16 - 13); /* Number of sectors per FAT */
    1196:	2b 85       	ldd	r18, Y+11	; 0x0b
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	32 2f       	mov	r19, r18
    119c:	22 27       	eor	r18, r18
    119e:	8a 85       	ldd	r24, Y+10	; 0x0a
    11a0:	28 2b       	or	r18, r24
    11a2:	40 e0       	ldi	r20, 0x00	; 0
    11a4:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize)
    11a6:	21 15       	cp	r18, r1
    11a8:	31 05       	cpc	r19, r1
    11aa:	41 05       	cpc	r20, r1
    11ac:	51 05       	cpc	r21, r1
    11ae:	21 f5       	brne	.+72     	; 0x11f8 <pf_mount+0x16a>
		fsize = LD_DWORD(buf + BPB_FATSz32 - 13);
    11b0:	2b 8d       	ldd	r18, Y+27	; 0x1b
    11b2:	82 2f       	mov	r24, r18
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	a0 e0       	ldi	r26, 0x00	; 0
    11b8:	b0 e0       	ldi	r27, 0x00	; 0
    11ba:	78 2f       	mov	r23, r24
    11bc:	66 27       	eor	r22, r22
    11be:	55 27       	eor	r21, r21
    11c0:	44 27       	eor	r20, r20
    11c2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    11c4:	89 2f       	mov	r24, r25
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	a0 e0       	ldi	r26, 0x00	; 0
    11ca:	b0 e0       	ldi	r27, 0x00	; 0
    11cc:	dc 01       	movw	r26, r24
    11ce:	99 27       	eor	r25, r25
    11d0:	88 27       	eor	r24, r24
    11d2:	84 2b       	or	r24, r20
    11d4:	95 2b       	or	r25, r21
    11d6:	a6 2b       	or	r26, r22
    11d8:	b7 2b       	or	r27, r23
    11da:	29 8d       	ldd	r18, Y+25	; 0x19
    11dc:	30 e0       	ldi	r19, 0x00	; 0
    11de:	32 2f       	mov	r19, r18
    11e0:	22 27       	eor	r18, r18
    11e2:	a9 01       	movw	r20, r18
    11e4:	60 e0       	ldi	r22, 0x00	; 0
    11e6:	70 e0       	ldi	r23, 0x00	; 0
    11e8:	48 2b       	or	r20, r24
    11ea:	59 2b       	or	r21, r25
    11ec:	6a 2b       	or	r22, r26
    11ee:	7b 2b       	or	r23, r27
    11f0:	88 8d       	ldd	r24, Y+24	; 0x18
    11f2:	9a 01       	movw	r18, r20
    11f4:	ab 01       	movw	r20, r22
    11f6:	28 2b       	or	r18, r24

	fsize *= buf[BPB_NumFATs - 13];                             /* Number of sectors in FAT area */
    11f8:	ac 81       	ldd	r26, Y+4	; 0x04
    11fa:	b0 e0       	ldi	r27, 0x00	; 0
    11fc:	0e 94 a6 0d 	call	0x1b4c	; 0x1b4c <__muluhisi3>
    1200:	6d a3       	std	Y+37, r22	; 0x25
    1202:	7e a3       	std	Y+38, r23	; 0x26
    1204:	8f a3       	std	Y+39, r24	; 0x27
    1206:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase   = bsect + LD_WORD(buf + BPB_RsvdSecCnt - 13); /* FAT start sector (lba) */
    1208:	8b 81       	ldd	r24, Y+3	; 0x03
    120a:	90 e0       	ldi	r25, 0x00	; 0
    120c:	98 2f       	mov	r25, r24
    120e:	88 27       	eor	r24, r24
    1210:	4a 81       	ldd	r20, Y+2	; 0x02
    1212:	50 e0       	ldi	r21, 0x00	; 0
    1214:	84 2b       	or	r24, r20
    1216:	95 2b       	or	r25, r21
    1218:	88 0e       	add	r8, r24
    121a:	99 1e       	adc	r9, r25
    121c:	a1 1c       	adc	r10, r1
    121e:	b1 1c       	adc	r11, r1
    1220:	d7 01       	movw	r26, r14
    1222:	1a 96       	adiw	r26, 0x0a	; 10
    1224:	8d 92       	st	X+, r8
    1226:	9d 92       	st	X+, r9
    1228:	ad 92       	st	X+, r10
    122a:	bc 92       	st	X, r11
    122c:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
    122e:	a9 81       	ldd	r26, Y+1	; 0x01
    1230:	f7 01       	movw	r30, r14
    1232:	a2 83       	std	Z+2, r26	; 0x02
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
    1234:	8e 81       	ldd	r24, Y+6	; 0x06
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	98 2f       	mov	r25, r24
    123a:	88 27       	eor	r24, r24
    123c:	2d 81       	ldd	r18, Y+5	; 0x05
    123e:	82 2b       	or	r24, r18
    1240:	95 83       	std	Z+5, r25	; 0x05
    1242:	84 83       	std	Z+4, r24	; 0x04
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
    1244:	08 85       	ldd	r16, Y+8	; 0x08
    1246:	10 e0       	ldi	r17, 0x00	; 0
    1248:	10 2f       	mov	r17, r16
    124a:	00 27       	eor	r16, r16
    124c:	2f 81       	ldd	r18, Y+7	; 0x07
    124e:	02 2b       	or	r16, r18
    1250:	20 e0       	ldi	r18, 0x00	; 0
    1252:	30 e0       	ldi	r19, 0x00	; 0
	if (!tsect)
    1254:	01 15       	cp	r16, r1
    1256:	11 05       	cpc	r17, r1
    1258:	21 05       	cpc	r18, r1
    125a:	31 05       	cpc	r19, r1
    125c:	01 f5       	brne	.+64     	; 0x129e <pf_mount+0x210>
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
    125e:	0f 89       	ldd	r16, Y+23	; 0x17
    1260:	10 e0       	ldi	r17, 0x00	; 0
    1262:	20 e0       	ldi	r18, 0x00	; 0
    1264:	30 e0       	ldi	r19, 0x00	; 0
    1266:	70 2e       	mov	r7, r16
    1268:	66 24       	eor	r6, r6
    126a:	55 24       	eor	r5, r5
    126c:	44 24       	eor	r4, r4
    126e:	0e 89       	ldd	r16, Y+22	; 0x16
    1270:	10 e0       	ldi	r17, 0x00	; 0
    1272:	20 e0       	ldi	r18, 0x00	; 0
    1274:	30 e0       	ldi	r19, 0x00	; 0
    1276:	98 01       	movw	r18, r16
    1278:	11 27       	eor	r17, r17
    127a:	00 27       	eor	r16, r16
    127c:	40 2a       	or	r4, r16
    127e:	51 2a       	or	r5, r17
    1280:	62 2a       	or	r6, r18
    1282:	73 2a       	or	r7, r19
    1284:	2d 89       	ldd	r18, Y+21	; 0x15
    1286:	30 e0       	ldi	r19, 0x00	; 0
    1288:	32 2f       	mov	r19, r18
    128a:	22 27       	eor	r18, r18
    128c:	89 01       	movw	r16, r18
    128e:	20 e0       	ldi	r18, 0x00	; 0
    1290:	30 e0       	ldi	r19, 0x00	; 0
    1292:	04 29       	or	r16, r4
    1294:	15 29       	or	r17, r5
    1296:	26 29       	or	r18, r6
    1298:	37 29       	or	r19, r7
    129a:	6c 89       	ldd	r22, Y+20	; 0x14
    129c:	06 2b       	or	r16, r22
	mclst = (tsect /* Last cluster# + 1 */
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
    129e:	eb 81       	ldd	r30, Y+3	; 0x03
    12a0:	f0 e0       	ldi	r31, 0x00	; 0
    12a2:	fe 2f       	mov	r31, r30
    12a4:	ee 27       	eor	r30, r30
    12a6:	4e 2b       	or	r20, r30
    12a8:	5f 2b       	or	r21, r31
    12aa:	04 1b       	sub	r16, r20
    12ac:	15 0b       	sbc	r17, r21
    12ae:	21 09       	sbc	r18, r1
    12b0:	31 09       	sbc	r19, r1
    12b2:	4d a1       	ldd	r20, Y+37	; 0x25
    12b4:	5e a1       	ldd	r21, Y+38	; 0x26
    12b6:	6f a1       	ldd	r22, Y+39	; 0x27
    12b8:	78 a5       	ldd	r23, Y+40	; 0x28
    12ba:	04 1b       	sub	r16, r20
    12bc:	15 0b       	sbc	r17, r21
    12be:	26 0b       	sbc	r18, r22
    12c0:	37 0b       	sbc	r19, r23
    12c2:	92 95       	swap	r25
    12c4:	82 95       	swap	r24
    12c6:	8f 70       	andi	r24, 0x0F	; 15
    12c8:	89 27       	eor	r24, r25
    12ca:	9f 70       	andi	r25, 0x0F	; 15
    12cc:	89 27       	eor	r24, r25
    12ce:	2c 01       	movw	r4, r24
    12d0:	61 2c       	mov	r6, r1
    12d2:	71 2c       	mov	r7, r1
    12d4:	c9 01       	movw	r24, r18
    12d6:	b8 01       	movw	r22, r16
    12d8:	64 19       	sub	r22, r4
    12da:	75 09       	sbc	r23, r5
    12dc:	86 09       	sbc	r24, r6
    12de:	97 09       	sbc	r25, r7
	            / fs->csize
    12e0:	2a 2f       	mov	r18, r26
    12e2:	30 e0       	ldi	r19, 0x00	; 0
    12e4:	40 e0       	ldi	r20, 0x00	; 0
    12e6:	50 e0       	ldi	r21, 0x00	; 0
    12e8:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <__udivmodsi4>
	fs->csize     = buf[BPB_SecPerClus - 13];                   /* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf + BPB_RootEntCnt - 13);         /* Nmuber of root directory entries */
	tsect         = LD_WORD(buf + BPB_TotSec16 - 13);           /* Number of sectors on the file system */
	if (!tsect)
		tsect = LD_DWORD(buf + BPB_TotSec32 - 13);
	mclst = (tsect /* Last cluster# + 1 */
    12ec:	da 01       	movw	r26, r20
    12ee:	c9 01       	movw	r24, r18
    12f0:	02 96       	adiw	r24, 0x02	; 2
    12f2:	a1 1d       	adc	r26, r1
    12f4:	b1 1d       	adc	r27, r1
	         - LD_WORD(buf + BPB_RsvdSecCnt - 13) - fsize - fs->n_rootdir / 16)
	            / fs->csize
	        + 2;
	fs->n_fatent = (CLUST)mclst;
    12f6:	f7 01       	movw	r30, r14
    12f8:	86 83       	std	Z+6, r24	; 0x06
    12fa:	97 83       	std	Z+7, r25	; 0x07
    12fc:	a0 87       	std	Z+8, r26	; 0x08
    12fe:	b1 87       	std	Z+9, r27	; 0x09
	fmt = 0; /* Determine the FAT sub type */
	if (_FS_FAT12 && mclst < 0xFF7)
		fmt = FS_FAT12;
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
    1300:	87 3f       	cpi	r24, 0xF7	; 247
    1302:	9f 4f       	sbci	r25, 0xFF	; 255
    1304:	a1 05       	cpc	r26, r1
    1306:	b1 05       	cpc	r27, r1
    1308:	20 f0       	brcs	.+8      	; 0x1312 <pf_mount+0x284>
		fmt = FS_FAT32;
    130a:	0f 2e       	mov	r0, r31
    130c:	f3 e0       	ldi	r31, 0x03	; 3
    130e:	df 2e       	mov	r13, r31
    1310:	f0 2d       	mov	r31, r0
	if (!fmt)
    1312:	dd 20       	and	r13, r13
    1314:	09 f4       	brne	.+2      	; 0x1318 <pf_mount+0x28a>
    1316:	45 c0       	rjmp	.+138    	; 0x13a2 <pf_mount+0x314>
		return FR_NO_FILESYSTEM;
	fs->fs_type = fmt;
    1318:	d7 01       	movw	r26, r14
    131a:	dc 92       	st	X, r13

	if (_FS_32ONLY || (_FS_FAT32 && fmt == FS_FAT32))
		fs->dirbase = LD_DWORD(buf + (BPB_RootClus - 13)); /* Root directory start cluster */
    131c:	8b a1       	ldd	r24, Y+35	; 0x23
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	a0 e0       	ldi	r26, 0x00	; 0
    1322:	b0 e0       	ldi	r27, 0x00	; 0
    1324:	78 2f       	mov	r23, r24
    1326:	66 27       	eor	r22, r22
    1328:	55 27       	eor	r21, r21
    132a:	44 27       	eor	r20, r20
    132c:	8a a1       	ldd	r24, Y+34	; 0x22
    132e:	90 e0       	ldi	r25, 0x00	; 0
    1330:	a0 e0       	ldi	r26, 0x00	; 0
    1332:	b0 e0       	ldi	r27, 0x00	; 0
    1334:	dc 01       	movw	r26, r24
    1336:	99 27       	eor	r25, r25
    1338:	88 27       	eor	r24, r24
    133a:	84 2b       	or	r24, r20
    133c:	95 2b       	or	r25, r21
    133e:	a6 2b       	or	r26, r22
    1340:	b7 2b       	or	r27, r23
    1342:	49 a1       	ldd	r20, Y+33	; 0x21
    1344:	50 e0       	ldi	r21, 0x00	; 0
    1346:	54 2f       	mov	r21, r20
    1348:	44 27       	eor	r20, r20
    134a:	60 e0       	ldi	r22, 0x00	; 0
    134c:	70 e0       	ldi	r23, 0x00	; 0
    134e:	84 2b       	or	r24, r20
    1350:	95 2b       	or	r25, r21
    1352:	a6 2b       	or	r26, r22
    1354:	b7 2b       	or	r27, r23
    1356:	28 a1       	ldd	r18, Y+32	; 0x20
    1358:	82 2b       	or	r24, r18
    135a:	f7 01       	movw	r30, r14
    135c:	86 87       	std	Z+14, r24	; 0x0e
    135e:	97 87       	std	Z+15, r25	; 0x0f
    1360:	a0 8b       	std	Z+16, r26	; 0x10
    1362:	b1 8b       	std	Z+17, r27	; 0x11
	else
		fs->dirbase = fs->fatbase + fsize;                   /* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16; /* Data start sector (lba) */
    1364:	4d a1       	ldd	r20, Y+37	; 0x25
    1366:	5e a1       	ldd	r21, Y+38	; 0x26
    1368:	6f a1       	ldd	r22, Y+39	; 0x27
    136a:	78 a5       	ldd	r23, Y+40	; 0x28
    136c:	84 0e       	add	r8, r20
    136e:	95 1e       	adc	r9, r21
    1370:	a6 1e       	adc	r10, r22
    1372:	b7 1e       	adc	r11, r23
    1374:	84 0c       	add	r8, r4
    1376:	95 1c       	adc	r9, r5
    1378:	a6 1c       	adc	r10, r6
    137a:	b7 1c       	adc	r11, r7
    137c:	82 8a       	std	Z+18, r8	; 0x12
    137e:	93 8a       	std	Z+19, r9	; 0x13
    1380:	a4 8a       	std	Z+20, r10	; 0x14
    1382:	b5 8a       	std	Z+21, r11	; 0x15

	fs->flag = 0;
    1384:	11 82       	std	Z+1, r1	; 0x01
	FatFs    = fs;
    1386:	f0 92 af 05 	sts	0x05AF, r15	; 0x8005af <FatFs+0x1>
    138a:	e0 92 ae 05 	sts	0x05AE, r14	; 0x8005ae <FatFs>

	return FR_OK;
    138e:	80 e0       	ldi	r24, 0x00	; 0
    1390:	09 c0       	rjmp	.+18     	; 0x13a4 <pf_mount+0x316>
	FatFs = 0;

	if (disk_initialize() & STA_NOINIT)
	{
		/* Check if the drive is ready or not */
		return FR_NOT_READY;
    1392:	82 e0       	ldi	r24, 0x02	; 2
    1394:	07 c0       	rjmp	.+14     	; 0x13a4 <pf_mount+0x316>
				fmt   = check_fs(buf, bsect); /* Check the partition */
			}
		}
	}
	if (fmt == 3)
		return FR_DISK_ERR;
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	05 c0       	rjmp	.+10     	; 0x13a4 <pf_mount+0x316>
	if (fmt)
		return FR_NO_FILESYSTEM; /* No valid FAT patition is found */
    139a:	86 e0       	ldi	r24, 0x06	; 6
    139c:	03 c0       	rjmp	.+6      	; 0x13a4 <pf_mount+0x316>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf)))
		return FR_DISK_ERR;
    139e:	81 e0       	ldi	r24, 0x01	; 1
    13a0:	01 c0       	rjmp	.+2      	; 0x13a4 <pf_mount+0x316>
	if (_FS_FAT16 && mclst >= 0xFF8 && mclst < 0xFFF7)
		fmt = FS_FAT16;
	if (_FS_FAT32 && mclst >= 0xFFF7)
		fmt = FS_FAT32;
	if (!fmt)
		return FR_NO_FILESYSTEM;
    13a2:	86 e0       	ldi	r24, 0x06	; 6

	fs->flag = 0;
	FatFs    = fs;

	return FR_OK;
}
    13a4:	a8 96       	adiw	r28, 0x28	; 40
    13a6:	0f b6       	in	r0, 0x3f	; 63
    13a8:	f8 94       	cli
    13aa:	de bf       	out	0x3e, r29	; 62
    13ac:	0f be       	out	0x3f, r0	; 63
    13ae:	cd bf       	out	0x3d, r28	; 61
    13b0:	df 91       	pop	r29
    13b2:	cf 91       	pop	r28
    13b4:	1f 91       	pop	r17
    13b6:	0f 91       	pop	r16
    13b8:	ff 90       	pop	r15
    13ba:	ef 90       	pop	r14
    13bc:	df 90       	pop	r13
    13be:	bf 90       	pop	r11
    13c0:	af 90       	pop	r10
    13c2:	9f 90       	pop	r9
    13c4:	8f 90       	pop	r8
    13c6:	7f 90       	pop	r7
    13c8:	6f 90       	pop	r6
    13ca:	5f 90       	pop	r5
    13cc:	4f 90       	pop	r4
    13ce:	08 95       	ret

000013d0 <pf_open>:
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT pf_open(const char *path /* Pointer to the file name */
)
 {
    13d0:	0f 93       	push	r16
    13d2:	1f 93       	push	r17
    13d4:	cf 93       	push	r28
    13d6:	df 93       	push	r29
    13d8:	cd b7       	in	r28, 0x3d	; 61
    13da:	de b7       	in	r29, 0x3e	; 62
    13dc:	ec 97       	sbiw	r28, 0x3c	; 60
    13de:	0f b6       	in	r0, 0x3f	; 63
    13e0:	f8 94       	cli
    13e2:	de bf       	out	0x3e, r29	; 62
    13e4:	0f be       	out	0x3f, r0	; 63
    13e6:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;
    13e8:	00 91 ae 05 	lds	r16, 0x05AE	; 0x8005ae <FatFs>
    13ec:	10 91 af 05 	lds	r17, 0x05AF	; 0x8005af <FatFs+0x1>

	if (!fs)
    13f0:	01 15       	cp	r16, r1
    13f2:	11 05       	cpc	r17, r1
    13f4:	09 f4       	brne	.+2      	; 0x13f8 <pf_open+0x28>
    13f6:	4a c0       	rjmp	.+148    	; 0x148c <pf_open+0xbc>
    13f8:	ac 01       	movw	r20, r24
		return FR_NOT_ENABLED; /* Check file system */

	fs->flag = 0;
    13fa:	f8 01       	movw	r30, r16
    13fc:	11 82       	std	Z+1, r1	; 0x01
	dj.fn    = sp;
    13fe:	ce 01       	movw	r24, r28
    1400:	41 96       	adiw	r24, 0x11	; 17
    1402:	9c 83       	std	Y+4, r25	; 0x04
    1404:	8b 83       	std	Y+3, r24	; 0x03
	res      = follow_path(&dj, dir, path); /* Follow the file path */
    1406:	be 01       	movw	r22, r28
    1408:	63 5e       	subi	r22, 0xE3	; 227
    140a:	7f 4f       	sbci	r23, 0xFF	; 255
    140c:	40 97       	sbiw	r24, 0x10	; 16
    140e:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <follow_path>
	if (res != FR_OK)
    1412:	81 11       	cpse	r24, r1
    1414:	40 c0       	rjmp	.+128    	; 0x1496 <pf_open+0xc6>
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
    1416:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1418:	88 23       	and	r24, r24
    141a:	d1 f1       	breq	.+116    	; 0x1490 <pf_open+0xc0>
    141c:	88 a5       	ldd	r24, Y+40	; 0x28
    141e:	84 fd       	sbrc	r24, 4
    1420:	39 c0       	rjmp	.+114    	; 0x1494 <pf_open+0xc4>
		return FR_NO_FILE;
	

	fs->org_clust = get_clust(dir);               /* File start cluster */
    1422:	ce 01       	movw	r24, r28
    1424:	4d 96       	adiw	r24, 0x1d	; 29
    1426:	0e 94 a6 05 	call	0xb4c	; 0xb4c <get_clust>
    142a:	f8 01       	movw	r30, r16
    142c:	66 8f       	std	Z+30, r22	; 0x1e
    142e:	77 8f       	std	Z+31, r23	; 0x1f
    1430:	80 a3       	std	Z+32, r24	; 0x20
    1432:	91 a3       	std	Z+33, r25	; 0x21
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
    1434:	8c ad       	ldd	r24, Y+60	; 0x3c
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	a0 e0       	ldi	r26, 0x00	; 0
    143a:	b0 e0       	ldi	r27, 0x00	; 0
    143c:	78 2f       	mov	r23, r24
    143e:	66 27       	eor	r22, r22
    1440:	55 27       	eor	r21, r21
    1442:	44 27       	eor	r20, r20
    1444:	9b ad       	ldd	r25, Y+59	; 0x3b
    1446:	89 2f       	mov	r24, r25
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	a0 e0       	ldi	r26, 0x00	; 0
    144c:	b0 e0       	ldi	r27, 0x00	; 0
    144e:	dc 01       	movw	r26, r24
    1450:	99 27       	eor	r25, r25
    1452:	88 27       	eor	r24, r24
    1454:	84 2b       	or	r24, r20
    1456:	95 2b       	or	r25, r21
    1458:	a6 2b       	or	r26, r22
    145a:	b7 2b       	or	r27, r23
    145c:	4a ad       	ldd	r20, Y+58	; 0x3a
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	54 2f       	mov	r21, r20
    1462:	44 27       	eor	r20, r20
    1464:	60 e0       	ldi	r22, 0x00	; 0
    1466:	70 e0       	ldi	r23, 0x00	; 0
    1468:	84 2b       	or	r24, r20
    146a:	95 2b       	or	r25, r21
    146c:	a6 2b       	or	r26, r22
    146e:	b7 2b       	or	r27, r23
    1470:	29 ad       	ldd	r18, Y+57	; 0x39
    1472:	82 2b       	or	r24, r18
    1474:	82 8f       	std	Z+26, r24	; 0x1a
    1476:	93 8f       	std	Z+27, r25	; 0x1b
    1478:	a4 8f       	std	Z+28, r26	; 0x1c
    147a:	b5 8f       	std	Z+29, r27	; 0x1d
	fs->fptr      = 0;                            /* File pointer */
    147c:	16 8a       	std	Z+22, r1	; 0x16
    147e:	17 8a       	std	Z+23, r1	; 0x17
    1480:	10 8e       	std	Z+24, r1	; 0x18
    1482:	11 8e       	std	Z+25, r1	; 0x19
	fs->flag      = FA_OPENED;
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	81 83       	std	Z+1, r24	; 0x01

	return FR_OK;
    1488:	80 e0       	ldi	r24, 0x00	; 0
    148a:	05 c0       	rjmp	.+10     	; 0x1496 <pf_open+0xc6>
	DIR     dj;
	BYTE    sp[12], dir[32];
	FATFS * fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED; /* Check file system */
    148c:	85 e0       	ldi	r24, 0x05	; 5
    148e:	03 c0       	rjmp	.+6      	; 0x1496 <pf_open+0xc6>
	dj.fn    = sp;
	res      = follow_path(&dj, dir, path); /* Follow the file path */
	if (res != FR_OK)
		return res;                          /* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR)) /* It is a directory */ // hier gaat het fout
		return FR_NO_FILE;
    1490:	83 e0       	ldi	r24, 0x03	; 3
    1492:	01 c0       	rjmp	.+2      	; 0x1496 <pf_open+0xc6>
    1494:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize     = LD_DWORD(dir + DIR_FileSize); /* File size */
	fs->fptr      = 0;                            /* File pointer */
	fs->flag      = FA_OPENED;

	return FR_OK;
}
    1496:	ec 96       	adiw	r28, 0x3c	; 60
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	df 91       	pop	r29
    14a4:	cf 91       	pop	r28
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	08 95       	ret

000014ac <pf_read>:

FRESULT pf_read(void *buff, /* Pointer to the read buffer (NULL:Forward data to the stream)*/
                UINT  btr,  /* Number of bytes to read */
                UINT *br    /* Pointer to number of bytes read */
)
{
    14ac:	6f 92       	push	r6
    14ae:	7f 92       	push	r7
    14b0:	8f 92       	push	r8
    14b2:	9f 92       	push	r9
    14b4:	af 92       	push	r10
    14b6:	bf 92       	push	r11
    14b8:	cf 92       	push	r12
    14ba:	df 92       	push	r13
    14bc:	ef 92       	push	r14
    14be:	ff 92       	push	r15
    14c0:	0f 93       	push	r16
    14c2:	1f 93       	push	r17
    14c4:	cf 93       	push	r28
    14c6:	df 93       	push	r29
    14c8:	3c 01       	movw	r6, r24
    14ca:	6b 01       	movw	r12, r22
    14cc:	4a 01       	movw	r8, r20
	DRESULT dr;
	CLUST   clst;
	DWORD   sect, remain;
	UINT    rcnt;
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;
    14ce:	e0 90 ae 05 	lds	r14, 0x05AE	; 0x8005ae <FatFs>
    14d2:	f0 90 af 05 	lds	r15, 0x05AF	; 0x8005af <FatFs+0x1>

	*br = 0;
    14d6:	fa 01       	movw	r30, r20
    14d8:	11 82       	std	Z+1, r1	; 0x01
    14da:	10 82       	st	Z, r1
	if (!fs)
    14dc:	e1 14       	cp	r14, r1
    14de:	f1 04       	cpc	r15, r1
    14e0:	09 f4       	brne	.+2      	; 0x14e4 <pf_read+0x38>
    14e2:	b5 c0       	rjmp	.+362    	; 0x164e <pf_read+0x1a2>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    14e4:	f7 01       	movw	r30, r14
    14e6:	81 81       	ldd	r24, Z+1	; 0x01
    14e8:	80 ff       	sbrs	r24, 0
    14ea:	b3 c0       	rjmp	.+358    	; 0x1652 <pf_read+0x1a6>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    14ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    14ee:	93 8d       	ldd	r25, Z+27	; 0x1b
    14f0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    14f2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    14f4:	46 89       	ldd	r20, Z+22	; 0x16
    14f6:	57 89       	ldd	r21, Z+23	; 0x17
    14f8:	60 8d       	ldd	r22, Z+24	; 0x18
    14fa:	71 8d       	ldd	r23, Z+25	; 0x19
    14fc:	84 1b       	sub	r24, r20
    14fe:	95 0b       	sbc	r25, r21
    1500:	a6 0b       	sbc	r26, r22
    1502:	b7 0b       	sbc	r27, r23
	if (btr > remain)
    1504:	a6 01       	movw	r20, r12
    1506:	60 e0       	ldi	r22, 0x00	; 0
    1508:	70 e0       	ldi	r23, 0x00	; 0
    150a:	84 17       	cp	r24, r20
    150c:	95 07       	cpc	r25, r21
    150e:	a6 07       	cpc	r26, r22
    1510:	b7 07       	cpc	r27, r23
    1512:	08 f4       	brcc	.+2      	; 0x1516 <pf_read+0x6a>
		btr = (UINT)remain; /* Truncate btr by remaining bytes */
    1514:	6c 01       	movw	r12, r24
			fs->dsect = sect + cs;
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
		if (rcnt > btr)
			rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    1516:	53 01       	movw	r10, r6
    1518:	94 c0       	rjmp	.+296    	; 0x1642 <pf_read+0x196>
	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {                       /* On the sector boundary? */
    151a:	f7 01       	movw	r30, r14
    151c:	86 89       	ldd	r24, Z+22	; 0x16
    151e:	97 89       	ldd	r25, Z+23	; 0x17
    1520:	a0 8d       	ldd	r26, Z+24	; 0x18
    1522:	b1 8d       	ldd	r27, Z+25	; 0x19
    1524:	ac 01       	movw	r20, r24
    1526:	bd 01       	movw	r22, r26
    1528:	51 70       	andi	r21, 0x01	; 1
    152a:	66 27       	eor	r22, r22
    152c:	77 27       	eor	r23, r23
    152e:	45 2b       	or	r20, r21
    1530:	46 2b       	or	r20, r22
    1532:	47 2b       	or	r20, r23
    1534:	09 f0       	breq	.+2      	; 0x1538 <pf_read+0x8c>
    1536:	48 c0       	rjmp	.+144    	; 0x15c8 <pf_read+0x11c>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1538:	c2 81       	ldd	r28, Z+2	; 0x02
    153a:	c1 50       	subi	r28, 0x01	; 1
    153c:	ac 01       	movw	r20, r24
    153e:	bd 01       	movw	r22, r26
    1540:	03 2e       	mov	r0, r19
    1542:	39 e0       	ldi	r19, 0x09	; 9
    1544:	76 95       	lsr	r23
    1546:	67 95       	ror	r22
    1548:	57 95       	ror	r21
    154a:	47 95       	ror	r20
    154c:	3a 95       	dec	r19
    154e:	d1 f7       	brne	.-12     	; 0x1544 <pf_read+0x98>
    1550:	30 2d       	mov	r19, r0
    1552:	c4 23       	and	r28, r20
			if (!cs) {                                     /* On the cluster boundary? */
    1554:	f1 f4       	brne	.+60     	; 0x1592 <pf_read+0xe6>
				if (fs->fptr == 0)                         /* On the top of the file? */
    1556:	89 2b       	or	r24, r25
    1558:	8a 2b       	or	r24, r26
    155a:	8b 2b       	or	r24, r27
    155c:	29 f4       	brne	.+10     	; 0x1568 <pf_read+0xbc>
					clst = fs->org_clust;
    155e:	66 8d       	ldd	r22, Z+30	; 0x1e
    1560:	77 8d       	ldd	r23, Z+31	; 0x1f
    1562:	80 a1       	ldd	r24, Z+32	; 0x20
    1564:	91 a1       	ldd	r25, Z+33	; 0x21
    1566:	07 c0       	rjmp	.+14     	; 0x1576 <pf_read+0xca>
				else
					clst = get_fat(fs->curr_clust);
    1568:	f7 01       	movw	r30, r14
    156a:	62 a1       	ldd	r22, Z+34	; 0x22
    156c:	73 a1       	ldd	r23, Z+35	; 0x23
    156e:	84 a1       	ldd	r24, Z+36	; 0x24
    1570:	95 a1       	ldd	r25, Z+37	; 0x25
    1572:	0e 94 93 06 	call	0xd26	; 0xd26 <get_fat>
				if (clst <= 1)
    1576:	62 30       	cpi	r22, 0x02	; 2
    1578:	71 05       	cpc	r23, r1
    157a:	81 05       	cpc	r24, r1
    157c:	91 05       	cpc	r25, r1
    157e:	20 f4       	brcc	.+8      	; 0x1588 <pf_read+0xdc>
					ABORT(FR_DISK_ERR);
    1580:	f7 01       	movw	r30, r14
    1582:	11 82       	std	Z+1, r1	; 0x01
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	66 c0       	rjmp	.+204    	; 0x1654 <pf_read+0x1a8>
				fs->curr_clust = clst; /* Update current cluster */
    1588:	f7 01       	movw	r30, r14
    158a:	62 a3       	std	Z+34, r22	; 0x22
    158c:	73 a3       	std	Z+35, r23	; 0x23
    158e:	84 a3       	std	Z+36, r24	; 0x24
    1590:	95 a3       	std	Z+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    1592:	f7 01       	movw	r30, r14
    1594:	62 a1       	ldd	r22, Z+34	; 0x22
    1596:	73 a1       	ldd	r23, Z+35	; 0x23
    1598:	84 a1       	ldd	r24, Z+36	; 0x24
    159a:	95 a1       	ldd	r25, Z+37	; 0x25
    159c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <clust2sect>
			if (!sect)
    15a0:	61 15       	cp	r22, r1
    15a2:	71 05       	cpc	r23, r1
    15a4:	81 05       	cpc	r24, r1
    15a6:	91 05       	cpc	r25, r1
    15a8:	21 f4       	brne	.+8      	; 0x15b2 <pf_read+0x106>
				ABORT(FR_DISK_ERR);
    15aa:	f7 01       	movw	r30, r14
    15ac:	11 82       	std	Z+1, r1	; 0x01
    15ae:	81 e0       	ldi	r24, 0x01	; 1
    15b0:	51 c0       	rjmp	.+162    	; 0x1654 <pf_read+0x1a8>
			fs->dsect = sect + cs;
    15b2:	dc 01       	movw	r26, r24
    15b4:	cb 01       	movw	r24, r22
    15b6:	8c 0f       	add	r24, r28
    15b8:	91 1d       	adc	r25, r1
    15ba:	a1 1d       	adc	r26, r1
    15bc:	b1 1d       	adc	r27, r1
    15be:	f7 01       	movw	r30, r14
    15c0:	86 a3       	std	Z+38, r24	; 0x26
    15c2:	97 a3       	std	Z+39, r25	; 0x27
    15c4:	a0 a7       	std	Z+40, r26	; 0x28
    15c6:	b1 a7       	std	Z+41, r27	; 0x29
		}
		rcnt = 512 - (UINT)fs->fptr % 512; /* Get partial sector data from sector buffer */
    15c8:	f7 01       	movw	r30, r14
    15ca:	86 89       	ldd	r24, Z+22	; 0x16
    15cc:	97 89       	ldd	r25, Z+23	; 0x17
    15ce:	a0 8d       	ldd	r26, Z+24	; 0x18
    15d0:	b1 8d       	ldd	r27, Z+25	; 0x19
    15d2:	9c 01       	movw	r18, r24
    15d4:	31 70       	andi	r19, 0x01	; 1
    15d6:	c0 e0       	ldi	r28, 0x00	; 0
    15d8:	d2 e0       	ldi	r29, 0x02	; 2
    15da:	c2 1b       	sub	r28, r18
    15dc:	d3 0b       	sbc	r29, r19
		if (rcnt > btr)
    15de:	cc 16       	cp	r12, r28
    15e0:	dd 06       	cpc	r13, r29
    15e2:	08 f4       	brcc	.+2      	; 0x15e6 <pf_read+0x13a>
			rcnt = btr;
    15e4:	e6 01       	movw	r28, r12
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (UINT)fs->fptr % 512, rcnt);
    15e6:	f7 01       	movw	r30, r14
    15e8:	46 a1       	ldd	r20, Z+38	; 0x26
    15ea:	57 a1       	ldd	r21, Z+39	; 0x27
    15ec:	60 a5       	ldd	r22, Z+40	; 0x28
    15ee:	71 a5       	ldd	r23, Z+41	; 0x29
    15f0:	61 14       	cp	r6, r1
    15f2:	71 04       	cpc	r7, r1
    15f4:	19 f4       	brne	.+6      	; 0x15fc <pf_read+0x150>
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	02 c0       	rjmp	.+4      	; 0x1600 <pf_read+0x154>
    15fc:	8a 2d       	mov	r24, r10
    15fe:	9b 2d       	mov	r25, r11
    1600:	8e 01       	movw	r16, r28
    1602:	0e 94 f5 02 	call	0x5ea	; 0x5ea <disk_readp>
		if (dr)
    1606:	88 23       	and	r24, r24
    1608:	21 f0       	breq	.+8      	; 0x1612 <pf_read+0x166>
			ABORT(FR_DISK_ERR);
    160a:	f7 01       	movw	r30, r14
    160c:	11 82       	std	Z+1, r1	; 0x01
    160e:	81 e0       	ldi	r24, 0x01	; 1
    1610:	21 c0       	rjmp	.+66     	; 0x1654 <pf_read+0x1a8>
		fs->fptr += rcnt;
    1612:	f7 01       	movw	r30, r14
    1614:	86 89       	ldd	r24, Z+22	; 0x16
    1616:	97 89       	ldd	r25, Z+23	; 0x17
    1618:	a0 8d       	ldd	r26, Z+24	; 0x18
    161a:	b1 8d       	ldd	r27, Z+25	; 0x19
    161c:	8c 0f       	add	r24, r28
    161e:	9d 1f       	adc	r25, r29
    1620:	a1 1d       	adc	r26, r1
    1622:	b1 1d       	adc	r27, r1
    1624:	86 8b       	std	Z+22, r24	; 0x16
    1626:	97 8b       	std	Z+23, r25	; 0x17
    1628:	a0 8f       	std	Z+24, r26	; 0x18
    162a:	b1 8f       	std	Z+25, r27	; 0x19
		rbuff += rcnt; /* Update pointers and counters */
    162c:	ac 0e       	add	r10, r28
    162e:	bd 1e       	adc	r11, r29
		btr -= rcnt;
    1630:	cc 1a       	sub	r12, r28
    1632:	dd 0a       	sbc	r13, r29
		*br += rcnt;
    1634:	f4 01       	movw	r30, r8
    1636:	80 81       	ld	r24, Z
    1638:	91 81       	ldd	r25, Z+1	; 0x01
    163a:	c8 0f       	add	r28, r24
    163c:	d9 1f       	adc	r29, r25
    163e:	d1 83       	std	Z+1, r29	; 0x01
    1640:	c0 83       	st	Z, r28

	remain = fs->fsize - fs->fptr;
	if (btr > remain)
		btr = (UINT)remain; /* Truncate btr by remaining bytes */

	while (btr) {                                          /* Repeat until all data transferred */
    1642:	c1 14       	cp	r12, r1
    1644:	d1 04       	cpc	r13, r1
    1646:	09 f0       	breq	.+2      	; 0x164a <pf_read+0x19e>
    1648:	68 cf       	rjmp	.-304    	; 0x151a <pf_read+0x6e>
		rbuff += rcnt; /* Update pointers and counters */
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
    164a:	80 e0       	ldi	r24, 0x00	; 0
    164c:	03 c0       	rjmp	.+6      	; 0x1654 <pf_read+0x1a8>
	BYTE    cs, *rbuff = buff;
	FATFS * fs = FatFs;

	*br = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    164e:	85 e0       	ldi	r24, 0x05	; 5
    1650:	01 c0       	rjmp	.+2      	; 0x1654 <pf_read+0x1a8>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1652:	84 e0       	ldi	r24, 0x04	; 4
		btr -= rcnt;
		*br += rcnt;
	}

	return FR_OK;
}
    1654:	df 91       	pop	r29
    1656:	cf 91       	pop	r28
    1658:	1f 91       	pop	r17
    165a:	0f 91       	pop	r16
    165c:	ff 90       	pop	r15
    165e:	ef 90       	pop	r14
    1660:	df 90       	pop	r13
    1662:	cf 90       	pop	r12
    1664:	bf 90       	pop	r11
    1666:	af 90       	pop	r10
    1668:	9f 90       	pop	r9
    166a:	8f 90       	pop	r8
    166c:	7f 90       	pop	r7
    166e:	6f 90       	pop	r6
    1670:	08 95       	ret

00001672 <pf_write>:

FRESULT pf_write(const void *buff, /* Pointer to the data to be written */
                 UINT        btw,  /* Number of bytes to write (0:Finalize the current write operation) */
                 UINT *      bw    /* Pointer to number of bytes written */
)
{
    1672:	4f 92       	push	r4
    1674:	5f 92       	push	r5
    1676:	6f 92       	push	r6
    1678:	7f 92       	push	r7
    167a:	af 92       	push	r10
    167c:	bf 92       	push	r11
    167e:	cf 92       	push	r12
    1680:	df 92       	push	r13
    1682:	ef 92       	push	r14
    1684:	ff 92       	push	r15
    1686:	0f 93       	push	r16
    1688:	1f 93       	push	r17
    168a:	cf 93       	push	r28
    168c:	df 93       	push	r29
    168e:	7c 01       	movw	r14, r24
    1690:	5b 01       	movw	r10, r22
    1692:	6a 01       	movw	r12, r20
	CLUST       clst;
	DWORD       sect, remain;
	const BYTE *p = buff;
	BYTE        cs;
	UINT        wcnt;
	FATFS *     fs = FatFs;
    1694:	c0 91 ae 05 	lds	r28, 0x05AE	; 0x8005ae <FatFs>
    1698:	d0 91 af 05 	lds	r29, 0x05AF	; 0x8005af <FatFs+0x1>

	*bw = 0;
    169c:	fa 01       	movw	r30, r20
    169e:	11 82       	std	Z+1, r1	; 0x01
    16a0:	10 82       	st	Z, r1
	if (!fs)
    16a2:	20 97       	sbiw	r28, 0x00	; 0
    16a4:	09 f4       	brne	.+2      	; 0x16a8 <pf_write+0x36>
    16a6:	df c0       	rjmp	.+446    	; 0x1866 <pf_write+0x1f4>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    16a8:	89 81       	ldd	r24, Y+1	; 0x01
    16aa:	80 ff       	sbrs	r24, 0
    16ac:	de c0       	rjmp	.+444    	; 0x186a <pf_write+0x1f8>
		return FR_NOT_OPENED;

	if (!btw) { /* Finalize request */
    16ae:	67 2b       	or	r22, r23
    16b0:	99 f4       	brne	.+38     	; 0x16d8 <pf_write+0x66>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0))
    16b2:	86 ff       	sbrs	r24, 6
    16b4:	0c c0       	rjmp	.+24     	; 0x16ce <pf_write+0x5c>
    16b6:	40 e0       	ldi	r20, 0x00	; 0
    16b8:	50 e0       	ldi	r21, 0x00	; 0
    16ba:	ba 01       	movw	r22, r20
    16bc:	80 e0       	ldi	r24, 0x00	; 0
    16be:	90 e0       	ldi	r25, 0x00	; 0
    16c0:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    16c4:	88 23       	and	r24, r24
    16c6:	19 f0       	breq	.+6      	; 0x16ce <pf_write+0x5c>
			ABORT(FR_DISK_ERR);
    16c8:	19 82       	std	Y+1, r1	; 0x01
    16ca:	81 e0       	ldi	r24, 0x01	; 1
    16cc:	cf c0       	rjmp	.+414    	; 0x186c <pf_write+0x1fa>
		fs->flag &= ~FA__WIP;
    16ce:	89 81       	ldd	r24, Y+1	; 0x01
    16d0:	8f 7b       	andi	r24, 0xBF	; 191
    16d2:	89 83       	std	Y+1, r24	; 0x01
		return FR_OK;
    16d4:	80 e0       	ldi	r24, 0x00	; 0
    16d6:	ca c0       	rjmp	.+404    	; 0x186c <pf_write+0x1fa>
	} else {                       /* Write data request */
		if (!(fs->flag & FA__WIP)) /* Round-down fptr to the sector boundary */
    16d8:	86 fd       	sbrc	r24, 6
    16da:	0a c0       	rjmp	.+20     	; 0x16f0 <pf_write+0x7e>
			fs->fptr &= 0xFFFFFE00;
    16dc:	8e 89       	ldd	r24, Y+22	; 0x16
    16de:	9f 89       	ldd	r25, Y+23	; 0x17
    16e0:	a8 8d       	ldd	r26, Y+24	; 0x18
    16e2:	b9 8d       	ldd	r27, Y+25	; 0x19
    16e4:	88 27       	eor	r24, r24
    16e6:	9e 7f       	andi	r25, 0xFE	; 254
    16e8:	8e 8b       	std	Y+22, r24	; 0x16
    16ea:	9f 8b       	std	Y+23, r25	; 0x17
    16ec:	a8 8f       	std	Y+24, r26	; 0x18
    16ee:	b9 8f       	std	Y+25, r27	; 0x19
	}
	remain = fs->fsize - fs->fptr;
    16f0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16f2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    16f4:	ac 8d       	ldd	r26, Y+28	; 0x1c
    16f6:	bd 8d       	ldd	r27, Y+29	; 0x1d
    16f8:	4e 89       	ldd	r20, Y+22	; 0x16
    16fa:	5f 89       	ldd	r21, Y+23	; 0x17
    16fc:	68 8d       	ldd	r22, Y+24	; 0x18
    16fe:	79 8d       	ldd	r23, Y+25	; 0x19
    1700:	84 1b       	sub	r24, r20
    1702:	95 0b       	sbc	r25, r21
    1704:	a6 0b       	sbc	r26, r22
    1706:	b7 0b       	sbc	r27, r23
	if (btw > remain)
    1708:	a5 01       	movw	r20, r10
    170a:	60 e0       	ldi	r22, 0x00	; 0
    170c:	70 e0       	ldi	r23, 0x00	; 0
    170e:	84 17       	cp	r24, r20
    1710:	95 07       	cpc	r25, r21
    1712:	a6 07       	cpc	r26, r22
    1714:	b7 07       	cpc	r27, r23
    1716:	08 f0       	brcs	.+2      	; 0x171a <pf_write+0xa8>
    1718:	a0 c0       	rjmp	.+320    	; 0x185a <pf_write+0x1e8>
		btw = (UINT)remain; /* Truncate btw by remaining bytes */
    171a:	5c 01       	movw	r10, r24
    171c:	9e c0       	rjmp	.+316    	; 0x185a <pf_write+0x1e8>

	while (btw) {                                          /* Repeat until all data transferred */
		if ((UINT)fs->fptr % 512 == 0) {                   /* On the sector boundary? */
    171e:	8e 89       	ldd	r24, Y+22	; 0x16
    1720:	9f 89       	ldd	r25, Y+23	; 0x17
    1722:	a8 8d       	ldd	r26, Y+24	; 0x18
    1724:	b9 8d       	ldd	r27, Y+25	; 0x19
    1726:	9c 01       	movw	r18, r24
    1728:	31 70       	andi	r19, 0x01	; 1
    172a:	23 2b       	or	r18, r19
    172c:	09 f0       	breq	.+2      	; 0x1730 <pf_write+0xbe>
    172e:	4e c0       	rjmp	.+156    	; 0x17cc <pf_write+0x15a>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1)); /* Sector offset in the cluster */
    1730:	1a 81       	ldd	r17, Y+2	; 0x02
    1732:	11 50       	subi	r17, 0x01	; 1
    1734:	ac 01       	movw	r20, r24
    1736:	bd 01       	movw	r22, r26
    1738:	03 2e       	mov	r0, r19
    173a:	39 e0       	ldi	r19, 0x09	; 9
    173c:	76 95       	lsr	r23
    173e:	67 95       	ror	r22
    1740:	57 95       	ror	r21
    1742:	47 95       	ror	r20
    1744:	3a 95       	dec	r19
    1746:	d1 f7       	brne	.-12     	; 0x173c <pf_write+0xca>
    1748:	30 2d       	mov	r19, r0
    174a:	14 23       	and	r17, r20
			if (!cs) {                                     /* On the cluster boundary? */
    174c:	d9 f4       	brne	.+54     	; 0x1784 <pf_write+0x112>
				if (fs->fptr == 0)                         /* On the top of the file? */
    174e:	89 2b       	or	r24, r25
    1750:	8a 2b       	or	r24, r26
    1752:	8b 2b       	or	r24, r27
    1754:	29 f4       	brne	.+10     	; 0x1760 <pf_write+0xee>
					clst = fs->org_clust;
    1756:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1758:	7f 8d       	ldd	r23, Y+31	; 0x1f
    175a:	88 a1       	ldd	r24, Y+32	; 0x20
    175c:	99 a1       	ldd	r25, Y+33	; 0x21
    175e:	06 c0       	rjmp	.+12     	; 0x176c <pf_write+0xfa>
				else
					clst = get_fat(fs->curr_clust);
    1760:	6a a1       	ldd	r22, Y+34	; 0x22
    1762:	7b a1       	ldd	r23, Y+35	; 0x23
    1764:	8c a1       	ldd	r24, Y+36	; 0x24
    1766:	9d a1       	ldd	r25, Y+37	; 0x25
    1768:	0e 94 93 06 	call	0xd26	; 0xd26 <get_fat>
				if (clst <= 1)
    176c:	62 30       	cpi	r22, 0x02	; 2
    176e:	71 05       	cpc	r23, r1
    1770:	81 05       	cpc	r24, r1
    1772:	91 05       	cpc	r25, r1
    1774:	18 f4       	brcc	.+6      	; 0x177c <pf_write+0x10a>
					ABORT(FR_DISK_ERR);
    1776:	19 82       	std	Y+1, r1	; 0x01
    1778:	81 e0       	ldi	r24, 0x01	; 1
    177a:	78 c0       	rjmp	.+240    	; 0x186c <pf_write+0x1fa>
				fs->curr_clust = clst; /* Update current cluster */
    177c:	6a a3       	std	Y+34, r22	; 0x22
    177e:	7b a3       	std	Y+35, r23	; 0x23
    1780:	8c a3       	std	Y+36, r24	; 0x24
    1782:	9d a3       	std	Y+37, r25	; 0x25
			}
			sect = clust2sect(fs->curr_clust); /* Get current sector */
    1784:	6a a1       	ldd	r22, Y+34	; 0x22
    1786:	7b a1       	ldd	r23, Y+35	; 0x23
    1788:	8c a1       	ldd	r24, Y+36	; 0x24
    178a:	9d a1       	ldd	r25, Y+37	; 0x25
    178c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <clust2sect>
			if (!sect)
    1790:	61 15       	cp	r22, r1
    1792:	71 05       	cpc	r23, r1
    1794:	81 05       	cpc	r24, r1
    1796:	91 05       	cpc	r25, r1
    1798:	19 f4       	brne	.+6      	; 0x17a0 <pf_write+0x12e>
				ABORT(FR_DISK_ERR);
    179a:	19 82       	std	Y+1, r1	; 0x01
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	66 c0       	rjmp	.+204    	; 0x186c <pf_write+0x1fa>
			fs->dsect = sect + cs;
    17a0:	ab 01       	movw	r20, r22
    17a2:	bc 01       	movw	r22, r24
    17a4:	41 0f       	add	r20, r17
    17a6:	51 1d       	adc	r21, r1
    17a8:	61 1d       	adc	r22, r1
    17aa:	71 1d       	adc	r23, r1
    17ac:	4e a3       	std	Y+38, r20	; 0x26
    17ae:	5f a3       	std	Y+39, r21	; 0x27
    17b0:	68 a7       	std	Y+40, r22	; 0x28
    17b2:	79 a7       	std	Y+41, r23	; 0x29
			if (disk_writep(0, fs->dsect))
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    17bc:	88 23       	and	r24, r24
    17be:	19 f0       	breq	.+6      	; 0x17c6 <pf_write+0x154>
				ABORT(FR_DISK_ERR); /* Initiate a sector write operation */
    17c0:	19 82       	std	Y+1, r1	; 0x01
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	53 c0       	rjmp	.+166    	; 0x186c <pf_write+0x1fa>
			fs->flag |= FA__WIP;
    17c6:	89 81       	ldd	r24, Y+1	; 0x01
    17c8:	80 64       	ori	r24, 0x40	; 64
    17ca:	89 83       	std	Y+1, r24	; 0x01
		}
		wcnt = 512 - (UINT)fs->fptr % 512; /* Number of bytes to write to the sector */
    17cc:	8e 89       	ldd	r24, Y+22	; 0x16
    17ce:	9f 89       	ldd	r25, Y+23	; 0x17
    17d0:	a8 8d       	ldd	r26, Y+24	; 0x18
    17d2:	b9 8d       	ldd	r27, Y+25	; 0x19
    17d4:	91 70       	andi	r25, 0x01	; 1
    17d6:	00 e0       	ldi	r16, 0x00	; 0
    17d8:	12 e0       	ldi	r17, 0x02	; 2
    17da:	08 1b       	sub	r16, r24
    17dc:	19 0b       	sbc	r17, r25
		if (wcnt > btw)
    17de:	a0 16       	cp	r10, r16
    17e0:	b1 06       	cpc	r11, r17
    17e2:	08 f4       	brcc	.+2      	; 0x17e6 <pf_write+0x174>
			wcnt = btw;
    17e4:	85 01       	movw	r16, r10
		if (disk_writep(p, wcnt))
    17e6:	28 01       	movw	r4, r16
    17e8:	61 2c       	mov	r6, r1
    17ea:	71 2c       	mov	r7, r1
    17ec:	b3 01       	movw	r22, r6
    17ee:	a2 01       	movw	r20, r4
    17f0:	c7 01       	movw	r24, r14
    17f2:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    17f6:	88 23       	and	r24, r24
    17f8:	19 f0       	breq	.+6      	; 0x1800 <pf_write+0x18e>
			ABORT(FR_DISK_ERR); /* Send data to the sector */
    17fa:	19 82       	std	Y+1, r1	; 0x01
    17fc:	81 e0       	ldi	r24, 0x01	; 1
    17fe:	36 c0       	rjmp	.+108    	; 0x186c <pf_write+0x1fa>
		fs->fptr += wcnt;
    1800:	8e 89       	ldd	r24, Y+22	; 0x16
    1802:	9f 89       	ldd	r25, Y+23	; 0x17
    1804:	a8 8d       	ldd	r26, Y+24	; 0x18
    1806:	b9 8d       	ldd	r27, Y+25	; 0x19
    1808:	48 0e       	add	r4, r24
    180a:	59 1e       	adc	r5, r25
    180c:	6a 1e       	adc	r6, r26
    180e:	7b 1e       	adc	r7, r27
    1810:	4e 8a       	std	Y+22, r4	; 0x16
    1812:	5f 8a       	std	Y+23, r5	; 0x17
    1814:	68 8e       	std	Y+24, r6	; 0x18
    1816:	79 8e       	std	Y+25, r7	; 0x19
		p += wcnt; /* Update pointers and counters */
    1818:	e0 0e       	add	r14, r16
    181a:	f1 1e       	adc	r15, r17
		btw -= wcnt;
    181c:	a0 1a       	sub	r10, r16
    181e:	b1 0a       	sbc	r11, r17
		*bw += wcnt;
    1820:	f6 01       	movw	r30, r12
    1822:	80 81       	ld	r24, Z
    1824:	91 81       	ldd	r25, Z+1	; 0x01
    1826:	08 0f       	add	r16, r24
    1828:	19 1f       	adc	r17, r25
    182a:	11 83       	std	Z+1, r17	; 0x01
    182c:	00 83       	st	Z, r16
		if ((UINT)fs->fptr % 512 == 0) {
    182e:	8e 89       	ldd	r24, Y+22	; 0x16
    1830:	9f 89       	ldd	r25, Y+23	; 0x17
    1832:	a8 8d       	ldd	r26, Y+24	; 0x18
    1834:	b9 8d       	ldd	r27, Y+25	; 0x19
    1836:	91 70       	andi	r25, 0x01	; 1
    1838:	89 2b       	or	r24, r25
    183a:	79 f4       	brne	.+30     	; 0x185a <pf_write+0x1e8>
			if (disk_writep(0, 0))
    183c:	40 e0       	ldi	r20, 0x00	; 0
    183e:	50 e0       	ldi	r21, 0x00	; 0
    1840:	ba 01       	movw	r22, r20
    1842:	80 e0       	ldi	r24, 0x00	; 0
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	0e 94 58 03 	call	0x6b0	; 0x6b0 <disk_writep>
    184a:	88 23       	and	r24, r24
    184c:	19 f0       	breq	.+6      	; 0x1854 <pf_write+0x1e2>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
    184e:	19 82       	std	Y+1, r1	; 0x01
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	0c c0       	rjmp	.+24     	; 0x186c <pf_write+0x1fa>
			fs->flag &= ~FA__WIP;
    1854:	89 81       	ldd	r24, Y+1	; 0x01
    1856:	8f 7b       	andi	r24, 0xBF	; 191
    1858:	89 83       	std	Y+1, r24	; 0x01
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain)
		btw = (UINT)remain; /* Truncate btw by remaining bytes */

	while (btw) {                                          /* Repeat until all data transferred */
    185a:	a1 14       	cp	r10, r1
    185c:	b1 04       	cpc	r11, r1
    185e:	09 f0       	breq	.+2      	; 0x1862 <pf_write+0x1f0>
    1860:	5e cf       	rjmp	.-324    	; 0x171e <pf_write+0xac>
				ABORT(FR_DISK_ERR); /* Finalize the current sector write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    1862:	80 e0       	ldi	r24, 0x00	; 0
    1864:	03 c0       	rjmp	.+6      	; 0x186c <pf_write+0x1fa>
	UINT        wcnt;
	FATFS *     fs = FatFs;

	*bw = 0;
	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1866:	85 e0       	ldi	r24, 0x05	; 5
    1868:	01 c0       	rjmp	.+2      	; 0x186c <pf_write+0x1fa>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    186a:	84 e0       	ldi	r24, 0x04	; 4
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
}
    186c:	df 91       	pop	r29
    186e:	cf 91       	pop	r28
    1870:	1f 91       	pop	r17
    1872:	0f 91       	pop	r16
    1874:	ff 90       	pop	r15
    1876:	ef 90       	pop	r14
    1878:	df 90       	pop	r13
    187a:	cf 90       	pop	r12
    187c:	bf 90       	pop	r11
    187e:	af 90       	pop	r10
    1880:	7f 90       	pop	r7
    1882:	6f 90       	pop	r6
    1884:	5f 90       	pop	r5
    1886:	4f 90       	pop	r4
    1888:	08 95       	ret

0000188a <pf_lseek>:
/*-----------------------------------------------------------------------*/
#if _USE_LSEEK

FRESULT pf_lseek(DWORD ofs /* File pointer from top of file */
)
{
    188a:	4f 92       	push	r4
    188c:	5f 92       	push	r5
    188e:	6f 92       	push	r6
    1890:	7f 92       	push	r7
    1892:	8f 92       	push	r8
    1894:	9f 92       	push	r9
    1896:	af 92       	push	r10
    1898:	bf 92       	push	r11
    189a:	cf 92       	push	r12
    189c:	df 92       	push	r13
    189e:	ef 92       	push	r14
    18a0:	ff 92       	push	r15
    18a2:	cf 93       	push	r28
    18a4:	df 93       	push	r29
    18a6:	00 d0       	rcall	.+0      	; 0x18a8 <pf_lseek+0x1e>
    18a8:	00 d0       	rcall	.+0      	; 0x18aa <pf_lseek+0x20>
    18aa:	00 d0       	rcall	.+0      	; 0x18ac <pf_lseek+0x22>
    18ac:	cd b7       	in	r28, 0x3d	; 61
    18ae:	de b7       	in	r29, 0x3e	; 62
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;
    18b0:	20 91 ae 05 	lds	r18, 0x05AE	; 0x8005ae <FatFs>
    18b4:	30 91 af 05 	lds	r19, 0x05AF	; 0x8005af <FatFs+0x1>
    18b8:	3e 83       	std	Y+6, r19	; 0x06
    18ba:	2d 83       	std	Y+5, r18	; 0x05

	if (!fs)
    18bc:	21 15       	cp	r18, r1
    18be:	31 05       	cpc	r19, r1
    18c0:	09 f4       	brne	.+2      	; 0x18c4 <pf_lseek+0x3a>
    18c2:	f4 c0       	rjmp	.+488    	; 0x1aac <pf_lseek+0x222>
		return FR_NOT_ENABLED;   /* Check file system */
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
    18c4:	d9 01       	movw	r26, r18
    18c6:	11 96       	adiw	r26, 0x01	; 1
    18c8:	2c 91       	ld	r18, X
    18ca:	11 97       	sbiw	r26, 0x01	; 1
    18cc:	20 ff       	sbrs	r18, 0
    18ce:	f0 c0       	rjmp	.+480    	; 0x1ab0 <pf_lseek+0x226>
		return FR_NOT_OPENED;

	if (ofs > fs->fsize)
    18d0:	5a 96       	adiw	r26, 0x1a	; 26
    18d2:	cd 90       	ld	r12, X+
    18d4:	dd 90       	ld	r13, X+
    18d6:	ed 90       	ld	r14, X+
    18d8:	fc 90       	ld	r15, X
    18da:	5d 97       	sbiw	r26, 0x1d	; 29
    18dc:	c6 16       	cp	r12, r22
    18de:	d7 06       	cpc	r13, r23
    18e0:	e8 06       	cpc	r14, r24
    18e2:	f9 06       	cpc	r15, r25
    18e4:	10 f0       	brcs	.+4      	; 0x18ea <pf_lseek+0x60>
    18e6:	6b 01       	movw	r12, r22
    18e8:	7c 01       	movw	r14, r24
		ofs = fs->fsize; /* Clip offset with the file size */
	ifptr    = fs->fptr;
    18ea:	ed 81       	ldd	r30, Y+5	; 0x05
    18ec:	fe 81       	ldd	r31, Y+6	; 0x06
    18ee:	46 88       	ldd	r4, Z+22	; 0x16
    18f0:	57 88       	ldd	r5, Z+23	; 0x17
    18f2:	60 8c       	ldd	r6, Z+24	; 0x18
    18f4:	71 8c       	ldd	r7, Z+25	; 0x19
	fs->fptr = 0;
    18f6:	16 8a       	std	Z+22, r1	; 0x16
    18f8:	17 8a       	std	Z+23, r1	; 0x17
    18fa:	10 8e       	std	Z+24, r1	; 0x18
    18fc:	11 8e       	std	Z+25, r1	; 0x19
	if (ofs > 0) {
    18fe:	c1 14       	cp	r12, r1
    1900:	d1 04       	cpc	r13, r1
    1902:	e1 04       	cpc	r14, r1
    1904:	f1 04       	cpc	r15, r1
    1906:	09 f4       	brne	.+2      	; 0x190a <pf_lseek+0x80>
    1908:	d5 c0       	rjmp	.+426    	; 0x1ab4 <pf_lseek+0x22a>
		bcs = (DWORD)fs->csize * 512;                            /* Cluster size (byte) */
    190a:	82 80       	ldd	r8, Z+2	; 0x02
    190c:	91 2c       	mov	r9, r1
    190e:	a1 2c       	mov	r10, r1
    1910:	b1 2c       	mov	r11, r1
    1912:	07 2e       	mov	r0, r23
    1914:	79 e0       	ldi	r23, 0x09	; 9
    1916:	88 0c       	add	r8, r8
    1918:	99 1c       	adc	r9, r9
    191a:	aa 1c       	adc	r10, r10
    191c:	bb 1c       	adc	r11, r11
    191e:	7a 95       	dec	r23
    1920:	d1 f7       	brne	.-12     	; 0x1916 <pf_lseek+0x8c>
    1922:	70 2d       	mov	r23, r0
		if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
    1924:	41 14       	cp	r4, r1
    1926:	51 04       	cpc	r5, r1
    1928:	61 04       	cpc	r6, r1
    192a:	71 04       	cpc	r7, r1
    192c:	09 f4       	brne	.+2      	; 0x1930 <pf_lseek+0xa6>
    192e:	40 c0       	rjmp	.+128    	; 0x19b0 <pf_lseek+0x126>
    1930:	c7 01       	movw	r24, r14
    1932:	b6 01       	movw	r22, r12
    1934:	61 50       	subi	r22, 0x01	; 1
    1936:	71 09       	sbc	r23, r1
    1938:	81 09       	sbc	r24, r1
    193a:	91 09       	sbc	r25, r1
    193c:	a5 01       	movw	r20, r10
    193e:	94 01       	movw	r18, r8
    1940:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <__udivmodsi4>
    1944:	29 83       	std	Y+1, r18	; 0x01
    1946:	3a 83       	std	Y+2, r19	; 0x02
    1948:	4b 83       	std	Y+3, r20	; 0x03
    194a:	5c 83       	std	Y+4, r21	; 0x04
    194c:	b1 e0       	ldi	r27, 0x01	; 1
    194e:	4b 1a       	sub	r4, r27
    1950:	51 08       	sbc	r5, r1
    1952:	61 08       	sbc	r6, r1
    1954:	71 08       	sbc	r7, r1
    1956:	c3 01       	movw	r24, r6
    1958:	b2 01       	movw	r22, r4
    195a:	a5 01       	movw	r20, r10
    195c:	94 01       	movw	r18, r8
    195e:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <__udivmodsi4>
    1962:	89 81       	ldd	r24, Y+1	; 0x01
    1964:	9a 81       	ldd	r25, Y+2	; 0x02
    1966:	ab 81       	ldd	r26, Y+3	; 0x03
    1968:	bc 81       	ldd	r27, Y+4	; 0x04
    196a:	82 17       	cp	r24, r18
    196c:	93 07       	cpc	r25, r19
    196e:	a4 07       	cpc	r26, r20
    1970:	b5 07       	cpc	r27, r21
    1972:	f0 f0       	brcs	.+60     	; 0x19b0 <pf_lseek+0x126>
			fs->fptr = (ifptr - 1) & ~(bcs - 1);                 /* start from the current cluster */
    1974:	88 27       	eor	r24, r24
    1976:	99 27       	eor	r25, r25
    1978:	dc 01       	movw	r26, r24
    197a:	88 19       	sub	r24, r8
    197c:	99 09       	sbc	r25, r9
    197e:	aa 09       	sbc	r26, r10
    1980:	bb 09       	sbc	r27, r11
    1982:	48 22       	and	r4, r24
    1984:	59 22       	and	r5, r25
    1986:	6a 22       	and	r6, r26
    1988:	7b 22       	and	r7, r27
    198a:	ad 81       	ldd	r26, Y+5	; 0x05
    198c:	be 81       	ldd	r27, Y+6	; 0x06
    198e:	56 96       	adiw	r26, 0x16	; 22
    1990:	4d 92       	st	X+, r4
    1992:	5d 92       	st	X+, r5
    1994:	6d 92       	st	X+, r6
    1996:	7c 92       	st	X, r7
    1998:	59 97       	sbiw	r26, 0x19	; 25
			ofs -= fs->fptr;
    199a:	c4 18       	sub	r12, r4
    199c:	d5 08       	sbc	r13, r5
    199e:	e6 08       	sbc	r14, r6
    19a0:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    19a2:	92 96       	adiw	r26, 0x22	; 34
    19a4:	6d 91       	ld	r22, X+
    19a6:	7d 91       	ld	r23, X+
    19a8:	8d 91       	ld	r24, X+
    19aa:	9c 91       	ld	r25, X
    19ac:	95 97       	sbiw	r26, 0x25	; 37
    19ae:	39 c0       	rjmp	.+114    	; 0x1a22 <pf_lseek+0x198>
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
    19b0:	ed 81       	ldd	r30, Y+5	; 0x05
    19b2:	fe 81       	ldd	r31, Y+6	; 0x06
    19b4:	66 8d       	ldd	r22, Z+30	; 0x1e
    19b6:	77 8d       	ldd	r23, Z+31	; 0x1f
    19b8:	80 a1       	ldd	r24, Z+32	; 0x20
    19ba:	91 a1       	ldd	r25, Z+33	; 0x21
			fs->curr_clust = clst;
    19bc:	62 a3       	std	Z+34, r22	; 0x22
    19be:	73 a3       	std	Z+35, r23	; 0x23
    19c0:	84 a3       	std	Z+36, r24	; 0x24
    19c2:	95 a3       	std	Z+37, r25	; 0x25
    19c4:	2e c0       	rjmp	.+92     	; 0x1a22 <pf_lseek+0x198>
		}
		while (ofs > bcs) {       /* Cluster following loop */
			clst = get_fat(clst); /* Follow cluster chain */
    19c6:	0e 94 93 06 	call	0xd26	; 0xd26 <get_fat>
			if (clst <= 1 || clst >= fs->n_fatent)
    19ca:	62 30       	cpi	r22, 0x02	; 2
    19cc:	71 05       	cpc	r23, r1
    19ce:	81 05       	cpc	r24, r1
    19d0:	91 05       	cpc	r25, r1
    19d2:	58 f0       	brcs	.+22     	; 0x19ea <pf_lseek+0x160>
    19d4:	ed 81       	ldd	r30, Y+5	; 0x05
    19d6:	fe 81       	ldd	r31, Y+6	; 0x06
    19d8:	46 80       	ldd	r4, Z+6	; 0x06
    19da:	57 80       	ldd	r5, Z+7	; 0x07
    19dc:	60 84       	ldd	r6, Z+8	; 0x08
    19de:	71 84       	ldd	r7, Z+9	; 0x09
    19e0:	64 15       	cp	r22, r4
    19e2:	75 05       	cpc	r23, r5
    19e4:	86 05       	cpc	r24, r6
    19e6:	97 05       	cpc	r25, r7
    19e8:	30 f0       	brcs	.+12     	; 0x19f6 <pf_lseek+0x16c>
				ABORT(FR_DISK_ERR);
    19ea:	ad 81       	ldd	r26, Y+5	; 0x05
    19ec:	be 81       	ldd	r27, Y+6	; 0x06
    19ee:	11 96       	adiw	r26, 0x01	; 1
    19f0:	1c 92       	st	X, r1
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	60 c0       	rjmp	.+192    	; 0x1ab6 <pf_lseek+0x22c>
			fs->curr_clust = clst;
    19f6:	ed 81       	ldd	r30, Y+5	; 0x05
    19f8:	fe 81       	ldd	r31, Y+6	; 0x06
    19fa:	62 a3       	std	Z+34, r22	; 0x22
    19fc:	73 a3       	std	Z+35, r23	; 0x23
    19fe:	84 a3       	std	Z+36, r24	; 0x24
    1a00:	95 a3       	std	Z+37, r25	; 0x25
			fs->fptr += bcs;
    1a02:	46 88       	ldd	r4, Z+22	; 0x16
    1a04:	57 88       	ldd	r5, Z+23	; 0x17
    1a06:	60 8c       	ldd	r6, Z+24	; 0x18
    1a08:	71 8c       	ldd	r7, Z+25	; 0x19
    1a0a:	48 0c       	add	r4, r8
    1a0c:	59 1c       	adc	r5, r9
    1a0e:	6a 1c       	adc	r6, r10
    1a10:	7b 1c       	adc	r7, r11
    1a12:	46 8a       	std	Z+22, r4	; 0x16
    1a14:	57 8a       	std	Z+23, r5	; 0x17
    1a16:	60 8e       	std	Z+24, r6	; 0x18
    1a18:	71 8e       	std	Z+25, r7	; 0x19
			ofs -= bcs;
    1a1a:	c8 18       	sub	r12, r8
    1a1c:	d9 08       	sbc	r13, r9
    1a1e:	ea 08       	sbc	r14, r10
    1a20:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {                            /* When seek to back cluster, */
			clst           = fs->org_clust; /* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {       /* Cluster following loop */
    1a22:	8c 14       	cp	r8, r12
    1a24:	9d 04       	cpc	r9, r13
    1a26:	ae 04       	cpc	r10, r14
    1a28:	bf 04       	cpc	r11, r15
    1a2a:	68 f2       	brcs	.-102    	; 0x19c6 <pf_lseek+0x13c>
				ABORT(FR_DISK_ERR);
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    1a2c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a2e:	fe 81       	ldd	r31, Y+6	; 0x06
    1a30:	86 88       	ldd	r8, Z+22	; 0x16
    1a32:	97 88       	ldd	r9, Z+23	; 0x17
    1a34:	a0 8c       	ldd	r10, Z+24	; 0x18
    1a36:	b1 8c       	ldd	r11, Z+25	; 0x19
    1a38:	c8 0c       	add	r12, r8
    1a3a:	d9 1c       	adc	r13, r9
    1a3c:	ea 1c       	adc	r14, r10
    1a3e:	fb 1c       	adc	r15, r11
    1a40:	c6 8a       	std	Z+22, r12	; 0x16
    1a42:	d7 8a       	std	Z+23, r13	; 0x17
    1a44:	e0 8e       	std	Z+24, r14	; 0x18
    1a46:	f1 8e       	std	Z+25, r15	; 0x19
		sect = clust2sect(clst); /* Current sector */
    1a48:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <clust2sect>
		if (!sect)
    1a4c:	61 15       	cp	r22, r1
    1a4e:	71 05       	cpc	r23, r1
    1a50:	81 05       	cpc	r24, r1
    1a52:	91 05       	cpc	r25, r1
    1a54:	29 f4       	brne	.+10     	; 0x1a60 <pf_lseek+0x1d6>
			ABORT(FR_DISK_ERR);
    1a56:	ed 81       	ldd	r30, Y+5	; 0x05
    1a58:	fe 81       	ldd	r31, Y+6	; 0x06
    1a5a:	11 82       	std	Z+1, r1	; 0x01
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	2b c0       	rjmp	.+86     	; 0x1ab6 <pf_lseek+0x22c>
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
    1a60:	0b 2e       	mov	r0, r27
    1a62:	b9 e0       	ldi	r27, 0x09	; 9
    1a64:	f6 94       	lsr	r15
    1a66:	e7 94       	ror	r14
    1a68:	d7 94       	ror	r13
    1a6a:	c7 94       	ror	r12
    1a6c:	ba 95       	dec	r27
    1a6e:	d1 f7       	brne	.-12     	; 0x1a64 <pf_lseek+0x1da>
    1a70:	b0 2d       	mov	r27, r0
    1a72:	ad 81       	ldd	r26, Y+5	; 0x05
    1a74:	be 81       	ldd	r27, Y+6	; 0x06
    1a76:	12 96       	adiw	r26, 0x02	; 2
    1a78:	2c 91       	ld	r18, X
    1a7a:	30 e0       	ldi	r19, 0x00	; 0
    1a7c:	21 50       	subi	r18, 0x01	; 1
    1a7e:	31 09       	sbc	r19, r1
    1a80:	49 01       	movw	r8, r18
    1a82:	33 0f       	add	r19, r19
    1a84:	aa 08       	sbc	r10, r10
    1a86:	bb 08       	sbc	r11, r11
    1a88:	c8 20       	and	r12, r8
    1a8a:	d9 20       	and	r13, r9
    1a8c:	ea 20       	and	r14, r10
    1a8e:	fb 20       	and	r15, r11
    1a90:	dc 01       	movw	r26, r24
    1a92:	cb 01       	movw	r24, r22
    1a94:	8c 0d       	add	r24, r12
    1a96:	9d 1d       	adc	r25, r13
    1a98:	ae 1d       	adc	r26, r14
    1a9a:	bf 1d       	adc	r27, r15
    1a9c:	ed 81       	ldd	r30, Y+5	; 0x05
    1a9e:	fe 81       	ldd	r31, Y+6	; 0x06
    1aa0:	86 a3       	std	Z+38, r24	; 0x26
    1aa2:	97 a3       	std	Z+39, r25	; 0x27
    1aa4:	a0 a7       	std	Z+40, r26	; 0x28
    1aa6:	b1 a7       	std	Z+41, r27	; 0x29
	}

	return FR_OK;
    1aa8:	80 e0       	ldi	r24, 0x00	; 0
    1aaa:	05 c0       	rjmp	.+10     	; 0x1ab6 <pf_lseek+0x22c>
	CLUST  clst;
	DWORD  bcs, sect, ifptr;
	FATFS *fs = FatFs;

	if (!fs)
		return FR_NOT_ENABLED;   /* Check file system */
    1aac:	85 e0       	ldi	r24, 0x05	; 5
    1aae:	03 c0       	rjmp	.+6      	; 0x1ab6 <pf_lseek+0x22c>
	if (!(fs->flag & FA_OPENED)) /* Check if opened */
		return FR_NOT_OPENED;
    1ab0:	84 e0       	ldi	r24, 0x04	; 4
    1ab2:	01 c0       	rjmp	.+2      	; 0x1ab6 <pf_lseek+0x22c>
		if (!sect)
			ABORT(FR_DISK_ERR);
		fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
	}

	return FR_OK;
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
}
    1ab6:	26 96       	adiw	r28, 0x06	; 6
    1ab8:	0f b6       	in	r0, 0x3f	; 63
    1aba:	f8 94       	cli
    1abc:	de bf       	out	0x3e, r29	; 62
    1abe:	0f be       	out	0x3f, r0	; 63
    1ac0:	cd bf       	out	0x3d, r28	; 61
    1ac2:	df 91       	pop	r29
    1ac4:	cf 91       	pop	r28
    1ac6:	ff 90       	pop	r15
    1ac8:	ef 90       	pop	r14
    1aca:	df 90       	pop	r13
    1acc:	cf 90       	pop	r12
    1ace:	bf 90       	pop	r11
    1ad0:	af 90       	pop	r10
    1ad2:	9f 90       	pop	r9
    1ad4:	8f 90       	pop	r8
    1ad6:	7f 90       	pop	r7
    1ad8:	6f 90       	pop	r6
    1ada:	5f 90       	pop	r5
    1adc:	4f 90       	pop	r4
    1ade:	08 95       	ret

00001ae0 <__divmodhi4>:
    1ae0:	97 fb       	bst	r25, 7
    1ae2:	07 2e       	mov	r0, r23
    1ae4:	16 f4       	brtc	.+4      	; 0x1aea <__divmodhi4+0xa>
    1ae6:	00 94       	com	r0
    1ae8:	07 d0       	rcall	.+14     	; 0x1af8 <__divmodhi4_neg1>
    1aea:	77 fd       	sbrc	r23, 7
    1aec:	09 d0       	rcall	.+18     	; 0x1b00 <__divmodhi4_neg2>
    1aee:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <__udivmodhi4>
    1af2:	07 fc       	sbrc	r0, 7
    1af4:	05 d0       	rcall	.+10     	; 0x1b00 <__divmodhi4_neg2>
    1af6:	3e f4       	brtc	.+14     	; 0x1b06 <__divmodhi4_exit>

00001af8 <__divmodhi4_neg1>:
    1af8:	90 95       	com	r25
    1afa:	81 95       	neg	r24
    1afc:	9f 4f       	sbci	r25, 0xFF	; 255
    1afe:	08 95       	ret

00001b00 <__divmodhi4_neg2>:
    1b00:	70 95       	com	r23
    1b02:	61 95       	neg	r22
    1b04:	7f 4f       	sbci	r23, 0xFF	; 255

00001b06 <__divmodhi4_exit>:
    1b06:	08 95       	ret

00001b08 <__udivmodsi4>:
    1b08:	a1 e2       	ldi	r26, 0x21	; 33
    1b0a:	1a 2e       	mov	r1, r26
    1b0c:	aa 1b       	sub	r26, r26
    1b0e:	bb 1b       	sub	r27, r27
    1b10:	fd 01       	movw	r30, r26
    1b12:	0d c0       	rjmp	.+26     	; 0x1b2e <__udivmodsi4_ep>

00001b14 <__udivmodsi4_loop>:
    1b14:	aa 1f       	adc	r26, r26
    1b16:	bb 1f       	adc	r27, r27
    1b18:	ee 1f       	adc	r30, r30
    1b1a:	ff 1f       	adc	r31, r31
    1b1c:	a2 17       	cp	r26, r18
    1b1e:	b3 07       	cpc	r27, r19
    1b20:	e4 07       	cpc	r30, r20
    1b22:	f5 07       	cpc	r31, r21
    1b24:	20 f0       	brcs	.+8      	; 0x1b2e <__udivmodsi4_ep>
    1b26:	a2 1b       	sub	r26, r18
    1b28:	b3 0b       	sbc	r27, r19
    1b2a:	e4 0b       	sbc	r30, r20
    1b2c:	f5 0b       	sbc	r31, r21

00001b2e <__udivmodsi4_ep>:
    1b2e:	66 1f       	adc	r22, r22
    1b30:	77 1f       	adc	r23, r23
    1b32:	88 1f       	adc	r24, r24
    1b34:	99 1f       	adc	r25, r25
    1b36:	1a 94       	dec	r1
    1b38:	69 f7       	brne	.-38     	; 0x1b14 <__udivmodsi4_loop>
    1b3a:	60 95       	com	r22
    1b3c:	70 95       	com	r23
    1b3e:	80 95       	com	r24
    1b40:	90 95       	com	r25
    1b42:	9b 01       	movw	r18, r22
    1b44:	ac 01       	movw	r20, r24
    1b46:	bd 01       	movw	r22, r26
    1b48:	cf 01       	movw	r24, r30
    1b4a:	08 95       	ret

00001b4c <__muluhisi3>:
    1b4c:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <__umulhisi3>
    1b50:	a5 9f       	mul	r26, r21
    1b52:	90 0d       	add	r25, r0
    1b54:	b4 9f       	mul	r27, r20
    1b56:	90 0d       	add	r25, r0
    1b58:	a4 9f       	mul	r26, r20
    1b5a:	80 0d       	add	r24, r0
    1b5c:	91 1d       	adc	r25, r1
    1b5e:	11 24       	eor	r1, r1
    1b60:	08 95       	ret

00001b62 <__udivmodhi4>:
    1b62:	aa 1b       	sub	r26, r26
    1b64:	bb 1b       	sub	r27, r27
    1b66:	51 e1       	ldi	r21, 0x11	; 17
    1b68:	07 c0       	rjmp	.+14     	; 0x1b78 <__udivmodhi4_ep>

00001b6a <__udivmodhi4_loop>:
    1b6a:	aa 1f       	adc	r26, r26
    1b6c:	bb 1f       	adc	r27, r27
    1b6e:	a6 17       	cp	r26, r22
    1b70:	b7 07       	cpc	r27, r23
    1b72:	10 f0       	brcs	.+4      	; 0x1b78 <__udivmodhi4_ep>
    1b74:	a6 1b       	sub	r26, r22
    1b76:	b7 0b       	sbc	r27, r23

00001b78 <__udivmodhi4_ep>:
    1b78:	88 1f       	adc	r24, r24
    1b7a:	99 1f       	adc	r25, r25
    1b7c:	5a 95       	dec	r21
    1b7e:	a9 f7       	brne	.-22     	; 0x1b6a <__udivmodhi4_loop>
    1b80:	80 95       	com	r24
    1b82:	90 95       	com	r25
    1b84:	bc 01       	movw	r22, r24
    1b86:	cd 01       	movw	r24, r26
    1b88:	08 95       	ret

00001b8a <__umulhisi3>:
    1b8a:	a2 9f       	mul	r26, r18
    1b8c:	b0 01       	movw	r22, r0
    1b8e:	b3 9f       	mul	r27, r19
    1b90:	c0 01       	movw	r24, r0
    1b92:	a3 9f       	mul	r26, r19
    1b94:	70 0d       	add	r23, r0
    1b96:	81 1d       	adc	r24, r1
    1b98:	11 24       	eor	r1, r1
    1b9a:	91 1d       	adc	r25, r1
    1b9c:	b2 9f       	mul	r27, r18
    1b9e:	70 0d       	add	r23, r0
    1ba0:	81 1d       	adc	r24, r1
    1ba2:	11 24       	eor	r1, r1
    1ba4:	91 1d       	adc	r25, r1
    1ba6:	08 95       	ret

00001ba8 <_exit>:
    1ba8:	f8 94       	cli

00001baa <__stop_program>:
    1baa:	ff cf       	rjmp	.-2      	; 0x1baa <__stop_program>
